diff --git a/projects/openttd_vs100.vcxproj b/projects/openttd_vs100.vcxproj
index 69360a6..a15aa4b 100644
--- a/projects/openttd_vs100.vcxproj
+++ b/projects/openttd_vs100.vcxproj
@@ -458,6 +458,8 @@
     <ClInclude Include="..\src\map_func.h" />
     <ClInclude Include="..\src\map_type.h" />
     <ClInclude Include="..\src\mixer.h" />
+    <ClInclude Include="..\src\moving_average.h" />
+    <ClCompile Include="..\src\moving_average.cpp" />
     <ClInclude Include="..\src\network\network.h" />
     <ClInclude Include="..\src\network\network_admin.h" />
     <ClInclude Include="..\src\network\network_base.h" />
diff --git a/projects/openttd_vs100.vcxproj.filters b/projects/openttd_vs100.vcxproj.filters
index fd904c1..0ca1d27 100644
--- a/projects/openttd_vs100.vcxproj.filters
+++ b/projects/openttd_vs100.vcxproj.filters
@@ -594,6 +594,12 @@
     <ClInclude Include="..\src\mixer.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\moving_average.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClCompile Include="..\src\moving_average.cpp">
+      <Filter>Header Files</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\network\network.h">
       <Filter>Header Files</Filter>
     </ClInclude>
diff --git a/projects/openttd_vs80.vcproj b/projects/openttd_vs80.vcproj
index 92813de..cbadaf4 100644
--- a/projects/openttd_vs80.vcproj
+++ b/projects/openttd_vs80.vcproj
@@ -1107,6 +1107,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
diff --git a/projects/openttd_vs90.vcproj b/projects/openttd_vs90.vcproj
index f04386b..6352d5f 100644
--- a/projects/openttd_vs90.vcproj
+++ b/projects/openttd_vs90.vcproj
@@ -1104,6 +1104,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
diff --git a/source.list b/source.list
index efcf338..613cd2b 100644
--- a/source.list
+++ b/source.list
@@ -191,6 +191,8 @@ livery.h
 map_func.h
 map_type.h
 mixer.h
+moving_average.h
+moving_average.cpp
 network/network.h
 network/network_admin.h
 network/network_base.h
diff --git a/src/aircraft_cmd.cpp b/src/aircraft_cmd.cpp
index 9afad2f..2171683 100644
--- a/src/aircraft_cmd.cpp
+++ b/src/aircraft_cmd.cpp
@@ -268,6 +268,7 @@ CommandCost CmdBuildAircraft(TileIndex tile, DoCommandFlag flags, const Engine *
 
 		v->name = NULL;
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 
 		v->acceleration = avi->acceleration;
 		v->engine_type = e->index;
diff --git a/src/core/math_func.cpp b/src/core/math_func.cpp
index 7f0630a..2226fa7 100644
--- a/src/core/math_func.cpp
+++ b/src/core/math_func.cpp
@@ -46,3 +46,23 @@ int GreatestCommonDivisor(int a, int b)
 	return a;
 
 }
+
+/**
+ * Deterministic approximate division.
+ * Cancels out division errors stemming from the integer nature of the division over multiple runs.
+ * @param a the dividend
+ * @param b the divisor
+ * @return a/b or (a/b)+1
+ */
+int DivideApprox(int a, int b) {
+	int random_like = ((a + b) * (a - b)) % b;
+
+	int remainder = a % b;
+
+	int ret = a / b;
+	if (abs(random_like) < abs(remainder)) {
+		ret += ((a < 0) ^ (b < 0)) ? -1 : 1;
+	}
+
+	return ret;
+}
diff --git a/src/core/math_func.hpp b/src/core/math_func.hpp
index 19f2f53..a824af3 100644
--- a/src/core/math_func.hpp
+++ b/src/core/math_func.hpp
@@ -317,6 +317,7 @@ static FORCEINLINE uint ToPercent16(uint i)
 
 int LeastCommonMultiple(int a, int b);
 int GreatestCommonDivisor(int a, int b);
+int DivideApprox(int a, int b);
 
 /**
  * Computes ceil(a / b) for non-negative a and b.
diff --git a/src/lang/english.txt b/src/lang/english.txt
index f2848f0..050ea58 100644
--- a/src/lang/english.txt
+++ b/src/lang/english.txt
@@ -3285,6 +3285,7 @@ STR_TIMETABLE_ORDER_VIEW_TOOLTIP                                :{BLACK}Switch t
 STR_TIMETABLE_TOOLTIP                                           :{BLACK}Timetable - click on an order to highlight it
 
 STR_TIMETABLE_NO_TRAVEL                                         :No travel
+STR_TIMETABLE_NOT_TIMETABLEABLE                                 :Travel (timetabled by next manual order)
 STR_TIMETABLE_TRAVEL_NOT_TIMETABLED                             :Travel (not timetabled)
 STR_TIMETABLE_TRAVEL_FOR                                        :Travel for {STRING1}
 STR_TIMETABLE_STAY_FOR                                          :and stay for {STRING1}
diff --git a/src/moving_average.cpp b/src/moving_average.cpp
new file mode 100644
index 0000000..c2b3341
--- /dev/null
+++ b/src/moving_average.cpp
@@ -0,0 +1,46 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.cpp Implementation of moving average functions */
+
+#include "moving_average.h"
+#include "date_func.h"
+#include "station_base.h"
+
+/**
+ * Run moving average decrease function on all items from a pool which are due
+ * this tick. This function expects to be run every tick. It calls a method
+ * "RunAverages()" on all items for which id % DAY_TICKS == _tick_counter % DAY_TICKS.
+ * So each item is called once a day.
+ */
+template <class Titem> void RunAverages()
+{
+	for(uint id = _tick_counter % DAY_TICKS; id < Titem::GetPoolSize(); id += DAY_TICKS) {
+		Titem *item = Titem::GetIfValid(id);
+		if (item != NULL) {
+			item->RunAverages();
+		}
+	}
+}
+
+/**
+ * Decrease the given value using this moving average
+ * @param value the moving average value to be decreased
+ * @return the decreased value
+ */
+template <class Tvalue>
+FORCEINLINE Tvalue &MovingAverage<Tvalue>::Decrease(Tvalue &value) const
+{
+	value *= this->length;
+	value /= (this->length + 1);
+	return value;
+}
+
+template class MovingAverage<uint>;
+template void RunAverages<Station>();
diff --git a/src/moving_average.h b/src/moving_average.h
new file mode 100644
index 0000000..a64ecf1
--- /dev/null
+++ b/src/moving_average.h
@@ -0,0 +1,66 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.h Utility class for moving averages. */
+
+#ifndef MOVING_AVERAGE_H_
+#define MOVING_AVERAGE_H_
+
+#include "stdafx.h"
+#include "settings_type.h"
+#include "core/math_func.hpp"
+
+/**
+ * Class implementing moving average functionality. An instance of this class
+ * can be used to get a meaningful (Monthly()) value from a moving average and
+ * it can be used to do the decrease operation.
+ * @tparam Tvalue a type supporting operator*(uint), operator/(uint),
+ * operator*=(uint) and operator/=(uint) with the usual semantics.
+ */
+template<class Tvalue>
+class MovingAverage {
+protected:
+	uint length;
+
+public:
+	/**
+	 * Create a moving average
+	 * @param length the length to be used
+	 */
+	FORCEINLINE MovingAverage(uint length) : length(length)
+	{
+		assert(this->length > 0);
+	}
+
+	/**
+	 * Get the length of this moving average
+	 * @return the length
+	 */
+	FORCEINLINE uint Length() const
+	{
+		return this->length;
+	}
+
+	/**
+	 * Get the current average for one month from the given value
+	 * @param value the raw moving average
+	 * @return the monthly average
+	 */
+	FORCEINLINE Tvalue Monthly(const Tvalue &value) const
+	{
+		return value * 30 / (this->length);
+	}
+
+	Tvalue &Decrease(Tvalue &value) const;
+};
+
+template<class Titem> void RunAverages();
+
+#endif /* MOVING_AVERAGE_H_ */
+
diff --git a/src/order_base.h b/src/order_base.h
index 2b60592..9f4cb52 100644
--- a/src/order_base.h
+++ b/src/order_base.h
@@ -124,6 +124,12 @@ public:
 	void MakeConditional(VehicleOrderID order);
 
 	/**
+	 * Makes this order an automatic order.
+	 * @param destination the station to go to.
+	 */
+	void MakeAutomatic(StationID destination);
+
+	/**
 	 * Gets the destination of this order.
 	 * @pre IsType(OT_GOTO_WAYPOINT) || IsType(OT_GOTO_DEPOT) || IsType(OT_GOTO_STATION).
 	 * @return the destination of the order.
@@ -265,6 +271,16 @@ struct OrderList : OrderListPool::PoolItem<&_orderlist_pool> {
 private:
 	friend void AfterLoadVehicles(bool part_of_load); ///< For instantiating the shared vehicle chain
 	friend const struct SaveLoad *GetOrderListDescription(); ///< Saving and loading of order lists.
+	
+	/**
+	 * Get the order after the given one or the first one, if the given one is the
+	 * last one.
+	 * @param curr the order to find the next one for
+	 * @return the next order
+	 */
+	inline const Order *GetNext(const Order *curr) const { return (curr->next == NULL) ? this->GetFirstOrder() : curr->next; }
+
+	StationID GetNextStoppingStation(const Order *next, StationID curr_station, uint hops) const;
 
 	Order *first;                   ///< First order of the order list
 	VehicleOrderID num_orders;      ///< NOSAVE: How many orders there are in the list
@@ -315,6 +331,8 @@ public:
 	 */
 	inline Order *GetLastOrder() const { return this->GetOrderAt(this->num_orders - 1); }
 
+	StationID GetNextStoppingStation(VehicleOrderID curr_order, StationID curr_station) const;
+
 	/**
 	 * Get number of orders in the order list.
 	 * @return number of orders in the chain.
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
index 684ff62..97f842f 100644
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -99,6 +99,12 @@ void Order::MakeConditional(VehicleOrderID order)
 	this->dest = 0;
 }
 
+void Order::MakeAutomatic(StationID destination)
+{
+	this->type = OT_AUTOMATIC;
+	this->dest = destination;
+}
+
 void Order::SetRefit(CargoID cargo, byte subtype)
 {
 	this->refit_cargo = cargo;
@@ -251,6 +257,61 @@ Order *OrderList::GetOrderAt(int index) const
 	return order;
 }
 
+/**
+ * Recursively determine the next deterministic station to stop at.
+ * @param next the first order to check
+ * @param curr_station the station the vehicle is just visiting or INVALID_STATION
+ * @param hops the number of orders we have already checked.
+ * @return the next stoppping station or INVALID_STATION
+ */
+StationID OrderList::GetNextStoppingStation(const Order *next, StationID curr_station, uint hops) const
+{
+	if (next == NULL || hops > this->GetNumOrders()) {
+		return INVALID_STATION;
+	}
+
+	if (next->IsType(OT_CONDITIONAL)) {
+		StationID skip_to = this->GetNextStoppingStation(this->GetOrderAt(next->GetConditionSkipToOrder()), curr_station, hops + 1);
+		StationID advance = this->GetNextStoppingStation(this->GetNext(next), curr_station, hops + 1);
+		return (skip_to == advance) ? skip_to : INVALID_STATION;
+	}
+
+	if (!(next->IsType(OT_GOTO_STATION) || next->IsType(OT_AUTOMATIC)) ||
+			(next->GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION) != 0 ||
+			next->GetDestination() == curr_station) {
+		return GetNextStoppingStation(this->GetNext(next), curr_station, hops + 1);
+	}
+
+	return next->GetDestination();
+}
+
+/**
+ * Get the next station the vehicle will stop at, if that is deterministic.
+ * @param curr_order the ID of the current order
+ * @param curr_station the station the vehicle is just visiting or INVALID_STATION
+ * @return The ID of the next station the vehicle will stop at or INVALID_STATION
+ */
+StationID OrderList::GetNextStoppingStation(VehicleOrderID curr_order, StationID curr_station) const
+{
+	const Order *curr = this->GetOrderAt(curr_order);
+	if (curr == NULL) {
+		curr = this->GetFirstOrder();
+		if (curr == NULL) return INVALID_STATION;
+	}
+
+	/* If we're not at a station or the current order doesn't yield the station
+	 * we're at, we have to check the current order; otherwise we have to check
+	 * the next one.
+	 */
+	if (curr_station == INVALID_STATION || 
+			!(curr->IsType(OT_GOTO_STATION) || curr->IsType(OT_AUTOMATIC)) ||
+			curr_station != curr->GetDestination()) {
+		return this->GetNextStoppingStation(curr, curr_station, 0);
+	} else {
+		return this->GetNextStoppingStation(this->GetNext(curr), curr_station, 1);
+	}
+}
+
 void OrderList::InsertOrderAt(Order *new_order, int index)
 {
 	if (this->first == NULL) {
@@ -700,6 +761,8 @@ void InsertOrder(Vehicle *v, Order *new_o, VehicleOrderID sel_ord)
 		}
 		/* Update any possible open window of the vehicle */
 		InvalidateVehicleOrder(u, INVALID_VEH_ORDER_ID | (sel_ord << 8));
+		
+		RecalcFrozenIfLoading(u);
 	}
 
 	/* As we insert an order, the order to skip to will be 'wrong'. */
@@ -732,6 +795,9 @@ static CommandCost DecloneOrder(Vehicle *dst, DoCommandFlag flags)
 	if (flags & DC_EXEC) {
 		DeleteVehicleOrders(dst);
 		InvalidateVehicleOrder(dst, -1);
+
+		RecalcFrozenIfLoading(dst);
+
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(dst->type), 0);
 	}
 	return CommandCost();
@@ -794,6 +860,8 @@ void DeleteOrder(Vehicle *v, VehicleOrderID sel_ord)
 
 		/* Update any possible open window of the vehicle */
 		InvalidateVehicleOrder(u, sel_ord | (INVALID_VEH_ORDER_ID << 8));
+
+		RecalcFrozenIfLoading(u);
 	}
 
 	/* As we delete an order, the order to skip to will be 'wrong'. */
@@ -837,10 +905,10 @@ CommandCost CmdSkipToOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 	if (ret.Failed()) return ret;
 
 	if (flags & DC_EXEC) {
-		v->cur_order_index = sel_ord;
-
 		if (v->current_order.IsType(OT_LOADING)) v->LeaveStation();
 
+		v->cur_order_index = sel_ord;
+
 		InvalidateVehicleOrder(v, -2);
 	}
 
@@ -905,6 +973,8 @@ CommandCost CmdMoveOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 			assert(v->orders.list == u->orders.list);
 			/* Update any possible open window of the vehicle */
 			InvalidateVehicleOrder(u, moving_order | (target_order << 8));
+
+			RecalcFrozenIfLoading(u);
 		}
 
 		/* As we move an order, the order to skip to will be 'wrong'. */
@@ -1161,6 +1231,8 @@ CommandCost CmdModifyOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 				u->current_order.SetLoadType(order->GetLoadType());
 			}
 			InvalidateVehicleOrder(u, -2);
+
+			RecalcFrozenIfLoading(u);
 		}
 	}
 
@@ -1293,6 +1365,8 @@ CommandCost CmdCloneOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 		default: return CMD_ERROR;
 	}
 
+	RecalcFrozenIfLoading(dst);
+
 	return CommandCost();
 }
 
@@ -1454,6 +1528,8 @@ void RemoveOrderFromAllVehicles(OrderType type, DestinationID destination)
 					/* In GUI, simulate by removing the order and adding it back */
 					InvalidateVehicleOrder(w, id | (INVALID_VEH_ORDER_ID << 8));
 					InvalidateVehicleOrder(w, (INVALID_VEH_ORDER_ID << 8) | id);
+
+					RecalcFrozenIfLoading(w);
 				}
 			}
 		}
@@ -1493,6 +1569,8 @@ void DeleteVehicleOrders(Vehicle *v, bool keep_orderlist)
 		v->orders.list->FreeChain(keep_orderlist);
 		if (!keep_orderlist) v->orders.list = NULL;
 	}
+
+	RecalcFrozenIfLoading(v);
 }
 
 uint16 GetServiceIntervalClamped(uint interval, CompanyID company_id)
@@ -1653,7 +1731,15 @@ bool UpdateOrderDest(Vehicle *v, const Order *order, int conditional_depth)
 	assert(v->cur_order_index < v->GetNumOrders());
 
 	/* Get the current order */
-	order = v->GetOrder(v->cur_order_index);
+	order = v->GetNextManualOrder(v->cur_order_index);
+	if (order == NULL) {
+		order = v->GetNextManualOrder(0);
+		if (order == NULL) {
+			v->current_order.Free();
+			v->dest_tile = 0;
+			return false;
+		}
+	}
 	v->current_order = *order;
 	return UpdateOrderDest(v, order, conditional_depth + 1);
 }
@@ -1708,7 +1794,7 @@ bool ProcessOrders(Vehicle *v)
 	/* Get the current order */
 	if (v->cur_order_index >= v->GetNumOrders()) v->cur_order_index = 0;
 
-	const Order *order = v->GetOrder(v->cur_order_index);
+	const Order *order = v->GetNextManualOrder(v->cur_order_index);
 
 	/* If no order, do nothing. */
 	if (order == NULL || (v->type == VEH_AIRCRAFT && !CheckForValidOrders(v))) {
diff --git a/src/order_gui.cpp b/src/order_gui.cpp
index a3ed0ce..8a15865 100644
--- a/src/order_gui.cpp
+++ b/src/order_gui.cpp
@@ -200,8 +200,15 @@ void DrawOrderString(const Vehicle *v, const Order *order, int order_index, int
 		DrawSprite(sprite, PAL_NONE, rtl ? right - sprite_size.width : left, y + ((int)FONT_HEIGHT_NORMAL - (int)sprite_size.height) / 2);
 	}
 
+	TextColour colour = TC_BLACK;
+	if (order->IsType(OT_AUTOMATIC)) {
+		colour =  selected ? TC_SILVER : TC_GREY;
+	} else if (selected) {
+		colour = TC_WHITE;
+	}
+
 	SetDParam(0, order_index + 1);
-	DrawString(left, rtl ? right - sprite_size.width - 3 : middle, y, STR_ORDER_INDEX, selected ? TC_WHITE : TC_BLACK, SA_RIGHT | SA_FORCE);
+	DrawString(left, rtl ? right - sprite_size.width - 3 : middle, y, STR_ORDER_INDEX, colour, SA_RIGHT | SA_FORCE);
 
 	SetDParam(5, STR_EMPTY);
 
@@ -211,6 +218,13 @@ void DrawOrderString(const Vehicle *v, const Order *order, int order_index, int
 			SetDParam(1, order->GetDestination());
 			break;
 
+		case OT_AUTOMATIC:
+			SetDParam(0, STR_ORDER_GO_TO_STATION);
+			SetDParam(1, STR_ORDER_GO_TO);
+			SetDParam(2, order->GetDestination());
+			SetDParam(3, STR_EMPTY);
+			break;
+
 		case OT_GOTO_STATION: {
 			OrderLoadFlags load = order->GetLoadType();
 			OrderUnloadFlags unload = order->GetUnloadType();
@@ -298,7 +312,7 @@ void DrawOrderString(const Vehicle *v, const Order *order, int order_index, int
 		default: NOT_REACHED();
 	}
 
-	DrawString(rtl ? left : middle, rtl ? middle : right, y, STR_ORDER_TEXT, selected ? TC_WHITE : TC_BLACK);
+	DrawString(rtl ? left : middle, rtl ? middle : right, y, STR_ORDER_TEXT, colour);
 }
 
 
diff --git a/src/order_type.h b/src/order_type.h
index 7b252ad..6d9b0f0 100644
--- a/src/order_type.h
+++ b/src/order_type.h
@@ -38,6 +38,7 @@ enum OrderType {
 	OT_DUMMY         = 5,
 	OT_GOTO_WAYPOINT = 6,
 	OT_CONDITIONAL   = 7,
+	OT_AUTOMATIC     = 8,
 	OT_END
 };
 
diff --git a/src/roadveh_cmd.cpp b/src/roadveh_cmd.cpp
index 422086e..7767c5c 100644
--- a/src/roadveh_cmd.cpp
+++ b/src/roadveh_cmd.cpp
@@ -235,6 +235,7 @@ CommandCost CmdBuildRoadVehicle(TileIndex tile, DoCommandFlag flags, const Engin
 		v->cargo_cap = rvi->capacity;
 
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 		v->engine_type = e->index;
 		v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
 
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
index 85a2579..3ac4fe6 100644
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -221,7 +221,7 @@
  *  154   21426
  *  155   21453
  */
-extern const uint16 SAVEGAME_VERSION = 155; ///< Current savegame version of OpenTTD.
+extern const uint16 SAVEGAME_VERSION = SL_CAPACITIES; ///< Current savegame version of OpenTTD.
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
index f9d1914..e426c0e 100644
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -88,9 +88,6 @@ enum SLRefType {
 	REF_ORDERLIST     = 8, ///< Load/save a reference to an orderlist.
 };
 
-/** Highest possible savegame version. */
-#define SL_MAX_VERSION 255
-
 /** Flags of a chunk. */
 enum ChunkType {
 	CH_RIFF         =  0,
@@ -546,4 +543,16 @@ bool SaveloadCrashWithMissingNewGRFs();
 extern char _savegame_format[8];
 extern bool _do_autosave;
 
+/**
+ * save/load versions used for the various branches
+ * SL_TRUNK is always the current trunk version.
+ */
+enum SaveLoadVersions {
+	SL_TRUNK = 155,
+	SL_CAPACITIES = SL_TRUNK + 20,
+
+	/** Highest possible savegame version. */
+	SL_MAX_VERSION = 255
+};
+
 #endif /* SAVELOAD_H */
diff --git a/src/saveload/station_sl.cpp b/src/saveload/station_sl.cpp
index 9e48724..a1e6822 100644
--- a/src/saveload/station_sl.cpp
+++ b/src/saveload/station_sl.cpp
@@ -205,6 +205,7 @@ static const SaveLoad _old_station_desc[] = {
 };
 
 static uint16 _waiting_acceptance;
+static uint16 _num_links;
 static uint16 _cargo_source;
 static uint32 _cargo_source_xy;
 static uint16 _cargo_days;
@@ -217,6 +218,26 @@ static const SaveLoad _station_speclist_desc[] = {
 	SLE_END()
 };
 
+static StationID _station_id;
+
+/**
+ * Wrapper function to get the LinkStat's internal structure while
+ * some of the variables are private.
+ * @return the saveload description for LinkStat.
+ */
+const SaveLoad *GetLinkStatDesc() {
+	static const SaveLoad linkstat_desc[] = {
+		SLEG_CONDVAR(             _station_id,         SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    length,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    capacity,            SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    frozen,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    usage,               SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_END()
+	};
+	
+	return linkstat_desc;
+}
+
 /**
  * Wrapper function to get the GoodsEntry's internal structure while
  * some of the variables itself are private.
@@ -240,7 +261,9 @@ const SaveLoad *GetGoodsDesc()
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_INT64,                  65, 67),
 		 SLE_CONDVAR(GoodsEntry, amount_fract,        SLE_UINT8,                 150, SL_MAX_VERSION),
 		 SLE_CONDLST(GoodsEntry, cargo.packets,       REF_CARGO_PACKET,           68, SL_MAX_VERSION),
-
+		 SLE_CONDVAR(GoodsEntry, supply,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, supply_new,          SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
 		SLE_END()
 	};
 
@@ -382,8 +405,14 @@ static void RealSave_STNN(BaseStation *bst)
 
 	if (!waypoint) {
 		Station *st = Station::From(bst);
-		for (CargoID i = 0; i < NUM_CARGO; i++) {
-			SlObject(&st->goods[i], GetGoodsDesc());
+		for (CargoID c = 0; c < NUM_CARGO; c++) {
+			_num_links = (uint16)st->goods[c].link_stats.size();
+			SlObject(&st->goods[c], GetGoodsDesc());
+			for (LinkStatMap::const_iterator it(st->goods[c].link_stats.begin()); it != st->goods[c].link_stats.end(); ++it) {
+				_station_id = it->first;
+				LinkStat ls(it->second); // make a copy to avoid constness problems
+				SlObject(&ls, GetLinkStatDesc());
+			}
 		}
 	}
 
@@ -414,8 +443,14 @@ static void Load_STNN()
 
 		if (!waypoint) {
 			Station *st = Station::From(bst);
-			for (CargoID i = 0; i < NUM_CARGO; i++) {
-				SlObject(&st->goods[i], GetGoodsDesc());
+			for (CargoID c = 0; c < NUM_CARGO; c++) {
+				SlObject(&st->goods[c], GetGoodsDesc());
+				LinkStat ls;
+				for (uint16 i = 0; i < _num_links; ++i) {
+					SlObject(&ls, GetLinkStatDesc());
+					assert(!ls.IsNull());
+					st->goods[c].link_stats[_station_id] = ls;
+				}
 			}
 		}
 
diff --git a/src/saveload/vehicle_sl.cpp b/src/saveload/vehicle_sl.cpp
index f6e40e7..9f5bc3a 100644
--- a/src/saveload/vehicle_sl.cpp
+++ b/src/saveload/vehicle_sl.cpp
@@ -452,6 +452,7 @@ const SaveLoad *GetVehicleDescription(VehicleType vt)
 		     SLE_VAR(Vehicle, vehstatus,             SLE_UINT8),
 		 SLE_CONDVAR(Vehicle, last_station_visited,  SLE_FILE_U8  | SLE_VAR_U16,   0,   4),
 		 SLE_CONDVAR(Vehicle, last_station_visited,  SLE_UINT16,                   5, SL_MAX_VERSION),
+		 SLE_CONDVAR(Vehicle, last_loading_station,  SLE_UINT16,       SL_CAPACITIES, SL_MAX_VERSION),
 
 		     SLE_VAR(Vehicle, cargo_type,            SLE_UINT8),
 		 SLE_CONDVAR(Vehicle, cargo_subtype,         SLE_UINT8,                   35, SL_MAX_VERSION),
@@ -742,6 +743,8 @@ void Load_VEHS()
 			v->last_station_visited = INVALID_STATION;
 		}
 
+		if (IsSavegameVersionBefore(SL_CAPACITIES)) v->last_loading_station = INVALID_STATION;
+
 		if (IsSavegameVersionBefore(5)) {
 			/* Convert the current_order.type (which is a mix of type and flags, because
 			 *  in those versions, they both were 4 bits big) to type and flags */
diff --git a/src/ship_cmd.cpp b/src/ship_cmd.cpp
index 7fffc3e..58fa99d 100644
--- a/src/ship_cmd.cpp
+++ b/src/ship_cmd.cpp
@@ -614,6 +614,7 @@ CommandCost CmdBuildShip(TileIndex tile, DoCommandFlag flags, const Engine *e, u
 		v->cargo_cap = svi->capacity;
 
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 		v->engine_type = e->index;
 
 		v->reliability = e->reliability;
diff --git a/src/station.cpp b/src/station.cpp
index 003798a..6211daa 100644
--- a/src/station.cpp
+++ b/src/station.cpp
@@ -63,7 +63,8 @@ Station::Station(TileIndex tile) :
 }
 
 /**
- * Clean up a station by clearing vehicle orders and invalidating windows.
+ * Clean up a station by clearing vehicle orders, invalidating windows and
+ * removing link stats.
  * Aircraft-Hangar orders need special treatment here, as the hangars are
  * actually part of a station (tiletype is STATION), but the order type
  * is OT_GOTO_DEPOT.
@@ -82,12 +83,23 @@ Station::~Station()
 		if (a->targetairport == this->index) a->targetairport = INVALID_STATION;
 	}
 
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID c = 0; c < NUM_CARGO; ++c) {
+			GoodsEntry &ge = st->goods[c];
+			ge.link_stats.erase(this->index);
+		}
+	}
+
 	Vehicle *v;
 	FOR_ALL_VEHICLES(v) {
 		/* Forget about this station if this station is removed */
 		if (v->last_station_visited == this->index) {
 			v->last_station_visited = INVALID_STATION;
 		}
+		if (v->last_loading_station == this->index) {
+			v->last_loading_station = INVALID_STATION;
+		}
 	}
 
 	InvalidateWindowData(WC_STATION_LIST, this->owner, 0);
diff --git a/src/station_base.h b/src/station_base.h
index d595379..ead85cc 100644
--- a/src/station_base.h
+++ b/src/station_base.h
@@ -17,12 +17,151 @@
 #include "cargopacket.h"
 #include "industry_type.h"
 #include "newgrf_storage.h"
+#include "moving_average.h"
+#include <map>
 
 typedef Pool<BaseStation, StationID, 32, 64000> StationPool;
 extern StationPool _station_pool;
 
 static const byte INITIAL_STATION_RATING = 175;
 
+/**
+ * Link statistics. They include figures for capacity and usage of a link. Both
+ * are moving averages which are increased for every vehicle arriving at the
+ * destination station and decreased in regular intervals. Additionally while a
+ * vehicle is loading at the source station part of the capacity is frozen and
+ * prevented from being decreased. This is done so that the link won't break
+ * down all the time when the typical "full load" order is used.
+ */
+class LinkStat : private MovingAverage<uint> {
+private:
+	/**
+	 * capacity of the link.
+	 * This is a moving average. Use MovingAverage::Monthly() to get a meaningful value
+	 */
+	uint capacity;
+	
+	/**
+	 * capacity of currently loading vehicles
+	 */
+	uint frozen;
+	
+	/**
+	 * usage of the link.
+	 * This is a moving average. Use MovingAverage::Monthly() to get a meaningful value
+	 */
+	uint usage;
+
+public:
+	/**
+	 * minimum length of moving averages for capacity and usage
+	 */
+	static const uint MIN_AVERAGE_LENGTH = 96;
+
+	friend const SaveLoad *GetLinkStatDesc();
+
+	FORCEINLINE LinkStat(uint distance = 1, uint capacity = 0, uint frozen = 0, uint usage = 0) :
+		MovingAverage<uint>(distance), capacity(capacity), frozen(frozen), usage(usage) {}
+
+	/**
+	 * reset everything to 0
+	 */
+	FORCEINLINE void Clear()
+	{
+		this->capacity = 0;
+		this->usage = 0;
+		this->frozen = 0;
+	}
+
+	/**
+	 * apply the moving averages to usage and capacity
+	 */
+	FORCEINLINE void Decrease()
+	{
+		this->MovingAverage<uint>::Decrease(this->usage);
+		this->capacity = max(this->MovingAverage<uint>::Decrease(this->capacity), this->frozen);
+	}
+
+	/**
+	 * get an estimate of the current the capacity
+	 * @return the capacity
+	 */
+	FORCEINLINE uint Capacity() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->capacity);
+	}
+
+	/**
+	 * get an estimage of the current usage
+	 * @return the usage
+	 */
+	FORCEINLINE uint Usage() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->usage);
+	}
+
+	/**
+	 * get the amount of frozen capacity
+	 */
+	FORCEINLINE uint Frozen() const
+	{
+		return this->frozen;
+	}
+
+	/**
+	 * add some capacity and usage
+	 * @param capacity the additional capacity
+	 * @param usage the additional usage
+	 */
+	FORCEINLINE void Increase(uint capacity, uint usage)
+	{
+		this->capacity += capacity;
+		this->usage += usage;
+	}
+
+	/**
+	 * freeze some of the capacity and prevent it from being decreased by the
+	 * moving average
+	 * @param capacity the amount of capacity to be frozen
+	 */
+	FORCEINLINE void Freeze(uint capacity)
+	{
+		this->frozen += capacity;
+		this->capacity = max(this->frozen, this->capacity);
+	}
+
+	/**
+	 * thaw some of the frozen capacity and make it available for Decrease()
+	 * @oaram capacity the capacity to be thawed
+	 */
+	FORCEINLINE void Unfreeze(uint capacity)
+	{
+		this->frozen -= capacity;
+	}
+
+	/**
+	 * thaw all frozen capacity
+	 */
+	FORCEINLINE void Unfreeze()
+	{
+		this->frozen = 0;
+	}
+
+	/**
+	 * check if the capacity is 0. This is necessary as Capacity() might return
+	 * 0 even if there is a miniscule amount of capacity left
+	 * @return if capacity is 0
+	 */
+	FORCEINLINE bool IsNull() const
+	{
+		return this->capacity == 0;
+	}
+};
+
+typedef std::map<StationID, LinkStat> LinkStatMap;
+
+uint GetMovingAverageLength(const Station *from, const Station *to);
+
 struct GoodsEntry {
 	enum AcceptancePickup {
 		ACCEPTANCE,
@@ -34,7 +173,9 @@ struct GoodsEntry {
 		days_since_pickup(255),
 		rating(INITIAL_STATION_RATING),
 		last_speed(0),
-		last_age(255)
+		last_age(255),
+		supply(0),
+		supply_new(0)
 	{}
 
 	byte acceptance_pickup;
@@ -44,6 +185,9 @@ struct GoodsEntry {
 	byte last_age;
 	byte amount_fract;      ///< Fractional part of the amount in the cargo list
 	StationCargoList cargo; ///< The cargo packets of cargo waiting in this station
+	uint supply;            ///< Cargo supplied last month
+	uint supply_new;        ///< Cargo supplied so far this month
+	LinkStatMap link_stats; ///< capacities and usage statistics for outgoing links
 };
 
 /** All airport-related information. Only valid if tile != INVALID_TILE. */
@@ -229,6 +373,8 @@ public:
 	/* virtual */ uint32 GetNewGRFVariable(const ResolverObject *object, byte variable, byte parameter, bool *available) const;
 
 	/* virtual */ void GetTileArea(TileArea *ta, StationType type) const;
+
+	void RunAverages();
 };
 
 #define FOR_ALL_STATIONS(var) FOR_ALL_BASE_STATIONS_OF_TYPE(Station, var)
diff --git a/src/station_cmd.cpp b/src/station_cmd.cpp
index fc6faff..19b203e 100644
--- a/src/station_cmd.cpp
+++ b/src/station_cmd.cpp
@@ -45,6 +45,7 @@
 #include "debug.h"
 #include "core/random_func.hpp"
 #include "company_base.h"
+#include "moving_average.h"
 #include "table/airporttile_ids.h"
 #include "newgrf_airporttiles.h"
 #include "order_backup.h"
@@ -3148,6 +3149,145 @@ static void UpdateStationRating(Station *st)
 	}
 }
 
+/**
+ * get the length of a moving average for a link between two stations
+ * @param from the source station
+ * @param to the destination station
+ * @return the moving average length
+ */
+uint GetMovingAverageLength(const Station *from, const Station *to)
+{
+	return LinkStat::MIN_AVERAGE_LENGTH + (DistanceManhattan(from->xy, to->xy) >> 2);
+}
+
+/**
+ * Run the moving average decrease function for all link stats.
+ */
+void Station::RunAverages() {
+	for(int goods_index = 0; goods_index < NUM_CARGO; ++goods_index) {
+		LinkStatMap &links = this->goods[goods_index].link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end();) {
+			StationID id = i->first;
+			Station *other = Station::GetIfValid(id);
+			if (other == NULL) {
+				links.erase(i++);
+			} else {
+				LinkStat &ls = i->second;
+				ls.Decrease();
+				if (ls.IsNull()) {
+					links.erase(i++);
+				} else {
+					++i;
+				}
+			}
+		}
+	}
+}
+
+/**
+ * Recalculate the frozen value of the station the given vehicle is loading at
+ * if the vehicle is loading.
+ * @param v the vehicle to be examined
+ */
+void RecalcFrozenIfLoading(const Vehicle *v) {
+	if (v->current_order.IsType(OT_LOADING)) {
+		RecalcFrozen(Station::Get(v->last_station_visited));
+	}
+}
+
+/**
+ * Recalculate all frozen values for all link stats of a station. This is done
+ * by adding up the capacities of all loading vehicles.
+ * @param st the station
+ */
+void RecalcFrozen(Station *st) {
+	for(int goods_index = 0; goods_index < NUM_CARGO; ++goods_index) {
+		GoodsEntry &good = st->goods[goods_index];
+		LinkStatMap &links = good.link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end(); ++i) {
+			i->second.Unfreeze();
+		}
+	}
+
+	std::list<Vehicle *>::iterator v_it = st->loading_vehicles.begin();
+	while(v_it != st->loading_vehicles.end()) {
+		const Vehicle *front = *v_it;
+		OrderList *orders = front->orders.list;
+		if (orders != NULL) {
+			StationID next_station_id = orders->GetNextStoppingStation(front->cur_order_index, st->index);
+			if (next_station_id != INVALID_STATION && next_station_id != st->index) {
+				IncreaseStats(st, front, next_station_id, true);
+			}
+		}
+		++v_it;
+	}
+}
+
+/**
+ * Decrease the frozen values of all link stats associated with vehicles in the
+ * given consist (ie the consist is leaving the station).
+ * @param st the station to decrease the frozen values on
+ * @param front the first vehicle in the consist
+ * @param next_station_id the station the vehicle is leaving for
+ */
+void DecreaseFrozen(Station *st, const Vehicle *front, StationID next_station_id) {
+	assert(st->index != next_station_id && next_station_id != INVALID_STATION);
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			LinkStatMap &link_stats = st->goods[v->cargo_type].link_stats;
+			LinkStatMap::iterator lstat_it = link_stats.find(next_station_id);
+			if (lstat_it == link_stats.end()) {
+				DEBUG(misc, 1, "frozen not in linkstat list.");
+				RecalcFrozen(st);
+				return;
+			} else {
+				LinkStat &link_stat = lstat_it->second;
+				if (link_stat.Frozen() < v->cargo_cap) {
+					DEBUG(misc, 1, "frozen is smaller than cargo cap.");
+					RecalcFrozen(st);
+					return;
+				} else {
+					link_stat.Unfreeze(v->cargo_cap);
+				}
+				assert(!link_stat.IsNull());
+			}
+		}
+	}
+}
+
+/**
+ * Either freeze or increase capacity for all link stats associated with vehicles
+ * in the given consist.
+ * @param st the station to get the link stats from
+ * @param front the first vehicle in the consist
+ * @param next_station_id the station the consist will be travelling to next
+ * @param freeze if true, freeze capacity, otherwise increase capacity
+ */
+void IncreaseStats(Station *st, const Vehicle *front, StationID next_station_id, bool freeze) {
+	Station *next = Station::GetIfValid(next_station_id);
+	assert(st->index != next_station_id && next != NULL);
+	uint average_length = GetMovingAverageLength(st, next);
+
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			LinkStatMap &stats = st->goods[v->cargo_type].link_stats;
+			LinkStatMap::iterator i = stats.find(next_station_id);
+			if (i == stats.end()) {
+				stats.insert(std::make_pair(next_station_id, LinkStat(average_length,
+						v->cargo_cap, freeze ? v->cargo_cap : 0, freeze ? 0 : v->cargo.Count())));
+			} else {
+				LinkStat &link_stat = i->second;
+				if (freeze) {
+					link_stat.Freeze(v->cargo_cap);
+				} else {
+					link_stat.Increase(v->cargo_cap, v->cargo.Count());
+				}
+				assert(!link_stat.IsNull());
+			}
+		}
+	}
+}
+
 /* called for every station each tick */
 static void StationHandleSmallTick(BaseStation *st)
 {
@@ -3164,6 +3304,8 @@ void OnTick_Station()
 {
 	if (_game_mode == GM_EDITOR) return;
 
+	RunAverages<Station>();
+
 	BaseStation *st;
 	FOR_ALL_BASE_STATIONS(st) {
 		StationHandleSmallTick(st);
@@ -3182,7 +3324,13 @@ void OnTick_Station()
 
 void StationMonthlyLoop()
 {
-	/* not used */
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for(int goods_index = 0; goods_index < NUM_CARGO; ++goods_index) {
+			st->goods[goods_index].supply = st->goods[goods_index].supply_new;
+			st->goods[goods_index].supply_new = 0;
+		}
+	}
 }
 
 
@@ -3215,6 +3363,7 @@ static uint UpdateStationWaiting(Station *st, CargoID type, uint amount, SourceT
 	if (amount == 0) return 0;
 
 	ge.cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id));
+	ge.supply_new += amount;
 
 	if (!HasBit(ge.acceptance_pickup, GoodsEntry::PICKUP)) {
 		InvalidateWindowData(WC_STATION_LIST, st->index);
diff --git a/src/station_func.h b/src/station_func.h
index 0fe5b2f..ad5d1c7 100644
--- a/src/station_func.h
+++ b/src/station_func.h
@@ -18,6 +18,7 @@
 #include "road_type.h"
 #include "cargo_type.h"
 #include "company_type.h"
+#include "vehicle_base.h"
 
 void ModifyStationRatingAround(TileIndex tile, Owner owner, int amount, uint radius);
 
@@ -46,4 +47,12 @@ bool IsStationTileElectrifiable(TileIndex tile);
 
 void UpdateAirportsNoise();
 
+void DecreaseFrozen(Station *st, const Vehicle *v, StationID next_station_id);
+
+void RecalcFrozen(Station * st);
+
+void RecalcFrozenIfLoading(const Vehicle * v);
+
+void IncreaseStats(Station *st, const Vehicle *v, StationID next_station_id, bool freeze);
+
 #endif /* STATION_FUNC_H */
diff --git a/src/timetable_cmd.cpp b/src/timetable_cmd.cpp
index 0f8fc39..40064f4 100644
--- a/src/timetable_cmd.cpp
+++ b/src/timetable_cmd.cpp
@@ -72,7 +72,7 @@ CommandCost CmdChangeTimetable(TileIndex tile, DoCommandFlag flags, uint32 p1, u
 
 	VehicleOrderID order_number = GB(p1, 20, 8);
 	Order *order = v->GetOrder(order_number);
-	if (order == NULL) return CMD_ERROR;
+	if (order == NULL || order->IsType(OT_AUTOMATIC)) return CMD_ERROR;
 
 	bool is_journey = HasBit(p1, 28);
 
@@ -238,11 +238,17 @@ void UpdateVehicleTimetable(Vehicle *v, bool travelling)
 	v->current_order_time = 0;
 
 	if (!_settings_game.order.timetabling) return;
+	if (v->current_order.IsType(OT_AUTOMATIC)) return; // no timetabling of auto orders
+
+	VehicleOrderID first_manual_order = 0;
+	for (Order *o = v->GetFirstOrder(); o != NULL && o->IsType(OT_AUTOMATIC); o = o->next) {
+		++first_manual_order;
+	}
 
 	bool just_started = false;
 
 	/* This vehicle is arriving at the first destination in the timetable. */
-	if (v->cur_order_index == 0 && travelling) {
+	if (v->cur_order_index == first_manual_order && travelling) {
 		/* If the start date hasn't been set, or it was set automatically when
 		 * the vehicle last arrived at the first destination, update it to the
 		 * current time. Otherwise set the late counter appropriately to when
@@ -279,7 +285,7 @@ void UpdateVehicleTimetable(Vehicle *v, bool travelling)
 			ChangeTimetable(v, v->cur_order_index, time_taken, travelling);
 		}
 
-		if (v->cur_order_index == 0 && travelling) {
+		if (v->cur_order_index == first_manual_order && travelling) {
 			/* If we just started we would have returned earlier and have not reached
 			 * this code. So obviously, we have completed our round: So turn autofill
 			 * off again. */
diff --git a/src/timetable_gui.cpp b/src/timetable_gui.cpp
index 026d20a..bd1e62a 100644
--- a/src/timetable_gui.cpp
+++ b/src/timetable_gui.cpp
@@ -90,7 +90,7 @@ static void SetArrivalDepartParams(int param1, int param2, Ticks ticks)
 static bool CanDetermineTimeTaken(const Order *order, bool travelling)
 {
 	/* Current order is conditional */
-	if (order->IsType(OT_CONDITIONAL)) return false;
+	if (order->IsType(OT_CONDITIONAL) || order->IsType(OT_AUTOMATIC)) return false;
 	/* No travel time and we have not already finished travelling */
 	if (travelling && order->travel_time == 0) return false;
 	/* No wait time but we are loading at this timetabled station */
@@ -317,7 +317,7 @@ struct TimetableWindow : Window {
 			if (selected != -1) {
 				const Order *order = v->GetOrder(((selected + 1) / 2) % v->GetNumOrders());
 				if (selected % 2 == 1) {
-					disable = order != NULL && order->IsType(OT_CONDITIONAL);
+					disable = order != NULL && (order->IsType(OT_CONDITIONAL) || order->IsType(OT_AUTOMATIC));
 				} else {
 					disable = order == NULL || ((!order->IsType(OT_GOTO_STATION) || (order->GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION)) && !order->IsType(OT_CONDITIONAL));
 				}
@@ -387,9 +387,12 @@ struct TimetableWindow : Window {
 						}
 					} else {
 						StringID string;
-
+						TextColour colour = (i == selected) ? TC_WHITE : TC_BLACK;
 						if (order->IsType(OT_CONDITIONAL)) {
 							string = STR_TIMETABLE_NO_TRAVEL;
+						} else if(order->IsType(OT_AUTOMATIC)) {
+							string = STR_TIMETABLE_NOT_TIMETABLEABLE;
+							colour = (i == selected) ? TC_SILVER : TC_GREY;
 						} else if (order->travel_time == 0) {
 							string = STR_TIMETABLE_TRAVEL_NOT_TIMETABLED;
 						} else {
@@ -397,7 +400,7 @@ struct TimetableWindow : Window {
 							string = STR_TIMETABLE_TRAVEL_FOR;
 						}
 
-						DrawString(rtl ? r.left + WD_FRAMERECT_LEFT : middle, rtl ? middle : r.right - WD_FRAMERECT_LEFT, y, string, (i == selected) ? TC_WHITE : TC_BLACK);
+						DrawString(rtl ? r.left + WD_FRAMERECT_LEFT : middle, rtl ? middle : r.right - WD_FRAMERECT_LEFT, y, string, colour);
 
 						if (final_order) break;
 					}
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
index 46c8045..2f8587a 100644
--- a/src/train_cmd.cpp
+++ b/src/train_cmd.cpp
@@ -695,6 +695,7 @@ CommandCost CmdBuildRailVehicle(TileIndex tile, DoCommandFlag flags, const Engin
 		v->cargo_type = e->GetDefaultCargoType();
 		v->cargo_cap = rvi->capacity;
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 
 		v->engine_type = e->index;
 		v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index bc54690..bd87528 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -1231,7 +1231,7 @@ void VehicleEnterDepot(Vehicle *v)
 	if (v->current_order.IsType(OT_GOTO_DEPOT)) {
 		SetWindowDirty(WC_VEHICLE_VIEW, v->index);
 
-		const Order *real_order = v->GetOrder(v->cur_order_index);
+		const Order *real_order = v->GetNextManualOrder(v->cur_order_index);
 		Order t = v->current_order;
 		v->current_order.MakeDummy();
 
@@ -1747,6 +1747,12 @@ void Vehicle::BeginLoading()
 		current_order.MakeLoading(true);
 		UpdateVehicleTimetable(this, true);
 
+		for (Order *order = this->GetOrder(this->cur_order_index);
+				order != NULL && order->IsType(OT_AUTOMATIC);
+				order = order->next) {
+			DeleteOrder(this, this->cur_order_index);
+		}
+
 		/* Furthermore add the Non Stop flag to mark that this station
 		 * is the actual destination of the vehicle, which is (for example)
 		 * necessary to be known for HandleTrainLoading to determine
@@ -1755,10 +1761,37 @@ void Vehicle::BeginLoading()
 		this->current_order.SetNonStopType(ONSF_NO_STOP_AT_ANY_STATION);
 
 	} else {
+		Order *in_list = this->GetOrder(this->cur_order_index);
+		if (this->orders.list->GetNumOrders() < MAX_VEH_ORDER_ID &&
+				((in_list == NULL && this->cur_order_index == 0) ||
+				(in_list != NULL && (!in_list->IsType(OT_AUTOMATIC) || 
+				in_list->GetDestination() != this->last_station_visited)))) {
+			Order *auto_order = new Order();
+			auto_order->MakeAutomatic(this->last_station_visited);
+			InsertOrder(this, auto_order, this->cur_order_index);
+			if (this->cur_order_index > 0) --this->cur_order_index;
+		}
 		current_order.MakeLoading(false);
 	}
 
-	Station::Get(this->last_station_visited)->loading_vehicles.push_back(this);
+	Station *curr_station = Station::Get(this->last_station_visited);
+	curr_station->loading_vehicles.push_back(this);
+
+	StationID next_station_id = INVALID_STATION;
+	OrderList *orders = this->orders.list;
+	if (orders != NULL) {
+		next_station_id = orders->GetNextStoppingStation(this->cur_order_index, this->last_station_visited);
+	}
+
+	if (this->last_loading_station != INVALID_STATION && this->last_loading_station != this->last_station_visited) {
+		IncreaseStats(Station::Get(this->last_loading_station), this, this->last_station_visited, false);
+	}
+
+	if (this->CanLeaveWithCargo() && next_station_id != INVALID_STATION) {
+		assert(next_station_id != this->last_station_visited);
+		/* freeze stats for the next link */
+		IncreaseStats(curr_station, this, next_station_id, true);
+	}
 
 	PrepareUnload(this);
 
@@ -1772,6 +1805,19 @@ void Vehicle::BeginLoading()
 	this->MarkDirty();
 }
 
+/**
+ * A vehicle can leave the current station with cargo if:
+ * - it can load cargo here OR (
+ * - it could leave the last station with cargo AND
+ * - it doesn't have to unload all cargo here)
+ */
+bool Vehicle::CanLeaveWithCargo()
+{
+	return ((this->current_order.GetLoadType() & OLFB_NO_LOAD) == 0 ||
+			((this->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) == 0 &&
+			this->last_loading_station != INVALID_STATION));
+}
+
 void Vehicle::LeaveStation()
 {
 	assert(current_order.IsType(OT_LOADING));
@@ -1785,6 +1831,27 @@ void Vehicle::LeaveStation()
 	Station *st = Station::Get(this->last_station_visited);
 	st->loading_vehicles.remove(this);
 
+	OrderList *orders = this->orders.list;
+	if (orders != NULL) {
+		StationID next_station_id = orders->GetNextStoppingStation(this->cur_order_index, this->last_station_visited);
+		if (next_station_id != INVALID_STATION && next_station_id != this->last_station_visited) {
+			DecreaseFrozen(st, this, next_station_id);
+		}
+	} else {
+		DEBUG(misc, 1, "orders are NULL");
+		RecalcFrozen(st);
+	}
+
+	if (this->CanLeaveWithCargo()) {
+		/* if the vehicle could load here or could stop with cargo loaded set the last loading station */
+		this->last_loading_station = this->last_station_visited;
+	} else {
+		/* if the vehicle couldn't load and had to unload or transfer everything
+		 * set the last loading station to invalid as it will leave empty.
+		 */
+		this->last_loading_station = INVALID_STATION;
+	}
+
 	HideFillingPercent(&this->fill_percent_te_id);
 
 	if (this->type == VEH_TRAIN && !(this->vehstatus & VS_CRASHED)) {
@@ -1812,7 +1879,7 @@ void Vehicle::HandleLoading(bool mode)
 			this->LeaveStation();
 
 			/* If this was not the final order, don't remove it from the list. */
-			if (!at_destination_station) return;
+			if (!at_destination_station) break;
 			break;
 		}
 
@@ -2143,6 +2210,20 @@ void Vehicle::RemoveFromShared()
 	this->previous_shared = NULL;
 }
 
+/**
+ * Get the next manual (not OT_AUTOMATIC) order after the one at the given index.
+ * @param index the index to start searching at
+ * @return the next manual order at or after index or NULL if there is none.
+ */
+Order *Vehicle::GetNextManualOrder(int index) const
+{
+	Order *order = this->GetOrder(index);
+	while(order != NULL && order->IsType(OT_AUTOMATIC)) {
+		order = order->next;
+	}
+	return order;
+}
+
 void StopAllVehicles()
 {
 	Vehicle *v;
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index 381a5e3..a2ace3b 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -114,6 +114,8 @@ private:
 
 	Vehicle *next_shared;               ///< pointer to the next vehicle that shares the order
 	Vehicle *previous_shared;           ///< NOSAVE: pointer to the previous vehicle in the shared order chain
+
+	bool CanLeaveWithCargo();
 public:
 	friend const SaveLoad *GetVehicleDescription(VehicleType vt); ///< So we can use private/protected variables in the saveload code
 	friend bool AfterLoadGame();
@@ -198,6 +200,7 @@ public:
 	byte waiting_triggers;              ///< triggers to be yet matched
 
 	StationID last_station_visited;
+	StationID last_loading_station;
 
 	CargoID cargo_type;                 ///< type of cargo this vehicle is carrying
 	byte cargo_subtype;                 ///< Used for livery refits (NewGRF variations)
@@ -662,6 +665,8 @@ public:
 		return (this->orders.list == NULL) ? NULL : this->orders.list->GetOrderAt(index);
 	}
 
+	Order *GetNextManualOrder(int index) const;
+
 	/**
 	 * Returns the last order of a vehicle, or NULL if it doesn't exists
 	 * @return last order of a vehicle, if available
diff --git a/src/vehiclelist.cpp b/src/vehiclelist.cpp
index 5303e19..1d0f096 100644
--- a/src/vehiclelist.cpp
+++ b/src/vehiclelist.cpp
@@ -119,7 +119,7 @@ bool GenerateVehicleSortList(VehicleList *list, const VehicleListIdentifier &vli
 					const Order *order;
 
 					FOR_VEHICLE_ORDERS(v, order) {
-						if ((order->IsType(OT_GOTO_STATION) || order->IsType(OT_GOTO_WAYPOINT))
+						if ((order->IsType(OT_GOTO_STATION) || order->IsType(OT_GOTO_WAYPOINT) || order->IsType(OT_AUTOMATIC))
 								&& order->GetDestination() == vli.index) {
 							*list->Append() = v;
 							break;
