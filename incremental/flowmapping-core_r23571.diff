diff --git a/projects/openttd_vs100.vcxproj b/projects/openttd_vs100.vcxproj
index fdad94d..514ed8d 100644
--- a/projects/openttd_vs100.vcxproj
+++ b/projects/openttd_vs100.vcxproj
@@ -328,6 +328,7 @@
     <ClCompile Include="..\src\ini_load.cpp" />
     <ClCompile Include="..\src\landscape.cpp" />
     <ClCompile Include="..\src\linkgraph\demands.cpp" />
+    <ClCompile Include="..\src\linkgraph\flowmapper.cpp" />
     <ClCompile Include="..\src\linkgraph\linkgraph.cpp" />
     <ClCompile Include="..\src\linkgraph\mcf.cpp" />
     <ClCompile Include="..\src\map.cpp" />
@@ -461,6 +462,7 @@
     <ClInclude Include="..\src\landscape_type.h" />
     <ClInclude Include="..\src\language.h" />
     <ClInclude Include="..\src\linkgraph\demands.h" />
+    <ClInclude Include="..\src\linkgraph\flowmapper.h" />
     <ClInclude Include="..\src\linkgraph\linkgraph.h" />
     <ClInclude Include="..\src\linkgraph\linkgraph_type.h" />
     <ClInclude Include="..\src\linkgraph\mcf.h" />
diff --git a/projects/openttd_vs100.vcxproj.filters b/projects/openttd_vs100.vcxproj.filters
index b06e354..475442c 100644
--- a/projects/openttd_vs100.vcxproj.filters
+++ b/projects/openttd_vs100.vcxproj.filters
@@ -207,6 +207,9 @@
     <ClCompile Include="..\src\linkgraph\demands.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\linkgraph\flowmapper.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\linkgraph\linkgraph.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -606,6 +609,9 @@
     <ClInclude Include="..\src\linkgraph\demands.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\linkgraph\flowmapper.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\linkgraph\linkgraph.h">
       <Filter>Header Files</Filter>
     </ClInclude>
diff --git a/projects/openttd_vs80.vcproj b/projects/openttd_vs80.vcproj
index b00e142..4835d4f 100644
--- a/projects/openttd_vs80.vcproj
+++ b/projects/openttd_vs80.vcproj
@@ -583,6 +583,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
 				>
 			</File>
@@ -1119,6 +1123,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\linkgraph\linkgraph.h"
 				>
 			</File>
diff --git a/projects/openttd_vs90.vcproj b/projects/openttd_vs90.vcproj
index 3ab10bb..b2f8ea1 100644
--- a/projects/openttd_vs90.vcproj
+++ b/projects/openttd_vs90.vcproj
@@ -580,6 +580,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
 				>
 			</File>
@@ -1116,6 +1120,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\linkgraph\linkgraph.h"
 				>
 			</File>
diff --git a/source.list b/source.list
index b0b6150..77aee5f 100644
--- a/source.list
+++ b/source.list
@@ -36,6 +36,7 @@ ini.cpp
 ini_load.cpp
 landscape.cpp
 linkgraph/demands.cpp
+linkgraph/flowmapper.cpp
 linkgraph/linkgraph.cpp
 linkgraph/mcf.cpp
 map.cpp
@@ -194,6 +195,7 @@ landscape.h
 landscape_type.h
 language.h
 linkgraph/demands.h
+linkgraph/flowmapper.h
 linkgraph/linkgraph.h
 linkgraph/linkgraph_type.h
 linkgraph/mcf.h
diff --git a/src/linkgraph/flowmapper.cpp b/src/linkgraph/flowmapper.cpp
new file mode 100644
index 0000000..8b45147
--- /dev/null
+++ b/src/linkgraph/flowmapper.cpp
@@ -0,0 +1,54 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file flowmapper.cpp Definition of flowmapper. */
+
+#include "../stdafx.h"
+#include "flowmapper.h"
+
+/**
+ * Map the paths generated by the MCF solver into flows associated with nodes.
+ * @param component the link graph component to be used.
+ */
+void FlowMapper::Run(LinkGraphComponent *component)
+{
+	for (NodeID node_id = 0; node_id < component->GetSize(); ++node_id) {
+		Node &prev_node = component->GetNode(node_id);
+		StationID prev = prev_node.station;
+		PathSet &paths = prev_node.paths;
+		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
+			Path *path = *i;
+			uint flow = path->GetFlow();
+			if (flow == 0) continue;
+			Node &node = component->GetNode(path->GetNode());
+			StationID via = node.station;
+			assert(prev != via);
+			StationID origin = component->GetNode(path->GetOrigin()).station;
+			assert(via != origin);
+			/* mark all of the flow for local consumption at "first" */
+			node.flows[origin][via] += flow;
+			/* pass some of the flow marked for local consumption at "prev" on
+			 * to this node
+			 */
+			prev_node.flows[origin][via] += flow;
+			/* find simple circular flows ... */
+			assert(node.flows[origin][prev] == 0);
+			if (prev != origin) {
+				prev_node.flows[origin][prev] -= flow;
+			}
+		}
+	}
+	for (NodeID node_id = 0; node_id < component->GetSize(); ++node_id) {
+		PathSet &paths = component->GetNode(node_id).paths;
+		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
+			delete *i;
+		}
+		paths.clear();
+	}
+}
diff --git a/src/linkgraph/flowmapper.h b/src/linkgraph/flowmapper.h
new file mode 100644
index 0000000..a2b6bc0
--- /dev/null
+++ b/src/linkgraph/flowmapper.h
@@ -0,0 +1,30 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file flowmapper.h Declaration of flow mapper; maps paths into flows at nodes. */
+
+#ifndef FLOWMAPPER_H_
+#define FLOWMAPPER_H_
+
+#include "linkgraph.h"
+
+/**
+ * Map the path trees generated by the MCF solver into flows. The path tree is
+ * useful to cache capacities and distances and allow quick disconnecting and
+ * reconnecting to other paths. The flows show how much cargo from which nodes
+ * is to be routed in which direction at a given node. This is what we need in
+ * the end.
+ */
+class FlowMapper : public ComponentHandler {
+public:
+	virtual ~FlowMapper() {}
+	virtual void Run(LinkGraphComponent *component);
+};
+
+#endif /* FLOWMAPPER_H_ */
diff --git a/src/linkgraph/linkgraph.cpp b/src/linkgraph/linkgraph.cpp
index e0c231a..d00609d 100644
--- a/src/linkgraph/linkgraph.cpp
+++ b/src/linkgraph/linkgraph.cpp
@@ -17,6 +17,7 @@
 #include "linkgraph.h"
 #include "demands.h"
 #include "mcf.h"
+#include "flowmapper.h"
 #include <queue>
 
 /**
@@ -300,6 +301,66 @@ void LinkGraphComponent::Init(LinkGraphComponentID id)
 	this->settings = _settings_game.linkgraph;
 }
 
+
+/**
+ * Exports all entries in the FlowViaMap pointed to by "source_flows_it", erases the source
+ * flows and increments the iterator afterwards.
+ * @param it Iterator pointing to the flows to be exported into the main game state.
+ * @param dest Flow stats to which the flows shall be exported.
+ * @param cargo Cargo we're exporting flows for (used to check if the link stats for the new
+ *        flows still exist).
+ */
+void Node::ExportFlows(FlowMap::iterator &it, FlowStatMap &station_flows, CargoID cargo)
+{
+	FlowStat *dest = NULL;
+	StationID source = it->first;
+	FlowViaMap &source_flows = it->second;
+	if (!Station::IsValidID(source)) {
+		source_flows.clear();
+	} else {
+		Station *curr_station = Station::Get(this->station);
+		for (FlowViaMap::iterator update = source_flows.begin(); update != source_flows.end();) {
+			StationID next = update->first;
+			int planned = update->second;
+			assert(planned >= 0);
+
+			Station *via = Station::GetIfValid(next);
+			if (planned > 0 && via != NULL) {
+				if (next == this->station || 
+						curr_station->goods[cargo].link_stats.find(next) !=
+						curr_station->goods[cargo].link_stats.end()) {
+					if (dest == NULL) {
+						dest = &(station_flows.insert(std::make_pair(it->first, FlowStat(next, planned))).first->second);
+					} else {
+						dest->AddShare(next, planned);
+					}
+				}
+			}
+			source_flows.erase(update++);
+		}
+	}
+	
+	assert(source_flows.empty());
+
+	this->flows.erase(it++);
+}
+
+/**
+ * Export all flows of this node to the main game state.
+ * @param cargo the cargo we're exporting flows for.
+ */
+void Node::ExportFlows(CargoID cargo)
+{
+	FlowStatMap &station_flows = Station::Get(this->station)->goods[cargo].flows;
+	station_flows.clear();
+
+	/* loop over remaining flows (for other sources) in the node's map and insert them into the station */
+	for (FlowMap::iterator it(this->flows.begin()); it != this->flows.end();) {
+		ExportFlows(it, station_flows, cargo);
+	}
+	assert(this->flows.empty());
+}
+
 /**
  * Merge the current job's results into the main game state.
  */
@@ -307,6 +368,13 @@ void LinkGraph::Join()
 {
 	this->LinkGraphJob::Join();
 
+	for (NodeID node_id = 0; node_id < this->GetSize(); ++node_id) {
+		Node &node = this->GetNode(node_id);
+		if (Station::IsValidID(node.station)) {
+			node.ExportFlows(this->cargo);
+		}
+	}
+
 	this->LinkGraphComponent::Clear();
 }
 
@@ -453,5 +521,7 @@ void InitializeLinkGraphs()
 	LinkGraphJob::ClearHandlers();
 	LinkGraphJob::AddHandler(new DemandHandler);
 	LinkGraphJob::AddHandler(new MCFHandler<MCF1stPass>);
+	LinkGraphJob::AddHandler(new FlowMapper);
 	LinkGraphJob::AddHandler(new MCFHandler<MCF2ndPass>);
+	LinkGraphJob::AddHandler(new FlowMapper);
 }
diff --git a/src/linkgraph/linkgraph.h b/src/linkgraph/linkgraph.h
index 65dcfda..146cab5 100644
--- a/src/linkgraph/linkgraph.h
+++ b/src/linkgraph/linkgraph.h
@@ -50,6 +50,10 @@ public:
 	~Node() {this->Init();}
 
 	void Init(StationID st = INVALID_STATION, uint sup = 0, uint dem = 0);
+	void ExportFlows(CargoID cargo);
+
+private:
+	void ExportFlows(FlowMap::iterator &it, FlowStatMap &station_flows, CargoID cargo);
 };
 
 /**
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
index 4e7fa0d..16f8e95 100644
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -233,7 +233,7 @@
  *  166   23415
  *  167   23504
  */
-extern const uint16 SAVEGAME_VERSION = SL_MCF; ///< Current savegame version of OpenTTD.
+extern const uint16 SAVEGAME_VERSION = SL_FLOWMAP; ///< Current savegame version of OpenTTD.
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
index 46ee141..65409c0 100644
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -551,6 +551,7 @@ enum SaveLoadVersions {
 	SL_COMPONENTS,
 	SL_DEMANDS = SL_COMPONENTS + 20,
 	SL_MCF,
+	SL_FLOWMAP,
 
 	/** Highest possible savegame version. */
 	SL_MAX_VERSION = 255
diff --git a/src/saveload/station_sl.cpp b/src/saveload/station_sl.cpp
index 488f114..3778a2b 100644
--- a/src/saveload/station_sl.cpp
+++ b/src/saveload/station_sl.cpp
@@ -226,6 +226,7 @@ static const SaveLoad _old_station_desc[] = {
 
 static uint16 _waiting_acceptance;
 static uint16 _num_links;
+static uint32 _num_flows;
 static uint16 _cargo_source;
 static uint32 _cargo_source_xy;
 static uint16 _cargo_days;
@@ -259,6 +260,20 @@ const SaveLoad *GetLinkStatDesc()
 	return linkstat_desc;
 }
 
+struct FlowSaveLoad {
+	FlowSaveLoad() : via(0), share(0) {}
+	StationID source;
+	StationID via;
+	uint32 share;
+};
+
+static const SaveLoad _flow_desc[] = {
+	SLE_CONDVAR(FlowSaveLoad, source,             SLE_UINT16,         SL_FLOWMAP, SL_MAX_VERSION),
+	SLE_CONDVAR(FlowSaveLoad, via,                SLE_UINT16,         SL_FLOWMAP, SL_MAX_VERSION),
+	SLE_CONDVAR(FlowSaveLoad, share,              SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+	SLE_END()
+};
+
 /**
  * Wrapper function to get the GoodsEntry's internal structure while
  * some of the variables itself are private.
@@ -285,6 +300,7 @@ const SaveLoad *GetGoodsDesc()
 		 SLE_CONDVAR(GoodsEntry, supply,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
 		 SLE_CONDVAR(GoodsEntry, supply_new,          SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
 		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_flows,          SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
 		 SLE_CONDVAR(GoodsEntry, last_component,      SLE_UINT16,      SL_COMPONENTS, SL_MAX_VERSION),
 		SLE_END()
 	};
@@ -436,12 +452,29 @@ static void RealSave_STNN(BaseStation *bst)
 		Station *st = Station::From(bst);
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
 			_num_links = (uint16)st->goods[i].link_stats.size();
+			_num_flows = 0;
+			for (FlowStatMap::const_iterator it(st->goods[i].flows.begin()); it != st->goods[i].flows.end(); ++it) {
+				_num_flows += (uint32)it->second.GetShares()->size();
+			}
 			SlObject(&st->goods[i], GetGoodsDesc());
 			for (LinkStatMap::const_iterator it(st->goods[i].link_stats.begin()); it != st->goods[i].link_stats.end(); ++it) {
 				_station_id = it->first;
 				LinkStat ls(it->second); // make a copy to avoid constness problems
 				SlObject(&ls, GetLinkStatDesc());
 			}
+			for (FlowStatMap::const_iterator outer_it(st->goods[i].flows.begin()); outer_it != st->goods[i].flows.end(); ++outer_it) {
+				const FlowStat::SharesMap *shares = outer_it->second.GetShares();
+				uint32 sum_shares = 0;
+				FlowSaveLoad flow;
+				flow.source = outer_it->first;
+				for (FlowStat::SharesMap::const_iterator inner_it(shares->begin()); inner_it != shares->end(); ++inner_it) {
+					flow.via = inner_it->second;
+					flow.share = inner_it->first - sum_shares;
+					sum_shares = inner_it->first;
+					assert(flow.share > 0);
+					SlObject(&flow, _flow_desc);
+				}
+			}
 		}
 	}
 
@@ -489,6 +522,18 @@ static void Load_STNN()
 					assert(ls.IsValid());
 					st->goods[i].link_stats.insert(std::make_pair(_station_id, ls));
 				}
+				FlowSaveLoad flow;
+				FlowStat *fs = NULL;
+				StationID prev_source = INVALID_STATION;
+				for (uint32 j = 0; j < _num_flows; ++j) {
+					SlObject(&flow, _flow_desc);
+					if (fs == NULL || prev_source != flow.source) {
+						fs = &(st->goods[i].flows.insert(std::make_pair(flow.source, FlowStat(flow.via, flow.share))).first->second);
+					} else {
+						fs->AddShare(flow.via, flow.share);
+					}
+					prev_source = flow.source;
+				}
 			}
 		}
 
diff --git a/src/station.cpp b/src/station.cpp
index 95509e5..87345e8 100644
--- a/src/station.cpp
+++ b/src/station.cpp
@@ -94,6 +94,7 @@ Station::~Station()
 		for (CargoID c = 0; c < NUM_CARGO; ++c) {
 			GoodsEntry &ge = st->goods[c];
 			ge.link_stats.erase(this->index);
+			DeleteStaleFlows(st->index, c, this->index);
 		}
 	}
 
diff --git a/src/station_base.h b/src/station_base.h
index 5815630..ab0e46d 100644
--- a/src/station_base.h
+++ b/src/station_base.h
@@ -12,6 +12,7 @@
 #ifndef STATION_BASE_H
 #define STATION_BASE_H
 
+#include "core/random_func.hpp"
 #include "base_station_base.h"
 #include "newgrf_airport.h"
 #include "cargopacket.h"
@@ -150,7 +151,64 @@ public:
 	}
 };
 
+/**
+ * Flow statistics telling how much flow should be sent along a link. This is
+ * done by creating "flow shares" and using std::map's upper_bound() method to
+ * look them up with a random number. A flow share is the difference between a
+ * key in a map and the previous key. So one key in the map doesn't actually
+ * mean anything by itself.
+ */
+class FlowStat {
+public:
+	typedef std::map<uint32, StationID> SharesMap;
+
+	FORCEINLINE FlowStat() {NOT_REACHED();}
+	
+	FORCEINLINE FlowStat(StationID st, uint flow)
+	{
+		assert(flow > 0);
+		this->shares[flow] = st;
+	}
+
+	/**
+	 * Add some flow.
+	 * @param st Remote station.
+	 * @param flow Amount of flow to be added.
+	 */
+	FORCEINLINE void AddShare(StationID st, uint flow)
+	{
+		assert(flow > 0);
+		this->shares[(--this->shares.end())->first + flow] = st;
+	}
+	
+	uint GetShare(StationID st) const;
+	
+	void EraseShare(StationID st);
+	
+	FORCEINLINE const SharesMap *GetShares() const {return &this->shares;}
+
+	/**
+	 * Get a station a package can be routed to. This done by drawing a
+	 * random number between 0 and sum_shares and then looking that up in 
+	 * the map with lower_bound. So each share gets selected with a
+	 * probability dependent on its flow.
+         * @return A station ID from the shares map.
+         */
+	FORCEINLINE StationID GetVia() const
+	{
+		assert(!this->shares.empty());
+		uint rand = RandomRange((--this->shares.end())->first - 1);
+		SharesMap::const_iterator it = this->shares.upper_bound(rand);
+		assert(it != this->shares.end());
+		return it->second;
+	}
+
+private:
+	SharesMap shares;  ///< Shares of flow to be sent via specified station (or consumed locally).
+};
+
 typedef std::map<StationID, LinkStat> LinkStatMap;
+typedef std::map<StationID, FlowStat> FlowStatMap; ///< Flow descriptions by origin stations.
 
 uint GetMovingAverageLength(const Station *from, const Station *to);
 
@@ -188,8 +246,16 @@ struct GoodsEntry {
 	StationCargoList cargo; ///< The cargo packets of cargo waiting in this station
 	uint supply;            ///< Cargo supplied last month.
 	uint supply_new;        ///< Cargo supplied so far this month.
+	FlowStatMap flows;      ///< Planned flows through this station.
 	LinkStatMap link_stats; ///< Capacities and usage statistics for outgoing links.
 	LinkGraphComponentID last_component; ///< Component this station was last part of in this cargo's link graph.
+	uint GetSumFlowVia(StationID via) const;
+
+	FORCEINLINE StationID GetVia(StationID source) const
+	{
+		FlowStatMap::const_iterator flow_it(this->flows.find(source));
+		return flow_it != this->flows.end() ? flow_it->second.GetVia() : INVALID_STATION;
+	}
 };
 
 /** All airport-related information. Only valid if tile != INVALID_TILE. */
diff --git a/src/station_cmd.cpp b/src/station_cmd.cpp
index d48d485..e1c694e 100644
--- a/src/station_cmd.cpp
+++ b/src/station_cmd.cpp
@@ -3245,6 +3245,26 @@ static void UpdateStationRating(Station *st)
 }
 
 /**
+ * Delete all flows at a station for specific cargo and destination.
+ * @param at Station to delete flows from.
+ * @param c_id Cargo for which flows shall be deleted.
+ * @param to Remote station of flows to be deleted.
+ */
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to)
+{
+	FlowStatMap &flows = Station::Get(at)->goods[c_id].flows;
+	for (FlowStatMap::iterator f_it = flows.begin(); f_it != flows.end();) {
+		FlowStat &s_flows = f_it->second;
+		s_flows.EraseShare(to);
+		if (s_flows.GetShares()->empty()) {
+			flows.erase(f_it++);
+		} else {
+			++f_it;
+		}
+	}
+}
+
+/**
  * Get the length of a moving average for a link between two stations.
  * @param from Source station.
  * @param to Destination station.
@@ -3273,10 +3293,15 @@ void Station::RunAverages()
 				if (ls.IsValid()) {
 					++i;
 				} else {
+					DeleteStaleFlows(this->index, goods_index, id);
 					links.erase(i++);
 				}
 			}
 		}
+
+		if (_settings_game.linkgraph.GetDistributionType(goods_index) == DT_MANUAL) {
+			this->goods[goods_index].flows.clear();
+		}
 	}
 }
 
@@ -3807,6 +3832,60 @@ static CommandCost TerraformTile_Station(TileIndex tile, DoCommandFlag flags, in
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 }
 
+/**
+ * Get flow for a station.
+ * @param st Station to get flow for.
+ * @return Flow for st.
+ */	
+uint FlowStat::GetShare(StationID st) const
+{
+	uint32 prev = 0;
+	for (SharesMap::const_iterator it = this->shares.begin(); it != this->shares.end(); ++it) {
+		if (it->second == st) {
+			return it->first - prev;
+		} else {
+			prev = it->first;
+		}
+	}
+	return 0;
+}
+	
+/**
+ * Erase shares for specified station.
+ * @param st Next Hop to be removed.
+ */
+void FlowStat::EraseShare(StationID st)
+{
+	uint32 removed_shares = 0;
+	uint32 last_share = 0;
+	SharesMap new_shares;
+	for (SharesMap::iterator it(this->shares.begin()); it != this->shares.end(); ++it) {
+		if (it->second == st) {
+			removed_shares += it->first - last_share;
+		} else {
+			new_shares[it->first - removed_shares] = it->second;
+		}
+		last_share = it->first;
+	}
+	this->shares.swap(new_shares);
+	for (SharesMap::iterator it(this->shares.begin()); it != this->shares.end(); ++it) {
+		assert(it->second != st);
+	}
+}
+
+/**
+ * Get the sum of flows via a specific station from this GoodsEntry.
+ * @param via Remote station to look for.
+ * @return a FlowStat with all flows for 'via' added up.
+ */
+uint GoodsEntry::GetSumFlowVia(StationID via) const
+{
+	uint ret = 0;
+	for (FlowStatMap::const_iterator i = this->flows.begin(); i != this->flows.end(); ++i) {
+		ret += i->second.GetShare(via);
+	}
+	return ret;
+}
 
 extern const TileTypeProcs _tile_type_station_procs = {
 	DrawTile_Station,           // draw_tile_proc
diff --git a/src/station_func.h b/src/station_func.h
index 7946d4b..a546874 100644
--- a/src/station_func.h
+++ b/src/station_func.h
@@ -52,6 +52,8 @@ void IncreaseStats(Station *st, const Vehicle *v, StationID next_station_id);
 
 void IncreaseStats(Station *st, CargoID cargo, StationID next_station_id, uint capacity, uint usage);
 
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to);
+
 /**
  * Calculates the maintenance cost of a number of station tiles.
  * @param num Number of station tiles.
