diff --git a/projects/openttd_vs100.vcxproj b/projects/openttd_vs100.vcxproj
index fa3cfd6..af0afea 100644
--- a/projects/openttd_vs100.vcxproj
+++ b/projects/openttd_vs100.vcxproj
@@ -465,6 +465,7 @@
     <ClInclude Include="..\src\landscape.h" />
     <ClInclude Include="..\src\landscape_type.h" />
     <ClInclude Include="..\src\language.h" />
+    <ClInclude Include="..\src\linkgraph_gui.h" />
     <ClInclude Include="..\src\linkgraph\demands.h" />
     <ClInclude Include="..\src\linkgraph\flowmapper.h" />
     <ClInclude Include="..\src\linkgraph\linkgraph.h" />
@@ -673,6 +674,7 @@
     <ClCompile Include="..\src\highscore_gui.cpp" />
     <ClCompile Include="..\src\industry_gui.cpp" />
     <ClCompile Include="..\src\intro_gui.cpp" />
+    <ClCompile Include="..\src\linkgraph_gui.cpp" />
     <ClCompile Include="..\src\main_gui.cpp" />
     <ClCompile Include="..\src\misc_gui.cpp" />
     <ClCompile Include="..\src\music_gui.cpp" />
diff --git a/projects/openttd_vs100.vcxproj.filters b/projects/openttd_vs100.vcxproj.filters
index 3bb527f..da76a2c 100644
--- a/projects/openttd_vs100.vcxproj.filters
+++ b/projects/openttd_vs100.vcxproj.filters
@@ -624,6 +624,9 @@
     <ClInclude Include="..\src\language.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\linkgraph_gui.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\linkgraph\demands.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -1248,6 +1251,9 @@
     <ClCompile Include="..\src\intro_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\linkgraph_gui.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\main_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
diff --git a/projects/openttd_vs80.vcproj b/projects/openttd_vs80.vcproj
index fb88913..175e07d 100644
--- a/projects/openttd_vs80.vcproj
+++ b/projects/openttd_vs80.vcproj
@@ -1135,6 +1135,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\linkgraph\demands.h"
 				>
 			</File>
@@ -1975,6 +1979,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\main_gui.cpp"
 				>
 			</File>
diff --git a/projects/openttd_vs90.vcproj b/projects/openttd_vs90.vcproj
index 7574128..8a0ca51 100644
--- a/projects/openttd_vs90.vcproj
+++ b/projects/openttd_vs90.vcproj
@@ -1132,6 +1132,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\linkgraph\demands.h"
 				>
 			</File>
@@ -1972,6 +1976,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\main_gui.cpp"
 				>
 			</File>
diff --git a/source.list b/source.list
index 6f49501..9b20d6d 100644
--- a/source.list
+++ b/source.list
@@ -198,6 +198,7 @@ ini_type.h
 landscape.h
 landscape_type.h
 language.h
+linkgraph_gui.h
 linkgraph/demands.h
 linkgraph/flowmapper.h
 linkgraph/linkgraph.h
@@ -425,6 +426,7 @@ group_gui.cpp
 highscore_gui.cpp
 industry_gui.cpp
 intro_gui.cpp
+linkgraph_gui.cpp
 main_gui.cpp
 misc_gui.cpp
 music_gui.cpp
diff --git a/src/linkgraph_gui.cpp b/src/linkgraph_gui.cpp
new file mode 100644
index 0000000..195e59d
--- /dev/null
+++ b/src/linkgraph_gui.cpp
@@ -0,0 +1,294 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_gui.cpp Implementation of linkgraph overlay GUI. */
+
+#include "stdafx.h"
+#include "window_gui.h"
+#include "company_base.h"
+#include "date_func.h"
+#include "linkgraph_gui.h"
+#include "viewport_func.h"
+
+/**
+ * Colours for the various "load" states of links. Ordered from "unused" to
+ * "overloaded".
+ */
+const uint8 LinkGraphOverlay::LINK_COLOURS[] = {
+	0x0f, 0xd1, 0xd0, 0x57,
+	0x55, 0x53, 0xbf, 0xbd,
+	0xba, 0xb9, 0xb7, 0xb5
+};
+
+/**
+ * Get a DPI for the widget we will be drawing to.
+ * @param dpi DrawPixelInfo to fill with the desired dimensions.
+ */ 
+void LinkGraphOverlay::GetWidgetDpi(DrawPixelInfo *dpi) const
+{
+	const NWidgetBase *wi = this->window->GetWidget<NWidgetBase>(this->widget_id);
+	dpi->left = dpi->top = 0;
+	dpi->width = wi->current_x;
+	dpi->height = wi->current_y;
+}
+
+/**
+ * Rebuild the cache and recalculate which links and stations to be shown.
+ */
+void LinkGraphOverlay::RebuildCache()
+{
+	this->cached_links.clear();
+	this->cached_stations.clear();
+
+	DrawPixelInfo dpi;
+	this->GetWidgetDpi(&dpi);
+
+	const Station *sta;
+	FOR_ALL_STATIONS(sta) {
+		/* Show links between stations of selected companies or "neutral" ones like oilrigs. */
+		if (sta->owner != INVALID_COMPANY && !HasBit(this->company_mask, sta->owner)) continue;
+		if (sta->rect.IsEmpty()) continue;
+
+		Point pta = this->GetStationMiddle(sta);
+
+		StationID from = sta->index;
+		StationLinkMap &seen_links = this->cached_links[from];
+
+		uint supply = 0;
+		CargoID c;
+		FOR_EACH_SET_CARGO_ID(c, this->cargo_mask) {
+			if (!CargoSpec::Get(c)->IsValid()) continue;
+
+			supply += sta->goods[c].supply;
+			const LinkStatMap &links = sta->goods[c].link_stats;
+			for (LinkStatMap::const_iterator i = links.begin(); i != links.end(); ++i) {
+				StationID to = i->first;
+				if (seen_links.find(to) != seen_links.end()) continue;
+
+				if (!Station::IsValidID(to)) continue;
+				const Station *stb = Station::Get(to);
+				if (stb->owner != INVALID_COMPANY && !HasBit(this->company_mask, stb->owner)) continue;
+				if (stb->rect.IsEmpty()) continue;
+
+				if (!this->IsLinkVisible(pta, this->GetStationMiddle(stb), &dpi)) continue;
+
+				this->AddLinks(sta, stb);
+				this->AddLinks(stb, sta);
+				seen_links[to]; // make sure it is created and marked as seen
+			}
+		}
+		if (this->IsPointVisible(pta, &dpi)) {
+			this->cached_stations.push_back(std::make_pair(from, supply));
+		}
+	}
+}
+
+/**
+ * Determine if a certain point is inside the given DPI, with some lee way.
+ * @param pt Point we are looking for.
+ * @param dpi Visible area.
+ * @param padding Extent of the point.
+ * @return If the point or any of its 'extent' is inside the dpi.
+ */
+FORCEINLINE bool LinkGraphOverlay::IsPointVisible(Point pt, const DrawPixelInfo *dpi, int padding) const
+{
+	return pt.x > dpi->left - padding && pt.y > dpi->top - padding &&
+			pt.x < dpi->left + dpi->width + padding &&
+			pt.y < dpi->top + dpi->height + padding;
+}
+
+/**
+ * Determine if a certain link crosses through the area given by the dpi with some lee way.
+ * @param pta First end of the link.
+ * @param ptb Second end of the link.
+ * @param dpi Visible area.
+ * @param padding Width or thickness of the link.
+ * @return If the link or any of its "thickness" is visible. This may return false positives.
+ */
+FORCEINLINE bool LinkGraphOverlay::IsLinkVisible(Point pta, Point ptb, const DrawPixelInfo *dpi, int padding) const
+{
+	return !((pta.x < dpi->left - padding && ptb.x < dpi->left - padding) ||
+			(pta.y < dpi->top - padding && ptb.y < dpi->top - padding) ||
+			(pta.x > dpi->left + dpi->width + padding &&
+					ptb.x > dpi->left + dpi->width + padding) ||
+			(pta.y > dpi->top + dpi->height + padding &&
+					ptb.y > dpi->top + dpi->height + padding));
+}
+
+/**
+ * Add all "interesting" links between the given stations to the cache.
+ * @param from The source station.
+ * @param to The destination station.
+ */
+void LinkGraphOverlay::AddLinks(const Station *from, const Station *to)
+{
+	CargoID c;
+	FOR_EACH_SET_CARGO_ID(c, this->cargo_mask) {
+		if (!CargoSpec::Get(c)->IsValid()) continue;
+		const GoodsEntry &ge = from->goods[c];
+		uint sum_flows = ge.GetSumFlowVia(to->index);
+		const LinkStatMap &ls_map = ge.link_stats;
+		LinkStatMap::const_iterator i = ls_map.find(to->index);
+		if (i != ls_map.end()) {
+			const LinkStat &link_stat = i->second;
+			this->AddStats(link_stat, sum_flows, this->cached_links[from->index][to->index]);
+		}
+	}
+}
+
+/**
+ * Add information from a given pair of link stat and flow stat to the given link properties.
+ * @param orig_link Link stat to read the information from.
+ * @param new_plan Planned flow for the link.
+ * @param cargo LinkProperties to write the information to.
+ */
+/* static */ void LinkGraphOverlay::AddStats(const LinkStat &orig_link, uint new_plan, LinkProperties &cargo)
+{
+	uint new_cap = orig_link.Capacity();
+	uint new_usg = orig_link.Usage();
+
+	/* multiply the numbers by 32 in order to avoid comparing to 0 too often. */
+	if (cargo.capacity == 0 ||
+			max(cargo.usage, cargo.planned) * 32 / (cargo.capacity + 1) < max(new_usg, new_plan) * 32 / (new_cap + 1)) {
+		cargo.capacity = new_cap;
+		cargo.usage = new_usg;
+		cargo.planned = new_plan;
+	}
+}
+
+/**
+ * Draw the linkgraph overlay or some part of it, in the area given.
+ * @param dpi Area to be drawn to.
+ */
+void LinkGraphOverlay::Draw(const DrawPixelInfo *dpi) const
+{
+	this->DrawLinks(dpi);
+	this->DrawStationDots(dpi);
+}
+
+/**
+ * Draw the cached links or part of them into the given area.
+ * @param dpi Area to be drawn to.
+ */
+void LinkGraphOverlay::DrawLinks(const DrawPixelInfo *dpi) const
+{
+	for (LinkMap::const_iterator i(this->cached_links.begin()); i != this->cached_links.end(); ++i) {
+		if (!Station::IsValidID(i->first)) continue;
+		Point pta = this->GetStationMiddle(Station::Get(i->first));
+		for (StationLinkMap::const_iterator j(i->second.begin()); j != i->second.end(); ++j) {
+			if (!Station::IsValidID(j->first)) continue;
+			Point ptb = this->GetStationMiddle(Station::Get(j->first));
+			if (!this->IsLinkVisible(pta, ptb, dpi, this->scale + 2)) continue;
+			this->DrawContent(pta, ptb, j->second);
+		}
+	}
+}
+
+/**
+ * Draw one specific link.
+ * @param pta Source of the link.
+ * @param ptb Destination of the link.
+ * @param cargo Properties of the link.
+ */
+void LinkGraphOverlay::DrawContent(Point pta, Point ptb, const LinkProperties &cargo) const
+{
+	int offset_y = (pta.x < ptb.x ? 1 : -1) * this->scale;
+	int offset_x = (pta.y > ptb.y ? 1 : -1) * this->scale;
+
+	uint usage_or_plan = min(cargo.capacity * 2 + 1, max(cargo.usage, cargo.planned));
+	int colour = LinkGraphOverlay::LINK_COLOURS[usage_or_plan * lengthof(LinkGraphOverlay::LINK_COLOURS) / (cargo.capacity * 2 + 2)];
+
+	GfxDrawLine(pta.x + offset_x, pta.y, ptb.x + offset_x, ptb.y, colour, scale);
+	GfxDrawLine(pta.x, pta.y + offset_y, ptb.x, ptb.y + offset_y, colour, scale);
+
+	GfxDrawLine(pta.x, pta.y, ptb.x, ptb.y, _colour_gradient[COLOUR_GREY][1], this->scale);
+}
+
+/**
+ * Draw dots for stations into the smallmap. The dots' sizes are determined by the amount of
+ * cargo produced there, their colours by the type of cargo produced.
+ */
+void LinkGraphOverlay::DrawStationDots(const DrawPixelInfo *dpi) const
+{
+	for (StationSupplyList::const_iterator i(this->cached_stations.begin()); i != this->cached_stations.end(); ++i) {
+		const Station *st = Station::GetIfValid(i->first);
+		if (st == NULL) continue;
+		Point pt = this->GetStationMiddle(st);
+		if (!this->IsPointVisible(pt, dpi, 3 * this->scale)) continue;
+
+		uint r = this->scale * 2 + this->scale * 2 * min(200, i->second) / 200;
+
+		LinkGraphOverlay::DrawVertex(pt.x, pt.y, r,
+				_colour_gradient[Company::Get(st->owner)->colour][5],
+				_colour_gradient[COLOUR_GREY][1]);
+	}
+}
+
+/**
+ * Draw a square symbolizing a producer of cargo.
+ * @param x X coordinate of the middle of the vertex.
+ * @param y Y coordinate of the middle of the vertex.
+ * @param size Y and y extend of the vertex.
+ * @param colour Colour with which the vertex will be filled.
+ * @param border_colour Colour for the border of the vertex.
+ */
+/* static */ void LinkGraphOverlay::DrawVertex(int x, int y, int size, int colour, int border_colour)
+{
+	size--;
+	int w1 = size / 2;
+	int w2 = size / 2 + size % 2;
+
+	GfxFillRect(x - w1, y - w1, x + w2, y + w2, colour);
+
+	w1++;
+	w2++;
+	GfxDrawLine(x - w1, y - w1, x + w2, y - w1, border_colour);
+	GfxDrawLine(x - w1, y + w2, x + w2, y + w2, border_colour);
+	GfxDrawLine(x - w1, y - w1, x - w1, y + w2, border_colour);
+	GfxDrawLine(x + w2, y - w1, x + w2, y + w2, border_colour);
+}
+
+/**
+ * Determine the middle of a station in the current window.
+ * @param st The station we're looking for.
+ * @return Middle point of the station in the current window.
+ */
+Point LinkGraphOverlay::GetStationMiddle(const Station *st) const {
+	//if (this->window->viewport != NULL) {
+	//	return GetViewportStationMiddle(this->window->viewport, st);
+	//} else {
+		/* assume this is a smallmap */
+		//return GetSmallmapStationMiddle(this->window, st);
+		Point dummy;
+		dummy.x = dummy.y = 0;
+		return dummy;
+	//}
+}
+
+/**
+ * Set a new cargo mask and rebuild the cache.
+ * @param cargo_mask New cargo mask.
+ */
+void LinkGraphOverlay::SetCargoMask(uint32 cargo_mask)
+{
+	this->cargo_mask = cargo_mask;
+	this->RebuildCache();
+	this->window->GetWidget<NWidgetBase>(this->widget_id)->SetDirty(this->window);
+}
+
+/**
+ * Set a new company mask and rebuild the cache.
+ * @param company_mask New company mask.
+ */
+void LinkGraphOverlay::SetCompanyMask(uint32 company_mask)
+{
+	this->company_mask = company_mask;
+	this->RebuildCache();
+	this->window->GetWidget<NWidgetBase>(this->widget_id)->SetDirty(this->window);
+}
diff --git a/src/linkgraph_gui.h b/src/linkgraph_gui.h
new file mode 100644
index 0000000..4ba8c73
--- /dev/null
+++ b/src/linkgraph_gui.h
@@ -0,0 +1,92 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_gui.h Declaration of linkgraph overlay GUI. */
+
+#ifndef LINKGRAPH_GUI_H_
+#define LINKGRAPH_GUI_H_
+
+#include "company_func.h"
+#include "station_base.h"
+#include "widget_type.h"
+#include <map>
+#include <list>
+
+/**
+ * Properties of a link between two stations.
+ */
+struct LinkProperties {
+	LinkProperties() : capacity(0), usage(0), planned(0) {}
+
+	uint capacity; ///< Capacity of the link.
+	uint usage;    ///< Actual usage of the link.
+	uint planned;  ///< Planned usage of the link.
+};
+
+/**
+ * Handles drawing of links into some window.
+ * The window must either be a smallmap or have a valid viewport.
+ */
+class LinkGraphOverlay {
+public:
+	typedef std::map<StationID, LinkProperties> StationLinkMap;
+	typedef std::map<StationID, StationLinkMap> LinkMap;
+	typedef std::list<std::pair<StationID, uint> > StationSupplyList;
+
+	static const uint8 LINK_COLOURS[];
+
+	/**
+	 * Create a link graph overlay for the specified window.
+	 * @param w Window to be drawn into.
+	 * @param wid ID of the widget to draw into.
+	 * @param cargo_mask Bitmask of cargoes to be shown.
+	 * @param company_mask Bitmask of companies to be shown.
+	 * @param scale Desired thickness of lines and size of station dots.
+	 */
+	LinkGraphOverlay(const Window *w, uint wid, uint32 cargo_mask = 0xFFFF,
+			uint32 company_mask = 1 << _local_company, uint scale = 1) :
+			window(w), widget_id(wid), cargo_mask(cargo_mask), company_mask(company_mask), scale(scale)
+	{}
+
+	void RebuildCache();
+	void Draw(const DrawPixelInfo *dpi) const;
+	void SetCargoMask(uint32 cargo_mask);
+	void SetCompanyMask(uint32 company_mask);
+
+	/** Get a bitmask of the currently shown cargoes. */
+	uint32 GetCargoMask() {return this->cargo_mask;}
+
+	/** Get a bitmask of the currently shown companies. */
+	uint32 GetCompanyMask() {return this->company_mask;}
+
+protected:
+	const Window *window;              ///< Window to be drawn into.
+	const uint widget_id;              ///< ID of Widget in Window to be drawn to.
+	uint32 cargo_mask;                 ///< Bitmask of cargos to be displayed.
+	uint32 company_mask;               ///< Bitmask of companies to be displayed.
+	LinkMap cached_links;              ///< Cache for links to reduce recalculation.
+	StationSupplyList cached_stations; ///< Cache for stations to be drawn.
+	uint scale;                        ///< Width of link lines.
+
+	Point GetStationMiddle(const Station *st) const;
+
+	void DrawForwBackLinks(Point pta, StationID sta, Point ptb, StationID stb) const;
+	void AddLinks(const Station *sta, const Station *stb);
+	void DrawLinks(const DrawPixelInfo *dpi) const;
+	void DrawStationDots(const DrawPixelInfo *dpi) const;
+	void DrawContent(Point pta, Point ptb, const LinkProperties &cargo) const;
+	bool IsLinkVisible(Point pta, Point ptb, const DrawPixelInfo *dpi, int padding = 0) const;
+	bool IsPointVisible(Point pt, const DrawPixelInfo *dpi, int padding = 0) const;
+	void GetWidgetDpi(DrawPixelInfo *dpi) const;
+
+	static void AddStats(const LinkStat &orig_link, uint new_flow, LinkProperties &cargo);
+	static void DrawVertex(int x, int y, int size, int colour, int border_colour);
+};
+
+#endif /* LINKGRAPH_GUI_H_ */
