diff --git a/projects/openttd_vs100.vcxproj b/projects/openttd_vs100.vcxproj
index 7fa0024..63bf9eb 100644
--- a/projects/openttd_vs100.vcxproj
+++ b/projects/openttd_vs100.vcxproj
@@ -328,6 +328,7 @@
     <ClCompile Include="..\src\ini_load.cpp" />
     <ClCompile Include="..\src\landscape.cpp" />
     <ClCompile Include="..\src\linkgraph\demands.cpp" />
+    <ClCompile Include="..\src\linkgraph\flowmapper.cpp" />
     <ClCompile Include="..\src\linkgraph\linkgraph.cpp" />
     <ClCompile Include="..\src\linkgraph\mcf.cpp" />
     <ClCompile Include="..\src\map.cpp" />
@@ -459,6 +460,7 @@
     <ClInclude Include="..\src\landscape_type.h" />
     <ClInclude Include="..\src\language.h" />
     <ClInclude Include="..\src\linkgraph\demands.h" />
+    <ClInclude Include="..\src\linkgraph\flowmapper.h" />
     <ClInclude Include="..\src\linkgraph\linkgraph.h" />
     <ClInclude Include="..\src\linkgraph\linkgraph_type.h" />
     <ClInclude Include="..\src\linkgraph\mcf.h" />
diff --git a/projects/openttd_vs100.vcxproj.filters b/projects/openttd_vs100.vcxproj.filters
index a9829b9..d609617 100644
--- a/projects/openttd_vs100.vcxproj.filters
+++ b/projects/openttd_vs100.vcxproj.filters
@@ -204,6 +204,9 @@
     <ClCompile Include="..\src\linkgraph\demands.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\linkgraph\flowmapper.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\linkgraph\linkgraph.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -597,6 +600,9 @@
     <ClInclude Include="..\src\linkgraph\demands.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\linkgraph\flowmapper.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\linkgraph\linkgraph.h">
       <Filter>Header Files</Filter>
     </ClInclude>
diff --git a/projects/openttd_vs80.vcproj b/projects/openttd_vs80.vcproj
index 02a9aa3..e94f837 100644
--- a/projects/openttd_vs80.vcproj
+++ b/projects/openttd_vs80.vcproj
@@ -583,6 +583,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
 				>
 			</File>
@@ -1111,6 +1115,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\linkgraph\linkgraph.h"
 				>
 			</File>
diff --git a/projects/openttd_vs90.vcproj b/projects/openttd_vs90.vcproj
index e23d21f..69b9bca 100644
--- a/projects/openttd_vs90.vcproj
+++ b/projects/openttd_vs90.vcproj
@@ -580,6 +580,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
 				>
 			</File>
@@ -1108,6 +1112,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\linkgraph\linkgraph.h"
 				>
 			</File>
diff --git a/source.list b/source.list
index 62ec468..64a2bdb 100644
--- a/source.list
+++ b/source.list
@@ -36,6 +36,7 @@ ini.cpp
 ini_load.cpp
 landscape.cpp
 linkgraph/demands.cpp
+linkgraph/flowmapper.cpp
 linkgraph/linkgraph.cpp
 linkgraph/mcf.cpp
 map.cpp
@@ -192,6 +193,7 @@ landscape.h
 landscape_type.h
 language.h
 linkgraph/demands.h
+linkgraph/flowmapper.h
 linkgraph/linkgraph.h
 linkgraph/linkgraph_type.h
 linkgraph/mcf.h
diff --git a/src/linkgraph/flowmapper.cpp b/src/linkgraph/flowmapper.cpp
new file mode 100644
index 0000000..8b45147
--- /dev/null
+++ b/src/linkgraph/flowmapper.cpp
@@ -0,0 +1,54 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file flowmapper.cpp Definition of flowmapper. */
+
+#include "../stdafx.h"
+#include "flowmapper.h"
+
+/**
+ * Map the paths generated by the MCF solver into flows associated with nodes.
+ * @param component the link graph component to be used.
+ */
+void FlowMapper::Run(LinkGraphComponent *component)
+{
+	for (NodeID node_id = 0; node_id < component->GetSize(); ++node_id) {
+		Node &prev_node = component->GetNode(node_id);
+		StationID prev = prev_node.station;
+		PathSet &paths = prev_node.paths;
+		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
+			Path *path = *i;
+			uint flow = path->GetFlow();
+			if (flow == 0) continue;
+			Node &node = component->GetNode(path->GetNode());
+			StationID via = node.station;
+			assert(prev != via);
+			StationID origin = component->GetNode(path->GetOrigin()).station;
+			assert(via != origin);
+			/* mark all of the flow for local consumption at "first" */
+			node.flows[origin][via] += flow;
+			/* pass some of the flow marked for local consumption at "prev" on
+			 * to this node
+			 */
+			prev_node.flows[origin][via] += flow;
+			/* find simple circular flows ... */
+			assert(node.flows[origin][prev] == 0);
+			if (prev != origin) {
+				prev_node.flows[origin][prev] -= flow;
+			}
+		}
+	}
+	for (NodeID node_id = 0; node_id < component->GetSize(); ++node_id) {
+		PathSet &paths = component->GetNode(node_id).paths;
+		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
+			delete *i;
+		}
+		paths.clear();
+	}
+}
diff --git a/src/linkgraph/flowmapper.h b/src/linkgraph/flowmapper.h
new file mode 100644
index 0000000..a2b6bc0
--- /dev/null
+++ b/src/linkgraph/flowmapper.h
@@ -0,0 +1,30 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file flowmapper.h Declaration of flow mapper; maps paths into flows at nodes. */
+
+#ifndef FLOWMAPPER_H_
+#define FLOWMAPPER_H_
+
+#include "linkgraph.h"
+
+/**
+ * Map the path trees generated by the MCF solver into flows. The path tree is
+ * useful to cache capacities and distances and allow quick disconnecting and
+ * reconnecting to other paths. The flows show how much cargo from which nodes
+ * is to be routed in which direction at a given node. This is what we need in
+ * the end.
+ */
+class FlowMapper : public ComponentHandler {
+public:
+	virtual ~FlowMapper() {}
+	virtual void Run(LinkGraphComponent *component);
+};
+
+#endif /* FLOWMAPPER_H_ */
diff --git a/src/linkgraph/linkgraph.cpp b/src/linkgraph/linkgraph.cpp
index 5bc9bf9..e58894d 100644
--- a/src/linkgraph/linkgraph.cpp
+++ b/src/linkgraph/linkgraph.cpp
@@ -17,6 +17,7 @@
 #include "linkgraph.h"
 #include "demands.h"
 #include "mcf.h"
+#include "flowmapper.h"
 #include <queue>
 
 /**
@@ -288,6 +289,93 @@ void LinkGraphComponent::Init(LinkGraphComponentID id)
 	this->settings = _settings_game.linkgraph;
 }
 
+
+/**
+ * Exports all entries in the FlowViaMap pointed to by "source_flows_it", erases the source
+ * flows and increments the iterator afterwards.
+ * @param it Iterator pointing to the flows to be exported into the main game state.
+ * @param dest Flow stats to which the flows shall be exported.
+ * @param cargo Cargo we're exporting flows for (used to check if the link stats for the new
+ *        flows still exist).
+ */
+void Node::ExportNewFlows(FlowMap::iterator &it, FlowStatSet &dest, CargoID cargo)
+{
+	StationID source = it->first;
+	FlowViaMap &source_flows = it->second;
+	if (!Station::IsValidID(source)) {
+		source_flows.clear();
+	} else {
+		Station *curr_station = Station::Get(this->station);
+		for (FlowViaMap::iterator update = source_flows.begin(); update != source_flows.end();) {
+			StationID next = update->first;
+			int planned = update->second;
+			assert(planned >= 0);
+
+			Station *via = Station::GetIfValid(next);
+			if (planned > 0 && via != NULL) {
+				uint distance = GetMovingAverageLength(curr_station, via);
+				if (next != this->station) {
+					const LinkStatMap &ls = curr_station->goods[cargo].link_stats;
+					if (ls.find(next) != ls.end()) {
+						dest.insert(FlowStat(distance, next, planned, 0));
+					}
+				} else {
+					dest.insert(FlowStat(distance, next, planned, 0));
+				}
+			}
+			source_flows.erase(update++);
+		}
+	}
+	assert(source_flows.empty());
+
+	this->flows.erase(it++);
+}
+
+/**
+ * Export all flows of this node to the main game state.
+ * @param cargo the cargo we're exporting flows for.
+ */
+void Node::ExportFlows(CargoID cargo)
+{
+	FlowStatMap &station_flows = Station::Get(this->station)->goods[cargo].flows;
+	FlowStatSet new_flows;
+	/* loop over all existing flows in the station and update them */
+	for (FlowStatMap::iterator station_outer_it(station_flows.begin()); station_outer_it != station_flows.end();) {
+		FlowMap::iterator node_outer_it(this->flows.find(station_outer_it->first));
+		if (node_outer_it == this->flows.end()) {
+			/* there are no flows for this source node anymore */
+			station_flows.erase(station_outer_it++);
+		} else {
+			FlowViaMap &source = node_outer_it->second;
+			FlowStatSet &dest = station_outer_it->second;
+			/* loop over the station's flow stats for this source node and update them */
+			for (FlowStatSet::iterator station_inner_it(dest.begin()); station_inner_it != dest.end();) {
+				FlowViaMap::iterator node_inner_it(source.find(station_inner_it->Via()));
+				if (node_inner_it != source.end()) {
+					assert(node_inner_it->second >= 0);
+					if (node_inner_it->second > 0) {
+						new_flows.insert(FlowStat(*station_inner_it, node_inner_it->second));
+					}
+					source.erase(node_inner_it);
+				}
+				dest.erase(station_inner_it++);
+			}
+			/* swap takes constant time, so we swap instead of adding all entries */
+			dest.swap(new_flows);
+			assert(new_flows.empty());
+			/* insert remaining flows for this source node */
+			ExportNewFlows(node_outer_it, dest, cargo);
+			/* careful: source_flows is dangling here */
+			++station_outer_it;
+		}
+	}
+	/* loop over remaining flows (for other sources) in the node's map and insert them into the station */
+	for (FlowMap::iterator it(this->flows.begin()); it != this->flows.end();) {
+		ExportNewFlows(it, station_flows[it->first], cargo);
+	}
+	assert(this->flows.empty());
+}
+
 /**
  * Merge the current job's results into the main game state.
  */
@@ -295,6 +383,13 @@ void LinkGraph::Join()
 {
 	this->LinkGraphJob::Join();
 
+	for (NodeID node_id = 0; node_id < this->GetSize(); ++node_id) {
+		Node &node = this->GetNode(node_id);
+		if (Station::IsValidID(node.station)) {
+			node.ExportFlows(this->cargo);
+		}
+	}
+
 	this->LinkGraphComponent::Clear();
 }
 
@@ -441,5 +536,7 @@ void InitializeLinkGraphs()
 	LinkGraphJob::ClearHandlers();
 	LinkGraphJob::AddHandler(new DemandHandler);
 	LinkGraphJob::AddHandler(new MCFHandler<MCF1stPass>);
+	LinkGraphJob::AddHandler(new FlowMapper);
 	LinkGraphJob::AddHandler(new MCFHandler<MCF2ndPass>);
+	LinkGraphJob::AddHandler(new FlowMapper);
 }
diff --git a/src/linkgraph/linkgraph.h b/src/linkgraph/linkgraph.h
index 65dcfda..acea738 100644
--- a/src/linkgraph/linkgraph.h
+++ b/src/linkgraph/linkgraph.h
@@ -50,6 +50,10 @@ public:
 	~Node() {this->Init();}
 
 	void Init(StationID st = INVALID_STATION, uint sup = 0, uint dem = 0);
+	void ExportFlows(CargoID cargo);
+
+private:
+	void ExportNewFlows(FlowMap::iterator &it, FlowStatSet &via_set, CargoID cargo);
 };
 
 /**
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
index 2910df5..363449a 100644
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -226,7 +226,7 @@
  *  159   21962
  *  160   21974
  */
-extern const uint16 SAVEGAME_VERSION = SL_MCF; ///< Current savegame version of OpenTTD.
+extern const uint16 SAVEGAME_VERSION = SL_FLOWMAP; ///< Current savegame version of OpenTTD.
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
index b910d54..272ade3 100644
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -556,6 +556,7 @@ enum SaveLoadVersions {
 	SL_COMPONENTS,
 	SL_DEMANDS = SL_COMPONENTS + 20,
 	SL_MCF,
+	SL_FLOWMAP,
 
 	/** Highest possible savegame version. */
 	SL_MAX_VERSION = 255
diff --git a/src/saveload/station_sl.cpp b/src/saveload/station_sl.cpp
index ccf056b..9f432c7 100644
--- a/src/saveload/station_sl.cpp
+++ b/src/saveload/station_sl.cpp
@@ -225,6 +225,7 @@ static const SaveLoad _old_station_desc[] = {
 
 static uint16 _waiting_acceptance;
 static uint16 _num_links;
+static uint32 _num_flows;
 static uint16 _cargo_source;
 static uint32 _cargo_source_xy;
 static uint16 _cargo_days;
@@ -259,6 +260,25 @@ const SaveLoad *GetLinkStatDesc()
 }
 
 /**
+ * Wrapper function to get the FlowStats's internal structure while
+ * some of the variables are private.
+ * @return the saveload description for FlowStat.
+ */
+const SaveLoad *GetFlowStatDesc()
+{
+	static const SaveLoad _flowstat_desc[] = {
+		SLEG_CONDVAR(             _station_id,         SLE_UINT16,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    via,                 SLE_UINT16,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    length,              SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    planned,             SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    sent,                SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_END()
+	};
+
+	return _flowstat_desc;
+}
+
+/**
  * Wrapper function to get the GoodsEntry's internal structure while
  * some of the variables itself are private.
  * @return the saveload description for GoodsEntry.
@@ -284,6 +304,7 @@ const SaveLoad *GetGoodsDesc()
 		 SLE_CONDVAR(GoodsEntry, supply,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
 		 SLE_CONDVAR(GoodsEntry, supply_new,          SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
 		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_flows,          SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
 		 SLE_CONDVAR(GoodsEntry, last_component,      SLE_UINT16,      SL_COMPONENTS, SL_MAX_VERSION),
 		SLE_END()
 	};
@@ -432,12 +453,23 @@ static void RealSave_STNN(BaseStation *bst)
 		Station *st = Station::From(bst);
 		for (CargoID c = 0; c < NUM_CARGO; c++) {
 			_num_links = (uint16)st->goods[c].link_stats.size();
+			_num_flows = 0;
+			for (FlowStatMap::const_iterator it(st->goods[c].flows.begin()); it != st->goods[c].flows.end(); ++it) {
+				_num_flows += (uint32)it->second.size();
+			}
 			SlObject(&st->goods[c], GetGoodsDesc());
 			for (LinkStatMap::const_iterator it(st->goods[c].link_stats.begin()); it != st->goods[c].link_stats.end(); ++it) {
 				_station_id = it->first;
 				LinkStat ls(it->second); // make a copy to avoid constness problems
 				SlObject(&ls, GetLinkStatDesc());
 			}
+			for (FlowStatMap::const_iterator outer_it(st->goods[c].flows.begin()); outer_it != st->goods[c].flows.end(); ++outer_it) {
+				_station_id = outer_it->first;
+				for (FlowStatSet::const_iterator inner_it(outer_it->second.begin()); inner_it != outer_it->second.end(); ++inner_it) {
+					FlowStat fs(*inner_it); // make a copy to avoid constness problems
+					SlObject(&fs, GetFlowStatDesc());
+				}
+			}
 		}
 	}
 
@@ -477,6 +509,11 @@ static void Load_STNN()
 					st->goods[c].link_stats.insert(
 						std::make_pair(_station_id, ls));
 				}
+				FlowStat fs;
+				for (uint32 i = 0; i < _num_flows; ++i) {
+					SlObject(&fs, GetFlowStatDesc());
+					st->goods[c].flows[_station_id].insert(fs);
+				}
 			}
 		}
 
diff --git a/src/station.cpp b/src/station.cpp
index 0971371..5d66a66 100644
--- a/src/station.cpp
+++ b/src/station.cpp
@@ -94,6 +94,7 @@ Station::~Station()
 		for (CargoID c = 0; c < NUM_CARGO; ++c) {
 			GoodsEntry &ge = st->goods[c];
 			ge.link_stats.erase(this->index);
+			DeleteStaleFlows(st->index, c, this->index);
 		}
 	}
 
diff --git a/src/station_base.h b/src/station_base.h
index 00eca56..bc3fc1d 100644
--- a/src/station_base.h
+++ b/src/station_base.h
@@ -20,6 +20,7 @@
 #include "newgrf_storage.h"
 #include "moving_average.h"
 #include <map>
+#include <set>
 
 typedef Pool<BaseStation, StationID, 32, 64000> StationPool;
 extern StationPool _station_pool;
@@ -149,7 +150,140 @@ public:
 	}
 };
 
+/**
+ * Flow statistics telling how much flow should be and was sent along a link.
+ */
+class FlowStat : private MovingAverage<uint> {
+private:
+	uint planned;  ///< Cargo planned to be sent along a link each "month" (30 units of time, determined by moving average).
+	uint sent;     ///< Moving average of cargo being sent.
+	StationID via; ///< Other end of the link. Can be this station, then it means "deliver here".
+
+public:
+	friend const SaveLoad *GetFlowStatDesc();
+
+	/**
+	 * Create a flow stat.
+	 * @param distance Distance to be used as length of moving average.
+	 * @param st Remote station.
+	 * @param planned Cargo planned to be sent along this link.
+	 * @param sent Cargo already sent along this link.
+	 */
+	FORCEINLINE FlowStat(uint distance = 1, StationID st = INVALID_STATION, uint planned = 0, uint sent = 0) :
+		MovingAverage<uint>(distance), planned(planned), sent(sent), via(st) {}
+
+	/**
+	 * Clone an existing flow stat, changing the plan.
+	 * @param prev Flow stat to be cloned.
+	 * @param new_plan New value for planned.
+	 */
+	FORCEINLINE FlowStat(const FlowStat &prev, uint new_plan) :
+		MovingAverage<uint>(prev.length), planned(new_plan), sent(prev.sent), via(prev.via) {}
+
+	/**
+	 * Prevents one copy operation when moving a flowstat from one set to another and decreasing it at the same time.
+	 */
+	FORCEINLINE FlowStat GetDecreasedCopy() const
+	{
+		FlowStat ret(this->length, this->via, this->planned, this->sent);
+		this->MovingAverage<uint>::Decrease(ret.sent);
+		return ret;
+	}
+
+	/**
+	 * Increase the sent value.
+	 * @param sent Amount to be added to sent.
+	 */
+	FORCEINLINE void Increase(uint sent)
+	{
+		this->sent += sent;
+	}
+
+	/**
+	 * Get an estimate of cargo sent along this link during the last 30 time units.
+	 * @return Cargo sent along this link.
+	 */
+	FORCEINLINE uint Sent() const
+	{
+		return this->MovingAverage<uint>::Monthly(sent);
+	}
+
+	/**
+	 * Get the amount of cargo planned to be sent along this link in 30 time units.
+	 * @return Cargo planned to be sent.
+	 */
+	FORCEINLINE uint Planned() const
+	{
+		return this->planned;
+	}
+
+	/**
+	 * Get the station this link is connected to.
+	 * @return Remote station.
+	 */
+	FORCEINLINE StationID Via() const
+	{
+		return this->via;
+	}
+
+	/**
+	 * Comparator for two flow stats for ordering them in a way that makes
+	 * the next flow stat to sent cargo for show up as first element.
+	 */
+	struct Comparator {
+		/**
+		 * Comparator function. Decides by planned - sent or via, if those
+		 * are equal.
+		 * @param x First flow stat.
+		 * @param y Second flow stat.
+		 * @return True if x.planned - x.sent is greater than y.planned - y.sent.
+		 */
+		bool operator()(const FlowStat &x, const FlowStat &y) const
+		{
+			int diff_x = (int)x.Planned() - (int)x.Sent();
+			int diff_y = (int)y.Planned() - (int)y.Sent();
+			if (diff_x != diff_y) {
+				return diff_x > diff_y;
+			} else {
+				return x.Via() > y.Via();
+			}
+		}
+	};
+
+	/**
+	 * Add up two flow stats' planned and sent figures and assign via from the other one to this one.
+	 * @param other Flow stat to add to this one.
+	 * @return This flow stat.
+	 */
+	FORCEINLINE FlowStat &operator+=(const FlowStat &other)
+	{
+		assert(this->via == INVALID_STATION || other.via == INVALID_STATION || this->via == other.via);
+		if (other.via != INVALID_STATION) this->via = other.via;
+		this->planned += other.planned;
+		uint sent = this->sent + other.sent;
+		if (sent > 0) {
+			this->length = (this->length * this->sent + other.length * other.sent) / sent;
+			assert(this->length > 0);
+		}
+		this->sent = sent;
+		return *this;
+	}
+
+	/**
+	 * Clear this flow stat.
+	 */
+	FORCEINLINE void Clear()
+	{
+		this->planned = 0;
+		this->sent = 0;
+		this->via = INVALID_STATION;
+	}
+};
+
+typedef std::set<FlowStat, FlowStat::Comparator> FlowStatSet; ///< Percentage of flow to be sent via specified station (or consumed locally).
+
 typedef std::map<StationID, LinkStat> LinkStatMap;
+typedef std::map<StationID, FlowStatSet> FlowStatMap; ///< Flow descriptions by origin stations.
 
 uint GetMovingAverageLength(const Station *from, const Station *to);
 
@@ -179,8 +313,10 @@ struct GoodsEntry {
 	StationCargoList cargo;              ///< The cargo packets of cargo waiting in this station.
 	uint supply;                         ///< Cargo supplied last month.
 	uint supply_new;                     ///< Cargo supplied so far this month.
+	FlowStatMap flows;                   ///< Planned flows through this station.
 	LinkStatMap link_stats;              ///< Capacities and usage statistics for outgoing links.
 	LinkGraphComponentID last_component; ///< Component this station was last part of in this cargo's link graph.
+	FlowStat GetSumFlowVia(StationID via) const;
 };
 
 /** All airport-related information. Only valid if tile != INVALID_TILE. */
diff --git a/src/station_cmd.cpp b/src/station_cmd.cpp
index 6a94cf7..89e27ca 100644
--- a/src/station_cmd.cpp
+++ b/src/station_cmd.cpp
@@ -3127,6 +3127,33 @@ static void UpdateStationRating(Station *st)
 }
 
 /**
+ * Delete all flows at a station for specific cargo and destination.
+ * @param at Station to delete flows from.
+ * @param c_id Cargo for which flows shall be deleted.
+ * @param to Remote station of flows to be deleted.
+ */
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to)
+{
+	FlowStatMap &flows = Station::Get(at)->goods[c_id].flows;
+	for (FlowStatMap::iterator f_it = flows.begin(); f_it != flows.end();) {
+		FlowStatSet &s_flows = f_it->second;
+		for (FlowStatSet::iterator s_it = s_flows.begin(); s_it != s_flows.end();) {
+			if (s_it->Via() == to) {
+				s_flows.erase(s_it++);
+				break; // There can only be one flow stat for this remote station in each set.
+			} else {
+				++s_it;
+			}
+		}
+		if (s_flows.empty()) {
+			flows.erase(f_it++);
+		} else {
+			++f_it;
+		}
+	}
+}
+
+/**
  * Get the length of a moving average for a link between two stations.
  * @param from Source station.
  * @param to Destination station.
@@ -3142,6 +3169,7 @@ uint GetMovingAverageLength(const Station *from, const Station *to)
  */
 void Station::RunAverages()
 {
+	FlowStatSet new_flows;
 	for (int goods_index = 0; goods_index < NUM_CARGO; ++goods_index) {
 		LinkStatMap &links = this->goods[goods_index].link_stats;
 		for (LinkStatMap::iterator i = links.begin(); i != links.end();) {
@@ -3155,10 +3183,33 @@ void Station::RunAverages()
 				if (ls.IsValid()) {
 					++i;
 				} else {
+					DeleteStaleFlows(this->index, goods_index, id);
 					links.erase(i++);
 				}
 			}
 		}
+
+		if (_settings_game.linkgraph.GetDistributionType(goods_index) == DT_MANUAL) {
+			this->goods[goods_index].flows.clear();
+			continue;
+		}
+
+		FlowStatMap &flows = this->goods[goods_index].flows;
+		for (FlowStatMap::iterator i = flows.begin(); i != flows.end();) {
+			if (!Station::IsValidID(i->first)) {
+				flows.erase(i++);
+			} else {
+				FlowStatSet &flow_set = i->second;
+				for (FlowStatSet::iterator j = flow_set.begin(); j != flow_set.end(); ++j) {
+					if (Station::IsValidID(j->Via())) {
+						new_flows.insert(j->GetDecreasedCopy());
+					}
+				}
+				flow_set.swap(new_flows);
+				new_flows.clear();
+				++i;
+			}
+		}
 	}
 }
 
@@ -3660,6 +3711,25 @@ static CommandCost TerraformTile_Station(TileIndex tile, DoCommandFlag flags, ui
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 }
 
+/**
+ * Get the sum of flows via a specific station from this GoodsEntry.
+ * @param via Remote station to look for.
+ * @return a FlowStat with all flows for 'via' added up.
+ */
+FlowStat GoodsEntry::GetSumFlowVia(StationID via) const
+{
+	FlowStat ret(1, via);
+	for (FlowStatMap::const_iterator i = this->flows.begin(); i != this->flows.end(); ++i) {
+		const FlowStatSet &flow_set = i->second;
+		for (FlowStatSet::const_iterator j = flow_set.begin(); j != flow_set.end(); ++j) {
+			const FlowStat &flow = *j;
+			if (flow.Via() == via) {
+				ret += flow;
+			}
+		}
+	}
+	return ret;
+}
 
 extern const TileTypeProcs _tile_type_station_procs = {
 	DrawTile_Station,           // draw_tile_proc
diff --git a/src/station_func.h b/src/station_func.h
index f114889..4eaf727 100644
--- a/src/station_func.h
+++ b/src/station_func.h
@@ -51,4 +51,6 @@ void IncreaseStats(Station *st, const Vehicle *v, StationID next_station_id);
 
 void IncreaseStats(Station *st, CargoID cargo, StationID next_station_id, uint capacity, uint usage);
 
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to);
+
 #endif /* STATION_FUNC_H */
