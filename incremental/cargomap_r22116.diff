diff --git a/src/autoreplace_cmd.cpp b/src/autoreplace_cmd.cpp
index 19a740d..e6307a1 100644
--- a/src/autoreplace_cmd.cpp
+++ b/src/autoreplace_cmd.cpp
@@ -119,7 +119,7 @@ static void TransferCargo(Vehicle *old_veh, Vehicle *new_head, bool part_of_chai
 			uint amount = min(src->cargo.Count(), dest->cargo_cap - dest->cargo.Count());
 			if (amount <= 0) continue;
 
-			src->cargo.MoveTo(&dest->cargo, amount, VehicleCargoList::MTA_UNLOAD, NULL);
+			src->cargo.MoveTo(&dest->cargo, amount);
 		}
 	}
 
diff --git a/src/cargopacket.cpp b/src/cargopacket.cpp
index 7bb3fb8..6ede95a 100644
--- a/src/cargopacket.cpp
+++ b/src/cargopacket.cpp
@@ -10,7 +10,9 @@
 /** @file cargopacket.cpp Implementation of the cargo packets. */
 
 #include "stdafx.h"
+#include "station_base.h"
 #include "core/pool_func.hpp"
+#include "core/random_func.hpp"
 #include "economy_base.h"
 
 /* Initialize the cargopacket-pool */
@@ -138,8 +140,8 @@ FORCEINLINE void CargoPacket::Merge(CargoPacket *cp)
 /**
  * Destroy the cargolist ("frees" all cargo packets).
  */
-template <class Tinst>
-CargoList<Tinst>::~CargoList()
+template <class Tinst, class Tcont>
+CargoList<Tinst, Tcont>::~CargoList()
 {
 	for (Iterator it(this->packets.begin()); it != this->packets.end(); ++it) {
 		delete *it;
@@ -161,8 +163,8 @@ void CargoList<Tinst>::OnCleanPool()
  * Decreases count and days_in_transit.
  * @param cp Packet to be removed from cache.
  */
-template <class Tinst>
-void CargoList<Tinst>::RemoveFromCache(const CargoPacket *cp)
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::RemoveFromCache(const CargoPacket *cp)
 {
 	this->count                 -= cp->count;
 	this->cargo_days_in_transit -= cp->days_in_transit * cp->count;
@@ -173,8 +175,8 @@ void CargoList<Tinst>::RemoveFromCache(const CargoPacket *cp)
  * Increases count and days_in_transit.
  * @param cp New packet to be inserted.
  */
-template <class Tinst>
-void CargoList<Tinst>::AddToCache(const CargoPacket *cp)
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::AddToCache(const CargoPacket *cp)
 {
 	this->count                 += cp->count;
 	this->cargo_days_in_transit += cp->days_in_transit * cp->count;
@@ -190,14 +192,13 @@ void CargoList<Tinst>::AddToCache(const CargoPacket *cp)
  *        the reservation list.
  * @pre cp != NULL
  */
-template <class Tinst>
-void CargoList<Tinst>::Append(CargoPacket *cp, bool update_cache)
+void VehicleCargoList::Append(CargoPacket *cp, bool update_cache)
 {
 	assert(cp != NULL);
-	if (update_cache) static_cast<Tinst *>(this)->AddToCache(cp);
-	for (List::reverse_iterator it(this->packets.rbegin()); it != this->packets.rend(); it++) {
+	if (update_cache) this->AddToCache(cp);
+	for (CargoPacketList::reverse_iterator it(this->packets.rbegin()); it != this->packets.rend(); it++) {
 		CargoPacket *icp = *it;
-		if (Tinst::AreMergable(icp, cp) && icp->count + cp->count <= CargoPacket::MAX_COUNT) {
+		if (VehicleCargoList::AreMergable(icp, cp) && icp->count + cp->count <= CargoPacket::MAX_COUNT) {
 			icp->Merge(cp);
 			return;
 		}
@@ -212,8 +213,8 @@ void CargoList<Tinst>::Append(CargoPacket *cp, bool update_cache)
  * first count cargo entities and removes the rest.
  * @param max_remaining Maximum amount of entities to be in the list after the command.
  */
-template <class Tinst>
-void CargoList<Tinst>::Truncate(uint max_remaining)
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::Truncate(uint max_remaining)
 {
 	for (Iterator it(packets.begin()); it != packets.end(); /* done during loop*/) {
 		CargoPacket *cp = *it;
@@ -253,27 +254,29 @@ void VehicleCargoList::Reserve(CargoPacket *cp)
 
 /**
  * Returns all reserved cargo to the station and removes it from the cache.
+ * @param ID of next the station the cargo wants to go next.
  * @param dest Station the cargo is returned to.
  */
-void VehicleCargoList::Unreserve(StationCargoList *dest)
+void VehicleCargoList::Unreserve(StationID next, StationCargoList *dest)
 {
 	Iterator it(this->reserved.begin());
 	while (it != this->reserved.end()) {
 		CargoPacket *cp = *it;
 		this->RemoveFromCache(cp);
 		this->reserved_count -= cp->count;
-		dest->Append(cp);
+		dest->Append(next, cp);
 		this->reserved.erase(it++);
 	}
 }
 
 /**
  * Load packets from the reservation list.
- * @params count Number of cargo to load.
- * @return true If there are still packets that might be loaded from the reservation list.
+ * @params max_move Number of cargo to load.
+ * @return Amount of cargo actually loaded.
  */
-bool VehicleCargoList::LoadReserved(uint max_move)
+uint VehicleCargoList::LoadReserved(uint max_move)
 {
+	uint orig_max = max_move;
 	Iterator it(this->reserved.begin());
 	while (it != this->reserved.end() && max_move > 0) {
 		CargoPacket *cp = *it;
@@ -291,140 +294,362 @@ bool VehicleCargoList::LoadReserved(uint max_move)
 			max_move = 0;
 		}
 	}
-	return it != packets.end();
-}
-
-/**
- * Moves the given amount of cargo to another list.
- * Depending on the value of mta the side effects of this function differ:
- *  - MTA_FINAL_DELIVERY: Destroys the packets that do not originate from a specific station.
- *  - MTA_CARGO_LOAD:     Sets the loaded_at_xy value of the moved packets.
- *  - MTA_TRANSFER:       Just move without side effects.
- *  - MTA_UNLOAD:         Just move without side effects.
- * @param dest  Destination to move the cargo to.
- * @param count Amount of cargo entities to move.
- * @param mta   How to handle the moving (side effects).
- * @param data  Depending on mta the data of this variable differs:
- *              - MTA_FINAL_DELIVERY - Station ID of packet's origin not to remove.
- *              - MTA_CARGO_LOAD     - Station's tile index of load.
- *              - MTA_TRANSFER       - Unused.
- *              - MTA_UNLOAD         - Unused.
- * @param payment The payment helper.
- *
- * @pre mta == MTA_FINAL_DELIVERY || dest != NULL
- * @pre mta == MTA_UNLOAD || mta == MTA_CARGO_LOAD || payment != NULL
- * @return True if there are still packets that might be moved from this cargo list.
+	return orig_max - max_move;
+}
+
+/**
+ * Move a single packet or part of it from this list to a vehicle and increment
+ * the given iterator.
+ * @param dest       Vehicle cargo list to move to.
+ * @param it         Iterator pointing to the packet.
+ * @param cap        Maximum amount of cargo to be moved.
+ * @param load_place New loaded_at for the packet.
+ * @param reserve    If the packet should be loaded on or reserved for the vehicle.
+ * @return           Actual amount of cargo which has been moved.
  */
-template <class Tinst>
-template <class Tother_inst>
-bool CargoList<Tinst>::MoveTo(Tother_inst *dest, uint max_move, MoveToAction mta, CargoPayment *payment, uint data)
+template<class Tinst, class Tcont>
+uint CargoList<Tinst, Tcont>::MovePacket(VehicleCargoList *dest, Iterator &it, uint cap, TileIndex load_place, bool reserve)
 {
-	assert(mta == MTA_FINAL_DELIVERY || dest != NULL);
-	assert(mta == MTA_UNLOAD || mta == MTA_CARGO_LOAD || mta == MTA_RESERVE || payment != NULL);
+	CargoPacket *packet = this->RemovePacket(it, cap, load_place);
+	uint ret = packet->count;
+	if (reserve) {
+		dest->Reserve(packet);
+	} else {
+		dest->Append(packet);
+	}
+	return ret;
+}
 
-	Iterator it(this->packets.begin());
-	while (it != this->packets.end() && max_move > 0) {
-		CargoPacket *cp = *it;
-		if (cp->source == data && mta == MTA_FINAL_DELIVERY) {
-			/* Skip cargo that originated from this station. */
-			++it;
-			continue;
-		}
+/**
+ * Move a single packet or part of it from this list to a station and increment
+ * the given iterator.
+ * @param dest Station cargo list to move to.
+ * @param next Next station the packet will travel to.
+ * @param it Iterator pointing to the packet.
+ * @param cap Maximum amount of cargo to be moved.
+ * @return Actual amount of cargo which has been moved.
+ */
+template<class Tinst, class Tcont>
+uint CargoList<Tinst, Tcont>::MovePacket(StationCargoList *dest, StationID next, Iterator &it, uint cap)
+{
+	CargoPacket *packet = this->RemovePacket(it, cap);
+	uint ret = packet->count;
+	dest->Append(next, packet);
+	return ret;
+}
 
-		if (cp->count <= max_move) {
-			/* Can move the complete packet */
-			max_move -= cp->count;
+/**
+ * Remove a single packet or part of it from this list and increment the given
+ * iterator.
+ * @param it Iterator pointing to the packet.
+ * @param cap Maximum amount of cargo to be moved.
+ * @param load_place New loaded_at for the packet or INVALID_TILE if the current
+ *        one shall be kept.
+ * @return Removed packet.
+ */
+template<class Tinst, class Tcont>
+CargoPacket *CargoList<Tinst, Tcont>::RemovePacket(Iterator &it, uint cap, TileIndex load_place)
+{
+	CargoPacket *packet = *it;
+	/* load the packet if possible */
+	if (packet->count > cap) {
+		/* packet needs to be split */
+		packet = packet->Split(cap);
+
+		/* We could not allocate a CargoPacket? Is the map that full?
+		 * Just remove the whole packet and drop some cargo then.
+		 */
+		if (packet == NULL) {
+			packet = *it;
+			uint dropped = packet->count - cap;
+			this->count -= dropped;
+			this->cargo_days_in_transit -= dropped * packet->days_in_transit; 
+			packet->count = cap;
 			this->packets.erase(it++);
-			static_cast<Tinst *>(this)->RemoveFromCache(cp);
-			switch (mta) {
-				case MTA_FINAL_DELIVERY:
-					payment->PayFinalDelivery(cp, cp->count);
-					delete cp;
-					continue; // of the loop
-
-				case MTA_RESERVE:
-					cp->loaded_at_xy = data;
-					/* this reinterpret cast is nasty. The method should be
-					 * refactored to get rid of it. However, as this is only
-					 * a step on the way to cargodist and the whole method is
-					 * rearranged in a later step we can tolerate it to make the
-					 * patches smaller.
-					 * MTA_RESERVE can only happen if dest is a vehicle, so we
-					 * cannot crash here. I don't know a way to assert that,
-					 * though.
-					 */
-					reinterpret_cast<VehicleCargoList *>(dest)->Reserve(cp);
-					continue;
-
-				case MTA_CARGO_LOAD:
-					cp->loaded_at_xy = data;
-					break;
-
-				case MTA_TRANSFER:
-					cp->feeder_share += payment->PayTransfer(cp, cp->count);
-					break;
-
-				case MTA_UNLOAD:
-					break;
-			}
-			dest->Append(cp);
-			continue;
+		} else {
+			assert(packet->count == cap);
+			++it;
 		}
+	} else {
+		this->packets.erase(it++);
+	}
+	static_cast<Tinst *>(this)->RemoveFromCache(packet);
+	if (load_place != INVALID_TILE) {
+		packet->loaded_at_xy = load_place;
+	}
+	return packet;
+}
 
-		/* Can move only part of the packet */
-		if (mta == MTA_FINAL_DELIVERY) {
-			/* Final delivery doesn't need package splitting. */
-			payment->PayFinalDelivery(cp, max_move);
+/**
+ * Invalidates the cached data and rebuilds it.
+ */
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::InvalidateCache()
+{
+	this->count = 0;
+	this->cargo_days_in_transit = 0;
 
-			/* Remove the delivered data from the cache */
-			uint left = cp->count - max_move;
-			cp->count = max_move;
-			static_cast<Tinst *>(this)->RemoveFromCache(cp);
+	for (ConstIterator it(this->packets.begin()); it != this->packets.end(); it++) {
+		static_cast<Tinst *>(this)->AddToCache(*it);
+	}
+}
 
-			/* Final delivery payment pays the feeder share, so we have to
-			 * reset that so it is not 'shown' twice for partial unloads. */
-			cp->feeder_share = 0;
-			cp->count = left;
-		} else {
-			/* But... the rest needs package splitting. */
-			CargoPacket *cp_new = cp->Split(max_move);
+/**
+ * Delete a vehicle cargo list and clear its reservation list.
+ */
+VehicleCargoList::~VehicleCargoList()
+{
+	for (Iterator it(this->reserved.begin()); it != this->reserved.end(); ++it) {
+		delete *it;
+	}
+}
 
-			/* We could not allocate a CargoPacket? Is the map that full? */
-			if (cp_new == NULL) return false;
+/**
+ * Deliver a specific packet or part of it to a station and handle payment. The
+ * given iterator is incremented in the process.
+ * @param it      Iterator pointing to the packet to be delivered.
+ * @param cap     Maximum amount of cargo to be unloaded.
+ * @param payment Payment object to use for payment.
+ * @return        Amount of cargo actually unloaded.
+ */
+uint VehicleCargoList::DeliverPacket(Iterator &it, uint cap, CargoPayment *payment)
+{
+	CargoPacket *p = *it;
+	uint unloaded = 0;
+	if (p->count <= cap) {
+		payment->PayFinalDelivery(p, p->count);
+		this->packets.erase(it++);
+		this->RemoveFromCache(p);
+		unloaded = p->count;
+		delete p;
+	} else {
+		payment->PayFinalDelivery(p, cap);
+		this->count -= cap;
+		this->cargo_days_in_transit -= cap * p->days_in_transit;
+		this->feeder_share -= p->feeder_share;
+		p->feeder_share = 0;
+		p->count -= cap;
+		unloaded = cap;
+		++it;
+	}
+	return unloaded;
+}
+
+/**
+ * Keep a packet in the vehicle while unloading by temporarily moving it to the
+ * reservation list. The given iterator is incremented in the process.
+ * @param it Iterator pointing to the packet.
+ * @return Size of the packet.
+ */
+uint VehicleCargoList::KeepPacket(Iterator &it)
+{
+	CargoPacket *cp = *it;
+	this->reserved.push_back(cp);
+	this->reserved_count += cp->count;
+	this->packets.erase(it++);
+	return cp->count;
+}
 
-			static_cast<Tinst *>(this)->RemoveFromCache(cp_new); // this reflects the changes in cp.
+/**
+ * Transfer a packet to a station, but don't deliver it. Increment the given
+ * iterator in the process.
+ * @param it Iterator pointing to a packet in the list.
+ * @param cap Maximum amount of cargo to be transferred.
+ * @param dest Cargo list of the station the cargo should be transferred to.
+ * @param payment Payment object to be updated with the resulting transfer
+ *                credits.
+ * @param next ID of the station the cargo wants to go to next.
+ * @return Amount of cargo actually moved.
+ */
+uint VehicleCargoList::TransferPacket(Iterator &it, uint cap, StationCargoList *dest, CargoPayment *payment, StationID next)
+{
+	CargoPacket *cp = this->RemovePacket(it, cap);
+	cp->feeder_share += payment->PayTransfer(cp, cp->count);
+	uint ret = cp->count;
+	dest->Append(next, cp);
+	return ret;
+}
 
-			if (mta == MTA_TRANSFER) {
-				/* Add the feeder share before inserting in dest. */
-				cp_new->feeder_share += payment->PayTransfer(cp_new, max_move);
-			} else if (mta == MTA_CARGO_LOAD) {
-				cp_new->loaded_at_xy = data;
-			}
+/**
+ * Determine what a cargo packet arriving at the station this list belongs to
+ * will do, using the "old", non-cargodist algorithm.
+ * @param flags  Unload flags telling if the cargo is accepted and what order
+ *               flags there are.
+ * @param source ID of the packets source station.
+ * @return       Unload type (deliver, transfer, keep) telling what to do with
+ *               the packet.
+ */
+UnloadType StationCargoList::WillUnloadOld(byte flags, StationID source)
+{
+	/* try to unload cargo */
+	bool move = (flags & (UL_DELIVER | UL_ACCEPTED | UL_TRANSFER)) != 0;
+	/* try to deliver cargo if unloading */
+	bool deliver = (flags & UL_ACCEPTED) && !(flags & UL_TRANSFER) && (source != this->station->index);
+	/* transfer cargo if delivery was unsuccessful */
+	bool transfer = (flags & (UL_TRANSFER | UL_DELIVER)) != 0;
+	if (move) {
+		if(deliver) {
+			return UL_DELIVER;
+		} else if (transfer) {
+			return UL_TRANSFER;
+		} else {
+			/* this case is for (non-)delivery to the source station without special flags.
+			 * like the code in MoveTo did, we keep the packet in this case
+			 */
+			return UL_KEEP;
+		}
+	} else {
+		return UL_KEEP;
+	}
+}
 
-			if (mta == MTA_RESERVE) {
-				/* nasty reinterpret cast, see above */
-				reinterpret_cast<VehicleCargoList *>(dest)->Reserve(cp_new);
+/**
+ * Determine what a cargo packet arriving at the station this list belongs to
+ * will do, using the Cargodist algorithm.
+ * @param flags  Unload flags telling if the cargo is accepted and what order
+ *               flags there are.
+ * @param next   Station the vehicle the cargo is coming from will
+ *               visit next (or INVALID_STATION if unknown).
+ * @param via    Station the cargo wants to go to next. If that is this
+ *               station the cargo wants to be delivered.
+ * @param source ID of the packets source station.
+ * @return       Unload type (deliver, transfer, keep) telling what to do with
+ *               the packet.
+ */
+UnloadType StationCargoList::WillUnloadCargoDist(byte flags, StationID next, StationID via, StationID source)
+{
+	if (via == this->station->index) {
+		/* this is the final destination, deliver ... */
+		if (flags & UL_TRANSFER) {
+			/* .. except if explicitly told not to do so ... */
+			return UL_TRANSFER;
+		} else if (flags & UL_ACCEPTED) {
+			return UL_DELIVER;
+		} else if (flags & UL_DELIVER) {
+			/* .. or if the station suddenly doesn't accept our cargo, but we have an explicit deliver order... */
+			return UL_TRANSFER;
+		} else {
+			/* .. or else if it doesn't accept. */
+			return UL_KEEP;
+		}
+	} else {
+		/* packet has to travel on, find out if it can stay on board */
+		if (flags & UL_DELIVER) {
+			/* order overrides cargodist:
+			 * play by the old loading rules here as player is interfering with cargodist
+			 * try to deliver, as move has been forced upon us */
+			if ((flags & UL_ACCEPTED) && !(flags & UL_TRANSFER) && source != this->station->index) {
+				return UL_DELIVER;
 			} else {
-				dest->Append(cp_new);
+				/* transfer cargo, as delivering didn't work */
+				return UL_TRANSFER;
 			}
+		} else if (flags & UL_TRANSFER) {
+			/* transfer forced */
+			return UL_TRANSFER;
+		} else if (next == via) {
+			/* vehicle goes to the packet's next hop or has nondeterministic order: keep the packet*/
+			return UL_KEEP;
+		} else {
+			/* vehicle goes somewhere else, transfer the packet*/
+			return UL_TRANSFER;
 		}
-
-		max_move = 0;
 	}
+}
 
-	return it != packets.end();
+/**
+ * Swap the reserved and packets lists when starting to load cargo. Pull in the
+ * "kept" packets which were stored in the reservation list so that we don't
+ * have to iterate over them all the time.
+ * @pre this->packets.empty()
+ */
+void VehicleCargoList::SwapReserved()
+{
+	assert(this->packets.empty());
+	this->packets.swap(this->reserved);
+	this->reserved_count = 0;
 }
 
-/** Invalidates the cached data and rebuilds it. */
-template <class Tinst>
-void CargoList<Tinst>::InvalidateCache()
+/**
+ * Moves the given amount of cargo from a vehicle to a station.
+ * Depending on the value of flags the side effects of this function differ:
+ *  - OUFB_UNLOAD_IF_POSSIBLE and dest->acceptance_pickup & GoodsEntry::ACCEPTANCE:
+ *  	packets are accepted here and may be unloaded and/or delivered (=destroyed);
+ *  	if not using cargodist: all packets are unloaded and delivered
+ *  	if using cargodist: only packets which have this station as final destination are unloaded and delivered.
+ *  	if using cargodist: other packets may or may not be unloaded, depending on next_station.
+ *  	if GoodsEntry::ACCEPTANCE is not set and using cargodist: packets may still be unloaded, but not delivered.
+ *  - OUFB_UNLOAD: unload all packets unconditionally;
+ *  	if OUF_UNLOAD_IF_POSSIBLE set and OUFB_TRANSFER not set: also deliver packets (no matter if using cargodist).
+ *  - OUFB_TRANSFER: don't deliver any packets;
+ *  	overrides delivering aspect of OUFB_UNLOAD_IF_POSSIBLE.
+ * @param source       Vehicle cargo list to take the cargo from.
+ * @param max_unload   Maximum amount of cargo entities to move.
+ * @param flags        How to handle the moving (side effects).
+ * @param next         Next unloading station in the vehicle's order list.
+ * @param has_stopped  Vehicle has stopped at this station before, so don't update the flow stats for kept cargo.
+ * @param payment      Payment object to be updated when delivering/transferring.
+ * @return Number of cargo entities actually moved.
+ */
+uint StationCargoList::TakeFrom(VehicleCargoList *source, uint max_unload, OrderUnloadFlags order_flags, StationID next, bool has_stopped, CargoPayment *payment)
 {
-	this->count = 0;
-	this->cargo_days_in_transit = 0;
+	uint remaining_unload = max_unload;
+	uint unloaded;
+	byte flags = this->GetUnloadFlags(order_flags);
+	GoodsEntry *dest = &this->station->goods[this->cargo];
+	UnloadType action;
+
+	for (VehicleCargoList::Iterator c = source->packets.begin(); c != source->packets.end() && remaining_unload > 0;) {
+		StationID cargo_source = (*c)->source;
+		FlowStatSet &flows = dest->flows[cargo_source];
+		FlowStatSet::iterator begin = flows.begin();
+		StationID via = (begin != flows.end() ? begin->Via() : INVALID_STATION);
+		if (via != INVALID_STATION && next != INVALID_STATION) {
+			/* use cargodist unloading*/
+			action = this->WillUnloadCargoDist(flags, next, via, cargo_source);
+		} else {
+			/* there is no plan: use normal unloading */
+			action = this->WillUnloadOld(flags, cargo_source);
+		}
 
-	for (ConstIterator it(this->packets.begin()); it != this->packets.end(); it++) {
-		static_cast<Tinst *>(this)->AddToCache(*it);
+		switch (action) {
+			case UL_DELIVER:
+				unloaded = source->DeliverPacket(c, remaining_unload, payment);
+				if (via != INVALID_STATION) {
+					if (via == this->station->index) {
+						dest->UpdateFlowStats(flows, begin, unloaded);
+					} else {
+						dest->UpdateFlowStats(flows, unloaded, this->station->index);
+					}
+				}
+				remaining_unload -= unloaded;
+				break;
+			case UL_TRANSFER:
+				/* TransferPacket may split the packet and return the transferred part */
+				if (via == this->station->index) {
+					via = (++begin != flows.end()) ? begin->Via() : INVALID_STATION;
+				}
+				unloaded = source->TransferPacket(c, remaining_unload, this, payment, via);
+				if (via != INVALID_STATION) {
+					dest->UpdateFlowStats(flows, begin, unloaded);
+				}
+				remaining_unload -= unloaded;
+				break;
+			case UL_KEEP:
+				unloaded = source->KeepPacket(c);
+				if (via != INVALID_STATION && next != INVALID_STATION && !has_stopped) {
+					if (via == next) {
+						dest->UpdateFlowStats(flows, begin, unloaded);
+					} else {
+						dest->UpdateFlowStats(flows, unloaded, next);
+					}
+				}
+				break;
+			default:
+				NOT_REACHED();
+		}
 	}
+	return max_unload - remaining_unload;
 }
 
 /**
@@ -450,6 +675,22 @@ void VehicleCargoList::AddToCache(const CargoPacket *cp)
 }
 
 /**
+ * Moves the given amount of cargo to another vehicle (during autoreplace).
+ * @param dest         Destination to move the cargo to.
+ * @param cap          Maximum amount of cargo entities to move.
+ * @return             Amount of cargo actually moved.
+ */
+uint VehicleCargoList::MoveTo(VehicleCargoList *dest, uint cap)
+{
+	uint orig_cap = cap;
+	Iterator it = packets.begin();
+	while (it != packets.end() && cap > 0) {
+		cap -= MovePacket(dest, it, cap);
+	}
+	return orig_cap - cap;
+}
+
+/**
  * Ages the all cargo in this list.
  */
 void VehicleCargoList::AgeCargo()
@@ -464,7 +705,154 @@ void VehicleCargoList::AgeCargo()
 	}
 }
 
-/** Invalidates the cached data and rebuild it. */
+/*
+ *
+ * Station cargo list implementation
+ *
+ */
+
+/**
+ * build unload flags from order flags and station acceptance.
+ * @param order_flags order flags to check for forced transfer/deliver
+ * @return some combination of UL_ACCEPTED, UL_DELIVER and UL_TRANSFER
+ */
+FORCEINLINE byte StationCargoList::GetUnloadFlags(OrderUnloadFlags order_flags)
+{
+	byte flags = 0;
+	if (HasBit(this->station->goods[this->cargo].acceptance_pickup, GoodsEntry::ACCEPTANCE)) {
+		flags |= UL_ACCEPTED;
+	}
+	if (order_flags & OUFB_UNLOAD) {
+		flags |= UL_DELIVER;
+	}
+	if (order_flags & OUFB_TRANSFER) {
+		flags |= UL_TRANSFER;
+	}
+	return flags;
+}
+
+/**
+ * Appends the given cargo packet to the range of packets with the same next station
+ * @warning After appending this packet may not exist anymore!
+ * @note Do not use the cargo packet anymore after it has been appended to this CargoList!
+ * @param next the next hop
+ * @param cp the cargo packet to add
+ * @pre cp != NULL
+ */
+void StationCargoList::Append(StationID next, CargoPacket *cp)
+{
+	assert(cp != NULL);
+	this->AddToCache(cp);
+
+	StationCargoPacketMap::List &list = this->packets[next];
+	for (StationCargoPacketMap::List::reverse_iterator it(list.rbegin()); it != list.rend(); it++) {
+		CargoPacket *icp = *it;
+		if (StationCargoList::AreMergable(icp, cp) && icp->count + cp->count <= CargoPacket::MAX_COUNT) {
+			icp->Merge(cp);
+			return;
+		}
+	}
+
+	/* The packet could not be merged with another one */
+	list.push_back(cp);
+}
+
+/**
+ * Move packets from a specific range in this list to a vehicle.
+ * @param dest Cargo list the packets will be moved to.
+ * @param cap Maximum amount of cargo to move.
+ * @param begin Begin of the range to take packets from.
+ * @param end End of the range to take packets from.
+ * @param reserve If the packets should be loaded on or reserved for the vehicle.
+ * @return Amount of cargo that has been moved.
+ */
+uint StationCargoList::MovePackets(VehicleCargoList *dest, uint cap, Iterator begin, Iterator end, bool reserve)
+{
+	uint orig_cap = cap;
+	while (begin != end && cap > 0) {
+		cap -= this->MovePacket(dest, begin, cap, this->station->xy, reserve);
+	}
+	return orig_cap - cap;
+}
+
+/**
+ * Move suitable packets from this list to a vehicle.
+ * @param dest Vehicle cargo list to move packets to.
+ * @param cap Maximum amount of cargo to be moved.
+ * @param next Next station the vehicle will stop at.
+ * @param reserve If the packets should be loaded on or reserved for the vehicle.
+ * @return Amount of cargo that has been moved.
+ */
+uint StationCargoList::MoveTo(VehicleCargoList *dest, uint cap, StationID next, bool reserve)
+{
+	uint orig_cap = cap;
+	if (next != INVALID_STATION) {
+		std::pair<Iterator, Iterator> bounds(this->packets.equal_range(next));
+		cap -= this->MovePackets(dest, cap, bounds.first, bounds.second, reserve);
+		if (cap > 0) {
+			bounds = this->packets.equal_range(INVALID_STATION);
+			cap -= this->MovePackets(dest, cap, bounds.first, bounds.second, reserve);
+		}
+	} else {
+		cap -= this->MovePackets(dest, cap, this->packets.begin(), this->packets.end(), reserve);
+	}
+	return orig_cap - cap;
+}
+
+/**
+ * Route all packets with station "to" as next hop to a different place.
+ * @param to station to exclude from routing.
+ */
+void StationCargoList::RerouteStalePackets(StationID to)
+{
+	std::pair<Iterator, Iterator> range(this->packets.equal_range(to));
+	for (Iterator it(range.first); it != range.second && it.GetKey() == to;) {
+		CargoPacket *packet = *it;
+		this->packets.erase(it++);
+		StationID next = this->station->goods[this->cargo].UpdateFlowStatsTransfer(packet->source, packet->count, this->station->index);
+		assert(next != to);
+
+		/* legal, as insert doesn't invalidate iterators in the MultiMap, however
+		 * this might insert the packet between range.first and range.second (which might be end())
+		 * This is why we check for GetKey above to avoid infinite loops
+		 */
+		this->packets.Insert(next, packet);
+	}
+}
+
+/**
+ * Truncate where each destination loses roughly the same percentage of its cargo.
+ * This is done by randomizing the selection of packets to be removed.
+ * @param max_remaining maximum amount of cargo to keep in the list.
+ */
+void StationCargoList::RandomTruncate(uint max_remaining)
+{
+	uint prev_count = this->count;
+	while (this->count > max_remaining) {
+		for (Iterator it(this->packets.begin()); it != this->packets.end();) {
+			if (RandomRange(prev_count) < max_remaining) {
+				++it;
+				continue;
+			}
+			CargoPacket *packet = *it;
+			uint diff = this->count - max_remaining;
+			if (packet->count > diff) {
+				packet->count -= diff;
+				this->count = max_remaining;
+				this->cargo_days_in_transit -= packet->days_in_transit * diff;
+				return;
+			} else {
+				this->packets.erase(it++);
+				this->RemoveFromCache(packet);
+				delete packet;
+			}
+		}
+	}
+}
+
+/**
+ * Invalidates the cached data and rebuilds it.
+ */
 void VehicleCargoList::InvalidateCache()
 {
 	this->feeder_share = 0;
@@ -493,12 +881,5 @@ void StationCargoList::AssignTo(Station *station, CargoID cargo)
 /*
  * We have to instantiate everything we want to be usable.
  */
-template class CargoList<VehicleCargoList>;
-template class CargoList<StationCargoList>;
-
-/** Autoreplace Vehicle -> Vehicle 'transfer'. */
-template bool CargoList<VehicleCargoList>::MoveTo(VehicleCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
-/** Cargo unloading at a station. */
-template bool CargoList<VehicleCargoList>::MoveTo(StationCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
-/** Cargo loading at a station. */
-template bool CargoList<StationCargoList>::MoveTo(VehicleCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
+template class CargoList<VehicleCargoList, CargoPacketList>;
+template class CargoList<StationCargoList, StationCargoPacketMap>;
diff --git a/src/cargopacket.h b/src/cargopacket.h
index b84b85d..96add16 100644
--- a/src/cargopacket.h
+++ b/src/cargopacket.h
@@ -15,9 +15,11 @@
 #include "core/pool_type.hpp"
 #include "economy_type.h"
 #include "station_type.h"
+#include "order_type.h"
 #include "cargo_type.h"
 #include "cargotype.h"
 #include "vehicle_type.h"
+#include "core/multimap.hpp"
 #include <list>
 
 /** Unique identifier for a single cargo packet. */
@@ -29,8 +31,9 @@ typedef Pool<CargoPacket, CargoPacketID, 1024, 0xFFF000, PT_NORMAL, true, false>
 /** The actual pool with cargo packets. */
 extern CargoPacketPool _cargopacket_pool;
 
-template <class Tinst> class CargoList;
+template <class Tinst, class Tcont> class CargoList;
 class StationCargoList; // forward-declare, so we can use it in VehicleCargoList::Unreserve
+class VehicleCargoList; // forward-declare, so we can use it in CargoList::MovePacket
 extern const struct SaveLoad *GetCargoPacketDesc();
 
 /**
@@ -48,7 +51,7 @@ private:
 	TileIndex loaded_at_xy;     ///< Location where this cargo has been loaded into the vehicle.
 
 	/** The CargoList caches, thus needs to know about it. */
-	template <class Tinst> friend class CargoList;
+	template <class Tinst, class Tcont> friend class CargoList;
 	friend class VehicleCargoList;
 	friend class StationCargoList;
 	/** We want this to be saved, right? */
@@ -142,7 +145,6 @@ public:
 		return this->loaded_at_xy;
 	}
 
-
 	static void InvalidateAllFrom(SourceType src_type, SourceID src);
 	static void InvalidateAllFrom(StationID sid);
 	static void AfterLoad();
@@ -161,39 +163,46 @@ public:
  */
 #define FOR_ALL_CARGOPACKETS(var) FOR_ALL_CARGOPACKETS_FROM(var, 0)
 
+/** Kind of actions that could be done with packets on unloading */
+enum UnloadType {
+	UL_KEEP     = 0,      ///< keep cargo on vehicle
+	UL_DELIVER  = 1 << 0, ///< deliver cargo
+	UL_TRANSFER = 1 << 1, ///< transfer cargo
+	UL_ACCEPTED = 1 << 2, ///< cargo is accepted
+};
+
 /**
  * Simple collection class for a list of cargo packets.
  * @tparam Tinst Actual instantation of this cargo list.
  */
-template <class Tinst>
+template <class Tinst, class Tcont>
 class CargoList {
 public:
-	/** Container with cargo packets. */
-	typedef std::list<CargoPacket *> List;
-	/** The iterator for our container. */
-	typedef List::iterator Iterator;
-	/** The const iterator for our container. */
-	typedef List::const_iterator ConstIterator;
-
-	/** Kind of actions that could be done with packets on move. */
-	enum MoveToAction {
-		MTA_FINAL_DELIVERY, ///< "Deliver" the packet to the final destination, i.e. destroy the packet.
-		MTA_CARGO_LOAD,     ///< Load the packet onto a vehicle, i.e. set the last loaded station ID.
-		MTA_RESERVE,        ///< Reserve cargo for later loading.
-		MTA_TRANSFER,       ///< The cargo is moved as part of a transfer.
-		MTA_UNLOAD,         ///< The cargo is moved as part of a forced unload.
-	};
+	/** Iterator for our container. */
+	typedef typename Tcont::iterator Iterator;
+	/** Const iterator for our container. */
+	typedef typename Tcont::const_iterator ConstIterator;
+	/** Reverse iterator for our container. */
+	typedef typename Tcont::reverse_iterator ReverseIterator;
+	/** Const reverse iterator for our container. */
+	typedef typename Tcont::const_reverse_iterator ConstReverseIterator;
 
 protected:
 	uint count;                 ///< Cache for the number of cargo entities.
 	uint cargo_days_in_transit; ///< Cache for the sum of number of days in transit of each entity; comparable to man-hours.
 
-	List packets;               ///< The cargo packets in this list.
+	Tcont packets;              ///< The cargo packets in this list.
 
 	void AddToCache(const CargoPacket *cp);
 
 	void RemoveFromCache(const CargoPacket *cp);
 
+	CargoPacket *RemovePacket(Iterator &it, uint cap, TileIndex load_place = INVALID_TILE);
+
+	uint MovePacket(StationCargoList *dest, StationID next, Iterator &it, uint cap);
+
+	uint MovePacket(VehicleCargoList *dest, Iterator &it, uint cap, TileIndex load_place = INVALID_TILE, bool reserved = false);
+
 public:
 	/** Create the cargo list. */
 	CargoList() {}
@@ -206,7 +215,7 @@ public:
 	 * Returns a pointer to the cargo packet list (so you can iterate over it etc).
 	 * @return Pointer to the packet list.
 	 */
-	FORCEINLINE const List *Packets() const
+	FORCEINLINE const Tcont *Packets() const
 	{
 		return &this->packets;
 	}
@@ -238,37 +247,43 @@ public:
 		return this->count == 0 ? 0 : this->cargo_days_in_transit / this->count;
 	}
 
-
 	void Append(CargoPacket *cp, bool update_cache = true);
 	void Truncate(uint max_remaining);
 
-	template <class Tother_inst>
-	bool MoveTo(Tother_inst *dest, uint count, MoveToAction mta, CargoPayment *payment, uint data = 0);
-
 	void InvalidateCache();
 };
 
+typedef std::list<CargoPacket *> CargoPacketList;
+
 /**
  * CargoList that is used for vehicles.
  */
-class VehicleCargoList : public CargoList<VehicleCargoList> {
+class VehicleCargoList : public CargoList<VehicleCargoList, CargoPacketList> {
 protected:
+	uint TransferPacket(Iterator &c, uint remaining_unload, StationCargoList *dest, CargoPayment *payment, StationID next);
+	uint DeliverPacket(Iterator &c, uint remaining_unload, CargoPayment *payment);
+	uint KeepPacket(Iterator &c);
+
 	/** The (direct) parent of this class. */
-	typedef CargoList<VehicleCargoList> Parent;
+	typedef CargoList<VehicleCargoList, CargoPacketList> Parent;
 
-	List reserved;       ///< The packets reserved for unloading in this list.
-	Money feeder_share;  ///< Cache for the feeder share.
-	uint reserved_count; ///< Cache for the number of reserved cargo entities.
+	CargoPacketList reserved; ///< Packets reserved for unloading in this list.
+	Money feeder_share;       ///< Cache for the feeder share.
+	uint reserved_count;      ///< Cache for the number of reserved cargo entities.
 
 	void AddToCache(const CargoPacket *cp);
 	void RemoveFromCache(const CargoPacket *cp);
 
 public:
+	/** The station cargo list needs to control the unloading. */
+	friend class StationCargoList;
 	/** The super class ought to know what it's doing. */
-	friend class CargoList<VehicleCargoList>;
+	friend class CargoList<VehicleCargoList, CargoPacketList>;
 	/** The vehicles have a cargo list (and we want that saved). */
 	friend const struct SaveLoad *GetVehicleDescription(VehicleType vt);
 
+	~VehicleCargoList();
+
 	/**
 	 * Returns total sum of the feeder share for all packets.
 	 * @return The before mentioned number.
@@ -278,6 +293,8 @@ public:
 		return this->feeder_share;
 	}
 
+	void Append(CargoPacket *cp, bool update_cache = true);
+
 	/**
 	 * Returns sum of cargo on board the vehicle (ie not only
 	 * reserved).
@@ -301,7 +318,7 @@ public:
 	 * Returns a pointer to the reserved cargo list.
 	 * @return Pointer to the reserved list.
 	 */
-	FORCEINLINE const List *Reserved() const
+	FORCEINLINE const CargoPacketList *Reserved() const
 	{
 		return &this->reserved;
 	}
@@ -326,14 +343,18 @@ public:
 
 	void Reserve(CargoPacket *cp);
 
-	void Unreserve(StationCargoList *dest);
+	void Unreserve(StationID next, StationCargoList *dest);
+
+	uint LoadReserved(uint count);
 
-	bool LoadReserved(uint count);
+	void SwapReserved();
 
 	void AgeCargo();
 
 	void InvalidateCache();
 
+	uint MoveTo(VehicleCargoList *dest, uint cap);
+
 	/**
 	 * Are two the two CargoPackets mergeable in the context of
 	 * a list of CargoPackets for a Vehicle?
@@ -351,13 +372,15 @@ public:
 	}
 };
 
+typedef MultiMap<StationID, CargoPacket *> StationCargoPacketMap;
+
 /**
  * CargoList that is used for stations.
  */
-class StationCargoList : public CargoList<StationCargoList> {
+class StationCargoList : public CargoList<StationCargoList, StationCargoPacketMap> {
 public:
 	/** The super class ought to know what it's doing. */
-	friend class CargoList<StationCargoList>;
+	friend class CargoList<StationCargoList, StationCargoPacketMap>;
 	/** The stations, via GoodsEntry, have a CargoList. */
 	friend const struct SaveLoad *GetGoodsDesc();
 
@@ -378,20 +401,39 @@ public:
 				cp1->source_id       == cp2->source_id;
 	}
 
+	uint TakeFrom(VehicleCargoList *source, uint max_unload, OrderUnloadFlags flags, StationID next_station, bool has_stopped, CargoPayment *payment);
+
+	uint MoveTo(VehicleCargoList *dest, uint cap, StationID next_station, bool reserve = false);
+
+	void Append(StationID next, CargoPacket *cp);
+
+	void RerouteStalePackets(StationID to);
+
+	void RandomTruncate(uint max_remaining);
+
 	/**
 	 * Returns source of the first cargo packet in this list.
 	 * @return The before mentioned source.
 	 */
 	FORCEINLINE StationID Source() const
 	{
-		return this->Empty() ? INVALID_STATION : this->packets.front()->source;
+		return this->Empty() ? INVALID_STATION : this->packets.begin()->second.front()->source;
 	}
 
 	void AssignTo(Station *station, CargoID cargo);
 
-private:
+	static void InvalidateAllFrom(SourceType src_type, SourceID src);
+
+protected:
 	Station *station; ///< Station this cargo list belongs to.
 	CargoID cargo;    ///< Cargo type this list holds.
+
+	byte GetUnloadFlags(OrderUnloadFlags order_flags);
+
+	UnloadType WillUnloadOld(byte flags, StationID source);
+	UnloadType WillUnloadCargoDist(byte flags, StationID next_station, StationID via, StationID source);
+
+	uint MovePackets(VehicleCargoList *dest, uint cap, Iterator begin, Iterator end, bool reserve);
 };
 
 #endif /* CARGOPACKET_H */
diff --git a/src/economy.cpp b/src/economy.cpp
index 2cafca4..4882d64 100644
--- a/src/economy.cpp
+++ b/src/economy.cpp
@@ -1077,17 +1077,34 @@ Money CargoPayment::PayTransfer(const CargoPacket *cp, uint count)
 
 /**
  * Prepare the vehicle to be unloaded.
+ * @param curr_station the station where the consist is at the moment
  * @param front_v the vehicle to be unloaded
+ * @param next_station_id id of the station the consist will be traveling next
  */
-void PrepareUnload(Vehicle *front_v)
+void PrepareUnload(Station *curr_station, Vehicle *front_v, StationID next_station_id)
 {
 	/* At this moment loading cannot be finished */
 	ClrBit(front_v->vehicle_flags, VF_LOADING_FINISHED);
 
-	/* Start unloading in at the first possible moment */
+	/* Start unloading at the first possible moment */
 	front_v->load_unload_ticks = 1;
 
-	if ((front_v->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
+	if ((front_v->current_order.GetUnloadType() & OUFB_NO_UNLOAD) != 0) {
+		/* vehicle will keep all its cargo and LoadUnloadVehicle will never call MoveToStation,
+		 * so we have to update the flow stats here.
+		 */
+		if (next_station_id == INVALID_STATION) {
+			return;
+		} else {
+			for (Vehicle *v = front_v; v != NULL; v = v->Next()) {
+				const CargoPacketList *packets = v->cargo.Packets();
+				for (VehicleCargoList::ConstIterator i(packets->begin()); i != packets->end(); ++i) {
+					curr_station->goods[v->cargo_type].UpdateFlowStats(
+							(*i)->SourceStation(), (*i)->Count(), next_station_id);
+				}
+			}
+		}
+	} else {
 		for (Vehicle *v = front_v; v != NULL; v = v->Next()) {
 			if (v->cargo_cap > 0 && !v->cargo.Empty()) {
 				SetBit(v->vehicle_flags, VF_CARGO_UNLOADING);
@@ -1107,19 +1124,42 @@ void PrepareUnload(Vehicle *front_v)
  * Reserves cargo if the full load order and improved_load is set.
  * @param st The station where the consist is loading at the moment
  * @param u The front of the loading vehicle consist
+ * @param next_station The next station the vehicle will stop at
  * @return bit field for the cargo classes with bits for the reserved cargos set (if anything was reserved).
  */
-uint32 ReserveConsist(Station *st, Vehicle *u)
+uint32 ReserveConsist(Station *st, Vehicle *u, StationID next_station)
 {
 	uint32 ret = 0;
 	if (_settings_game.order.improved_load && (u->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
 		/* Update reserved cargo */
 		for (Vehicle *v = u; v != NULL; v = v->Next()) {
+			/* Only reserve if the vehicle is not unloading anymore.
+			 *
+			 * The packets that are kept in the vehicle because they have the
+			 * same destination as the vehicle are stored in the reservation
+			 * list while unloading for performance reasons. The reservation
+			 * list is swapped with the onboard list after unloading. This
+			 * doesn't increase the load/unload time. So if we start reserving
+			 * cargo before unloading has stopped we'll load that cargo for free
+			 * later. Like this there is a slightly increased probability that
+			 * another vehicle which has arrived later loads cargo that should
+			 * be loaded by this vehicle but as the algorithm isn't perfect in
+			 * that regard anyway we can tolerate it.
+			 *
+			 * The algorithm isn't perfect as it only counts free capacity for
+			 * reservation. If another vehicle arrives later but unloads faster
+			 * than this one, this vehicle won't reserve all the cargo it may
+			 * be able to take after fully unloading. So the other vehicle may
+			 * load it even if it has arrived later.
+			 */
+			if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING)) continue;
+
 			int cap = v->cargo_cap - v->cargo.Count();
 			if (cap > 0) {
 				StationCargoList &list = st->goods[v->cargo_type].cargo;
-				list.MoveTo(&v->cargo, cap, StationCargoList::MTA_RESERVE, NULL, st->xy);
-				SetBit(ret, v->cargo_type);
+				if (list.MoveTo(&v->cargo, cap, next_station, true) > 0) {
+					SetBit(ret, v->cargo_type);
+				}
 			}
 		}
 	}
@@ -1140,11 +1180,19 @@ static uint32 LoadUnloadVehicle(Vehicle *v, uint32 cargos_reserved)
 	StationID last_visited = v->last_station_visited;
 	Station *st = Station::Get(last_visited);
 
+	StationID next_station = INVALID_STATION;
+	OrderList *orders = v->orders.list;
+	if (orders != NULL) {
+		next_station = orders->GetNextStoppingStation(v->cur_auto_order_index, last_visited);
+	}
+
 	/* We have not waited enough time till the next round of loading/unloading */
 	if (v->load_unload_ticks != 0) {
-		return cargos_reserved | ReserveConsist(st, v);
+		return cargos_reserved | ReserveConsist(st, v, next_station);
 	}
 
+	OrderUnloadFlags unload_flags = v->current_order.GetUnloadType();
+
 	if (v->type == VEH_TRAIN && (!IsTileType(v->tile, MP_STATION) || GetStationIndex(v->tile) != st->index)) {
 		/* The train reversed in the station. Take the "easy" way
 		 * out and let the train just leave as it always did. */
@@ -1185,59 +1233,42 @@ static uint32 LoadUnloadVehicle(Vehicle *v, uint32 cargos_reserved)
 
 		GoodsEntry *ge = &st->goods[v->cargo_type];
 
-		if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING) && (u->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
+		if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING)) {
+			/* vehicle wants to unload something */
+
 			uint cargo_count = v->cargo.OnboardCount();
 			uint amount_unloaded = _settings_game.order.gradual_loading ? min(cargo_count, load_amount) : cargo_count;
-			bool remaining = false; // Are there cargo entities in this vehicle that can still be unloaded here?
-			bool accepted  = false; // Is the cargo accepted by the station?
 
+			uint prev_count = ge->cargo.Count();
 			payment->SetCargo(v->cargo_type);
+			uint delivered = ge->cargo.TakeFrom(&v->cargo, amount_unloaded, unload_flags,
+					next_station, u->last_loading_station == last_visited, payment);
 
-			if (HasBit(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE) && !(u->current_order.GetUnloadType() & OUFB_TRANSFER)) {
-				/* The cargo has reached its final destination, the packets may now be destroyed */
-				remaining = v->cargo.MoveTo<StationCargoList>(NULL, amount_unloaded, VehicleCargoList::MTA_FINAL_DELIVERY, payment, last_visited);
-
-				dirty_vehicle = true;
-				accepted = true;
-			}
+			st->time_since_unload = 0;
+			unloading_time += delivered;
 
-			/* The !accepted || v->cargo.Count == cargo_count clause is there
-			 * to make it possible to force unload vehicles at the station where
-			 * they were loaded, but to not force unload the vehicle when the
-			 * station is still accepting the cargo in the vehicle. It doesn't
-			 * accept cargo that was loaded at the same station. */
-			if ((u->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) && (!accepted || v->cargo.OnboardCount() == cargo_count)) {
-				remaining = v->cargo.MoveTo(&ge->cargo, amount_unloaded, u->current_order.GetUnloadType() & OUFB_TRANSFER ? VehicleCargoList::MTA_TRANSFER : VehicleCargoList::MTA_UNLOAD, payment);
+			if (ge->cargo.Count() > prev_count) {
+				/* something has been transferred. The station windows need updating. */
+				dirty_station = true;
 				if (!HasBit(ge->acceptance_pickup, GoodsEntry::PICKUP)) {
 					InvalidateWindowData(WC_STATION_LIST, last_visited);
 					SetBit(ge->acceptance_pickup, GoodsEntry::PICKUP);
 				}
-
-				dirty_vehicle = dirty_station = true;
-			} else if (!accepted) {
-				/* The order changed while unloading (unset unload/transfer) or the
-				 * station does not accept our goods. */
-				ClrBit(v->vehicle_flags, VF_CARGO_UNLOADING);
-
-				/* Say we loaded something, otherwise we'll think we didn't unload
-				 * something and we didn't load something, so we must be finished
-				 * at this station. Setting the unloaded means that we will get a
-				 * retry for loading in the next cycle. */
-				anything_unloaded = true;
-				continue;
 			}
 
-			/* Deliver goods to the station */
-			st->time_since_unload = 0;
-
-			unloading_time += amount_unloaded;
-
 			anything_unloaded = true;
-			if (_settings_game.order.gradual_loading && remaining) {
-				completely_emptied = false;
-			} else {
-				/* We have finished unloading (cargo count == 0) */
+			dirty_vehicle = true;
+
+			/* load_amount might (theoretically) be 0, which would make delivered == 0 even though there is still cargo
+			 * in the vehicle. Thus OnboardCount > 0. In that case we can't stop unloading as SwapReserved wouldn't work.
+			 * v->cargo also contains the cargo reserved for the vehicle which is not on board at the moment, but will be
+			 * swapped back when done unloading.
+			 */
+			if (v->cargo.OnboardCount() == 0) {
+				/* done delivering */
+				if (!v->cargo.Empty()) completely_emptied = false;
 				ClrBit(v->vehicle_flags, VF_CARGO_UNLOADING);
+				v->cargo.SwapReserved();
 			}
 
 			continue;
@@ -1277,20 +1308,17 @@ static uint32 LoadUnloadVehicle(Vehicle *v, uint32 cargos_reserved)
 			if (_settings_game.order.gradual_loading) cap_left = min(cap_left, load_amount);
 			if (v->cargo.Empty()) TriggerVehicle(v, VEHICLE_TRIGGER_NEW_CARGO);
 
-			uint reserved_count = v->cargo.ReservedCount();
-			uint station_count = ge->cargo.Count();
-
+			int loaded = 0;
 			if (_settings_game.order.improved_load) {
-				v->cargo.LoadReserved(cap_left);
+				loaded += v->cargo.LoadReserved(cap_left);
 			}
-
-			if (v->cargo.ReservedCount() == 0) {
-				ge->cargo.MoveTo(&v->cargo, cap_left - reserved_count, StationCargoList::MTA_CARGO_LOAD, NULL, st->xy);
+			if (loaded < cap_left) {
+				assert(v->cargo.ReservedCount() == 0);
+				loaded += ge->cargo.MoveTo(&v->cargo, cap_left - loaded, next_station);
 			}
-			uint loaded = reserved_count + station_count - v->cargo.ReservedCount() - ge->cargo.Count();
 
 			/* Store whether the maximum possible load amount was loaded or not.*/
-			if (loaded == (uint)cap_left) {
+			if (loaded == cap_left) {
 				SetBit(full_load_amount, v->cargo_type);
 			} else {
 				ClrBit(full_load_amount, v->cargo_type);
diff --git a/src/economy_func.h b/src/economy_func.h
index e9c9c17..5af968d 100644
--- a/src/economy_func.h
+++ b/src/economy_func.h
@@ -33,7 +33,7 @@ void StartupIndustryDailyChanges(bool init_counter);
 Money GetTransportedGoodsIncome(uint num_pieces, uint dist, byte transit_days, CargoID cargo_type);
 uint MoveGoodsToStation(CargoID type, uint amount, SourceType source_type, SourceID source_id, const StationList *all_stations);
 
-void PrepareUnload(Vehicle *front_v);
+void PrepareUnload(Station *curr_station, Vehicle *front_v, StationID next_station_id);
 void LoadUnloadStation(Station *st);
 
 Money GetPrice(Price index, uint cost_factor, const struct GRFFile *grf_file, int shift = 0);
diff --git a/src/saveload/cargopacket_sl.cpp b/src/saveload/cargopacket_sl.cpp
index eafe534..da920cc 100644
--- a/src/saveload/cargopacket_sl.cpp
+++ b/src/saveload/cargopacket_sl.cpp
@@ -26,7 +26,7 @@
 		 * to the current tile of the vehicle to prevent excessive profits
 		 */
 		FOR_ALL_VEHICLES(v) {
-			const VehicleCargoList::List *packets = v->cargo.Packets();
+			const CargoPacketList *packets = v->cargo.Packets();
 			for (VehicleCargoList::ConstIterator it(packets->begin()); it != packets->end(); it++) {
 				CargoPacket *cp = *it;
 				cp->source_xy = Station::IsValidID(cp->source) ? Station::Get(cp->source)->xy : v->tile;
@@ -44,7 +44,7 @@
 			for (CargoID c = 0; c < NUM_CARGO; c++) {
 				GoodsEntry *ge = &st->goods[c];
 
-				const StationCargoList::List *packets = ge->cargo.Packets();
+				const StationCargoPacketMap *packets = ge->cargo.Packets();
 				for (StationCargoList::ConstIterator it(packets->begin()); it != packets->end(); it++) {
 					CargoPacket *cp = *it;
 					cp->source_xy = Station::IsValidID(cp->source) ? Station::Get(cp->source)->xy : st->xy;
diff --git a/src/saveload/economy_sl.cpp b/src/saveload/economy_sl.cpp
index be66e70..ccfc202 100644
--- a/src/saveload/economy_sl.cpp
+++ b/src/saveload/economy_sl.cpp
@@ -63,11 +63,11 @@ static void Load_ECMY()
 }
 
 static const SaveLoad _cargopayment_desc[] = {
-	SLE_REF(CargoPayment, front,         REF_VEHICLE),
-	SLE_VAR(CargoPayment, route_profit,  SLE_INT64),
-	SLE_VAR(CargoPayment, visual_profit, SLE_INT64),
-//	SLE_CONDVAR(CargoPayment, visual_transfer,  SLE_INT64, <some version>, SL_MAX_VERSION),
-	SLE_END()
+	    SLE_REF(CargoPayment, front,           REF_VEHICLE),
+	    SLE_VAR(CargoPayment, route_profit,    SLE_INT64),
+	    SLE_VAR(CargoPayment, visual_profit,   SLE_INT64),
+	SLE_CONDVAR(CargoPayment, visual_transfer, SLE_INT64, SL_CARGOMAP, SL_MAX_VERSION),
+	    SLE_END()
 };
 
 static void Save_CAPY()
diff --git a/src/saveload/oldloader_sl.cpp b/src/saveload/oldloader_sl.cpp
index 362df6b..2649bc5 100644
--- a/src/saveload/oldloader_sl.cpp
+++ b/src/saveload/oldloader_sl.cpp
@@ -711,7 +711,7 @@ static bool LoadOldGood(LoadgameState *ls, int num)
 	SB(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE, 1, HasBit(_waiting_acceptance, 15));
 	SB(ge->acceptance_pickup, GoodsEntry::PICKUP, 1, _cargo_source != 0xFF);
 	if (GB(_waiting_acceptance, 0, 12) != 0 && CargoPacket::CanAllocateItem()) {
-		ge->cargo.Append(new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, (_cargo_source == 0xFF) ? INVALID_STATION : _cargo_source, 0, 0));
+		ge->cargo.Append(INVALID_STATION, new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, (_cargo_source == 0xFF) ? INVALID_STATION : _cargo_source, 0, 0));
 	}
 
 	return true;
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
index c4fffa1..be755a2 100644
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -226,7 +226,7 @@
  *  159   21962
  *  160   21974
  */
-extern const uint16 SAVEGAME_VERSION = SL_RESERVATION; ///< Current savegame version of OpenTTD.
+extern const uint16 SAVEGAME_VERSION = SL_CARGOMAP; ///< Current savegame version of OpenTTD.
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
index a1b925e..34e7932 100644
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -558,6 +558,7 @@ enum SaveLoadVersions {
 	SL_DEMANDS = SL_COMPONENTS + 20,
 	SL_MCF,
 	SL_FLOWMAP,
+	SL_CARGOMAP,
 
 	/** Highest possible savegame version. */
 	SL_MAX_VERSION = 255
diff --git a/src/saveload/station_sl.cpp b/src/saveload/station_sl.cpp
index eeaf4e4..62cff14 100644
--- a/src/saveload/station_sl.cpp
+++ b/src/saveload/station_sl.cpp
@@ -228,7 +228,7 @@ static uint16 _num_links;
 static uint32 _num_flows;
 static uint16 _cargo_source;
 static uint32 _cargo_source_xy;
-static uint16 _cargo_days;
+static uint8  _cargo_days;
 static Money  _cargo_feeder_share;
 
 static const SaveLoad _station_speclist_desc[] = {
@@ -278,6 +278,9 @@ const SaveLoad *GetFlowStatDesc()
 	return _flowstat_desc;
 }
 
+std::list<CargoPacket *> _packets;
+uint32 _num_dests;
+
 /**
  * Wrapper function to get the GoodsEntry's internal structure while
  * some of the variables itself are private.
@@ -300,7 +303,8 @@ const SaveLoad *GetGoodsDesc()
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_FILE_U32 | SLE_VAR_I64, 14, 64),
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_INT64,                  65, 67),
 		 SLE_CONDVAR(GoodsEntry, amount_fract,        SLE_UINT8,                 150, SL_MAX_VERSION),
-		 SLE_CONDLST(GoodsEntry, cargo.packets,       REF_CARGO_PACKET,           68, SL_MAX_VERSION),
+		SLEG_CONDLST(            _packets,            REF_CARGO_PACKET,           68, SL_CARGOMAP - 1),
+		SLEG_CONDVAR(            _num_dests,          SLE_UINT32,        SL_CARGOMAP, SL_MAX_VERSION),
 		 SLE_CONDVAR(GoodsEntry, supply,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
 		 SLE_CONDVAR(GoodsEntry, supply_new,          SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
 		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
@@ -312,6 +316,35 @@ const SaveLoad *GetGoodsDesc()
 	return goods_desc;
 }
 
+typedef std::pair<const StationID, std::list<CargoPacket *> > StationCargoPair;
+
+static const SaveLoad _cargo_list_desc[] = {
+	SLE_VAR(StationCargoPair, first,  SLE_UINT16),
+	SLE_LST(StationCargoPair, second, REF_CARGO_PACKET),
+	SLE_END()
+};
+
+/**
+ * swap the temporary packets with the packets without specific destination in
+ * the given goods entry. Assert that at least one of those is empty.
+ * @param ge the goods entry to swap with
+ */
+static void SwapPackets(GoodsEntry *ge)
+{
+	StationCargoPacketMap &ge_packets = const_cast<StationCargoPacketMap &>(*ge->cargo.Packets());
+
+	if (_packets.empty()) {
+		std::map<StationID, std::list<CargoPacket *> >::iterator it(ge_packets.find(INVALID_STATION));
+		if (it == ge_packets.end()) {
+			return;
+		} else {
+			it->second.swap(_packets);
+		}
+	} else {
+		assert(ge_packets[INVALID_STATION].empty());
+		ge_packets[INVALID_STATION].swap(_packets);
+	}
+}
 
 static void Load_STNS()
 {
@@ -327,6 +360,7 @@ static void Load_STNS()
 		for (CargoID i = 0; i < num_cargo; i++) {
 			GoodsEntry *ge = &st->goods[i];
 			SlObject(ge, GetGoodsDesc());
+			SwapPackets(ge);
 			if (IsSavegameVersionBefore(68)) {
 				SB(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE, 1, HasBit(_waiting_acceptance, 15));
 				if (GB(_waiting_acceptance, 0, 12) != 0) {
@@ -338,7 +372,10 @@ static void Load_STNS()
 					 * savegame versions. As the CargoPacketPool has more than
 					 * 16 million entries; it fits by an order of magnitude. */
 					assert(CargoPacket::CanAllocateItem());
-					ge->cargo.Append(new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, source, _cargo_source_xy, _cargo_source_xy, _cargo_feeder_share));
+
+					/* Don't construct the packet with station here, because that'll fail with old savegames */
+					CargoPacket *cp = new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, source, _cargo_source_xy, _cargo_source_xy, _cargo_feeder_share);
+					ge->cargo.Append(INVALID_STATION, cp);
 					SB(ge->acceptance_pickup, GoodsEntry::PICKUP, 1, 1);
 				}
 			}
@@ -364,7 +401,9 @@ static void Ptrs_STNS()
 		if (!IsSavegameVersionBefore(68)) {
 			for (CargoID i = 0; i < NUM_CARGO; i++) {
 				GoodsEntry *ge = &st->goods[i];
+				SwapPackets(ge);
 				SlObject(ge, GetGoodsDesc());
+				SwapPackets(ge);
 			}
 		}
 		SlObject(st, _old_station_desc);
@@ -452,6 +491,7 @@ static void RealSave_STNN(BaseStation *bst)
 	if (!waypoint) {
 		Station *st = Station::From(bst);
 		for (CargoID c = 0; c < NUM_CARGO; c++) {
+			_num_dests = (uint32)st->goods[c].cargo.Packets()->MapSize();
 			_num_links = (uint16)st->goods[c].link_stats.size();
 			_num_flows = 0;
 			for (FlowStatMap::const_iterator it(st->goods[c].flows.begin()); it != st->goods[c].flows.end(); ++it) {
@@ -470,6 +510,9 @@ static void RealSave_STNN(BaseStation *bst)
 					SlObject(&fs, GetFlowStatDesc());
 				}
 			}
+			for (StationCargoPacketMap::ConstMapIterator it(st->goods[c].cargo.Packets()->begin()); it != st->goods[c].cargo.Packets()->end(); ++it) {
+				SlObject(const_cast<StationCargoPacketMap::value_type *>(&(*it)), _cargo_list_desc);
+			}
 		}
 	}
 
@@ -513,6 +556,16 @@ static void Load_STNN()
 					SlObject(&fs, GetFlowStatDesc());
 					st->goods[c].flows[_station_id].insert(fs);
 				}
+				if (IsSavegameVersionBefore(SL_CARGOMAP -1)) {
+					SwapPackets(&st->goods[c]);
+				} else {
+					StationCargoPair pair;
+					for (uint i = 0; i < _num_dests; ++i) {
+						SlObject(&pair, _cargo_list_desc);
+						const_cast<StationCargoPacketMap &>(*(st->goods[c].cargo.Packets()))[pair.first].swap(pair.second);
+						assert(pair.second.empty());
+					}
+				}
 			}
 		}
 
@@ -535,7 +588,16 @@ static void Ptrs_STNN()
 	FOR_ALL_STATIONS(st) {
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
 			GoodsEntry *ge = &st->goods[i];
-			SlObject(ge, GetGoodsDesc());
+			if (IsSavegameVersionBefore(SL_CARGOMAP)) {
+				SwapPackets(ge);
+				SlObject(ge, GetGoodsDesc());
+				SwapPackets(ge);
+			} else {
+				SlObject(ge, GetGoodsDesc());
+				for (StationCargoPacketMap::ConstMapIterator it = ge->cargo.Packets()->begin(); it != ge->cargo.Packets()->end(); ++it) {
+					SlObject(const_cast<StationCargoPair *>(&(*it)), _cargo_list_desc);
+				}
+			}
 		}
 		SlObject(st, _station_desc);
 	}
diff --git a/src/station.cpp b/src/station.cpp
index 9a5f2e1..1ff4235 100644
--- a/src/station.cpp
+++ b/src/station.cpp
@@ -99,6 +99,7 @@ Station::~Station()
 			GoodsEntry &ge = st->goods[c];
 			ge.link_stats.erase(this->index);
 			DeleteStaleFlows(st->index, c, this->index);
+			ge.cargo.RerouteStalePackets(this->index);
 		}
 	}
 
diff --git a/src/station_base.h b/src/station_base.h
index 4d00743..e5ba013 100644
--- a/src/station_base.h
+++ b/src/station_base.h
@@ -328,6 +328,12 @@ struct GoodsEntry {
 	LinkStatMap link_stats;              ///< Capacities and usage statistics for outgoing links.
 	LinkGraphComponentID last_component; ///< Component this station was last part of in this cargo's link graph.
 	FlowStat GetSumFlowVia(StationID via) const;
+
+	void UpdateFlowStats(StationID source, uint count, StationID next);
+	void UpdateFlowStats(FlowStatSet &flow_stats, uint count, StationID next);
+	void UpdateFlowStats(FlowStatSet &flow_stats, FlowStatSet::iterator flow_it, uint count);
+
+	StationID UpdateFlowStatsTransfer(StationID source, uint count, StationID curr);
 };
 
 /** All airport-related information. Only valid if tile != INVALID_TILE. */
diff --git a/src/station_cmd.cpp b/src/station_cmd.cpp
index 46e1c96..0cd77a3 100644
--- a/src/station_cmd.cpp
+++ b/src/station_cmd.cpp
@@ -3095,7 +3095,7 @@ static void UpdateStationRating(Station *st)
 					waiting_changed = true;
 				}
 
-				if (waiting_changed) ge->cargo.Truncate(waiting);
+				if (waiting_changed) ge->cargo.RandomTruncate(waiting);
 			}
 		}
 	}
@@ -3158,12 +3158,14 @@ void Station::RunAverages()
 			StationID id = i->first;
 			Station *other = Station::GetIfValid(id);
 			if (other == NULL) {
+				this->goods[goods_index].cargo.RerouteStalePackets(id);
 				links.erase(i++);
 			} else {
 				LinkStat &ls = i->second;
 				ls.Decrease();
 				if (ls.HasCapacity()) {
 					DeleteStaleFlows(this->index, goods_index, id);
+					this->goods[goods_index].cargo.RerouteStalePackets(id);
 					links.erase(i++);
 				} else {
 					++i;
@@ -3380,7 +3382,16 @@ static uint UpdateStationWaiting(Station *st, CargoID type, uint amount, SourceT
 	/* No new "real" cargo item yet. */
 	if (amount == 0) return 0;
 
-	ge.cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id));
+	StationID id = st->index;
+	StationID next = INVALID_STATION;
+	FlowStatSet &flow_stats = ge.flows[id];
+	FlowStatSet::iterator i = flow_stats.begin();
+	if (i != flow_stats.end()) {
+		next = i->Via();
+		ge.UpdateFlowStats(flow_stats, i, amount);
+	}
+
+	ge.cargo.Append(next, new CargoPacket(st->index, st->xy, amount, source_type, source_id));
 	ge.supply_new += amount;
 
 	if (!HasBit(ge.acceptance_pickup, GoodsEntry::PICKUP)) {
@@ -3745,6 +3756,77 @@ static CommandCost TerraformTile_Station(TileIndex tile, DoCommandFlag flags, ui
 }
 
 /**
+ * Update the flow stats for a specific entry.
+ * @param flow_stats Flow stats to update.
+ * @param flow_it Iterator pointing to an entry in flow_stats.
+ * @param count Amount by which the flow should be increased.
+ */
+void GoodsEntry::UpdateFlowStats(FlowStatSet &flow_stats, FlowStatSet::iterator flow_it, uint count)
+{
+	FlowStat fs = *flow_it;
+	fs.Increase(count);
+	flow_stats.erase(flow_it);
+	flow_stats.insert(fs);
+}
+
+/**
+ * Update the flow stats for a specific next station.
+ * @param flow_stats Flow stats to update.
+ * @param count Amount by which the flow should be increased.
+ * @param next Next hop for which the flow stats should be updated.
+ */
+void GoodsEntry::UpdateFlowStats(FlowStatSet &flow_stats, uint count, StationID next)
+{
+	FlowStatSet::iterator flow_it = flow_stats.begin();
+	while (flow_it != flow_stats.end()) {
+		StationID via = flow_it->Via();
+		if (via == next) { //usually the first one is the correct one
+			this->UpdateFlowStats(flow_stats, flow_it, count);
+			return;
+		} else {
+			++flow_it;
+		}
+	}
+}
+
+/**
+ * Update the flow stats for "count" cargo from "source" sent to "next".
+ * @param source ID of station the cargo is from.
+ * @param count Amount of cargo.
+ * @param next ID of the station the cargo is travelling to.
+ */
+void GoodsEntry::UpdateFlowStats(StationID source, uint count, StationID next)
+{
+	if (source == INVALID_STATION || next == INVALID_STATION || this->flows.empty()) return;
+	FlowStatSet &flow_stats = this->flows[source];
+	this->UpdateFlowStats(flow_stats, count, next);
+}
+
+/**
+ * Update the flow stats for "count" cargo that cannot be delivered here.
+ * @param source ID of station where the cargo is from.
+ * @param count Amount of cargo.
+ * @param curr ID of station where it is stored for now.
+ * @return ID of the station where the cargo is sent next.
+ */
+StationID GoodsEntry::UpdateFlowStatsTransfer(StationID source, uint count, StationID curr)
+{
+	if (source == INVALID_STATION || this->flows.empty()) return INVALID_STATION;
+	FlowStatSet &flow_stats = this->flows[source];
+	FlowStatSet::iterator flow_it = flow_stats.begin();
+	while (flow_it != flow_stats.end()) {
+		StationID via = flow_it->Via();
+		if (via != curr) {
+			this->UpdateFlowStats(flow_stats, flow_it, count);
+			return via;
+		} else {
+			++flow_it;
+		}
+	}
+	return INVALID_STATION;
+}
+
+/**
  * Get the sum of flows via a specific station from this GoodsEntry.
  * @param via Remote station to look for.
  * @return a FlowStat with all flows for 'via' added up.
diff --git a/src/station_gui.cpp b/src/station_gui.cpp
index 433ab12..0f30670 100644
--- a/src/station_gui.cpp
+++ b/src/station_gui.cpp
@@ -1008,7 +1008,7 @@ struct StationViewWindow : public Window {
 				this->cargo_rows[i] = (uint16)cargolist->size();
 
 				/* Add an entry for each distinct cargo source. */
-				const StationCargoList::List *packets = st->goods[i].cargo.Packets();
+				const StationCargoPacketMap *packets = st->goods[i].cargo.Packets();
 				for (StationCargoList::ConstIterator it(packets->begin()); it != packets->end(); it++) {
 					const CargoPacket *cp = *it;
 					if (cp->SourceStation() != station_id) {
diff --git a/src/station_type.h b/src/station_type.h
index d6084d7..3223082 100644
--- a/src/station_type.h
+++ b/src/station_type.h
@@ -14,6 +14,7 @@
 
 #include "core/smallvec_type.hpp"
 #include "tilearea_type.h"
+#include <list>
 
 typedef uint16 StationID;
 typedef uint16 RoadStopID;
@@ -88,6 +89,9 @@ enum CatchmentArea {
 static const uint MAX_LENGTH_STATION_NAME_CHARS  =  32; ///< The maximum length of a station name in characters including '\0'
 static const uint MAX_LENGTH_STATION_NAME_PIXELS = 180; ///< The maximum length of a station name in pixels
 
+/** List of station IDs */
+typedef std::list<StationID> StationIDList;
+
 /** List of stations */
 typedef SmallVector<Station *, 2> StationList;
 
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index c1c8b7f..9377c51 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -674,7 +674,7 @@ void Vehicle::PreDestructor()
 		st->loading_vehicles.remove(this);
 
 		HideFillingPercent(&this->fill_percent_te_id);
-		this->CancelReservation(st);
+		this->CancelReservation(INVALID_STATION, st);
 		delete this->cargo_payment;
 	}
 
@@ -1879,7 +1879,7 @@ void Vehicle::BeginLoading()
 		IncreaseStats(curr_station, this, next_station_id, true);
 	}
 
-	PrepareUnload(this);
+	PrepareUnload(curr_station, this, next_station_id);
 
 	SetWindowDirty(GetWindowClassForVehicleType(this->type), this->owner);
 	SetWindowWidgetDirty(WC_VEHICLE_VIEW, this->index, VVW_WIDGET_START_STOP_VEH);
@@ -1895,13 +1895,15 @@ void Vehicle::BeginLoading()
  * Return all reserved cargo packets to the station.
  * @param st the station where the reserved packets should go.
  */
-void Vehicle::CancelReservation(Station *st)
+void Vehicle::CancelReservation(StationID next, Station *st)
 {
 	for (Vehicle *v = this; v != NULL; v = v->next) {
 		VehicleCargoList &cargo = v->cargo;
 		if (cargo.ReservedCount() > 0) {
 			DEBUG(misc, 1, "cancelling cargo reservation");
-			cargo.Unreserve(&st->goods[v->cargo_type].cargo);
+			GoodsEntry &ge = st->goods[v->cargo_type];
+			cargo.Unreserve(next, &ge.cargo);
+			SetBit(ge.acceptance_pickup, GoodsEntry::PICKUP);
 		}
 	}
 }
@@ -1934,16 +1936,17 @@ void Vehicle::LeaveStation()
 
 	this->current_order.MakeLeaveStation();
 	Station *st = Station::Get(this->last_station_visited);
-	this->CancelReservation(st);
 	st->loading_vehicles.remove(this);
 
 	OrderList *orders = this->orders.list;
 	if (orders != NULL) {
 		StationID next_station_id = orders->GetNextStoppingStation(this->cur_auto_order_index, this->last_station_visited);
+		this->CancelReservation(next_station_id, st);
 		if (next_station_id != INVALID_STATION && next_station_id != this->last_station_visited) {
 			DecreaseFrozen(st, this, next_station_id);
 		}
 	} else {
+		this->CancelReservation(INVALID_STATION, st);
 		DEBUG(misc, 1, "orders are NULL");
 		RecalcFrozen(st);
 	}
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index bc6c172..ffeb743 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -247,7 +247,7 @@ public:
 	virtual ~Vehicle();
 
 	void BeginLoading();
-	void CancelReservation(Station *st);
+	void CancelReservation(StationID next, Station *st);
 	void LeaveStation();
 
 	GroundVehicleCache *GetGroundVehicleCache();
