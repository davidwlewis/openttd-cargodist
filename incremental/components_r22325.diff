diff --git a/docs/linkgraph.txt b/docs/linkgraph.txt
new file mode 100644
index 0000000..ddb125a
--- /dev/null
+++ b/docs/linkgraph.txt
@@ -0,0 +1,30 @@
+Some clarifications about the link graph
+----------------------------------------
+
+InitializeLinkGraphs joins all threads, so if the game is abendoned
+with some threads still running, they're joined as soon as the next game
+(possibly the title game) is started. see also InitializeGame.
+
+The MCF algorithm can be quite CPU-hungry as it's NP-hard and takes
+exponential time (though with a very small constant factor) in the number
+of nodes.
+This is why it is run in a separate thread where possible. However after
+some time the thread is joined and if it hasn't finished by then the game
+will hang. This problem gets worse if we are running on a platform without
+threads. However, as those are usually the ones with less CPU power I
+assume the contention for the CPU would make the game hard to play even
+with threads or even without cargodist (autosave ...). I might be wrong,
+but I won't put any work into this before someone shows me some problem.
+
+You can configure the link graph recalculation interval. A link graph
+recalculation interval of X days means that each link graph job has X days
+to run before it is joined. The downside is that the flow stats won't be
+updated before the job is finished and thus a long interval means less
+updates and longer times until changes in capacities are accounted for.
+If you play a very large map with a complicated link graph you may want to
+raise the interval to avoid lags. The same holds for systems with slow
+CPUs.
+
+Another option to avoid excessive lags is to reduce the accuracy of link
+graph calculations. Generally the accurace is inversely correlated to the
+CPU requirements of the MCF algorithm.
diff --git a/projects/openttd_vs100.vcxproj b/projects/openttd_vs100.vcxproj
index e1039a3..3a3ebff 100644
--- a/projects/openttd_vs100.vcxproj
+++ b/projects/openttd_vs100.vcxproj
@@ -327,6 +327,7 @@
     <ClCompile Include="..\src\ini.cpp" />
     <ClCompile Include="..\src\ini_load.cpp" />
     <ClCompile Include="..\src\landscape.cpp" />
+    <ClCompile Include="..\src\linkgraph\linkgraph.cpp" />
     <ClCompile Include="..\src\map.cpp" />
     <ClCompile Include="..\src\misc.cpp" />
     <ClCompile Include="..\src\mixer.cpp" />
@@ -455,6 +456,8 @@
     <ClInclude Include="..\src\landscape.h" />
     <ClInclude Include="..\src\landscape_type.h" />
     <ClInclude Include="..\src\language.h" />
+    <ClInclude Include="..\src\linkgraph\linkgraph.h" />
+    <ClInclude Include="..\src\linkgraph\linkgraph_type.h" />
     <ClInclude Include="..\src\livery.h" />
     <ClInclude Include="..\src\map_func.h" />
     <ClInclude Include="..\src\map_type.h" />
@@ -727,6 +730,7 @@
     <ClCompile Include="..\src\saveload\group_sl.cpp" />
     <ClCompile Include="..\src\saveload\industry_sl.cpp" />
     <ClCompile Include="..\src\saveload\labelmaps_sl.cpp" />
+    <ClCompile Include="..\src\saveload\linkgraph_sl.cpp" />
     <ClCompile Include="..\src\saveload\map_sl.cpp" />
     <ClCompile Include="..\src\saveload\misc_sl.cpp" />
     <ClCompile Include="..\src\saveload\newgrf_sl.cpp" />
diff --git a/projects/openttd_vs100.vcxproj.filters b/projects/openttd_vs100.vcxproj.filters
index f8930c8..4bdbac7 100644
--- a/projects/openttd_vs100.vcxproj.filters
+++ b/projects/openttd_vs100.vcxproj.filters
@@ -201,6 +201,9 @@
     <ClCompile Include="..\src\landscape.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\linkgraph\linkgraph.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -585,6 +588,12 @@
     <ClInclude Include="..\src\language.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\linkgraph\linkgraph.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\linkgraph_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\livery.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -1401,6 +1410,9 @@
     <ClCompile Include="..\src\saveload\labelmaps_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\saveload\linkgraph_sl.cpp">
+      <Filter>Save/Load handlers</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\saveload\map_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
diff --git a/projects/openttd_vs80.vcproj b/projects/openttd_vs80.vcproj
index 81a5ff9..b22b9a6 100644
--- a/projects/openttd_vs80.vcproj
+++ b/projects/openttd_vs80.vcproj
@@ -579,6 +579,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1095,6 +1099,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -2203,6 +2215,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
diff --git a/projects/openttd_vs90.vcproj b/projects/openttd_vs90.vcproj
index ccc718c..76a36dd 100644
--- a/projects/openttd_vs90.vcproj
+++ b/projects/openttd_vs90.vcproj
@@ -576,6 +576,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1092,6 +1096,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -2200,6 +2212,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
diff --git a/source.list b/source.list
index 3cbf9cb..8ce6770 100644
--- a/source.list
+++ b/source.list
@@ -35,6 +35,7 @@ hotkeys.cpp
 ini.cpp
 ini_load.cpp
 landscape.cpp
+linkgraph/linkgraph.cpp
 map.cpp
 misc.cpp
 mixer.cpp
@@ -188,6 +189,8 @@ ini_type.h
 landscape.h
 landscape_type.h
 language.h
+linkgraph/linkgraph.h
+linkgraph/linkgraph_type.h
 livery.h
 map_func.h
 map_type.h
@@ -485,6 +488,7 @@ saveload/gamelog_sl.cpp
 saveload/group_sl.cpp
 saveload/industry_sl.cpp
 saveload/labelmaps_sl.cpp
+saveload/linkgraph_sl.cpp
 saveload/map_sl.cpp
 saveload/misc_sl.cpp
 saveload/newgrf_sl.cpp
diff --git a/src/landscape.cpp b/src/landscape.cpp
index c60bf8b..421c3e4 100644
--- a/src/landscape.cpp
+++ b/src/landscape.cpp
@@ -1004,6 +1004,7 @@ void OnTick_Station();
 void OnTick_Industry();
 
 void OnTick_Companies();
+void OnTick_LinkGraph();
 
 void CallLandscapeTick()
 {
@@ -1013,4 +1014,5 @@ void CallLandscapeTick()
 	OnTick_Industry();
 
 	OnTick_Companies();
+	OnTick_LinkGraph();
 }
diff --git a/src/lang/english.txt b/src/lang/english.txt
index ca6d0fa..bad1a4c 100644
--- a/src/lang/english.txt
+++ b/src/lang/english.txt
@@ -1322,11 +1322,21 @@ STR_CONFIG_SETTING_LARGER_TOWNS_DISABLED                        :{LTBLUE}Proport
 STR_CONFIG_SETTING_CITY_SIZE_MULTIPLIER                         :{LTBLUE}Initial city size multiplier: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD                        :{LTBLUE}Remove absurd road-elements during the road construction: {ORANGE}{STRING1}
 
+STR_CONFIG_SETTING_LINKGRAPH_INTERVAL                           :{LTBLUE}Link graph recalculation interval: {ORANGE}{STRING1} days
+STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC                       :symmetric
+STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC                      :asymmetric
+STR_CONFIG_SETTING_DISTRIBUTION_MANUAL                          :manual
+STR_CONFIG_SETTING_DISTRIBUTION_PAX                             :{LTBLUE}Distribution for passengers: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_MAIL                            :{LTBLUE}Distribution for mail: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED                        :{LTBLUE}Distribution for the ARMOURED cargo class: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT                         :{LTBLUE}Distribution for other cargo classes: {ORANGE}{STRING1}
+
 STR_CONFIG_SETTING_GUI                                          :{ORANGE}Interface
 STR_CONFIG_SETTING_CONSTRUCTION                                 :{ORANGE}Construction
 STR_CONFIG_SETTING_VEHICLES                                     :{ORANGE}Vehicles
 STR_CONFIG_SETTING_STATIONS                                     :{ORANGE}Stations
 STR_CONFIG_SETTING_ECONOMY                                      :{ORANGE}Economy
+STR_CONFIG_SETTING_LINKGRAPH                                    :{ORANGE}Link graph
 STR_CONFIG_SETTING_AI                                           :{ORANGE}Competitors
 STR_CONFIG_SETTING_DISPLAY_OPTIONS                              :{ORANGE}Display options
 STR_CONFIG_SETTING_INTERACTION                                  :{ORANGE}Interaction
diff --git a/src/linkgraph/linkgraph.cpp b/src/linkgraph/linkgraph.cpp
new file mode 100644
index 0000000..267403a
--- /dev/null
+++ b/src/linkgraph/linkgraph.cpp
@@ -0,0 +1,358 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph.cpp Definition of link graph classes used for cargo distribution. */
+
+#include "../stdafx.h"
+#include "../map_func.h"
+#include "../core/bitmath_func.hpp"
+#include "../debug.h"
+#include "../moving_average.h"
+#include "linkgraph.h"
+#include <queue>
+
+/**
+ * Global array of link graphs, one for each cargo.
+ */
+LinkGraph _link_graphs[NUM_CARGO];
+
+/**
+ * Handlers to be run for each job.
+ */
+LinkGraphJob::HandlerList LinkGraphJob::_handlers;
+
+/**
+ * Create a node.
+ * @param st ID of the associated station.
+ * @param sup Supply of cargo at the station last month.
+ * @param dem Acceptance for cargo at the station.
+ */
+FORCEINLINE void Node::Init(StationID st, uint sup, uint dem)
+{
+	this->supply = sup;
+	this->demand = dem;
+	this->station = st;
+}
+
+/**
+ * Create an edge.
+ * @param distance Length of the link as manhattan distance.
+ * @param capacity Capacity of the link.
+ */
+FORCEINLINE void Edge::Init(uint distance, uint capacity)
+{
+	this->distance = distance;
+	this->capacity = capacity;
+}
+
+
+/**
+ * 1. Build the link graph component containing the given station by using BFS on the link stats.
+ * 2. Set every included station's last_component to the new component's ID (this->current_component_id).
+ * 3. Start a link graph job with the new component.
+ * @param first Station to start the search at.
+ */
+void LinkGraph::CreateComponent(Station *first)
+{
+	std::map<Station *, NodeID> index;
+	index[first] = this->AddNode(first);
+
+	std::queue<Station *> search_queue;
+	search_queue.push(first);
+
+	/* find all stations belonging to the current component */
+	while (!search_queue.empty()) {
+		Station *source = search_queue.front();
+		search_queue.pop();
+
+		const LinkStatMap &links = source->goods[this->cargo].link_stats;
+		for (LinkStatMap::const_iterator i = links.begin(); i != links.end(); ++i) {
+			Station *target = Station::GetIfValid(i->first);
+			if (target == NULL) continue;
+
+			std::map<Station *, NodeID>::iterator index_it = index.find(target);
+			if (index_it == index.end()) {
+				search_queue.push(target);
+				NodeID node = this->AddNode(target);
+				index[target] = node;
+
+				this->AddEdge(index[source], node, i->second.Capacity());
+			} else {
+				this->AddEdge(index[source], index_it->second, i->second.Capacity());
+			}
+		}
+	}
+
+	/* here the list of nodes and edges for this component is complete. */
+	this->SpawnThread();
+}
+
+/**
+ * Looks for a suitable station to create the next link graph component from.
+ * Linearly searches all stations starting from current_station_id for one that
+ * hasn't been visited in this run over the link graph. The current run and the
+ * last run are differentiated by giving the components IDs divisible by 2
+ * every second run and ones not divisible by 2 on the other runs.
+ *
+ * If such a station is found current_station_id is set to that station's ID
+ * and CreateComponent is called with it.
+ *
+ * The search wraps around and changes current_component_id to 0 or 1
+ * accordingly. If the starting point is reached again it stops.
+ */
+void LinkGraph::NextComponent()
+{
+	if (this->GetSize() > 0) return; // don't mess with running jobs (might happen when changing interval)
+	StationID last_station_id = this->current_station_id;
+	LinkGraphComponentID current_component_id = this->LinkGraphComponent::index;
+
+	do {
+		if (++this->current_station_id >= Station::GetPoolSize()) {
+			/* Wrap around and recycle the component IDs. Use different
+			 * divisibility by 2 than in the last run so that we can find out
+			 * which stations haven't been seen in this run.
+			 */
+			this->current_station_id = 0;
+			if (current_component_id % 2 == 0) {
+				current_component_id = 1;
+			} else {
+				current_component_id = 0;
+			}
+		}
+
+		/* find first station of next component */
+		Station *station = Station::GetIfValid(this->current_station_id);
+		if (station != NULL) {
+			GoodsEntry &ge = station->goods[this->cargo];
+			if (ge.last_component == INVALID_LINKGRAPH_COMPONENT ||
+					(ge.last_component + current_component_id) % 2 != 0) {
+				/* Different divisibility by 2: This station has not been seen
+				 * in the current run over the link graph.
+				 */
+
+				if (!ge.link_stats.empty()) {
+					this->LinkGraphComponent::Init(current_component_id + 2);
+					CreateComponent(station);
+					return;
+				}
+			}
+		}
+
+	} while (this->current_station_id != last_station_id);
+}
+
+/**
+ * Spawn or join a link graph component if any link graph is due to do so.
+ * Spawning is done on COMPONENTS_SPAWN_TICK every day, joining on
+ * COMPONENT_JOIN_TICK. Each link graph is due every recalc_interval days.
+ */
+void OnTick_LinkGraph()
+{
+	if (_date_fract == LinkGraph::COMPONENTS_SPAWN_TICK ||
+			_date_fract == LinkGraph::COMPONENTS_JOIN_TICK) {
+
+		/* This creates a fair distribution of all link graphs' turns over
+		 * the available dates.
+		 */
+		for (uint cargo = _date % _settings_game.linkgraph.recalc_interval; cargo < NUM_CARGO;
+				cargo += _settings_game.linkgraph.recalc_interval) {
+
+			/* don't calculate a link graph if the distribution is manual */
+			if (_settings_game.linkgraph.GetDistributionType(cargo) == DT_MANUAL) continue;
+
+			if (_date_fract == LinkGraph::COMPONENTS_SPAWN_TICK) {
+				_link_graphs[cargo].NextComponent();
+			} else /* LinkGraph::COMPONENTS_JOIN_TICK */ {
+				_link_graphs[cargo].Join();
+			}
+		}
+	}
+}
+
+/**
+ * Add a node to the component and create empty edges associated with it. Set
+ * the station's last_component to this component. Calculate the distances to all
+ * other nodes. The distances to _all_ nodes are important as the demand
+ * calculator relies on their availability.
+ * @param st New node's station.
+ * @return New node's ID.
+ */
+NodeID LinkGraphComponent::AddNode(Station *st)
+{
+	GoodsEntry &good = st->goods[this->cargo];
+	good.last_component = this->index;
+
+	bool do_resize = (this->nodes.size() == this->num_nodes);
+
+	if (do_resize) {
+		this->nodes.push_back(Node());
+		this->edges.push_back(std::vector<Edge>(this->num_nodes + 1));
+	}
+
+	this->nodes[this->num_nodes].Init(st->index, good.supply,
+			HasBit(good.acceptance_pickup, GoodsEntry::ACCEPTANCE));
+
+	std::vector<Edge> &new_edges = this->edges[this->num_nodes];
+	for (NodeID i = 0; i < this->num_nodes; ++i) {
+		uint distance = DistanceManhattan(st->xy, Station::Get(this->nodes[i].station)->xy);
+		if (do_resize) this->edges[i].push_back(Edge());
+		new_edges[i].Init(distance);
+		this->edges[i][this->num_nodes].Init(distance);
+	}
+
+	return this->num_nodes++;
+}
+
+/**
+ * Fill an edge with values from a link.
+ * @param from Source node of the link.
+ * @param to Destination node of the link.
+ * @param capacity Capacity of the link.
+ */
+FORCEINLINE void LinkGraphComponent::AddEdge(NodeID from, NodeID to, uint capacity)
+{
+	assert(from != to);
+	this->edges[from][to].capacity = capacity;
+}
+
+/**
+ * Resize the component and fill it with empty nodes and edges. Used when
+ * loading from save games.
+ *
+ * WARNING: The nodes and edges are expected to contain anything while
+ * num_nodes is expected to contain the desired size. Normally this is an
+ * invalid state, but just after loading the component's structure it is valid.
+ * This method should only be called from Load_LGRP.
+ */
+void LinkGraphComponent::SetSize()
+{
+	if (this->nodes.size() < this->num_nodes) {
+		for (EdgeMatrix::iterator i = this->edges.begin(); i != this->edges.end(); ++i) {
+			i->resize(this->num_nodes);
+		}
+		this->nodes.resize(this->num_nodes);
+		this->edges.resize(this->num_nodes, std::vector<Edge>(this->num_nodes));
+	}
+
+	for (uint i = 0; i < this->num_nodes; ++i) {
+		this->nodes[i].Init();
+		for (uint j = 0; j < this->num_nodes; ++j) {
+			this->edges[i][j].Init();
+		}
+	}
+}
+
+/**
+ * Create an empty component.
+ */
+LinkGraphComponent::LinkGraphComponent() :
+		settings(_settings_game.linkgraph),
+		cargo(INVALID_CARGO),
+		num_nodes(0),
+		index(INVALID_LINKGRAPH_COMPONENT)
+{}
+
+/**
+ * (Re-)initialize this component with a new ID and a new copy of the settings.
+ */
+void LinkGraphComponent::Init(LinkGraphComponentID id)
+{
+	assert(this->num_nodes == 0);
+	this->index = id;
+	this->settings = _settings_game.linkgraph;
+}
+
+/**
+ * Merge the current job's results into the main game state.
+ */
+void LinkGraph::Join()
+{
+	this->LinkGraphJob::Join();
+
+	this->LinkGraphComponent::Clear();
+}
+
+/**
+ * Run all handlers for the given Job.
+ * @param j Pointer to a link graph job.
+ */
+/* static */ void LinkGraphJob::RunLinkGraphJob(void *j)
+{
+	LinkGraphJob *job = (LinkGraphJob *)j;
+	for (HandlerList::iterator i = _handlers.begin(); i != _handlers.end(); ++i) {
+		(*i)->Run(job);
+	}
+}
+
+/**
+ * Clear the handlers.
+ */
+/* static */ void LinkGraphJob::ClearHandlers()
+{
+	for (HandlerList::iterator i = _handlers.begin(); i != _handlers.end(); ++i) {
+		delete *i;
+	}
+	_handlers.clear();
+}
+
+/**
+ * Join the calling thread with this job's thread if threading is enabled.
+ */
+FORCEINLINE void LinkGraphJob::Join()
+{
+	if (this->thread == NULL) return;
+	this->thread->Join();
+	delete this->thread;
+	this->thread = NULL;
+}
+
+/**
+ * Spawn a thread if possible and run the link graph job in the thread. If
+ * that's not possible run the job right now in the current thread.
+ */
+void LinkGraphJob::SpawnThread()
+{
+	assert(this->thread == NULL);
+	if (!ThreadObject::New(&(LinkGraphJob::RunLinkGraphJob), this, &(this->thread))) {
+		this->thread = NULL;
+		/* Of course this will hang a bit.
+		 * On the other hand, if you want to play games which make this hang noticably
+		 * on a platform without threads then you'll probably get other problems first.
+		 * OK:
+		 * If someone comes and tells me that this hangs for him/her, I'll implement a
+		 * smaller grained "Step" method for all handlers and add some more ticks where
+		 * "Step" is called. No problem in principle.
+		 */
+		LinkGraphJob::RunLinkGraphJob(this);
+	}
+}
+
+/**
+ * (Re-)Initialize the link graph: join all jobs and set current_station_id and
+ * cargo to their start values.
+ * @param cargo New cargo ID for the link graph.
+ */
+void LinkGraph::Init(CargoID cargo)
+{
+	this->LinkGraphJob::Join();
+	this->LinkGraphComponent::Clear();
+
+	this->current_station_id = 0;
+	this->LinkGraphComponent::cargo = cargo;
+}
+
+/**
+ * Initialize all link graphs. Used when loading a game.
+ */
+void InitializeLinkGraphs()
+{
+	for (CargoID c = 0; c < NUM_CARGO; ++c) _link_graphs[c].Init(c);
+
+	LinkGraphJob::ClearHandlers();
+}
diff --git a/src/linkgraph/linkgraph.h b/src/linkgraph/linkgraph.h
new file mode 100644
index 0000000..305255f
--- /dev/null
+++ b/src/linkgraph/linkgraph.h
@@ -0,0 +1,247 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph.h Declaration of link graph classes used for cargo distribution. */
+
+#ifndef LINKGRAPH_H_
+#define LINKGRAPH_H_
+
+#include "../station_base.h"
+#include "../cargo_type.h"
+#include "../thread/thread.h"
+#include "../settings_type.h"
+#include "../date_func.h"
+#include "linkgraph_type.h"
+#include <list>
+#include <vector>
+
+struct SaveLoad;
+
+/**
+ * Node of the link graph. contains all relevant information from the associated
+ * station. It's copied so that the link graph job can work on its own data set
+ * in a separate thread.
+ */
+class Node {
+public:
+	uint supply;       ///< Supply at the station.
+	uint demand;       ///< Acceptance at the station.
+	StationID station; ///< Station ID.
+
+	void Init(StationID st = INVALID_STATION, uint sup = 0, uint dem = 0);
+};
+
+/**
+ * An edge in the link graph. Corresponds to a link between two stations.
+ */
+class Edge {
+public:
+	uint distance; ///< Length of the link.
+	uint capacity; ///< Capacity of the link.
+
+	void Init(uint distance = 0, uint capacity = 0);
+};
+
+/**
+ * A connected component of a link graph. Contains a complete set of stations
+ * connected by links as nodes and edges. Each component also holds a copy of
+ * the link graph settings at the time of its creation. The global settings
+ * might change between the creation and join time so we can't rely on them.
+ */
+class LinkGraphComponent {
+private:
+	typedef std::vector<Node> NodeVector;
+	typedef std::vector<std::vector<Edge> > EdgeMatrix;
+
+public:
+	LinkGraphComponent();
+
+	void Init(LinkGraphComponentID id);
+
+	/**
+	 * Get a reference to an edge.
+	 * @param from Origin node.
+	 * @param to Destination node.
+	 * @return Edge between from and to.
+	 */
+	FORCEINLINE Edge &GetEdge(NodeID from, NodeID to)
+	{
+		return this->edges[from][to];
+	}
+
+	/**
+	 * Get a reference to a node with the specified id.
+	 * @param num ID of the node.
+	 * @return the Requested node.
+	 */
+	FORCEINLINE Node &GetNode(NodeID num)
+	{
+		return this->nodes[num];
+	}
+
+	/**
+	 * Get the current size of the component.
+	 * @return Size.
+	 */
+	FORCEINLINE uint GetSize() const
+	{
+		return this->num_nodes;
+	}
+
+	void SetSize();
+
+	NodeID AddNode(Station *st);
+
+	void AddEdge(NodeID from, NodeID to, uint capacity);
+
+	/**
+	 * Get the ID of this component.
+	 * @return ID.
+	 */
+	FORCEINLINE LinkGraphComponentID GetIndex() const
+	{
+		return this->index;
+	}
+
+	/**
+	 * Get the cargo ID this component's link graph refers to.
+	 * @return Cargo ID.
+	 */
+	FORCEINLINE CargoID GetCargo() const
+	{
+		return this->cargo;
+	}
+
+	/**
+	 * Get the link graph settings for this component.
+	 * @return Settings.
+	 */
+	FORCEINLINE const LinkGraphSettings &GetSettings() const
+	{
+		return this->settings;
+	}
+
+	/**
+	 * Mark this component as empty.
+	 */
+	FORCEINLINE void Clear()
+	{
+		this->num_nodes = 0;
+	}
+
+protected:
+	LinkGraphSettings settings; ///< Copy of _settings_game.linkgraph at creation time.
+	CargoID cargo;              ///< Cargo of this component's link graph.
+	uint num_nodes;             ///< Number of nodes in the component.
+	LinkGraphComponentID index; ///< ID of the component.
+	NodeVector nodes;           ///< Nodes in the component.
+	EdgeMatrix edges;           ///< Edges in the component.
+};
+
+/**
+ * A handler doing "something" on a link graph component. It must not keep any
+ * state as it is called concurrently from different threads.
+ */
+class ComponentHandler {
+public:
+	/**
+	 * Destroy the handler. Must be given due to virtual Run.
+	 */
+	virtual ~ComponentHandler() {}
+
+	/**
+	 * Run the handler. A link graph handler must not read or write any data
+	 * outside the given component as that would create a potential desync.
+	 * @param component Link graph component to run the handler on.
+	 */
+	virtual void Run(LinkGraphComponent *component) = 0;
+};
+
+/**
+ * A job to be executed on a link graph component. It inherits a component and
+ * keeps a static list of handlers to be run on it. It may or may not run in a
+ * thread and contains a thread object for this option.
+ */
+class LinkGraphJob : public LinkGraphComponent {
+private:
+	typedef std::list<ComponentHandler *> HandlerList;
+
+public:
+
+	LinkGraphJob() : thread(NULL) {}
+
+	/**
+	 * Destructor; Clean up the thread if it's there.
+	 */
+	~LinkGraphJob()
+	{
+		this->Join();
+	}
+
+	static void RunLinkGraphJob(void *j);
+
+	/**
+	 * Add a handler to the end of the list.
+	 * @param handler Handler to be added.
+	 */
+	static void AddHandler(ComponentHandler *handler)
+	{
+		LinkGraphJob::_handlers.push_back(handler);
+	}
+
+	static void ClearHandlers();
+
+	void SpawnThread();
+
+	void Join();
+
+private:
+	static HandlerList _handlers;   ///< Handlers the job is executing.
+	ThreadObject *thread;           ///< Thread the job is running in or NULL if it's running in the main thread.
+
+	/**
+	 * Private Copy-Constructor: there cannot be two identical LinkGraphJobs.
+	 * @param other hypothetical other job to be copied.
+	 * @note It's necessary to explicitly initialize the link graph component in order to silence some compile warnings.
+	 */
+	LinkGraphJob(const LinkGraphJob &other) : LinkGraphComponent(other) {NOT_REACHED();}
+};
+
+/**
+ * A link graph, inheriting one job.
+ */
+class LinkGraph : public LinkGraphJob {
+public:
+	/* Those are ticks where not much else is happening, so a small lag might go unnoticed. */
+	static const uint COMPONENTS_JOIN_TICK  = 21; ///< Tick when jobs are joined every day.
+	static const uint COMPONENTS_SPAWN_TICK = 58; ///< Tick when jobs are spawned every day.
+
+	/**
+	 * Create a link graph.
+	 */
+	LinkGraph() : current_station_id(0) {}
+
+	void Init(CargoID cargo);
+
+	void NextComponent();
+
+	void Join();
+
+private:
+	StationID current_station_id; ///< ID of the last station examined while creating components.
+
+	friend const SaveLoad *GetLinkGraphDesc();
+
+	void CreateComponent(Station *first);
+};
+
+void InitializeLinkGraphs();
+extern LinkGraph _link_graphs[NUM_CARGO];
+
+#endif /* LINKGRAPH_H_ */
diff --git a/src/linkgraph/linkgraph_type.h b/src/linkgraph/linkgraph_type.h
new file mode 100644
index 0000000..cd73b1c
--- /dev/null
+++ b/src/linkgraph/linkgraph_type.h
@@ -0,0 +1,36 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_type.h Declaration of link graph types used for cargo distribution. */
+
+#ifndef LINKGRAPH_TYPE_H_
+#define LINKGRAPH_TYPE_H_
+
+typedef uint16 LinkGraphComponentID;
+static const LinkGraphComponentID INVALID_LINKGRAPH_COMPONENT = UINT16_MAX;
+
+typedef uint NodeID;
+static const NodeID INVALID_NODE = UINT_MAX;
+
+enum DistributionType {
+	DT_BEGIN = 0,
+	DT_SYMMETRIC = 0, ///< symmetric distribution. The same amount of cargo travels in each direction between each pair of nodes.
+	DT_ASYMMETRIC,    ///< asymmetric distribution. Usually cargo will only travel in one direction.
+	DT_MANUAL,        ///< manual distribution. No link graph calculations are run.
+	DT_NUM = 3,
+	DT_END = 3
+};
+
+/* It needs to be 8bits, because we save and load it as such
+ * Define basic enum properties
+ */
+template <> struct EnumPropsT<DistributionType> : MakeEnumPropsT<DistributionType, byte, DT_BEGIN, DT_END, DT_NUM> {};
+typedef TinyEnumT<DistributionType> DistributionTypeByte; // typedefing-enumification of DistributionType
+
+#endif /* LINKGRAPH_TYPE_H_ */
diff --git a/src/misc.cpp b/src/misc.cpp
index 09ace07..d6c9b8f 100644
--- a/src/misc.cpp
+++ b/src/misc.cpp
@@ -47,6 +47,7 @@ void InitializeCompanies();
 void InitializeCheats();
 void InitializeNPF();
 void InitializeOldNames();
+void InitializeLinkGraphs();
 
 void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settings)
 {
@@ -101,6 +102,7 @@ void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settin
 #endif /* ENABLE_NETWORK */
 	InitializeAnimatedTiles();
 
+	InitializeLinkGraphs();
 	InitializeEconomy();
 
 	ResetObjectToPlace();
diff --git a/src/openttd.cpp b/src/openttd.cpp
index 816180b..0ae8004 100644
--- a/src/openttd.cpp
+++ b/src/openttd.cpp
@@ -65,6 +65,8 @@
 #include "town.h"
 #include "industry.h"
 
+#include "linkgraph/linkgraph.h"
+
 #include <stdarg.h>
 
 #include "table/strings.h"
@@ -266,6 +268,12 @@ static void ShutdownGame()
 	/* Uninitialize variables that are allocated dynamically */
 	GamelogReset();
 
+	/* Reinitialize the link graphs to forcibly stop the threads.
+	 * If a link graph thread is running while the link graph handlers are
+	 * deleted we get a crash.
+	 */
+	InitializeLinkGraphs();
+
 #ifdef ENABLE_NETWORK
 	free(_config_file);
 #endif
diff --git a/src/saveload/afterload.cpp b/src/saveload/afterload.cpp
index 4acd05b..64a888e 100644
--- a/src/saveload/afterload.cpp
+++ b/src/saveload/afterload.cpp
@@ -2604,6 +2604,8 @@ bool AfterLoadGame()
 	InitializeWindowsAndCaches();
 	/* Restore the signals */
 	ResetSignalHandlers();
+
+	AfterLoadLinkGraphs();
 	return true;
 }
 
diff --git a/src/saveload/linkgraph_sl.cpp b/src/saveload/linkgraph_sl.cpp
new file mode 100644
index 0000000..134010f
--- /dev/null
+++ b/src/saveload/linkgraph_sl.cpp
@@ -0,0 +1,153 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_sl.cpp Code handling saving and loading of link graphs */
+
+#include "../stdafx.h"
+#include "../linkgraph/linkgraph.h"
+#include "../settings_internal.h"
+#include "saveload.h"
+#include <vector>
+
+const SettingDesc *GetSettingDescription(uint index);
+
+/**
+ * Get a SaveLoad array for a link graph. The settings struct is derived from
+ * the global settings saveload array. The exact entries are calculated when the function
+ * is called the first time.
+ * It's necessary to keep a copy of the settings for each link graph so that you can
+ * change the settings while in-game and still not mess with current link graph runs.
+ * Of course the settings have to be saved and loaded, too, to avoid desyncs.
+ * @return Array of SaveLoad structs.
+ */
+const SaveLoad *GetLinkGraphDesc()
+{
+	static std::vector<SaveLoad> saveloads;
+	static const char *prefix = "linkgraph.";
+
+	/* Build the SaveLoad array on first call and don't touch it later on */
+	if (saveloads.empty()) {
+		size_t offset_gamesettings = cpp_offsetof(GameSettings, linkgraph);
+		size_t offset_component = cpp_offsetof(LinkGraph, settings);
+
+		size_t prefixlen = strlen(prefix);
+
+		int setting = 0;
+		const SettingDesc *desc = GetSettingDescription(setting);
+		while (desc->save.cmd != SL_END) {
+			if (desc->desc.name != NULL && strncmp(desc->desc.name, prefix, prefixlen) == 0) {
+				SaveLoad sl = desc->save;
+				char *&address = reinterpret_cast<char *&>(sl.address);
+				address -= offset_gamesettings;
+				address += offset_component;
+				saveloads.push_back(sl);
+			}
+			desc = GetSettingDescription(++setting);
+		}
+
+		const SaveLoad component_desc[] = {
+			SLE_CONDVAR(LinkGraph, num_nodes,          SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, index,              SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, current_station_id, SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, cargo,              SLE_UINT8,  SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_END()
+		};
+
+		int i = 0;
+		do {
+			saveloads.push_back(component_desc[i++]);
+		} while (saveloads.back().cmd != SL_END);
+	}
+
+	return &saveloads[0];
+}
+
+/* Edges and nodes are saved in the correct order, so we don't need to save their ids. */
+
+/**
+ * SaveLoad desc for a link graph node.
+ */
+static const SaveLoad _node_desc[] = {
+	 SLE_CONDVAR(Node, supply,    SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Node, demand,    SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Node, station,   SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_END()
+};
+
+/**
+ * SaveLoad desc for a link graph edge.
+ */
+static const SaveLoad _edge_desc[] = {
+	 SLE_CONDVAR(Edge, distance,  SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Edge, capacity,  SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_END()
+};
+
+/**
+ * Save/load a component of a link graph
+ * @param comp the component to be saved or loaded
+ */
+static void SaveLoad_LinkGraphComponent(LinkGraphComponent &comp)
+{
+	uint size = comp.GetSize();
+	for (NodeID from = 0; from < size; ++from) {
+		Node *node = &comp.GetNode(from);
+		SlObject(node, _node_desc);
+		for (NodeID to = 0; to < size; ++to) {
+			SlObject(&comp.GetEdge(from, to), _edge_desc);
+		}
+	}
+}
+
+/**
+ * Save all link graphs.
+ */
+static void DoSave_LGRP(void *)
+{
+	for (CargoID cargo = 0; cargo < NUM_CARGO; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		SlObject(&graph, GetLinkGraphDesc());
+		SaveLoad_LinkGraphComponent(graph);
+	}
+}
+
+/**
+ * Load all link graphs.
+ */
+static void Load_LGRP()
+{
+	for (CargoID cargo = 0; cargo < NUM_CARGO; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		assert(graph.GetSize() == 0);
+		SlObject(&graph, GetLinkGraphDesc());
+		graph.SetSize();
+		SaveLoad_LinkGraphComponent(graph);
+	}
+}
+
+/**
+ * Spawn the threads for running link graph calculations.
+ * Has to be done after loading as the cargo classes might have changed.
+ */
+void AfterLoadLinkGraphs()
+{
+	for (CargoID cargo = 0; cargo < NUM_CARGO; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		if (graph.GetSize() > 0) graph.SpawnThread();
+	}
+}
+
+static void Save_LGRP()
+{
+	SlAutolength((AutolengthProc*)DoSave_LGRP, NULL);
+}
+
+extern const ChunkHandler _linkgraph_chunk_handlers[] = {
+	{ 'LGRP', Save_LGRP, Load_LGRP, NULL, NULL, CH_LAST},
+};
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
index c2829c2..e922323 100644
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -226,7 +226,7 @@
  *  159   21962
  *  160   21974
  */
-extern const uint16 SAVEGAME_VERSION = SL_CAPACITIES; ///< Current savegame version of OpenTTD.
+extern const uint16 SAVEGAME_VERSION = SL_COMPONENTS; ///< Current savegame version of OpenTTD.
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
@@ -402,6 +402,7 @@ extern const ChunkHandler _group_chunk_handlers[];
 extern const ChunkHandler _cargopacket_chunk_handlers[];
 extern const ChunkHandler _autoreplace_chunk_handlers[];
 extern const ChunkHandler _labelmaps_chunk_handlers[];
+extern const ChunkHandler _linkgraph_chunk_handlers[];
 extern const ChunkHandler _airport_chunk_handlers[];
 extern const ChunkHandler _object_chunk_handlers[];
 
@@ -432,6 +433,7 @@ static const ChunkHandler * const _chunk_handlers[] = {
 	_cargopacket_chunk_handlers,
 	_autoreplace_chunk_handlers,
 	_labelmaps_chunk_handlers,
+	_linkgraph_chunk_handlers,
 	_airport_chunk_handlers,
 	_object_chunk_handlers,
 	NULL,
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
index d2a5ca6..5dc371c 100644
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -553,6 +553,7 @@ extern bool _do_autosave;
 enum SaveLoadVersions {
 	SL_TRUNK = 160,
 	SL_CAPACITIES = SL_TRUNK + 20,
+	SL_COMPONENTS,
 
 	/** Highest possible savegame version. */
 	SL_MAX_VERSION = 255
diff --git a/src/saveload/saveload_internal.h b/src/saveload/saveload_internal.h
index b400861..4bf5646 100644
--- a/src/saveload/saveload_internal.h
+++ b/src/saveload/saveload_internal.h
@@ -30,6 +30,7 @@ void AfterLoadVehicles(bool part_of_load);
 void AfterLoadStations();
 void AfterLoadRoadStops();
 void AfterLoadLabelMaps();
+void AfterLoadLinkGraphs();
 void UpdateHousesAndTowns();
 
 void UpdateOldAircraft();
diff --git a/src/saveload/station_sl.cpp b/src/saveload/station_sl.cpp
index 86ad5d7..ccf056b 100644
--- a/src/saveload/station_sl.cpp
+++ b/src/saveload/station_sl.cpp
@@ -284,6 +284,7 @@ const SaveLoad *GetGoodsDesc()
 		 SLE_CONDVAR(GoodsEntry, supply,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
 		 SLE_CONDVAR(GoodsEntry, supply_new,          SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
 		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, last_component,      SLE_UINT16,      SL_COMPONENTS, SL_MAX_VERSION),
 		SLE_END()
 	};
 
diff --git a/src/settings.cpp b/src/settings.cpp
index 38101e7..a6e432f 100644
--- a/src/settings.cpp
+++ b/src/settings.cpp
@@ -1618,7 +1618,7 @@ void DeleteGRFPresetFromConfig(const char *config_name)
 	delete ini;
 }
 
-static const SettingDesc *GetSettingDescription(uint index)
+const SettingDesc *GetSettingDescription(uint index)
 {
 	if (index >= lengthof(_settings)) return NULL;
 	return &_settings[index];
diff --git a/src/settings_gui.cpp b/src/settings_gui.cpp
index a070e11..64df413 100644
--- a/src/settings_gui.cpp
+++ b/src/settings_gui.cpp
@@ -1478,6 +1478,16 @@ static SettingEntry _settings_economy[] = {
 /** Economy sub-page */
 static SettingsPage _settings_economy_page = {_settings_economy, lengthof(_settings_economy)};
 
+static SettingEntry _settings_linkgraph[] = {
+	SettingEntry("linkgraph.recalc_interval"),
+	SettingEntry("linkgraph.distribution_pax"),
+	SettingEntry("linkgraph.distribution_mail"),
+	SettingEntry("linkgraph.distribution_armoured"),
+	SettingEntry("linkgraph.distribution_default"),
+};
+/** Linkgraph sub-page */
+static SettingsPage _settings_linkgraph_page = {_settings_linkgraph, lengthof(_settings_linkgraph)};
+
 static SettingEntry _settings_ai_npc[] = {
 	SettingEntry("ai.ai_in_multiplayer"),
 	SettingEntry("ai.ai_disable_veh_train"),
@@ -1570,6 +1580,7 @@ static SettingEntry _settings_main[] = {
 	SettingEntry(&_settings_vehicles_page,     STR_CONFIG_SETTING_VEHICLES),
 	SettingEntry(&_settings_stations_page,     STR_CONFIG_SETTING_STATIONS),
 	SettingEntry(&_settings_economy_page,      STR_CONFIG_SETTING_ECONOMY),
+	SettingEntry(&_settings_linkgraph_page,    STR_CONFIG_SETTING_LINKGRAPH),
 	SettingEntry(&_settings_ai_page,           STR_CONFIG_SETTING_AI),
 };
 
diff --git a/src/settings_type.h b/src/settings_type.h
index 3b8b324..b6fa377 100644
--- a/src/settings_type.h
+++ b/src/settings_type.h
@@ -17,6 +17,8 @@
 #include "transport_type.h"
 #include "network/core/config.h"
 #include "company_type.h"
+#include "cargotype.h"
+#include "linkgraph/linkgraph_type.h"
 #include "openttd.h"
 
 /** Available industry map generation densities. */
@@ -405,6 +407,26 @@ struct EconomySettings {
 	bool   allow_town_level_crossings;       ///< towns are allowed to build level crossings
 };
 
+struct LinkGraphSettings {
+	uint16 recalc_interval;                     ///< minimum interval (in days) between subsequent calculations of components in the same link graph
+	DistributionTypeByte distribution_pax;      ///< distribution type for passengers
+	DistributionTypeByte distribution_mail;     ///< distribution type for mail
+	DistributionTypeByte distribution_armoured; ///< distribution type for armoured cargo class
+	DistributionTypeByte distribution_default;  ///< distribution type for all other goods
+
+	FORCEINLINE DistributionType GetDistributionType(CargoID cargo) const {
+		if (IsCargoInClass(cargo, CC_PASSENGERS)) {
+			return this->distribution_pax;
+		} else if (IsCargoInClass(cargo, CC_MAIL)) {
+			return this->distribution_mail;
+		} else if (IsCargoInClass(cargo, CC_ARMOURED)) {
+			return this->distribution_armoured;
+		} else {
+			return this->distribution_default;
+		}
+	}
+};
+
 /** Settings related to stations. */
 struct StationSettings {
 	bool   modified_catchment;               ///< different-size catchment areas
@@ -443,6 +465,7 @@ struct GameSettings {
 	OrderSettings        order;              ///< settings related to orders
 	VehicleSettings      vehicle;            ///< options for vehicles
 	EconomySettings      economy;            ///< settings to change the economy
+	LinkGraphSettings    linkgraph;          ///< settings for link graph calculations
 	StationSettings      station;            ///< settings related to station management
 	LocaleSettings       locale;             ///< settings related to used currency/unit system in the current game
 };
diff --git a/src/station_base.h b/src/station_base.h
index 141de7f..9726310 100644
--- a/src/station_base.h
+++ b/src/station_base.h
@@ -16,6 +16,7 @@
 #include "newgrf_airport.h"
 #include "cargopacket.h"
 #include "industry_type.h"
+#include "linkgraph/linkgraph_type.h"
 #include "newgrf_storage.h"
 #include "moving_average.h"
 #include <map>
@@ -165,7 +166,8 @@ struct GoodsEntry {
 		last_speed(0),
 		last_age(255),
 		supply(0),
-		supply_new(0)
+		supply_new(0),
+		last_component(INVALID_LINKGRAPH_COMPONENT)
 	{}
 
 	byte acceptance_pickup;
@@ -173,11 +175,12 @@ struct GoodsEntry {
 	byte rating;
 	byte last_speed;
 	byte last_age;
-	byte amount_fract;      ///< Fractional part of the amount in the cargo list.
-	StationCargoList cargo; ///< The cargo packets of cargo waiting in this station.
-	uint supply;            ///< Cargo supplied last month.
-	uint supply_new;        ///< Cargo supplied so far this month.
-	LinkStatMap link_stats; ///< Capacities and usage statistics for outgoing links.
+	byte amount_fract;                   ///< Fractional part of the amount in the cargo list.
+	StationCargoList cargo;              ///< The cargo packets of cargo waiting in this station.
+	uint supply;                         ///< Cargo supplied last month.
+	uint supply_new;                     ///< Cargo supplied so far this month.
+	LinkStatMap link_stats;              ///< Capacities and usage statistics for outgoing links.
+	LinkGraphComponentID last_component; ///< Component this station was last part of in this cargo's link graph.
 };
 
 /** All airport-related information. Only valid if tile != INVALID_TILE. */
diff --git a/src/table/settings.ini b/src/table/settings.ini
index 36db523..84fe601 100644
--- a/src/table/settings.ini
+++ b/src/table/settings.ini
@@ -514,6 +514,71 @@ guiflags = SGF_NO_NETWORK
 def      = true
 str      = STR_CONFIG_SETTING_ALLOW_TOWN_LEVEL_CROSSINGS
 
+; link graph
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.recalc_interval
+type     = SLE_UINT16
+from     = SL_COMPONENTS
+def      = 16
+min      = 1
+max      = 4096
+interval = 1
+str      = STR_CONFIG_SETTING_LINKGRAPH_INTERVAL
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_pax
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_PAX
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_mail
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_MAIL
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_armoured
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_default
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_ASYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
 ; Vehicles
 
 [SDT_VAR]
