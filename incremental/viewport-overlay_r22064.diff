diff --git a/src/linkgraph_gui.cpp b/src/linkgraph_gui.cpp
index 363f715..d2814ba 100644
--- a/src/linkgraph_gui.cpp
+++ b/src/linkgraph_gui.cpp
@@ -15,6 +15,7 @@
 #include "company_base.h"
 #include "date_func.h"
 #include "linkgraph_gui.h"
+#include "main_gui.h"
 
 template<class Twindow, uint Twidget_id>
 void LinkGraphOverlay<Twindow, Twidget_id>::GetWidgetDpi(DrawPixelInfo *dpi) const
@@ -217,3 +218,14 @@ template<class Twindow, uint Twidget_id>
 	GfxDrawLine(x - w1, y - w1, x - w1, y + w2, border_colour);
 	GfxDrawLine(x + w2, y - w1, x + w2, y + w2, border_colour);
 }
+
+template class LinkGraphOverlay<MainWindow, MW_VIEWPORT>;
+/**
+ * Colours for the various "load" states of links. Ordered from "empty" to
+ * "overcrowded".
+ */
+template<> const uint8 LinkGraphOverlay<MainWindow, MW_VIEWPORT>::LINK_COLOURS[] = {
+	0x0f, 0xd1, 0xd0, 0x57,
+	0x55, 0x53, 0xbf, 0xbd,
+	0xba, 0xb9, 0xb7, 0xb5
+};
diff --git a/src/main_gui.cpp b/src/main_gui.cpp
index 3f43dcd..2cd972c 100644
--- a/src/main_gui.cpp
+++ b/src/main_gui.cpp
@@ -30,7 +30,8 @@
 #include "toolbar_gui.h"
 #include "statusbar_gui.h"
 #include "tilehighlight_func.h"
-#include "hotkeys.h"
+#include "landscape.h"
+#include "main_gui.h"
 
 #include "saveload/saveload.h"
 
@@ -199,11 +200,6 @@ void ZoomInOrOutToCursorWindow(bool in, Window *w)
 	}
 }
 
-/** Widgets of the main window. */
-enum MainWindowWidgets {
-	MW_VIEWPORT, ///< Main window viewport.
-};
-
 static const struct NWidgetPart _nested_main_window_widgets[] = {
 	NWidget(NWID_VIEWPORT, INVALID_COLOUR, MW_VIEWPORT), SetResize(1, 1),
 };
@@ -239,207 +235,220 @@ enum {
 	GHK_CHAT_SERVER,
 };
 
-struct MainWindow : Window
+MainWindow::MainWindow() : Window(), overlay(this)
 {
-	MainWindow() : Window()
-	{
-		this->InitNested(&_main_window_desc, 0);
-		ResizeWindow(this, _screen.width, _screen.height);
+	this->InitNested(&_main_window_desc, 0);
+	ResizeWindow(this, _screen.width, _screen.height);
 
-		NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(MW_VIEWPORT);
-		nvp->InitializeViewport(this, TileXY(32, 32), ZOOM_LVL_VIEWPORT);
-	}
+	NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(MW_VIEWPORT);
+	nvp->InitializeViewport(this, TileXY(32, 32), ZOOM_LVL_VIEWPORT);
 
-	virtual void OnPaint()
-	{
-		this->DrawWidgets();
-		if (_game_mode == GM_MENU) {
-			static const SpriteID title_sprites[] = {SPR_OTTD_O, SPR_OTTD_P, SPR_OTTD_E, SPR_OTTD_N, SPR_OTTD_T, SPR_OTTD_T, SPR_OTTD_D};
-			static const uint LETTER_SPACING = 10;
-			int name_width = (lengthof(title_sprites) - 1) * LETTER_SPACING;
+	this->overlay.RebuildCache();
+}
 
-			for (uint i = 0; i < lengthof(title_sprites); i++) {
-				name_width += GetSpriteSize(title_sprites[i]).width;
-			}
-			int off_x = (this->width - name_width) / 2;
+Point MainWindow::GetStationMiddle(const Station *st) const
+{
+	int x = (st->rect.right + st->rect.left + 1) * TILE_SIZE / 2;
+	int y = (st->rect.bottom + st->rect.top + 1) * TILE_SIZE / 2;
+	int z = GetSlopeZ(Clamp(x, 0, MapSizeX() * TILE_SIZE - 1), Clamp(y, 0, MapSizeY() * TILE_SIZE - 1));
+
+	Point p = RemapCoords(x, y, z);
+	p.x = UnScaleByZoom(p.x - this->viewport->virtual_left, this->viewport->zoom) + this->viewport->left;
+	p.y = UnScaleByZoom(p.y - this->viewport->virtual_top, this->viewport->zoom) + this->viewport->top;
+	return p;
+}
 
-			for (uint i = 0; i < lengthof(title_sprites); i++) {
-				DrawSprite(title_sprites[i], PAL_NONE, off_x, 50);
-				off_x += GetSpriteSize(title_sprites[i]).width + LETTER_SPACING;
-			}
+void MainWindow::OnPaint()
+{
+	this->DrawWidgets();
+	this->overlay.Draw();
+	if (_game_mode == GM_MENU) {
+		static const SpriteID title_sprites[] = {SPR_OTTD_O, SPR_OTTD_P, SPR_OTTD_E, SPR_OTTD_N, SPR_OTTD_T, SPR_OTTD_T, SPR_OTTD_D};
+		static const uint LETTER_SPACING = 10;
+		int name_width = (lengthof(title_sprites) - 1) * LETTER_SPACING;
+
+		for (uint i = 0; i < lengthof(title_sprites); i++) {
+			name_width += GetSpriteSize(title_sprites[i]).width;
+		}
+		int off_x = (this->width - name_width) / 2;
+
+		for (uint i = 0; i < lengthof(title_sprites); i++) {
+			DrawSprite(title_sprites[i], PAL_NONE, off_x, 50);
+			off_x += GetSpriteSize(title_sprites[i]).width + LETTER_SPACING;
 		}
 	}
+}
+
+EventState MainWindow::OnKeyPress(uint16 key, uint16 keycode)
+{
+	int num = CheckHotkeyMatch(global_hotkeys, keycode, this);
+	if (num == GHK_QUIT) {
+		HandleExitGameRequest();
+		return ES_HANDLED;
+	}
+
+	/* Disable all key shortcuts, except quit shortcuts when
+	 * generating the world, otherwise they create threading
+	 * problem during the generating, resulting in random
+	 * assertions that are hard to trigger and debug */
+	if (IsGeneratingWorld()) return ES_NOT_HANDLED;
+
+	switch (num) {
+		case GHK_ABANDON:
+			/* No point returning from the main menu to itself */
+			if (_game_mode == GM_MENU) return ES_HANDLED;
+			if (_settings_client.gui.autosave_on_exit) {
+				DoExitSave();
+				_switch_mode = SM_MENU;
+			} else {
+				AskExitToGameMenu();
+			}
+			return ES_HANDLED;
 
-	virtual EventState OnKeyPress(uint16 key, uint16 keycode)
-	{
-		int num = CheckHotkeyMatch(global_hotkeys, keycode, this);
-		if (num == GHK_QUIT) {
-			HandleExitGameRequest();
+		case GHK_CONSOLE:
+			IConsoleSwitch();
 			return ES_HANDLED;
-		}
 
-		/* Disable all key shortcuts, except quit shortcuts when
-		 * generating the world, otherwise they create threading
-		 * problem during the generating, resulting in random
-		 * assertions that are hard to trigger and debug */
-		if (IsGeneratingWorld()) return ES_NOT_HANDLED;
-
-		switch (num) {
-			case GHK_ABANDON:
-				/* No point returning from the main menu to itself */
-				if (_game_mode == GM_MENU) return ES_HANDLED;
-				if (_settings_client.gui.autosave_on_exit) {
-					DoExitSave();
-					_switch_mode = SM_MENU;
-				} else {
-					AskExitToGameMenu();
-				}
-				return ES_HANDLED;
-
-			case GHK_CONSOLE:
-				IConsoleSwitch();
-				return ES_HANDLED;
-
-			case GHK_BOUNDING_BOXES:
-				extern bool _draw_bounding_boxes;
-				_draw_bounding_boxes = !_draw_bounding_boxes;
-				MarkWholeScreenDirty();
-				return ES_HANDLED;
-		}
+		case GHK_BOUNDING_BOXES:
+			extern bool _draw_bounding_boxes;
+			_draw_bounding_boxes = !_draw_bounding_boxes;
+			MarkWholeScreenDirty();
+			return ES_HANDLED;
+	}
+
+	if (_game_mode == GM_MENU) return ES_NOT_HANDLED;
 
-		if (_game_mode == GM_MENU) return ES_NOT_HANDLED;
-
-		switch (num) {
-			case GHK_CENTER:
-			case GHK_CENTER_ZOOM: {
-				Point pt = GetTileBelowCursor();
-				if (pt.x != -1) {
-					bool instant = (num == GHK_CENTER_ZOOM && this->viewport->zoom != ZOOM_LVL_MIN);
-					if (num == GHK_CENTER_ZOOM) MaxZoomInOut(ZOOM_IN, this);
-					ScrollMainWindowTo(pt.x, pt.y, -1, instant);
-				}
-				break;
+	switch (num) {
+		case GHK_CENTER:
+		case GHK_CENTER_ZOOM: {
+			Point pt = GetTileBelowCursor();
+			if (pt.x != -1) {
+				bool instant = (num == GHK_CENTER_ZOOM && this->viewport->zoom != ZOOM_LVL_MIN);
+				if (num == GHK_CENTER_ZOOM) MaxZoomInOut(ZOOM_IN, this);
+				ScrollMainWindowTo(pt.x, pt.y, -1, instant);
 			}
+			break;
+		}
 
-			case GHK_RESET_OBJECT_TO_PLACE: ResetObjectToPlace(); break;
-			case GHK_DELETE_WINDOWS: DeleteNonVitalWindows(); break;
-			case GHK_DELETE_NONVITAL_WINDOWS: DeleteAllNonVitalWindows(); break;
-			case GHK_REFRESH_SCREEN: MarkWholeScreenDirty(); break;
-
-			case GHK_CRASH: // Crash the game
-				*(volatile byte *)0 = 0;
-				break;
-
-			case GHK_MONEY: // Gimme money
-				/* You can only cheat for money in single player. */
-				if (!_networking) DoCommandP(0, 10000000, 0, CMD_MONEY_CHEAT);
-				break;
-
-			case GHK_UPDATE_COORDS: // Update the coordinates of all station signs
-				UpdateAllVirtCoords();
-				break;
-
-			case GHK_TOGGLE_TRANSPARENCY:
-			case GHK_TOGGLE_TRANSPARENCY + 1:
-			case GHK_TOGGLE_TRANSPARENCY + 2:
-			case GHK_TOGGLE_TRANSPARENCY + 3:
-			case GHK_TOGGLE_TRANSPARENCY + 4:
-			case GHK_TOGGLE_TRANSPARENCY + 5:
-			case GHK_TOGGLE_TRANSPARENCY + 6:
-			case GHK_TOGGLE_TRANSPARENCY + 7:
-			case GHK_TOGGLE_TRANSPARENCY + 8:
-				/* Transparency toggle hot keys */
-				ToggleTransparency((TransparencyOption)(num - GHK_TOGGLE_TRANSPARENCY));
-				MarkWholeScreenDirty();
-				break;
-
-			case GHK_TOGGLE_INVISIBILITY:
-			case GHK_TOGGLE_INVISIBILITY + 1:
-			case GHK_TOGGLE_INVISIBILITY + 2:
-			case GHK_TOGGLE_INVISIBILITY + 3:
-			case GHK_TOGGLE_INVISIBILITY + 4:
-			case GHK_TOGGLE_INVISIBILITY + 5:
-			case GHK_TOGGLE_INVISIBILITY + 6:
-			case GHK_TOGGLE_INVISIBILITY + 7:
-				/* Invisibility toggle hot keys */
-				ToggleInvisibilityWithTransparency((TransparencyOption)(num - GHK_TOGGLE_INVISIBILITY));
-				MarkWholeScreenDirty();
-				break;
-
-			case GHK_TRANSPARENCY_TOOLBAR:
-				ShowTransparencyToolbar();
-				break;
-
-			case GHK_TRANSPARANCY:
-				ResetRestoreAllTransparency();
-				break;
+		case GHK_RESET_OBJECT_TO_PLACE: ResetObjectToPlace(); break;
+		case GHK_DELETE_WINDOWS: DeleteNonVitalWindows(); break;
+		case GHK_DELETE_NONVITAL_WINDOWS: DeleteAllNonVitalWindows(); break;
+		case GHK_REFRESH_SCREEN: MarkWholeScreenDirty(); break;
+
+		case GHK_CRASH: // Crash the game
+			*(volatile byte *)0 = 0;
+			break;
+
+		case GHK_MONEY: // Gimme money
+			/* You can only cheat for money in single player. */
+			if (!_networking) DoCommandP(0, 10000000, 0, CMD_MONEY_CHEAT);
+			break;
+
+		case GHK_UPDATE_COORDS: // Update the coordinates of all station signs
+			UpdateAllVirtCoords();
+			break;
+
+		case GHK_TOGGLE_TRANSPARENCY:
+		case GHK_TOGGLE_TRANSPARENCY + 1:
+		case GHK_TOGGLE_TRANSPARENCY + 2:
+		case GHK_TOGGLE_TRANSPARENCY + 3:
+		case GHK_TOGGLE_TRANSPARENCY + 4:
+		case GHK_TOGGLE_TRANSPARENCY + 5:
+		case GHK_TOGGLE_TRANSPARENCY + 6:
+		case GHK_TOGGLE_TRANSPARENCY + 7:
+		case GHK_TOGGLE_TRANSPARENCY + 8:
+			/* Transparency toggle hot keys */
+			ToggleTransparency((TransparencyOption)(num - GHK_TOGGLE_TRANSPARENCY));
+			MarkWholeScreenDirty();
+			break;
+
+		case GHK_TOGGLE_INVISIBILITY:
+		case GHK_TOGGLE_INVISIBILITY + 1:
+		case GHK_TOGGLE_INVISIBILITY + 2:
+		case GHK_TOGGLE_INVISIBILITY + 3:
+		case GHK_TOGGLE_INVISIBILITY + 4:
+		case GHK_TOGGLE_INVISIBILITY + 5:
+		case GHK_TOGGLE_INVISIBILITY + 6:
+		case GHK_TOGGLE_INVISIBILITY + 7:
+			/* Invisibility toggle hot keys */
+			ToggleInvisibilityWithTransparency((TransparencyOption)(num - GHK_TOGGLE_INVISIBILITY));
+			MarkWholeScreenDirty();
+			break;
+
+		case GHK_TRANSPARENCY_TOOLBAR:
+			ShowTransparencyToolbar();
+			break;
+
+		case GHK_TRANSPARANCY:
+			ResetRestoreAllTransparency();
+			break;
 
 #ifdef ENABLE_NETWORK
-			case GHK_CHAT: // smart chat; send to team if any, otherwise to all
-				if (_networking) {
-					const NetworkClientInfo *cio = NetworkFindClientInfoFromClientID(_network_own_client_id);
-					if (cio == NULL) break;
-
-					ShowNetworkChatQueryWindow(NetworkClientPreferTeamChat(cio) ? DESTTYPE_TEAM : DESTTYPE_BROADCAST, cio->client_playas);
-				}
-				break;
-
-			case GHK_CHAT_ALL: // send text message to all clients
-				if (_networking) ShowNetworkChatQueryWindow(DESTTYPE_BROADCAST, 0);
-				break;
-
-			case GHK_CHAT_COMPANY: // send text to all team mates
-				if (_networking) {
-					const NetworkClientInfo *cio = NetworkFindClientInfoFromClientID(_network_own_client_id);
-					if (cio == NULL) break;
-
-					ShowNetworkChatQueryWindow(DESTTYPE_TEAM, cio->client_playas);
-				}
-				break;
-
-			case GHK_CHAT_SERVER: // send text to the server
-				if (_networking && !_network_server) {
-					ShowNetworkChatQueryWindow(DESTTYPE_CLIENT, CLIENT_ID_SERVER);
-				}
-				break;
-#endif
+		case GHK_CHAT: // smart chat; send to team if any, otherwise to all
+			if (_networking) {
+				const NetworkClientInfo *cio = NetworkFindClientInfoFromClientID(_network_own_client_id);
+				if (cio == NULL) break;
 
-			default: return ES_NOT_HANDLED;
-		}
-		return ES_HANDLED;
-	}
+				ShowNetworkChatQueryWindow(NetworkClientPreferTeamChat(cio) ? DESTTYPE_TEAM : DESTTYPE_BROADCAST, cio->client_playas);
+			}
+			break;
 
-	virtual void OnScroll(Point delta)
-	{
-		this->viewport->scrollpos_x += ScaleByZoom(delta.x, this->viewport->zoom);
-		this->viewport->scrollpos_y += ScaleByZoom(delta.y, this->viewport->zoom);
-		this->viewport->dest_scrollpos_x = this->viewport->scrollpos_x;
-		this->viewport->dest_scrollpos_y = this->viewport->scrollpos_y;
-	}
+		case GHK_CHAT_ALL: // send text message to all clients
+			if (_networking) ShowNetworkChatQueryWindow(DESTTYPE_BROADCAST, 0);
+			break;
 
-	virtual void OnMouseWheel(int wheel)
-	{
-		if (_settings_client.gui.scrollwheel_scrolling == 0) {
-			ZoomInOrOutToCursorWindow(wheel < 0, this);
-		}
+		case GHK_CHAT_COMPANY: // send text to all team mates
+			if (_networking) {
+				const NetworkClientInfo *cio = NetworkFindClientInfoFromClientID(_network_own_client_id);
+				if (cio == NULL) break;
+
+				ShowNetworkChatQueryWindow(DESTTYPE_TEAM, cio->client_playas);
+			}
+			break;
+
+		case GHK_CHAT_SERVER: // send text to the server
+			if (_networking && !_network_server) {
+				ShowNetworkChatQueryWindow(DESTTYPE_CLIENT, CLIENT_ID_SERVER);
+			}
+			break;
+#endif
+
+		default: return ES_NOT_HANDLED;
 	}
+	return ES_HANDLED;
+}
 
-	virtual void OnResize()
-	{
-		if (this->viewport != NULL) {
-			NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(MW_VIEWPORT);
-			nvp->UpdateViewportCoordinates(this);
-		}
+void MainWindow::OnScroll(Point delta)
+{
+	this->viewport->scrollpos_x += ScaleByZoom(delta.x, this->viewport->zoom);
+	this->viewport->scrollpos_y += ScaleByZoom(delta.y, this->viewport->zoom);
+	this->viewport->dest_scrollpos_x = this->viewport->scrollpos_x;
+	this->viewport->dest_scrollpos_y = this->viewport->scrollpos_y;
+	this->overlay.RebuildCache();
+}
+
+void MainWindow::OnMouseWheel(int wheel)
+{
+	if (_settings_client.gui.scrollwheel_scrolling == 0) {
+		ZoomInOrOutToCursorWindow(wheel < 0, this);
+		this->overlay.RebuildCache();
 	}
+}
 
-	virtual void OnInvalidateData(int data)
-	{
-		/* Forward the message to the appropiate toolbar (ingame or scenario editor) */
-		InvalidateWindowData(WC_MAIN_TOOLBAR, 0, data);
+void MainWindow::OnResize()
+{
+	if (this->viewport != NULL) {
+		NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(MW_VIEWPORT);
+		nvp->UpdateViewportCoordinates(this);
+		this->overlay.RebuildCache();
 	}
+}
 
-	static Hotkey<MainWindow> global_hotkeys[];
-};
+void MainWindow::OnInvalidateData(int data)
+{
+	/* Forward the message to the appropiate toolbar (ingame or scenario editor) */
+	InvalidateWindowData(WC_MAIN_TOOLBAR, 0, data);
+}
 
 const uint16 _ghk_quit_keys[] = {'Q' | WKC_CTRL, 'Q' | WKC_META, 0};
 const uint16 _ghk_abandon_keys[] = {'W' | WKC_CTRL, 'W' | WKC_META, 0};
diff --git a/src/main_gui.h b/src/main_gui.h
new file mode 100644
index 0000000..c3c863c
--- /dev/null
+++ b/src/main_gui.h
@@ -0,0 +1,42 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file main_gui.cpp Declaration of class for handling of the main viewport. */
+
+#ifndef MAIN_GUI_H_
+#define MAIN_GUI_H_
+
+#include "linkgraph_gui.h"
+#include "hotkeys.h"
+#include "core/geometry_type.hpp"
+
+/** Widgets of the main window. */
+enum MainWindowWidgets {
+	MW_VIEWPORT, ///< Main window viewport.
+};
+
+struct MainWindow : Window
+{
+	LinkGraphOverlay<MainWindow, MW_VIEWPORT> overlay;
+
+	MainWindow();
+
+	virtual void OnPaint();
+	virtual EventState OnKeyPress(uint16 key, uint16 keycode);
+	virtual void OnScroll(Point delta);
+	virtual void OnMouseWheel(int wheel);
+	virtual void OnResize();
+	virtual void OnInvalidateData(int data);
+
+	Point GetStationMiddle(const Station *st) const;
+
+	static Hotkey<MainWindow> global_hotkeys[];
+};
+
+#endif /* MAIN_GUI_H_ */
