diff --git a/projects/openttd_vs100.vcxproj b/projects/openttd_vs100.vcxproj
index 34173c1..8591053 100644
--- a/projects/openttd_vs100.vcxproj
+++ b/projects/openttd_vs100.vcxproj
@@ -457,6 +457,8 @@
     <ClInclude Include="..\src\map_func.h" />
     <ClInclude Include="..\src\map_type.h" />
     <ClInclude Include="..\src\mixer.h" />
+    <ClInclude Include="..\src\moving_average.h" />
+    <ClCompile Include="..\src\moving_average.cpp" />
     <ClInclude Include="..\src\network\network.h" />
     <ClInclude Include="..\src\network\network_admin.h" />
     <ClInclude Include="..\src\network\network_base.h" />
diff --git a/projects/openttd_vs100.vcxproj.filters b/projects/openttd_vs100.vcxproj.filters
index af54dea..e42175b 100644
--- a/projects/openttd_vs100.vcxproj.filters
+++ b/projects/openttd_vs100.vcxproj.filters
@@ -591,6 +591,12 @@
     <ClInclude Include="..\src\mixer.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\moving_average.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClCompile Include="..\src\moving_average.cpp">
+      <Filter>Header Files</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\network\network.h">
       <Filter>Header Files</Filter>
     </ClInclude>
diff --git a/projects/openttd_vs80.vcproj b/projects/openttd_vs80.vcproj
index eb9d856..0b9231b 100644
--- a/projects/openttd_vs80.vcproj
+++ b/projects/openttd_vs80.vcproj
@@ -1103,6 +1103,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
diff --git a/projects/openttd_vs90.vcproj b/projects/openttd_vs90.vcproj
index 1afdab1..63d71ae 100644
--- a/projects/openttd_vs90.vcproj
+++ b/projects/openttd_vs90.vcproj
@@ -1100,6 +1100,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
diff --git a/source.list b/source.list
index 528a7b9..9f5926f 100644
--- a/source.list
+++ b/source.list
@@ -190,6 +190,8 @@ livery.h
 map_func.h
 map_type.h
 mixer.h
+moving_average.h
+moving_average.cpp
 network/network.h
 network/network_admin.h
 network/network_base.h
diff --git a/src/aircraft_cmd.cpp b/src/aircraft_cmd.cpp
index 907fedb..0f25f8d 100644
--- a/src/aircraft_cmd.cpp
+++ b/src/aircraft_cmd.cpp
@@ -1164,7 +1164,6 @@ static void AircraftEntersTerminal(Aircraft *v)
 	if (v->current_order.IsType(OT_GOTO_DEPOT)) return;
 
 	Station *st = Station::Get(v->targetairport);
-	v->last_station_visited = v->targetairport;
 
 	/* Check if station was ever visited before */
 	if (!(st->had_vehicle_of_type & HVOT_AIRCRAFT)) {
@@ -1180,7 +1179,7 @@ static void AircraftEntersTerminal(Aircraft *v)
 		AI::NewEvent(v->owner, new AIEventStationFirstVehicle(st->index, v->index));
 	}
 
-	v->BeginLoading();
+	v->BeginLoading(v->targetairport);
 }
 
 static void AircraftLandAirplane(Aircraft *v)
diff --git a/src/core/math_func.cpp b/src/core/math_func.cpp
index 7f0630a..2226fa7 100644
--- a/src/core/math_func.cpp
+++ b/src/core/math_func.cpp
@@ -46,3 +46,23 @@ int GreatestCommonDivisor(int a, int b)
 	return a;
 
 }
+
+/**
+ * Deterministic approximate division.
+ * Cancels out division errors stemming from the integer nature of the division over multiple runs.
+ * @param a the dividend
+ * @param b the divisor
+ * @return a/b or (a/b)+1
+ */
+int DivideApprox(int a, int b) {
+	int random_like = ((a + b) * (a - b)) % b;
+
+	int remainder = a % b;
+
+	int ret = a / b;
+	if (abs(random_like) < abs(remainder)) {
+		ret += ((a < 0) ^ (b < 0)) ? -1 : 1;
+	}
+
+	return ret;
+}
diff --git a/src/core/math_func.hpp b/src/core/math_func.hpp
index 19f2f53..a824af3 100644
--- a/src/core/math_func.hpp
+++ b/src/core/math_func.hpp
@@ -317,6 +317,7 @@ static FORCEINLINE uint ToPercent16(uint i)
 
 int LeastCommonMultiple(int a, int b);
 int GreatestCommonDivisor(int a, int b);
+int DivideApprox(int a, int b);
 
 /**
  * Computes ceil(a / b) for non-negative a and b.
diff --git a/src/moving_average.cpp b/src/moving_average.cpp
new file mode 100644
index 0000000..c2b3341
--- /dev/null
+++ b/src/moving_average.cpp
@@ -0,0 +1,46 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.cpp Implementation of moving average functions */
+
+#include "moving_average.h"
+#include "date_func.h"
+#include "station_base.h"
+
+/**
+ * Run moving average decrease function on all items from a pool which are due
+ * this tick. This function expects to be run every tick. It calls a method
+ * "RunAverages()" on all items for which id % DAY_TICKS == _tick_counter % DAY_TICKS.
+ * So each item is called once a day.
+ */
+template <class Titem> void RunAverages()
+{
+	for(uint id = _tick_counter % DAY_TICKS; id < Titem::GetPoolSize(); id += DAY_TICKS) {
+		Titem *item = Titem::GetIfValid(id);
+		if (item != NULL) {
+			item->RunAverages();
+		}
+	}
+}
+
+/**
+ * Decrease the given value using this moving average
+ * @param value the moving average value to be decreased
+ * @return the decreased value
+ */
+template <class Tvalue>
+FORCEINLINE Tvalue &MovingAverage<Tvalue>::Decrease(Tvalue &value) const
+{
+	value *= this->length;
+	value /= (this->length + 1);
+	return value;
+}
+
+template class MovingAverage<uint>;
+template void RunAverages<Station>();
diff --git a/src/moving_average.h b/src/moving_average.h
new file mode 100644
index 0000000..a64ecf1
--- /dev/null
+++ b/src/moving_average.h
@@ -0,0 +1,66 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.h Utility class for moving averages. */
+
+#ifndef MOVING_AVERAGE_H_
+#define MOVING_AVERAGE_H_
+
+#include "stdafx.h"
+#include "settings_type.h"
+#include "core/math_func.hpp"
+
+/**
+ * Class implementing moving average functionality. An instance of this class
+ * can be used to get a meaningful (Monthly()) value from a moving average and
+ * it can be used to do the decrease operation.
+ * @tparam Tvalue a type supporting operator*(uint), operator/(uint),
+ * operator*=(uint) and operator/=(uint) with the usual semantics.
+ */
+template<class Tvalue>
+class MovingAverage {
+protected:
+	uint length;
+
+public:
+	/**
+	 * Create a moving average
+	 * @param length the length to be used
+	 */
+	FORCEINLINE MovingAverage(uint length) : length(length)
+	{
+		assert(this->length > 0);
+	}
+
+	/**
+	 * Get the length of this moving average
+	 * @return the length
+	 */
+	FORCEINLINE uint Length() const
+	{
+		return this->length;
+	}
+
+	/**
+	 * Get the current average for one month from the given value
+	 * @param value the raw moving average
+	 * @return the monthly average
+	 */
+	FORCEINLINE Tvalue Monthly(const Tvalue &value) const
+	{
+		return value * 30 / (this->length);
+	}
+
+	Tvalue &Decrease(Tvalue &value) const;
+};
+
+template<class Titem> void RunAverages();
+
+#endif /* MOVING_AVERAGE_H_ */
+
diff --git a/src/order_base.h b/src/order_base.h
index fccc802..ed0dc89 100644
--- a/src/order_base.h
+++ b/src/order_base.h
@@ -262,6 +262,8 @@ struct OrderList : OrderListPool::PoolItem<&_orderlist_pool> {
 private:
 	friend void AfterLoadVehicles(bool part_of_load); ///< For instantiating the shared vehicle chain
 	friend const struct SaveLoad *GetOrderListDescription(); ///< Saving and loading of order lists.
+	const Order *GetNext(const Order *curr) const;
+	StationID GetNextStoppingStation(const Order *next, uint hops, bool check_nonstop) const;
 
 	Order *first;                   ///< First order of the order list
 	VehicleOrderID num_orders;      ///< NOSAVE: How many orders there are in the list
@@ -312,6 +314,8 @@ public:
 	 */
 	inline Order *GetLastOrder() const { return this->GetOrderAt(this->num_orders - 1); }
 
+	StationID GetNextStoppingStation(VehicleOrderID curr_order, StationID curr_station, bool check_nonstop) const;
+
 	/**
 	 * Get number of orders in the order list.
 	 * @return number of orders in the chain.
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
index b792c9b..02c742a 100644
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -255,6 +255,86 @@ Order *OrderList::GetOrderAt(int index) const
 	return order;
 }
 
+/**
+ * Get the order after the given one or the first one, if the given one is the
+ * last one.
+ * @param curr the order to find the next one for
+ * @return the next order
+ */
+const Order *OrderList::GetNext(const Order *curr) const
+{
+	const Order *next = curr->next;
+	if (next == NULL) {
+		next = this->GetFirstOrder();
+	}
+	return next;
+}
+
+/**
+ * Recursively determine the next deterministic station to stop at.
+ * @param next the first order to check
+ * @param hops the number of orders we have already checked.
+ * @param check_nonstop if true regard orders without non-stop flag as nondeterministic
+ * @return the next stoppping station or INVALID_STATION
+ */
+StationID OrderList::GetNextStoppingStation(const Order *next, uint hops, bool check_nonstop) const
+{
+	if (next == NULL || hops > this->GetNumOrders()) {
+		return INVALID_STATION;
+	}
+
+	if (next->GetType() == OT_CONDITIONAL) {
+		StationID skip_to = this->GetNextStoppingStation(this->GetOrderAt(next->GetConditionSkipToOrder()), hops + 1, check_nonstop);
+		StationID advance = this->GetNextStoppingStation(this->GetNext(next), hops + 1, check_nonstop);
+		if (skip_to == advance) {
+			return skip_to; // skipping over non-stopping orders
+		} else {
+			return INVALID_STATION; // nondeterministic
+		}
+	}
+
+	if (check_nonstop) {
+		switch(next->GetNonStopType()) {
+		case ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS:
+			if (next->GetType() == OT_GOTO_STATION) return next->GetDestination(); // else fall through
+		case ONSF_NO_STOP_AT_ANY_STATION:
+			return GetNextStoppingStation(this->GetNext(next), hops + 1, check_nonstop);
+		default: // nondeterministic
+			return INVALID_STATION;
+		}
+	} else if (next->GetType() == OT_GOTO_STATION) {
+		return next->GetDestination();
+	} else {
+		return this->GetNextStoppingStation(this->GetNext(next), hops + 1, check_nonstop);
+	}
+}
+
+/**
+ * Get the next station the vehicle will stop at, if that is deterministic.
+ * @param curr_order the ID of the current order
+ * @param curr_station the station the vehicle is just visiting or INVALID_STATION
+ * @param check_nonstop if true regard orders without non-stop flag as nondeterministic
+ * @return The ID of the next station the vehicle will stop at or INVALID_STATION
+ */
+StationID OrderList::GetNextStoppingStation(VehicleOrderID curr_order, StationID curr_station, bool check_nonstop) const {
+	const Order *curr = this->GetOrderAt(curr_order);
+	if (curr == NULL) {
+		curr = this->GetFirstOrder();
+		if (curr == NULL) return INVALID_STATION;
+	}
+
+	/* If we're not at a station or the current order doesn't yield the station
+	 * we're at, we have to check the current order; otherwise we have to check
+	 * the next one.
+	 */
+	if (curr_station == INVALID_STATION || curr->GetType() != OT_GOTO_STATION ||
+			curr_station != curr->GetDestination()) {
+		return this->GetNextStoppingStation(curr, 0, check_nonstop);
+	} else {
+		return this->GetNextStoppingStation(this->GetNext(curr), 1, check_nonstop);
+	}
+}
+
 void OrderList::InsertOrderAt(Order *new_order, int index)
 {
 	if (this->first == NULL) {
@@ -691,6 +771,8 @@ CommandCost CmdInsertOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 			}
 			/* Update any possible open window of the vehicle */
 			InvalidateVehicleOrder(u, INVALID_VEH_ORDER_ID | (sel_ord << 8));
+
+			RecalcFrozenIfLoading(u);
 		}
 
 		/* As we insert an order, the order to skip to will be 'wrong'. */
@@ -726,6 +808,9 @@ static CommandCost DecloneOrder(Vehicle *dst, DoCommandFlag flags)
 	if (flags & DC_EXEC) {
 		DeleteVehicleOrders(dst);
 		InvalidateVehicleOrder(dst, -1);
+
+		RecalcFrozenIfLoading(dst);
+
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(dst->type), 0);
 	}
 	return CommandCost();
@@ -780,6 +865,8 @@ CommandCost CmdDeleteOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 
 			/* Update any possible open window of the vehicle */
 			InvalidateVehicleOrder(u, sel_ord | (INVALID_VEH_ORDER_ID << 8));
+
+			RecalcFrozenIfLoading(u);
 		}
 
 		/* As we delete an order, the order to skip to will be 'wrong'. */
@@ -825,10 +912,10 @@ CommandCost CmdSkipToOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 	if (ret.Failed()) return ret;
 
 	if (flags & DC_EXEC) {
-		v->cur_order_index = sel_ord;
-
 		if (v->current_order.IsType(OT_LOADING)) v->LeaveStation();
 
+		v->cur_order_index = sel_ord;
+
 		InvalidateVehicleOrder(v, -2);
 	}
 
@@ -893,6 +980,8 @@ CommandCost CmdMoveOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 			assert(v->orders.list == u->orders.list);
 			/* Update any possible open window of the vehicle */
 			InvalidateVehicleOrder(u, moving_order | (target_order << 8));
+
+			RecalcFrozenIfLoading(u);
 		}
 
 		/* As we move an order, the order to skip to will be 'wrong'. */
@@ -1149,6 +1238,8 @@ CommandCost CmdModifyOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 				u->current_order.SetLoadType(order->GetLoadType());
 			}
 			InvalidateVehicleOrder(u, -2);
+
+			RecalcFrozenIfLoading(u);
 		}
 	}
 
@@ -1281,6 +1372,8 @@ CommandCost CmdCloneOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 		default: return CMD_ERROR;
 	}
 
+	RecalcFrozenIfLoading(dst);
+
 	return CommandCost();
 }
 
@@ -1442,6 +1535,8 @@ void RemoveOrderFromAllVehicles(OrderType type, DestinationID destination)
 					/* In GUI, simulate by removing the order and adding it back */
 					InvalidateVehicleOrder(w, id | (INVALID_VEH_ORDER_ID << 8));
 					InvalidateVehicleOrder(w, (INVALID_VEH_ORDER_ID << 8) | id);
+
+					RecalcFrozenIfLoading(w);
 				}
 			}
 		}
@@ -1484,6 +1579,8 @@ void DeleteVehicleOrders(Vehicle *v, bool keep_orderlist)
 		v->orders.list->FreeChain(keep_orderlist);
 		if (!keep_orderlist) v->orders.list = NULL;
 	}
+
+	RecalcFrozenIfLoading(v);
 }
 
 uint16 GetServiceIntervalClamped(uint interval, CompanyID company_id)
@@ -1682,16 +1779,13 @@ bool ProcessOrders(Vehicle *v)
 	 * it won't hit the point in code where may_reverse is checked)
 	 */
 	bool may_reverse = v->current_order.IsType(OT_NOTHING);
+	StationID update_last_visited = INVALID_STATION;
 
 	/* Check if we've reached a 'via' destination. */
 	if (((v->current_order.IsType(OT_GOTO_STATION) && (v->current_order.GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION)) || v->current_order.IsType(OT_GOTO_WAYPOINT)) &&
 			IsTileType(v->tile, MP_STATION) &&
 			v->current_order.GetDestination() == GetStationIndex(v->tile)) {
-		/* We set the last visited station here because we do not want
-		 * the train to stop at this 'via' station if the next order
-		 * is a no-non-stop order; in that case not setting the last
-		 * visited station will cause the vehicle to still stop. */
-		v->last_station_visited = v->current_order.GetDestination();
+		update_last_visited = v->current_order.GetDestination();
 		UpdateVehicleTimetable(v, true);
 		v->IncrementOrderIndex();
 	}
@@ -1731,6 +1825,26 @@ bool ProcessOrders(Vehicle *v)
 
 		case VEH_ROAD:
 		case VEH_TRAIN:
+			/* We set the last visited station here because we do not want
+			 * the train to stop at this 'via' station if the next order
+			 * is a no-non-stop order; in that case not setting the last
+			 * visited station will cause the vehicle to still stop.
+			 *
+			 * However, this interferes with cargodist. The last station
+			 * visited should be the last station the vehicle has actually
+			 * stopped at. If the order isn't non-stop this doesn't matter
+			 * as cargodist will go crazy anyway. So we can set it in that
+			 * case.
+			 *
+			 * Station::IsValidID(update_last_visited) also makes sure we don't
+			 * do this for waypoints.
+			 */
+			if (Station::IsValidID(update_last_visited) && !(v->current_order.GetNonStopType() & ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS)) {
+				if (Station::IsValidID(v->last_station_visited)) {
+					IncreaseStats(Station::Get(v->last_station_visited), v, update_last_visited, false);
+				}
+				v->last_station_visited = update_last_visited;
+			}
 			break;
 
 		case VEH_AIRCRAFT:
diff --git a/src/roadveh_cmd.cpp b/src/roadveh_cmd.cpp
index 2689af8..d1e7e59 100644
--- a/src/roadveh_cmd.cpp
+++ b/src/roadveh_cmd.cpp
@@ -1343,9 +1343,8 @@ again:
 					v->owner == GetTileOwner(v->tile) && !v->current_order.IsType(OT_LEAVESTATION) &&
 					GetRoadStopType(v->tile) == (v->IsBus() ? ROADSTOP_BUS : ROADSTOP_TRUCK)) {
 				Station *st = Station::GetByTile(v->tile);
-				v->last_station_visited = st->index;
 				RoadVehArrivesAt(v, st);
-				v->BeginLoading();
+				v->BeginLoading(st->index);
 			}
 			return false;
 		}
@@ -1402,12 +1401,12 @@ again:
 
 			rs->SetEntranceBusy(false);
 
-			v->last_station_visited = st->index;
-
 			if (IsDriveThroughStopTile(v->tile) || (v->current_order.IsType(OT_GOTO_STATION) && v->current_order.GetDestination() == st->index)) {
 				RoadVehArrivesAt(v, st);
-				v->BeginLoading();
+				v->BeginLoading(st->index);
 				return false;
+			} else {
+				v->last_station_visited = st->index;
 			}
 		} else {
 			/* Vehicle is ready to leave a bay in a road stop */
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
index 6f0bc05..25f5f67 100644
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -215,7 +215,7 @@
  *  150   20857
  *  151   20918
  */
-extern const uint16 SAVEGAME_VERSION = 151; ///< current savegame version of OpenTTD
+extern const uint16 SAVEGAME_VERSION = SL_CAPACITIES; ///< current savegame version of OpenTTD
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
index cf7ff82..547d0a2 100644
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -83,8 +83,6 @@ enum SLRefType {
 	REF_ORDERLIST     = 8,
 };
 
-#define SL_MAX_VERSION 255
-
 enum ChunkType {
 	CH_RIFF         =  0,
 	CH_ARRAY        =  1,
@@ -353,4 +351,14 @@ bool SaveloadCrashWithMissingNewGRFs();
 extern char _savegame_format[8];
 extern bool _do_autosave;
 
+/**
+ * save/load versions used for the various branches
+ * SL_TRUNK is always the current trunk version.
+ */
+enum SaveLoadVersions {
+	SL_TRUNK = 151,
+	SL_CAPACITIES = SL_TRUNK + 20,
+	SL_MAX_VERSION = 255
+};
+
 #endif /* SAVELOAD_H */
diff --git a/src/saveload/station_sl.cpp b/src/saveload/station_sl.cpp
index 1be9b41..b79ca9a 100644
--- a/src/saveload/station_sl.cpp
+++ b/src/saveload/station_sl.cpp
@@ -205,6 +205,7 @@ static const SaveLoad _old_station_desc[] = {
 };
 
 static uint16 _waiting_acceptance;
+static uint16 _num_links;
 static uint16 _cargo_source;
 static uint32 _cargo_source_xy;
 static uint16 _cargo_days;
@@ -217,6 +218,26 @@ static const SaveLoad _station_speclist_desc[] = {
 	SLE_END()
 };
 
+static StationID _station_id;
+
+/**
+ * Wrapper function to get the LinkStat's internal structure while
+ * some of the variables are private.
+ * @return the saveload description for LinkStat.
+ */
+const SaveLoad *GetLinkStatDesc() {
+	static const SaveLoad linkstat_desc[] = {
+		SLEG_CONDVAR(             _station_id,         SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    length,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    capacity,            SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    frozen,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    usage,               SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_END()
+	};
+	
+	return linkstat_desc;
+}
+
 /**
  * Wrapper function to get the GoodsEntry's internal structure while
  * some of the variables itself are private.
@@ -240,7 +261,9 @@ const SaveLoad *GetGoodsDesc()
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_INT64,                  65, 67),
 		 SLE_CONDVAR(GoodsEntry, amount_fract,        SLE_UINT8,                 150, SL_MAX_VERSION),
 		 SLE_CONDLST(GoodsEntry, cargo.packets,       REF_CARGO_PACKET,           68, SL_MAX_VERSION),
-
+		 SLE_CONDVAR(GoodsEntry, supply,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, supply_new,          SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
 		SLE_END()
 	};
 
@@ -382,8 +405,14 @@ static void RealSave_STNN(BaseStation *bst)
 
 	if (!waypoint) {
 		Station *st = Station::From(bst);
-		for (CargoID i = 0; i < NUM_CARGO; i++) {
-			SlObject(&st->goods[i], GetGoodsDesc());
+		for (CargoID c = 0; c < NUM_CARGO; c++) {
+			_num_links = (uint16)st->goods[c].link_stats.size();
+			SlObject(&st->goods[c], GetGoodsDesc());
+			for (LinkStatMap::const_iterator it(st->goods[c].link_stats.begin()); it != st->goods[c].link_stats.end(); ++it) {
+				_station_id = it->first;
+				LinkStat ls(it->second); // make a copy to avoid constness problems
+				SlObject(&ls, GetLinkStatDesc());
+			}
 		}
 	}
 
@@ -414,8 +443,14 @@ static void Load_STNN()
 
 		if (!waypoint) {
 			Station *st = Station::From(bst);
-			for (CargoID i = 0; i < NUM_CARGO; i++) {
-				SlObject(&st->goods[i], GetGoodsDesc());
+			for (CargoID c = 0; c < NUM_CARGO; c++) {
+				SlObject(&st->goods[c], GetGoodsDesc());
+				LinkStat ls;
+				for (uint16 i = 0; i < _num_links; ++i) {
+					SlObject(&ls, GetLinkStatDesc());
+					assert(!ls.IsNull());
+					st->goods[c].link_stats[_station_id] = ls;
+				}
 			}
 		}
 
diff --git a/src/ship_cmd.cpp b/src/ship_cmd.cpp
index 0196935..dbf6c5c 100644
--- a/src/ship_cmd.cpp
+++ b/src/ship_cmd.cpp
@@ -473,14 +473,14 @@ static void ShipController(Ship *v)
 									return;
 								}
 							} else if (v->current_order.IsType(OT_GOTO_STATION)) {
-								v->last_station_visited = v->current_order.GetDestination();
 
 								/* Process station in the orderlist. */
 								Station *st = Station::Get(v->current_order.GetDestination());
 								if (st->facilities & FACIL_DOCK) { // ugly, ugly workaround for problem with ships able to drop off cargo at wrong stations
 									ShipArrivesAt(v, st);
-									v->BeginLoading();
+									v->BeginLoading(v->current_order.GetDestination());
 								} else { // leave stations without docks right aways
+									v->last_station_visited = v->current_order.GetDestination();
 									v->current_order.MakeLeaveStation();
 									v->IncrementOrderIndex();
 								}
diff --git a/src/station.cpp b/src/station.cpp
index 956dde1..f58e7bd 100644
--- a/src/station.cpp
+++ b/src/station.cpp
@@ -63,7 +63,8 @@ Station::Station(TileIndex tile) :
 }
 
 /**
- * Clean up a station by clearing vehicle orders and invalidating windows.
+ * Clean up a station by clearing vehicle orders, invalidating windows and
+ * removing link stats.
  * Aircraft-Hangar orders need special treatment here, as the hangars are
  * actually part of a station (tiletype is STATION), but the order type
  * is OT_GOTO_DEPOT.
@@ -82,6 +83,14 @@ Station::~Station()
 		if (a->targetairport == this->index) a->targetairport = INVALID_STATION;
 	}
 
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID c = 0; c < NUM_CARGO; ++c) {
+			GoodsEntry &ge = st->goods[c];
+			ge.link_stats.erase(this->index);
+		}
+	}
+
 	Vehicle *v;
 	FOR_ALL_VEHICLES(v) {
 		/* Forget about this station if this station is removed */
diff --git a/src/station_base.h b/src/station_base.h
index d595379..ead85cc 100644
--- a/src/station_base.h
+++ b/src/station_base.h
@@ -17,12 +17,151 @@
 #include "cargopacket.h"
 #include "industry_type.h"
 #include "newgrf_storage.h"
+#include "moving_average.h"
+#include <map>
 
 typedef Pool<BaseStation, StationID, 32, 64000> StationPool;
 extern StationPool _station_pool;
 
 static const byte INITIAL_STATION_RATING = 175;
 
+/**
+ * Link statistics. They include figures for capacity and usage of a link. Both
+ * are moving averages which are increased for every vehicle arriving at the
+ * destination station and decreased in regular intervals. Additionally while a
+ * vehicle is loading at the source station part of the capacity is frozen and
+ * prevented from being decreased. This is done so that the link won't break
+ * down all the time when the typical "full load" order is used.
+ */
+class LinkStat : private MovingAverage<uint> {
+private:
+	/**
+	 * capacity of the link.
+	 * This is a moving average. Use MovingAverage::Monthly() to get a meaningful value
+	 */
+	uint capacity;
+	
+	/**
+	 * capacity of currently loading vehicles
+	 */
+	uint frozen;
+	
+	/**
+	 * usage of the link.
+	 * This is a moving average. Use MovingAverage::Monthly() to get a meaningful value
+	 */
+	uint usage;
+
+public:
+	/**
+	 * minimum length of moving averages for capacity and usage
+	 */
+	static const uint MIN_AVERAGE_LENGTH = 96;
+
+	friend const SaveLoad *GetLinkStatDesc();
+
+	FORCEINLINE LinkStat(uint distance = 1, uint capacity = 0, uint frozen = 0, uint usage = 0) :
+		MovingAverage<uint>(distance), capacity(capacity), frozen(frozen), usage(usage) {}
+
+	/**
+	 * reset everything to 0
+	 */
+	FORCEINLINE void Clear()
+	{
+		this->capacity = 0;
+		this->usage = 0;
+		this->frozen = 0;
+	}
+
+	/**
+	 * apply the moving averages to usage and capacity
+	 */
+	FORCEINLINE void Decrease()
+	{
+		this->MovingAverage<uint>::Decrease(this->usage);
+		this->capacity = max(this->MovingAverage<uint>::Decrease(this->capacity), this->frozen);
+	}
+
+	/**
+	 * get an estimate of the current the capacity
+	 * @return the capacity
+	 */
+	FORCEINLINE uint Capacity() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->capacity);
+	}
+
+	/**
+	 * get an estimage of the current usage
+	 * @return the usage
+	 */
+	FORCEINLINE uint Usage() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->usage);
+	}
+
+	/**
+	 * get the amount of frozen capacity
+	 */
+	FORCEINLINE uint Frozen() const
+	{
+		return this->frozen;
+	}
+
+	/**
+	 * add some capacity and usage
+	 * @param capacity the additional capacity
+	 * @param usage the additional usage
+	 */
+	FORCEINLINE void Increase(uint capacity, uint usage)
+	{
+		this->capacity += capacity;
+		this->usage += usage;
+	}
+
+	/**
+	 * freeze some of the capacity and prevent it from being decreased by the
+	 * moving average
+	 * @param capacity the amount of capacity to be frozen
+	 */
+	FORCEINLINE void Freeze(uint capacity)
+	{
+		this->frozen += capacity;
+		this->capacity = max(this->frozen, this->capacity);
+	}
+
+	/**
+	 * thaw some of the frozen capacity and make it available for Decrease()
+	 * @oaram capacity the capacity to be thawed
+	 */
+	FORCEINLINE void Unfreeze(uint capacity)
+	{
+		this->frozen -= capacity;
+	}
+
+	/**
+	 * thaw all frozen capacity
+	 */
+	FORCEINLINE void Unfreeze()
+	{
+		this->frozen = 0;
+	}
+
+	/**
+	 * check if the capacity is 0. This is necessary as Capacity() might return
+	 * 0 even if there is a miniscule amount of capacity left
+	 * @return if capacity is 0
+	 */
+	FORCEINLINE bool IsNull() const
+	{
+		return this->capacity == 0;
+	}
+};
+
+typedef std::map<StationID, LinkStat> LinkStatMap;
+
+uint GetMovingAverageLength(const Station *from, const Station *to);
+
 struct GoodsEntry {
 	enum AcceptancePickup {
 		ACCEPTANCE,
@@ -34,7 +173,9 @@ struct GoodsEntry {
 		days_since_pickup(255),
 		rating(INITIAL_STATION_RATING),
 		last_speed(0),
-		last_age(255)
+		last_age(255),
+		supply(0),
+		supply_new(0)
 	{}
 
 	byte acceptance_pickup;
@@ -44,6 +185,9 @@ struct GoodsEntry {
 	byte last_age;
 	byte amount_fract;      ///< Fractional part of the amount in the cargo list
 	StationCargoList cargo; ///< The cargo packets of cargo waiting in this station
+	uint supply;            ///< Cargo supplied last month
+	uint supply_new;        ///< Cargo supplied so far this month
+	LinkStatMap link_stats; ///< capacities and usage statistics for outgoing links
 };
 
 /** All airport-related information. Only valid if tile != INVALID_TILE. */
@@ -229,6 +373,8 @@ public:
 	/* virtual */ uint32 GetNewGRFVariable(const ResolverObject *object, byte variable, byte parameter, bool *available) const;
 
 	/* virtual */ void GetTileArea(TileArea *ta, StationType type) const;
+
+	void RunAverages();
 };
 
 #define FOR_ALL_STATIONS(var) FOR_ALL_BASE_STATIONS_OF_TYPE(Station, var)
diff --git a/src/station_cmd.cpp b/src/station_cmd.cpp
index 85104cc..73b1a19 100644
--- a/src/station_cmd.cpp
+++ b/src/station_cmd.cpp
@@ -45,6 +45,7 @@
 #include "debug.h"
 #include "core/random_func.hpp"
 #include "company_base.h"
+#include "moving_average.h"
 #include "table/airporttile_ids.h"
 #include "newgrf_airporttiles.h"
 #include "order_backup.h"
@@ -3134,6 +3135,146 @@ static void UpdateStationRating(Station *st)
 	}
 }
 
+/**
+ * get the length of a moving average for a link between two stations
+ * @param from the source station
+ * @param to the destination station
+ * @return the moving average length
+ */
+uint GetMovingAverageLength(const Station *from, const Station *to)
+{
+	return LinkStat::MIN_AVERAGE_LENGTH + (DistanceManhattan(from->xy, to->xy) >> 2);
+}
+
+/**
+ * Run the moving average decrease function for all link stats.
+ */
+void Station::RunAverages() {
+	for(int goods_index = 0; goods_index < NUM_CARGO; ++goods_index) {
+		LinkStatMap &links = this->goods[goods_index].link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end();) {
+			StationID id = i->first;
+			Station *other = Station::GetIfValid(id);
+			if (other == NULL) {
+				links.erase(i++);
+			} else {
+				LinkStat &ls = i->second;
+				ls.Decrease();
+				if (ls.IsNull()) {
+					links.erase(i++);
+				} else {
+					++i;
+				}
+			}
+		}
+	}
+}
+
+/**
+ * Recalculate the frozen value of the station the given vehicle is loading at
+ * if the vehicle is loading.
+ * @param v the vehicle to be examined
+ */
+void RecalcFrozenIfLoading(const Vehicle *v) {
+	if (v->current_order.IsType(OT_LOADING)) {
+		RecalcFrozen(Station::Get(v->last_station_visited));
+	}
+}
+
+/**
+ * Recalculate all frozen values for all link stats of a station. This is done
+ * by adding up the capacities of all loading vehicles.
+ * @param st the station
+ */
+void RecalcFrozen(Station *st) {
+	for(int goods_index = 0; goods_index < NUM_CARGO; ++goods_index) {
+		GoodsEntry &good = st->goods[goods_index];
+		LinkStatMap &links = good.link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end(); ++i) {
+			i->second.Unfreeze();
+		}
+	}
+
+	std::list<Vehicle *>::iterator v_it = st->loading_vehicles.begin();
+	while(v_it != st->loading_vehicles.end()) {
+		const Vehicle *front = *v_it;
+		OrderList *orders = front->orders.list;
+		if (orders != NULL) {
+			StationID next_station_id = orders->GetNextStoppingStation(front->cur_order_index,
+					st->index, front->type == VEH_ROAD || front->type == VEH_TRAIN);
+			if (next_station_id != INVALID_STATION && next_station_id != st->index) {
+				IncreaseStats(st, front, next_station_id, true);
+			}
+		}
+		++v_it;
+	}
+}
+
+/**
+ * Decrease the frozen values of all link stats associated with vehicles in the
+ * given consist (ie the consist is leaving the station).
+ * @param st the station to decrease the frozen values on
+ * @param front the first vehicle in the consist
+ * @param next_station_id the station the vehicle is leaving for
+ */
+void DecreaseFrozen(Station *st, const Vehicle *front, StationID next_station_id) {
+	assert(st->index != next_station_id && next_station_id != INVALID_STATION);
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			LinkStatMap &link_stats = st->goods[v->cargo_type].link_stats;
+			LinkStatMap::iterator lstat_it = link_stats.find(next_station_id);
+			if (lstat_it == link_stats.end()) {
+				DEBUG(misc, 1, "frozen not in linkstat list.");
+				RecalcFrozen(st);
+				return;
+			} else {
+				LinkStat &link_stat = lstat_it->second;
+				if (link_stat.Frozen() < v->cargo_cap) {
+					DEBUG(misc, 1, "frozen is smaller than cargo cap.");
+					RecalcFrozen(st);
+					return;
+				} else {
+					link_stat.Unfreeze(v->cargo_cap);
+				}
+				assert(!link_stat.IsNull());
+			}
+		}
+	}
+}
+
+/**
+ * Either freeze or increase capacity for all link stats associated with vehicles
+ * in the given consist.
+ * @param st the station to get the link stats from
+ * @param front the first vehicle in the consist
+ * @param next_station_id the station the consist will be travelling to next
+ * @param freeze if true, freeze capacity, otherwise increase capacity
+ */
+void IncreaseStats(Station *st, const Vehicle *front, StationID next_station_id, bool freeze) {
+	Station *next = Station::GetIfValid(next_station_id);
+	assert(st->index != next_station_id && next != NULL);
+	uint average_length = GetMovingAverageLength(st, next);
+
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			LinkStatMap &stats = st->goods[v->cargo_type].link_stats;
+			LinkStatMap::iterator i = stats.find(next_station_id);
+			if (i == stats.end()) {
+				stats.insert(std::make_pair(next_station_id, LinkStat(average_length,
+						v->cargo_cap, freeze ? v->cargo_cap : 0, freeze ? 0 : v->cargo.Count())));
+			} else {
+				LinkStat &link_stat = i->second;
+				if (freeze) {
+					link_stat.Freeze(v->cargo_cap);
+				} else {
+					link_stat.Increase(v->cargo_cap, v->cargo.Count());
+				}
+				assert(!link_stat.IsNull());
+			}
+		}
+	}
+}
+
 /* called for every station each tick */
 static void StationHandleSmallTick(BaseStation *st)
 {
@@ -3150,6 +3291,8 @@ void OnTick_Station()
 {
 	if (_game_mode == GM_EDITOR) return;
 
+	RunAverages<Station>();
+
 	BaseStation *st;
 	FOR_ALL_BASE_STATIONS(st) {
 		StationHandleSmallTick(st);
@@ -3168,7 +3311,13 @@ void OnTick_Station()
 
 void StationMonthlyLoop()
 {
-	/* not used */
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for(int goods_index = 0; goods_index < NUM_CARGO; ++goods_index) {
+			st->goods[goods_index].supply = st->goods[goods_index].supply_new;
+			st->goods[goods_index].supply_new = 0;
+		}
+	}
 }
 
 
@@ -3201,6 +3350,7 @@ static uint UpdateStationWaiting(Station *st, CargoID type, uint amount, SourceT
 
 	st->goods[type].cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id));
 	SetBit(st->goods[type].acceptance_pickup, GoodsEntry::PICKUP);
+	st->goods[type].supply_new += amount;
 
 	TriggerStationAnimation(st, st->xy, SAT_NEW_CARGO, type);
 	AirportAnimationTrigger(st, AAT_STATION_NEW_CARGO, type);
diff --git a/src/station_func.h b/src/station_func.h
index 0fe5b2f..ad5d1c7 100644
--- a/src/station_func.h
+++ b/src/station_func.h
@@ -18,6 +18,7 @@
 #include "road_type.h"
 #include "cargo_type.h"
 #include "company_type.h"
+#include "vehicle_base.h"
 
 void ModifyStationRatingAround(TileIndex tile, Owner owner, int amount, uint radius);
 
@@ -46,4 +47,12 @@ bool IsStationTileElectrifiable(TileIndex tile);
 
 void UpdateAirportsNoise();
 
+void DecreaseFrozen(Station *st, const Vehicle *v, StationID next_station_id);
+
+void RecalcFrozen(Station * st);
+
+void RecalcFrozenIfLoading(const Vehicle * v);
+
+void IncreaseStats(Station *st, const Vehicle *v, StationID next_station_id, bool freeze);
+
 #endif /* STATION_FUNC_H */
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
index a34cf77..c8a27e3 100644
--- a/src/train_cmd.cpp
+++ b/src/train_cmd.cpp
@@ -2812,8 +2812,6 @@ int Train::UpdateSpeed()
 
 static void TrainEnterStation(Train *v, StationID station)
 {
-	v->last_station_visited = station;
-
 	/* check if a train ever visited this station before */
 	Station *st = Station::Get(station);
 	if (!(st->had_vehicle_of_type & HVOT_TRAIN)) {
@@ -2831,7 +2829,7 @@ static void TrainEnterStation(Train *v, StationID station)
 	v->force_proceed = TFP_NONE;
 	SetWindowDirty(WC_VEHICLE_VIEW, v->index);
 
-	v->BeginLoading();
+	v->BeginLoading(station);
 
 	TriggerStationAnimation(st, v->tile, SAT_TRAIN_ARRIVES);
 }
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index 5cb07b6..ac09564 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -1693,13 +1693,16 @@ uint GetVehicleCapacity(const Vehicle *v, uint16 *mail_capacity)
 	return capacity;
 }
 
-
-void Vehicle::BeginLoading()
+/**
+ * Start loading the vehicle and set last_station_visited in the process.
+ * @param curr_station_id ID of the station the vehicle has arrived at
+ */
+void Vehicle::BeginLoading(StationID curr_station_id)
 {
 	assert(IsTileType(tile, MP_STATION) || type == VEH_SHIP);
 
 	if (this->current_order.IsType(OT_GOTO_STATION) &&
-			this->current_order.GetDestination() == this->last_station_visited) {
+			this->current_order.GetDestination() == curr_station_id) {
 		current_order.MakeLoading(true);
 		UpdateVehicleTimetable(this, true);
 
@@ -1714,9 +1717,26 @@ void Vehicle::BeginLoading()
 		current_order.MakeLoading(false);
 	}
 
-	Station::Get(this->last_station_visited)->loading_vehicles.push_back(this);
+	Station *curr_station = Station::Get(curr_station_id);
+	curr_station->loading_vehicles.push_back(this);
 
-	PrepareUnload(this);
+	StationID next_station_id = INVALID_STATION;
+	OrderList *orders = this->orders.list;
+	if (orders != NULL) {
+		next_station_id = orders->GetNextStoppingStation(this->cur_order_index,
+				curr_station_id, this->type == VEH_ROAD || this->type == VEH_TRAIN);
+	}
+
+	if (this->last_station_visited != INVALID_STATION && this->last_station_visited != curr_station_id) {
+		IncreaseStats(Station::Get(this->last_station_visited), this, curr_station_id, false);
+	}
+
+	if (next_station_id != INVALID_STATION && next_station_id != curr_station_id) {
+		IncreaseStats(curr_station, this, next_station_id, true);
+	}
+
+	this->last_station_visited = curr_station_id;
+	PrepareUnload(this); // refers to this->last_station_visited for the distance
 
 	SetWindowDirty(GetWindowClassForVehicleType(this->type), this->owner);
 	SetWindowWidgetDirty(WC_VEHICLE_VIEW, this->index, VVW_WIDGET_START_STOP_VEH);
@@ -1741,6 +1761,18 @@ void Vehicle::LeaveStation()
 	Station *st = Station::Get(this->last_station_visited);
 	st->loading_vehicles.remove(this);
 
+	OrderList *orders = this->orders.list;
+	if (orders != NULL) {
+		StationID next_station_id = orders->GetNextStoppingStation(this->cur_order_index,
+				this->last_station_visited, this->type == VEH_ROAD || this->type == VEH_TRAIN);
+		if (next_station_id != INVALID_STATION && next_station_id != this->last_station_visited) {
+			DecreaseFrozen(st, this, next_station_id);
+		}
+	} else {
+		DEBUG(misc, 1, "orders are NULL");
+		RecalcFrozen(st);
+	}
+
 	HideFillingPercent(&this->fill_percent_te_id);
 
 	if (this->type == VEH_TRAIN && !(this->vehstatus & VS_CRASHED)) {
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index b2b3879..a09f231 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -196,7 +196,7 @@ public:
 	/** We want to 'destruct' the right class. */
 	virtual ~Vehicle();
 
-	void BeginLoading();
+	void BeginLoading(StationID curr_station_id);
 	void LeaveStation();
 
 	/**
