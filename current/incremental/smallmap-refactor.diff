diff --git a/src/smallmap_gui.cpp b/src/smallmap_gui.cpp
index 2fd8662..832616f 100644
--- a/src/smallmap_gui.cpp
+++ b/src/smallmap_gui.cpp
@@ -14,43 +14,19 @@
 #include "industry.h"
 #include "station_map.h"
 #include "landscape.h"
-#include "window_gui.h"
 #include "tree_map.h"
 #include "viewport_func.h"
 #include "town.h"
-#include "blitter/factory.hpp"
 #include "tunnelbridge_map.h"
-#include "strings_func.h"
 #include "core/endian_func.hpp"
 #include "vehicle_base.h"
 #include "sound_func.h"
 #include "window_func.h"
 #include "company_base.h"
+#include "smallmap_gui.h"
 
 #include "table/strings.h"
 
-/** Widget numbers of the small map window. */
-enum SmallMapWindowWidgets {
-	SM_WIDGET_CAPTION,           ///< Caption widget.
-	SM_WIDGET_MAP_BORDER,        ///< Border around the smallmap.
-	SM_WIDGET_MAP,               ///< Panel containing the smallmap.
-	SM_WIDGET_LEGEND,            ///< Bottom panel to display smallmap legends.
-	SM_WIDGET_ZOOM_IN,           ///< Button to zoom in one step.
-	SM_WIDGET_ZOOM_OUT,          ///< Button to zoom out one step.
-	SM_WIDGET_CONTOUR,           ///< Button to select the contour view (height map).
-	SM_WIDGET_VEHICLES,          ///< Button to select the vehicles view.
-	SM_WIDGET_INDUSTRIES,        ///< Button to select the industries view.
-	SM_WIDGET_ROUTES,            ///< Button to select the routes view.
-	SM_WIDGET_VEGETATION,        ///< Button to select the vegetation view.
-	SM_WIDGET_OWNERS,            ///< Button to select the owners view.
-	SM_WIDGET_CENTERMAP,         ///< Button to move smallmap center to main window center.
-	SM_WIDGET_TOGGLETOWNNAME,    ///< Toggle button to display town names.
-	SM_WIDGET_SELECT_BUTTONS,    ///< Selection widget for the buttons present in some smallmap modes.
-	SM_WIDGET_ENABLE_ALL,        ///< Button to enable display of all legend entries.
-	SM_WIDGET_DISABLE_ALL,       ///< Button to disable display of all legend entries.
-	SM_WIDGET_SHOW_HEIGHT,       ///< Show heightmap toggle button.
-};
-
 static int _smallmap_industry_count; ///< Number of used industries
 static int _smallmap_company_count;  ///< Number of entries in the owner legend.
 
@@ -77,18 +53,6 @@ static const int NUM_NO_COMPANY_ENTRIES = 4; ///< Number of entries in the owner
  */
 #define MS(a, b) {a, b, INVALID_INDUSTRYTYPE, 0, INVALID_COMPANY, true, false, true}
 
-/** Structure for holding relevant data for legends in small map */
-struct LegendAndColour {
-	uint8 colour;              ///< Colour of the item on the map.
-	StringID legend;           ///< String corresponding to the coloured item.
-	IndustryType type;         ///< Type of industry. Only valid for industry entries.
-	uint8 height;              ///< Height in tiles. Only valid for height legend entries.
-	CompanyID company;         ///< Company to display. Only valid for company entries of the owner legend.
-	bool show_on_map;          ///< For filtering industries, if \c true, industry is shown on the map in colour.
-	bool end;                  ///< This is the end of the list.
-	bool col_break;            ///< Perform a column break and go further at the next column.
-};
-
 /** Legend text giving the colours to look for on the minimap */
 static LegendAndColour _legend_land_contours[] = {
 	/* The colours for the following values are set at BuildLandLegend() based on each colour scheme. */
@@ -558,991 +522,906 @@ static const byte _vehicle_type_colours[6] = {
 	184, 191, 152, 15, 215, 184
 };
 
+/**
+ * Remap tile to location on this smallmap.
+ * @param tile_x X coordinate of the tile.
+ * @param tile_y Y coordinate of the tile.
+ * @return Position to draw on.
+ */
+FORCEINLINE Point SmallMapWindow::RemapTile(int tile_x, int tile_y) const
+{
+	int x_offset = tile_x - this->scroll_x / (int)TILE_SIZE;
+	int y_offset = tile_y - this->scroll_y / (int)TILE_SIZE;
 
-/** Class managing the smallmap window. */
-class SmallMapWindow : public Window {
-	/** Types of legends in the #SM_WIDGET_LEGEND widget. */
-	enum SmallMapType {
-		SMT_CONTOUR,
-		SMT_VEHICLES,
-		SMT_INDUSTRY,
-		SMT_ROUTES,
-		SMT_VEGETATION,
-		SMT_OWNER,
-	};
-
-	/** Available kinds of zoomlevel changes. */
-	enum ZoomLevelChange {
-		ZLC_INITIALIZE, ///< Initialize zoom level.
-		ZLC_ZOOM_OUT,   ///< Zoom out.
-		ZLC_ZOOM_IN,    ///< Zoom in.
-	};
-
-	static SmallMapType map_type; ///< Currently displayed legends.
-	static bool show_towns;       ///< Display town names in the smallmap.
-
-	static const uint LEGEND_BLOB_WIDTH = 8;              ///< Width of the coloured blob in front of a line text in the #SM_WIDGET_LEGEND widget.
-	static const uint INDUSTRY_MIN_NUMBER_OF_COLUMNS = 2; ///< Minimal number of columns in the #SM_WIDGET_LEGEND widget for the #SMT_INDUSTRY legend.
-	uint min_number_of_fixed_rows; ///< Minimal number of rows in the legends for the fixed layouts only (all except #SMT_INDUSTRY).
-	uint column_width;             ///< Width of a column in the #SM_WIDGET_LEGEND widget.
-
-	int32 scroll_x;  ///< Horizontal world coordinate of the base tile left of the top-left corner of the smallmap display.
-	int32 scroll_y;  ///< Vertical world coordinate of the base tile left of the top-left corner of the smallmap display.
-	int32 subscroll; ///< Number of pixels (0..3) between the right end of the base tile and the pixel at the top-left corner of the smallmap display.
-	int zoom;        ///< Zoom level. Bigger number means more zoom-out (further away).
-
-	static const uint8 FORCE_REFRESH_PERIOD = 0x1F; ///< map is redrawn after that many ticks
-	uint8 refresh; ///< refresh counter, zeroed every FORCE_REFRESH_PERIOD ticks
-
-	/**
-	 * Remap tile to location on this smallmap.
-	 * @param tile_x X coordinate of the tile.
-	 * @param tile_y Y coordinate of the tile.
-	 * @return Position to draw on.
-	 */
-	FORCEINLINE Point RemapTile(int tile_x, int tile_y) const
-	{
-		int x_offset = tile_x - this->scroll_x / (int)TILE_SIZE;
-		int y_offset = tile_y - this->scroll_y / (int)TILE_SIZE;
-
-		if (this->zoom == 1) return RemapCoords(x_offset, y_offset, 0);
-
-		/* For negative offsets, round towards -inf. */
-		if (x_offset < 0) x_offset -= this->zoom - 1;
-		if (y_offset < 0) y_offset -= this->zoom - 1;
-
-		return RemapCoords(x_offset / this->zoom, y_offset / this->zoom, 0);
-	}
+	if (this->zoom == 1) return RemapCoords(x_offset, y_offset, 0);
 
-	/**
-	 * Determine the tile relative to the base tile of the smallmap, and the pixel position at
-	 * that tile for a point in the smallmap.
-	 * @param px       Horizontal coordinate of the pixel.
-	 * @param py       Vertical coordinate of the pixel.
-	 * @param sub[out] Pixel position at the tile (0..3).
-	 * @param add_sub  Add current #subscroll to the position.
-	 * @return Tile being displayed at the given position relative to #scroll_x and #scroll_y.
-	 * @note The #subscroll offset is already accounted for.
-	 */
-	FORCEINLINE Point PixelToTile(int px, int py, int *sub, bool add_sub = true) const
-	{
-		if (add_sub) px += this->subscroll;  // Total horizontal offset.
+	/* For negative offsets, round towards -inf. */
+	if (x_offset < 0) x_offset -= this->zoom - 1;
+	if (y_offset < 0) y_offset -= this->zoom - 1;
 
-		/* For each two rows down, add a x and a y tile, and
-		 * For each four pixels to the right, move a tile to the right. */
-		Point pt = {((py >> 1) - (px >> 2)) * this->zoom, ((py >> 1) + (px >> 2)) * this->zoom};
-		px &= 3;
+	return RemapCoords(x_offset / this->zoom, y_offset / this->zoom, 0);
+}
 
-		if (py & 1) { // Odd number of rows, handle the 2 pixel shift.
-			if (px < 2) {
-				pt.x += this->zoom;
-				px += 2;
-			} else {
-				pt.y += this->zoom;
-				px -= 2;
-			}
-		}
+/**
+ * Determine the tile relative to the base tile of the smallmap, and the pixel position at
+ * that tile for a point in the smallmap.
+ * @param px       Horizontal coordinate of the pixel.
+ * @param py       Vertical coordinate of the pixel.
+ * @param sub[out] Pixel position at the tile (0..3).
+ * @param add_sub  Add current #subscroll to the position.
+ * @return Tile being displayed at the given position relative to #scroll_x and #scroll_y.
+ * @note The #subscroll offset is already accounted for.
+ */
+FORCEINLINE Point SmallMapWindow::PixelToTile(int px, int py, int *sub, bool add_sub) const
+{
+	if (add_sub) px += this->subscroll;  // Total horizontal offset.
 
-		*sub = px;
-		return pt;
-	}
+	/* For each two rows down, add a x and a y tile, and
+	 * For each four pixels to the right, move a tile to the right. */
+	Point pt = {((py >> 1) - (px >> 2)) * this->zoom, ((py >> 1) + (px >> 2)) * this->zoom};
+	px &= 3;
 
-	/**
-	 * Compute base parameters of the smallmap such that tile (\a tx, \a ty) starts at pixel (\a x, \a y).
-	 * @param tx        Tile x coordinate.
-	 * @param ty        Tile y coordinate.
-	 * @param x         Non-negative horizontal position in the display where the tile starts.
-	 * @param y         Non-negative vertical position in the display where the tile starts.
-	 * @param sub [out] Value of #subscroll needed.
-	 * @return #scroll_x, #scroll_y values.
-	 */
-	Point ComputeScroll(int tx, int ty, int x, int y, int *sub)
-	{
-		assert(x >= 0 && y >= 0);
-
-		int new_sub;
-		Point tile_xy = PixelToTile(x, y, &new_sub, false);
-		tx -= tile_xy.x;
-		ty -= tile_xy.y;
-
-		Point scroll;
-		if (new_sub == 0) {
-			*sub = 0;
-			scroll.x = (tx + this->zoom) * TILE_SIZE;
-			scroll.y = (ty - this->zoom) * TILE_SIZE;
+	if (py & 1) { // Odd number of rows, handle the 2 pixel shift.
+		if (px < 2) {
+			pt.x += this->zoom;
+			px += 2;
 		} else {
-			*sub = 4 - new_sub;
-			scroll.x = (tx + 2 * this->zoom) * TILE_SIZE;
-			scroll.y = (ty - 2 * this->zoom) * TILE_SIZE;
+			pt.y += this->zoom;
+			px -= 2;
 		}
-		return scroll;
 	}
 
-	/**
-	 * Initialize or change the zoom level.
-	 * @param change  Way to change the zoom level.
-	 * @param zoom_pt Position to keep fixed while zooming.
-	 * @pre \c *zoom_pt should contain a point in the smallmap display when zooming in or out.
-	 */
-	void SetZoomLevel(ZoomLevelChange change, const Point *zoom_pt)
-	{
-		static const int zoomlevels[] = {1, 2, 4, 6, 8}; // Available zoom levels. Bigger number means more zoom-out (further away).
-		static const int MIN_ZOOM_INDEX = 0;
-		static const int MAX_ZOOM_INDEX = lengthof(zoomlevels) - 1;
-
-		int new_index, cur_index, sub;
-		Point tile;
-		switch (change) {
-			case ZLC_INITIALIZE:
-				cur_index = - 1; // Definitely different from new_index.
-				new_index = MIN_ZOOM_INDEX;
-				break;
+	*sub = px;
+	return pt;
+}
 
-			case ZLC_ZOOM_IN:
-			case ZLC_ZOOM_OUT:
-				for (cur_index = MIN_ZOOM_INDEX; cur_index <= MAX_ZOOM_INDEX; cur_index++) {
-					if (this->zoom == zoomlevels[cur_index]) break;
-				}
-				assert(cur_index <= MAX_ZOOM_INDEX);
+/**
+ * Compute base parameters of the smallmap such that tile (\a tx, \a ty) starts at pixel (\a x, \a y).
+ * @param tx        Tile x coordinate.
+ * @param ty        Tile y coordinate.
+ * @param x         Non-negative horizontal position in the display where the tile starts.
+ * @param y         Non-negative vertical position in the display where the tile starts.
+ * @param sub [out] Value of #subscroll needed.
+ * @return #scroll_x, #scroll_y values.
+ */
+Point SmallMapWindow::ComputeScroll(int tx, int ty, int x, int y, int *sub)
+{
+	assert(x >= 0 && y >= 0);
+
+	int new_sub;
+	Point tile_xy = PixelToTile(x, y, &new_sub, false);
+	tx -= tile_xy.x;
+	ty -= tile_xy.y;
+
+	Point scroll;
+	if (new_sub == 0) {
+		*sub = 0;
+		scroll.x = (tx + this->zoom) * TILE_SIZE;
+		scroll.y = (ty - this->zoom) * TILE_SIZE;
+	} else {
+		*sub = 4 - new_sub;
+		scroll.x = (tx + 2 * this->zoom) * TILE_SIZE;
+		scroll.y = (ty - 2 * this->zoom) * TILE_SIZE;
+	}
+	return scroll;
+}
 
-				tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
-				new_index = Clamp(cur_index + ((change == ZLC_ZOOM_IN) ? -1 : 1), MIN_ZOOM_INDEX, MAX_ZOOM_INDEX);
-				break;
+/**
+ * Initialize or change the zoom level.
+ * @param change  Way to change the zoom level.
+ * @param zoom_pt Position to keep fixed while zooming.
+ * @pre \c *zoom_pt should contain a point in the smallmap display when zooming in or out.
+ */
+void SmallMapWindow::SetZoomLevel(ZoomLevelChange change, const Point *zoom_pt)
+{
+	static const int zoomlevels[] = {1, 2, 4, 6, 8}; // Available zoom levels. Bigger number means more zoom-out (further away).
+	static const int MIN_ZOOM_INDEX = 0;
+	static const int MAX_ZOOM_INDEX = lengthof(zoomlevels) - 1;
+
+	int new_index, cur_index, sub;
+	Point tile;
+	switch (change) {
+		case ZLC_INITIALIZE:
+			cur_index = - 1; // Definitely different from new_index.
+			new_index = MIN_ZOOM_INDEX;
+			break;
+
+		case ZLC_ZOOM_IN:
+		case ZLC_ZOOM_OUT:
+			for (cur_index = MIN_ZOOM_INDEX; cur_index <= MAX_ZOOM_INDEX; cur_index++) {
+				if (this->zoom == zoomlevels[cur_index]) break;
+			}
+			assert(cur_index <= MAX_ZOOM_INDEX);
 
-			default: NOT_REACHED();
-		}
+			tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
+			new_index = Clamp(cur_index + ((change == ZLC_ZOOM_IN) ? -1 : 1), MIN_ZOOM_INDEX, MAX_ZOOM_INDEX);
+			break;
 
-		if (new_index != cur_index) {
-			this->zoom = zoomlevels[new_index];
-			if (cur_index >= 0) {
-				Point new_tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
-				this->SetNewScroll(this->scroll_x + (tile.x - new_tile.x) * TILE_SIZE,
-						this->scroll_y + (tile.y - new_tile.y) * TILE_SIZE, sub);
-			}
-			this->SetWidgetDisabledState(SM_WIDGET_ZOOM_IN,  this->zoom == zoomlevels[MIN_ZOOM_INDEX]);
-			this->SetWidgetDisabledState(SM_WIDGET_ZOOM_OUT, this->zoom == zoomlevels[MAX_ZOOM_INDEX]);
-			this->SetDirty();
+		default: NOT_REACHED();
+	}
+
+	if (new_index != cur_index) {
+		this->zoom = zoomlevels[new_index];
+		if (cur_index >= 0) {
+			Point new_tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
+			this->SetNewScroll(this->scroll_x + (tile.x - new_tile.x) * TILE_SIZE,
+					this->scroll_y + (tile.y - new_tile.y) * TILE_SIZE, sub);
 		}
+		this->SetWidgetDisabledState(SM_WIDGET_ZOOM_IN,  this->zoom == zoomlevels[MIN_ZOOM_INDEX]);
+		this->SetWidgetDisabledState(SM_WIDGET_ZOOM_OUT, this->zoom == zoomlevels[MAX_ZOOM_INDEX]);
+		this->SetDirty();
 	}
+}
 
-	/**
-	 * Decide which colours to show to the user for a group of tiles.
-	 * @param ta Tile area to investigate.
-	 * @return Colours to display.
-	 */
-	inline uint32 GetTileColours(const TileArea &ta) const
-	{
-		int importance = 0;
-		TileIndex tile = INVALID_TILE; // Position of the most important tile.
-		TileType et = MP_VOID;         // Effective tile type at that position.
-
-		TILE_AREA_LOOP(ti, ta) {
-			TileType ttype = GetEffectiveTileType(ti);
-			if (_tiletype_importance[ttype] > importance) {
-				importance = _tiletype_importance[ttype];
-				tile = ti;
-				et = ttype;
-			}
+/**
+ * Decide which colours to show to the user for a group of tiles.
+ * @param ta Tile area to investigate.
+ * @return Colours to display.
+ */
+inline uint32 SmallMapWindow::GetTileColours(const TileArea &ta) const
+{
+	int importance = 0;
+	TileIndex tile = INVALID_TILE; // Position of the most important tile.
+	TileType et = MP_VOID;         // Effective tile type at that position.
+
+	TILE_AREA_LOOP(ti, ta) {
+		TileType ttype = GetEffectiveTileType(ti);
+		if (_tiletype_importance[ttype] > importance) {
+			importance = _tiletype_importance[ttype];
+			tile = ti;
+			et = ttype;
 		}
+	}
 
-		switch (this->map_type) {
-			case SMT_CONTOUR:
-				return GetSmallMapContoursPixels(tile, et);
+	switch (this->map_type) {
+		case SMT_CONTOUR:
+			return GetSmallMapContoursPixels(tile, et);
 
-			case SMT_VEHICLES:
-				return GetSmallMapVehiclesPixels(tile, et);
+		case SMT_VEHICLES:
+			return GetSmallMapVehiclesPixels(tile, et);
 
-			case SMT_INDUSTRY:
-				return GetSmallMapIndustriesPixels(tile, et);
+		case SMT_INDUSTRY:
+			return GetSmallMapIndustriesPixels(tile, et);
 
-			case SMT_ROUTES:
-				return GetSmallMapRoutesPixels(tile, et);
+		case SMT_ROUTES:
+			return GetSmallMapRoutesPixels(tile, et);
 
-			case SMT_VEGETATION:
-				return GetSmallMapVegetationPixels(tile, et);
+		case SMT_VEGETATION:
+			return GetSmallMapVegetationPixels(tile, et);
 
-			case SMT_OWNER:
-				return GetSmallMapOwnerPixels(tile, et);
+		case SMT_OWNER:
+			return GetSmallMapOwnerPixels(tile, et);
 
-			default: NOT_REACHED();
-		}
+		default: NOT_REACHED();
 	}
+}
 
-	/**
-	 * Draws one column of tiles of the small map in a certain mode onto the screen buffer, skipping the shifted rows in between.
-	 *
-	 * @param dst Pointer to a part of the screen buffer to write to.
-	 * @param xc The X coordinate of the first tile in the column.
-	 * @param yc The Y coordinate of the first tile in the column
-	 * @param pitch Number of pixels to advance in the screen buffer each time a pixel is written.
-	 * @param reps Number of lines to draw
-	 * @param start_pos Position of first pixel to draw.
-	 * @param end_pos Position of last pixel to draw (exclusive).
-	 * @param blitter current blitter
-	 * @note If pixel position is below \c 0, skip drawing.
-	 * @see GetSmallMapPixels(TileIndex)
-	 */
-	void DrawSmallMapColumn(void *dst, uint xc, uint yc, int pitch, int reps, int start_pos, int end_pos, Blitter *blitter) const
-	{
-		void *dst_ptr_abs_end = blitter->MoveTo(_screen.dst_ptr, 0, _screen.height);
-		uint min_xy = _settings_game.construction.freeform_edges ? 1 : 0;
-
-		do {
-			/* Check if the tile (xc,yc) is within the map range */
-			if (xc >= MapMaxX() || yc >= MapMaxY()) continue;
-
-			/* Check if the dst pointer points to a pixel inside the screen buffer */
-			if (dst < _screen.dst_ptr) continue;
-			if (dst >= dst_ptr_abs_end) continue;
-
-			/* Construct tilearea covered by (xc, yc, xc + this->zoom, yc + this->zoom) such that it is within min_xy limits. */
-			TileArea ta;
-			if (min_xy == 1 && (xc == 0 || yc == 0)) {
-				if (this->zoom == 1) continue; // The tile area is empty, don't draw anything.
+/**
+ * Draws one column of tiles of the small map in a certain mode onto the screen buffer, skipping the shifted rows in between.
+ *
+ * @param dst Pointer to a part of the screen buffer to write to.
+ * @param xc The X coordinate of the first tile in the column.
+ * @param yc The Y coordinate of the first tile in the column
+ * @param pitch Number of pixels to advance in the screen buffer each time a pixel is written.
+ * @param reps Number of lines to draw
+ * @param start_pos Position of first pixel to draw.
+ * @param end_pos Position of last pixel to draw (exclusive).
+ * @param blitter current blitter
+ * @note If pixel position is below \c 0, skip drawing.
+ * @see GetSmallMapPixels(TileIndex)
+ */
+void SmallMapWindow::DrawSmallMapColumn(void *dst, uint xc, uint yc, int pitch, int reps, int start_pos, int end_pos, Blitter *blitter) const
+{
+	void *dst_ptr_abs_end = blitter->MoveTo(_screen.dst_ptr, 0, _screen.height);
+	uint min_xy = _settings_game.construction.freeform_edges ? 1 : 0;
 
-				ta = TileArea(TileXY(max(min_xy, xc), max(min_xy, yc)), this->zoom - (xc == 0), this->zoom - (yc == 0));
-			} else {
-				ta = TileArea(TileXY(xc, yc), this->zoom, this->zoom);
-			}
-			ta.ClampToMap(); // Clamp to map boundaries (may contain MP_VOID tiles!).
-
-			uint32 val = this->GetTileColours(ta);
-			uint8 *val8 = (uint8 *)&val;
-			int idx = max(0, -start_pos);
-			for (int pos = max(0, start_pos); pos < end_pos; pos++) {
-				blitter->SetPixel(dst, idx, 0, val8[idx]);
-				idx++;
-			}
-		/* Switch to next tile in the column */
-		} while (xc += this->zoom, yc += this->zoom, dst = blitter->MoveTo(dst, pitch, 0), --reps != 0);
-	}
+	do {
+		/* Check if the tile (xc,yc) is within the map range */
+		if (xc >= MapMaxX() || yc >= MapMaxY()) continue;
 
-	/**
-	 * Adds vehicles to the smallmap.
-	 * @param dpi the part of the smallmap to be drawn into
-	 * @param blitter current blitter
-	 */
-	void DrawVehicles(const DrawPixelInfo *dpi, Blitter *blitter) const
-	{
-		const Vehicle *v;
-		FOR_ALL_VEHICLES(v) {
-			if (v->type == VEH_EFFECT) continue;
-			if (v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) continue;
-
-			/* Remap into flat coordinates. */
-			Point pt = this->RemapTile(v->x_pos / TILE_SIZE, v->y_pos / TILE_SIZE);
-
-			int y = pt.y - dpi->top;
-			if (!IsInsideMM(y, 0, dpi->height)) continue; // y is out of bounds.
-
-			bool skip = false; // Default is to draw both pixels.
-			int x = pt.x - this->subscroll - 3 - dpi->left; // Offset X coordinate.
-			if (x < 0) {
-				/* if x+1 is 0, that means we're on the very left edge,
-				 * and should thus only draw a single pixel */
-				if (++x != 0) continue;
-				skip = true;
-			} else if (x >= dpi->width - 1) {
-				/* Check if we're at the very right edge, and if so draw only a single pixel */
-				if (x != dpi->width - 1) continue;
-				skip = true;
-			}
+		/* Check if the dst pointer points to a pixel inside the screen buffer */
+		if (dst < _screen.dst_ptr) continue;
+		if (dst >= dst_ptr_abs_end) continue;
 
-			/* Calculate pointer to pixel and the colour */
-			byte colour = (this->map_type == SMT_VEHICLES) ? _vehicle_type_colours[v->type] : 0xF;
+		/* Construct tilearea covered by (xc, yc, xc + this->zoom, yc + this->zoom) such that it is within min_xy limits. */
+		TileArea ta;
+		if (min_xy == 1 && (xc == 0 || yc == 0)) {
+			if (this->zoom == 1) continue; // The tile area is empty, don't draw anything.
 
-			/* And draw either one or two pixels depending on clipping */
-			blitter->SetPixel(dpi->dst_ptr, x, y, colour);
-			if (!skip) blitter->SetPixel(dpi->dst_ptr, x + 1, y, colour);
+			ta = TileArea(TileXY(max(min_xy, xc), max(min_xy, yc)), this->zoom - (xc == 0), this->zoom - (yc == 0));
+		} else {
+			ta = TileArea(TileXY(xc, yc), this->zoom, this->zoom);
 		}
-	}
+		ta.ClampToMap(); // Clamp to map boundaries (may contain MP_VOID tiles!).
+
+		uint32 val = this->GetTileColours(ta);
+		uint8 *val8 = (uint8 *)&val;
+		int idx = max(0, -start_pos);
+		for (int pos = max(0, start_pos); pos < end_pos; pos++) {
+			blitter->SetPixel(dst, idx, 0, val8[idx]);
+			idx++;
+		}
+	/* Switch to next tile in the column */
+	} while (xc += this->zoom, yc += this->zoom, dst = blitter->MoveTo(dst, pitch, 0), --reps != 0);
+}
 
-	/**
-	 * Adds town names to the smallmap.
-	 * @param dpi the part of the smallmap to be drawn into
-	 */
-	void DrawTowns(const DrawPixelInfo *dpi) const
-	{
-		const Town *t;
-		FOR_ALL_TOWNS(t) {
-			/* Remap the town coordinate */
-			Point pt = this->RemapTile(TileX(t->xy), TileY(t->xy));
-			int x = pt.x - this->subscroll - (t->sign.width_small >> 1);
-			int y = pt.y;
-
-			/* Check if the town sign is within bounds */
-			if (x + t->sign.width_small > dpi->left &&
-					x < dpi->left + dpi->width &&
-					y + FONT_HEIGHT_SMALL > dpi->top &&
-					y < dpi->top + dpi->height) {
-				/* And draw it. */
-				SetDParam(0, t->index);
-				DrawString(x, x + t->sign.width_small, y, STR_SMALLMAP_TOWN);
-			}
+/**
+ * Adds vehicles to the smallmap.
+ * @param dpi the part of the smallmap to be drawn into
+ * @param blitter current blitter
+ */
+void SmallMapWindow::DrawVehicles(const DrawPixelInfo *dpi, Blitter *blitter) const
+{
+	const Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		if (v->type == VEH_EFFECT) continue;
+		if (v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) continue;
+
+		/* Remap into flat coordinates. */
+		Point pt = this->RemapTile(v->x_pos / TILE_SIZE, v->y_pos / TILE_SIZE);
+
+		int y = pt.y - dpi->top;
+		if (!IsInsideMM(y, 0, dpi->height)) continue; // y is out of bounds.
+
+		bool skip = false; // Default is to draw both pixels.
+		int x = pt.x - this->subscroll - 3 - dpi->left; // Offset X coordinate.
+		if (x < 0) {
+			/* if x+1 is 0, that means we're on the very left edge,
+			 * and should thus only draw a single pixel */
+			if (++x != 0) continue;
+			skip = true;
+		} else if (x >= dpi->width - 1) {
+			/* Check if we're at the very right edge, and if so draw only a single pixel */
+			if (x != dpi->width - 1) continue;
+			skip = true;
 		}
-	}
 
-	/**
-	 * Draws vertical part of map indicator
-	 * @param x X coord of left/right border of main viewport
-	 * @param y Y coord of top border of main viewport
-	 * @param y2 Y coord of bottom border of main viewport
-	 */
-	static inline void DrawVertMapIndicator(int x, int y, int y2)
-	{
-		GfxFillRect(x, y,      x, y + 3, 69);
-		GfxFillRect(x, y2 - 3, x, y2,    69);
-	}
+		/* Calculate pointer to pixel and the colour */
+		byte colour = (this->map_type == SMT_VEHICLES) ? _vehicle_type_colours[v->type] : 0xF;
 
-	/**
-	 * Draws horizontal part of map indicator
-	 * @param x X coord of left border of main viewport
-	 * @param x2 X coord of right border of main viewport
-	 * @param y Y coord of top/bottom border of main viewport
-	 */
-	static inline void DrawHorizMapIndicator(int x, int x2, int y)
-	{
-		GfxFillRect(x,      y, x + 3, y, 69);
-		GfxFillRect(x2 - 3, y, x2,    y, 69);
+		/* And draw either one or two pixels depending on clipping */
+		blitter->SetPixel(dpi->dst_ptr, x, y, colour);
+		if (!skip) blitter->SetPixel(dpi->dst_ptr, x + 1, y, colour);
 	}
+}
 
-	/**
-	 * Adds map indicators to the smallmap.
-	 */
-	void DrawMapIndicators() const
-	{
-		/* Find main viewport. */
-		const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
+/**
+ * Adds town names to the smallmap.
+ * @param dpi the part of the smallmap to be drawn into
+ */
+void SmallMapWindow::DrawTowns(const DrawPixelInfo *dpi) const
+{
+	const Town *t;
+	FOR_ALL_TOWNS(t) {
+		/* Remap the town coordinate */
+		Point pt = this->RemapTile(TileX(t->xy), TileY(t->xy));
+		int x = pt.x - this->subscroll - (t->sign.width_small >> 1);
+		int y = pt.y;
+
+		/* Check if the town sign is within bounds */
+		if (x + t->sign.width_small > dpi->left &&
+				x < dpi->left + dpi->width &&
+				y + FONT_HEIGHT_SMALL > dpi->top &&
+				y < dpi->top + dpi->height) {
+			/* And draw it. */
+			SetDParam(0, t->index);
+			DrawString(x, x + t->sign.width_small, y, STR_SMALLMAP_TOWN);
+		}
+	}
+}
 
-		Point tile = InverseRemapCoords(vp->virtual_left, vp->virtual_top);
-		Point tl = this->RemapTile(tile.x >> 4, tile.y >> 4);
-		tl.x -= this->subscroll;
+/**
+ * Adds map indicators to the smallmap.
+ */
+void SmallMapWindow::DrawMapIndicators() const
+{
+	/* Find main viewport. */
+	const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
 
-		tile = InverseRemapCoords(vp->virtual_left + vp->virtual_width, vp->virtual_top + vp->virtual_height);
-		Point br = this->RemapTile(tile.x >> 4, tile.y >> 4);
-		br.x -= this->subscroll;
+	Point tile = InverseRemapCoords(vp->virtual_left, vp->virtual_top);
+	Point tl = this->RemapTile(tile.x >> 4, tile.y >> 4);
+	tl.x -= this->subscroll;
 
-		SmallMapWindow::DrawVertMapIndicator(tl.x, tl.y, br.y);
-		SmallMapWindow::DrawVertMapIndicator(br.x, tl.y, br.y);
+	tile = InverseRemapCoords(vp->virtual_left + vp->virtual_width, vp->virtual_top + vp->virtual_height);
+	Point br = this->RemapTile(tile.x >> 4, tile.y >> 4);
+	br.x -= this->subscroll;
 
-		SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, tl.y);
-		SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, br.y);
-	}
+	SmallMapWindow::DrawVertMapIndicator(tl.x, tl.y, br.y);
+	SmallMapWindow::DrawVertMapIndicator(br.x, tl.y, br.y);
 
-	/**
-	 * Draws the small map.
-	 *
-	 * Basically, the small map is draw column of pixels by column of pixels. The pixels
-	 * are drawn directly into the screen buffer. The final map is drawn in multiple passes.
-	 * The passes are:
-	 * <ol><li>The colours of tiles in the different modes.</li>
-	 * <li>Town names (optional)</li></ol>
-	 *
-	 * @param dpi pointer to pixel to write onto
-	 */
-	void DrawSmallMap(DrawPixelInfo *dpi) const
-	{
-		Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
-		DrawPixelInfo *old_dpi;
-
-		old_dpi = _cur_dpi;
-		_cur_dpi = dpi;
-
-		/* Clear it */
-		GfxFillRect(dpi->left, dpi->top, dpi->left + dpi->width - 1, dpi->top + dpi->height - 1, 0);
-
-		/* Which tile is displayed at (dpi->left, dpi->top)? */
-		int dx;
-		Point tile = this->PixelToTile(dpi->left, dpi->top, &dx);
-		int tile_x = this->scroll_x / (int)TILE_SIZE + tile.x;
-		int tile_y = this->scroll_y / (int)TILE_SIZE + tile.y;
-
-		void *ptr = blitter->MoveTo(dpi->dst_ptr, -dx - 4, 0);
-		int x = - dx - 4;
-		int y = 0;
-
-		for (;;) {
-			/* Distance from left edge */
-			if (x >= -3) {
-				if (x >= dpi->width) break; // Exit the loop.
-
-				int end_pos = min(dpi->width, x + 4);
-				int reps = (dpi->height - y + 1) / 2; // Number of lines.
-				if (reps > 0) {
-					this->DrawSmallMapColumn(ptr, tile_x, tile_y, dpi->pitch * 2, reps, x, end_pos, blitter);
-				}
-			}
+	SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, tl.y);
+	SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, br.y);
+}
 
-			if (y == 0) {
-				tile_y += this->zoom;
-				y++;
-				ptr = blitter->MoveTo(ptr, 0, 1);
-			} else {
-				tile_x -= this->zoom;
-				y--;
-				ptr = blitter->MoveTo(ptr, 0, -1);
+/**
+ * Draws the small map.
+ *
+ * Basically, the small map is draw column of pixels by column of pixels. The pixels
+ * are drawn directly into the screen buffer. The final map is drawn in multiple passes.
+ * The passes are:
+ * <ol><li>The colours of tiles in the different modes.</li>
+ * <li>Town names (optional)</li></ol>
+ *
+ * @param dpi pointer to pixel to write onto
+ */
+void SmallMapWindow::DrawSmallMap(DrawPixelInfo *dpi) const
+{
+	Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
+	DrawPixelInfo *old_dpi;
+
+	old_dpi = _cur_dpi;
+	_cur_dpi = dpi;
+
+	/* Clear it */
+	GfxFillRect(dpi->left, dpi->top, dpi->left + dpi->width - 1, dpi->top + dpi->height - 1, 0);
+
+	/* Which tile is displayed at (dpi->left, dpi->top)? */
+	int dx;
+	Point tile = this->PixelToTile(dpi->left, dpi->top, &dx);
+	int tile_x = this->scroll_x / (int)TILE_SIZE + tile.x;
+	int tile_y = this->scroll_y / (int)TILE_SIZE + tile.y;
+
+	void *ptr = blitter->MoveTo(dpi->dst_ptr, -dx - 4, 0);
+	int x = - dx - 4;
+	int y = 0;
+
+	for (;;) {
+		/* Distance from left edge */
+		if (x >= -3) {
+			if (x >= dpi->width) break; // Exit the loop.
+
+			int end_pos = min(dpi->width, x + 4);
+			int reps = (dpi->height - y + 1) / 2; // Number of lines.
+			if (reps > 0) {
+				this->DrawSmallMapColumn(ptr, tile_x, tile_y, dpi->pitch * 2, reps, x, end_pos, blitter);
 			}
-			ptr = blitter->MoveTo(ptr, 2, 0);
-			x += 2;
 		}
 
-		/* Draw vehicles */
-		if (this->map_type == SMT_CONTOUR || this->map_type == SMT_VEHICLES) this->DrawVehicles(dpi, blitter);
-
-		/* Draw town names */
-		if (this->show_towns) this->DrawTowns(dpi);
-
-		/* Draw map indicators */
-		this->DrawMapIndicators();
-
-		_cur_dpi = old_dpi;
+		if (y == 0) {
+			tile_y += this->zoom;
+			y++;
+			ptr = blitter->MoveTo(ptr, 0, 1);
+		} else {
+			tile_x -= this->zoom;
+			y--;
+			ptr = blitter->MoveTo(ptr, 0, -1);
+		}
+		ptr = blitter->MoveTo(ptr, 2, 0);
+		x += 2;
 	}
 
-	/**
-	 * Function to set up widgets depending on the information being shown on the smallmap.
-	 */
-	void SetupWidgetData()
-	{
-		StringID legend_tooltip;
-		StringID enable_all_tooltip;
-		StringID disable_all_tooltip;
-		int plane;
-		switch (this->map_type) {
-			case SMT_INDUSTRY:
-				legend_tooltip = STR_SMALLMAP_TOOLTIP_INDUSTRY_SELECTION;
-				enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_INDUSTRIES;
-				disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_INDUSTRIES;
-				plane = 0;
-				break;
+	/* Draw vehicles */
+	if (this->map_type == SMT_CONTOUR || this->map_type == SMT_VEHICLES) this->DrawVehicles(dpi, blitter);
 
-			case SMT_OWNER:
-				legend_tooltip = STR_SMALLMAP_TOOLTIP_COMPANY_SELECTION;
-				enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_COMPANIES;
-				disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_COMPANIES;
-				plane = 0;
-				break;
+	/* Draw town names */
+	if (this->show_towns) this->DrawTowns(dpi);
 
-			default:
-				legend_tooltip = STR_NULL;
-				enable_all_tooltip = STR_NULL;
-				disable_all_tooltip = STR_NULL;
-				plane = 1;
-				break;
-		}
+	/* Draw map indicators */
+	this->DrawMapIndicators();
 
-		this->GetWidget<NWidgetCore>(SM_WIDGET_LEGEND)->SetDataTip(STR_NULL, legend_tooltip);
-		this->GetWidget<NWidgetCore>(SM_WIDGET_ENABLE_ALL)->SetDataTip(STR_SMALLMAP_ENABLE_ALL, enable_all_tooltip);
-		this->GetWidget<NWidgetCore>(SM_WIDGET_DISABLE_ALL)->SetDataTip(STR_SMALLMAP_DISABLE_ALL, disable_all_tooltip);
-		this->GetWidget<NWidgetStacked>(SM_WIDGET_SELECT_BUTTONS)->SetDisplayedPlane(plane);
-	}
-
-public:
-	uint min_number_of_columns;    ///< Minimal number of columns in legends.
+	_cur_dpi = old_dpi;
+}
 
-	SmallMapWindow(const WindowDesc *desc, int window_number) : Window(), refresh(FORCE_REFRESH_PERIOD)
-	{
-		this->InitNested(desc, window_number);
-		this->LowerWidget(this->map_type + SM_WIDGET_CONTOUR);
+/**
+ * Function to set up widgets depending on the information being shown on the smallmap.
+ */
+void SmallMapWindow::SetupWidgetData()
+{
+	StringID legend_tooltip;
+	StringID enable_all_tooltip;
+	StringID disable_all_tooltip;
+	int plane;
+	switch (this->map_type) {
+		case SMT_INDUSTRY:
+			legend_tooltip = STR_SMALLMAP_TOOLTIP_INDUSTRY_SELECTION;
+			enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_INDUSTRIES;
+			disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_INDUSTRIES;
+			plane = 0;
+			break;
+
+		case SMT_OWNER:
+			legend_tooltip = STR_SMALLMAP_TOOLTIP_COMPANY_SELECTION;
+			enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_COMPANIES;
+			disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_COMPANIES;
+			plane = 0;
+			break;
 
-		BuildLandLegend();
-		this->SetWidgetLoweredState(SM_WIDGET_SHOW_HEIGHT, _smallmap_show_heightmap);
+		default:
+			legend_tooltip = STR_NULL;
+			enable_all_tooltip = STR_NULL;
+			disable_all_tooltip = STR_NULL;
+			plane = 1;
+			break;
+	}
 
-		this->SetWidgetLoweredState(SM_WIDGET_TOGGLETOWNNAME, this->show_towns);
+	this->GetWidget<NWidgetCore>(SM_WIDGET_LEGEND)->SetDataTip(STR_NULL, legend_tooltip);
+	this->GetWidget<NWidgetCore>(SM_WIDGET_ENABLE_ALL)->SetDataTip(STR_SMALLMAP_ENABLE_ALL, enable_all_tooltip);
+	this->GetWidget<NWidgetCore>(SM_WIDGET_DISABLE_ALL)->SetDataTip(STR_SMALLMAP_DISABLE_ALL, disable_all_tooltip);
+	this->GetWidget<NWidgetStacked>(SM_WIDGET_SELECT_BUTTONS)->SetDisplayedPlane(plane);
+}
 
-		this->SetupWidgetData();
+SmallMapWindow::SmallMapWindow(const WindowDesc *desc, int window_number) : Window(), refresh(FORCE_REFRESH_PERIOD)
+{
+	this->InitNested(desc, window_number);
+	this->LowerWidget(this->map_type + SM_WIDGET_CONTOUR);
 
-		this->SetZoomLevel(ZLC_INITIALIZE, NULL);
-		this->SmallMapCenterOnCurrentPos();
-	}
+	BuildLandLegend();
+	this->SetWidgetLoweredState(SM_WIDGET_SHOW_HEIGHT, _smallmap_show_heightmap);
 
-	/**
-	 * Compute minimal required width of the legends.
-	 * @return Minimally needed width for displaying the smallmap legends in pixels.
-	 */
-	inline uint GetMinLegendWidth() const
-	{
-		return WD_FRAMERECT_LEFT + this->min_number_of_columns * this->column_width;
-	}
+	this->SetWidgetLoweredState(SM_WIDGET_TOGGLETOWNNAME, this->show_towns);
 
-	/**
-	 * Return number of columns that can be displayed in \a width pixels.
-	 * @return Number of columns to display.
-	 */
-	inline uint GetNumberColumnsLegend(uint width) const
-	{
-		return width / this->column_width;
-	}
+	this->SetupWidgetData();
 
-	/**
-	 * Compute height given a number of columns.
-	 * @param Number of columns.
-	 * @return Needed height for displaying the smallmap legends in pixels.
-	 */
-	uint GetLegendHeight(uint num_columns) const
-	{
-		uint num_rows = max(this->min_number_of_fixed_rows, CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), num_columns));
-		return WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM + num_rows * FONT_HEIGHT_SMALL;
-	}
+	this->SetZoomLevel(ZLC_INITIALIZE, NULL);
+	this->SmallMapCenterOnCurrentPos();
+}
 
-	virtual void SetStringParameters(int widget) const
-	{
-		switch (widget) {
-			case SM_WIDGET_CAPTION:
-				SetDParam(0, STR_SMALLMAP_TYPE_CONTOURS + this->map_type);
-				break;
-		}
+/**
+ * Compute height given a number of columns.
+ * @param Number of columns.
+ * @return Needed height for displaying the smallmap legends in pixels.
+ */
+void SmallMapWindow::SetStringParameters(int widget) const
+{
+	switch (widget) {
+		case SM_WIDGET_CAPTION:
+			SetDParam(0, STR_SMALLMAP_TYPE_CONTOURS + this->map_type);
+			break;
 	}
+}
 
-	virtual void OnInit()
-	{
-		uint min_width = 0;
-		this->min_number_of_columns = INDUSTRY_MIN_NUMBER_OF_COLUMNS;
-		this->min_number_of_fixed_rows = 0;
-		for (uint i = 0; i < lengthof(_legend_table); i++) {
-			uint height = 0;
-			uint num_columns = 1;
-			for (const LegendAndColour *tbl = _legend_table[i]; !tbl->end; ++tbl) {
-				StringID str;
-				if (i == SMT_INDUSTRY) {
-					SetDParam(0, tbl->legend);
-					SetDParam(1, IndustryPool::MAX_SIZE);
-					str = STR_SMALLMAP_INDUSTRY;
-				} else if (i == SMT_OWNER) {
-					if (tbl->company != INVALID_COMPANY) {
-						if (!Company::IsValidID(tbl->company)) {
-							/* Rebuild the owner legend. */
-							BuildOwnerLegend();
-							this->OnInit();
-							return;
-						}
-						/* Non-fixed legend entries for the owner view. */
-						SetDParam(0, tbl->company);
-						str = STR_SMALLMAP_COMPANY;
-					} else {
-						str = tbl->legend;
+void SmallMapWindow::OnInit()
+{
+	uint min_width = 0;
+	this->min_number_of_columns = INDUSTRY_MIN_NUMBER_OF_COLUMNS;
+	this->min_number_of_fixed_rows = 0;
+	for (uint i = 0; i < lengthof(_legend_table); i++) {
+		uint height = 0;
+		uint num_columns = 1;
+		for (const LegendAndColour *tbl = _legend_table[i]; !tbl->end; ++tbl) {
+			StringID str;
+			if (i == SMT_INDUSTRY) {
+				SetDParam(0, tbl->legend);
+				SetDParam(1, IndustryPool::MAX_SIZE);
+				str = STR_SMALLMAP_INDUSTRY;
+			} else if (i == SMT_OWNER) {
+				if (tbl->company != INVALID_COMPANY) {
+					if (!Company::IsValidID(tbl->company)) {
+						/* Rebuild the owner legend. */
+						BuildOwnerLegend();
+						this->OnInit();
+						return;
 					}
+					/* Non-fixed legend entries for the owner view. */
+					SetDParam(0, tbl->company);
+					str = STR_SMALLMAP_COMPANY;
 				} else {
-					if (tbl->col_break) {
-						this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
-						height = 0;
-						num_columns++;
-					}
-					height++;
 					str = tbl->legend;
 				}
-				min_width = max(GetStringBoundingBox(str).width, min_width);
+			} else {
+				if (tbl->col_break) {
+					this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
+					height = 0;
+					num_columns++;
+				}
+				height++;
+				str = tbl->legend;
 			}
-			this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
-			this->min_number_of_columns = max(this->min_number_of_columns, num_columns);
+			min_width = max(GetStringBoundingBox(str).width, min_width);
 		}
-
-		/* The width of a column is the minimum width of all texts + the size of the blob + some spacing */
-		this->column_width = min_width + LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+		this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
+		this->min_number_of_columns = max(this->min_number_of_columns, num_columns);
 	}
 
-	virtual void OnPaint()
-	{
-		if (this->map_type == SMT_OWNER) {
-			for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
-				if (tbl->company != INVALID_COMPANY && !Company::IsValidID(tbl->company)) {
-					/* Rebuild the owner legend. */
-					BuildOwnerLegend();
-					this->InvalidateData(1);
-					break;
-				}
+	/* The width of a column is the minimum width of all texts + the size of the blob + some spacing */
+	this->column_width = min_width + LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+}
+
+void SmallMapWindow::OnPaint()
+{
+	if (this->map_type == SMT_OWNER) {
+		for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
+			if (tbl->company != INVALID_COMPANY && !Company::IsValidID(tbl->company)) {
+				/* Rebuild the owner legend. */
+				BuildOwnerLegend();
+				this->InvalidateData(1);
+				break;
 			}
 		}
-
-		this->DrawWidgets();
 	}
 
-	virtual void DrawWidget(const Rect &r, int widget) const
-	{
-		switch (widget) {
-			case SM_WIDGET_MAP: {
-				DrawPixelInfo new_dpi;
-				if (!FillDrawPixelInfo(&new_dpi, r.left + 1, r.top + 1, r.right - r.left - 1, r.bottom - r.top - 1)) return;
-				this->DrawSmallMap(&new_dpi);
-				break;
+	this->DrawWidgets();
+}
+
+void SmallMapWindow::DrawWidget(const Rect &r, int widget) const
+{
+	switch (widget) {
+		case SM_WIDGET_MAP: {
+			DrawPixelInfo new_dpi;
+			if (!FillDrawPixelInfo(&new_dpi, r.left + 1, r.top + 1, r.right - r.left - 1, r.bottom - r.top - 1)) return;
+			this->DrawSmallMap(&new_dpi);
+			break;
+		}
+
+		case SM_WIDGET_LEGEND: {
+			uint columns = this->GetNumberColumnsLegend(r.right - r.left + 1);
+			uint number_of_rows = this->GetNumberRowsLegend(columns);
+			bool rtl = _current_text_dir == TD_RTL;
+			uint y_org = r.top + WD_FRAMERECT_TOP;
+			uint x = rtl ? r.right - this->column_width - WD_FRAMERECT_RIGHT : r.left + WD_FRAMERECT_LEFT;
+			uint y = y_org;
+			uint i = 0; // Row counter for industry legend.
+			uint row_height = FONT_HEIGHT_SMALL;
+
+			uint text_left  = rtl ? 0 : LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT;
+			uint text_right = this->column_width - 1 - (rtl ? LEGEND_BLOB_WIDTH + WD_FRAMERECT_RIGHT : 0);
+			uint blob_left  = rtl ? this->column_width - 1 - LEGEND_BLOB_WIDTH : 0;
+			uint blob_right = rtl ? this->column_width - 1 : LEGEND_BLOB_WIDTH;
+
+			StringID string = STR_NULL;
+			switch (this->map_type) {
+				case SMT_INDUSTRY:
+					string = STR_SMALLMAP_INDUSTRY;
+					break;
+				case SMT_OWNER:
+					string = STR_SMALLMAP_COMPANY;
+					break;
+				default:
+					break;
 			}
 
-			case SM_WIDGET_LEGEND: {
-				uint columns = this->GetNumberColumnsLegend(r.right - r.left + 1);
-				uint number_of_rows = max((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) ? CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), columns) : 0, this->min_number_of_fixed_rows);
-				bool rtl = _current_text_dir == TD_RTL;
-				uint y_org = r.top + WD_FRAMERECT_TOP;
-				uint x = rtl ? r.right - this->column_width - WD_FRAMERECT_RIGHT : r.left + WD_FRAMERECT_LEFT;
-				uint y = y_org;
-				uint i = 0; // Row counter for industry legend.
-				uint row_height = FONT_HEIGHT_SMALL;
-
-				uint text_left  = rtl ? 0 : LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT;
-				uint text_right = this->column_width - 1 - (rtl ? LEGEND_BLOB_WIDTH + WD_FRAMERECT_RIGHT : 0);
-				uint blob_left  = rtl ? this->column_width - 1 - LEGEND_BLOB_WIDTH : 0;
-				uint blob_right = rtl ? this->column_width - 1 : LEGEND_BLOB_WIDTH;
-
-				for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
-					if (tbl->col_break || ((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) && i++ >= number_of_rows)) {
-						/* Column break needed, continue at top, COLUMN_WIDTH pixels
-						 * (one "row") to the right. */
-						x += rtl ? -(int)this->column_width : this->column_width;
-						y = y_org;
-						i = 1;
-					}
+			for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
+				if (tbl->col_break || ((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) && i++ >= number_of_rows)) {
+					/* Column break needed, continue at top, COLUMN_WIDTH pixels
+					 * (one "row") to the right. */
+					x += rtl ? -(int)this->column_width : this->column_width;
+					y = y_org;
+					i = 1;
+				}
 
-					if (this->map_type == SMT_INDUSTRY) {
+				switch (this->map_type) {
+					case SMT_INDUSTRY:
 						/* Industry name must be formatted, since it's not in tiny font in the specs.
 						 * So, draw with a parameter and use the STR_SMALLMAP_INDUSTRY string, which is tiny font */
 						SetDParam(0, tbl->legend);
 						SetDParam(1, Industry::GetIndustryTypeCount(tbl->type));
-						if (!tbl->show_on_map) {
-							/* Simply draw the string, not the black border of the legend colour.
-							 * This will enforce the idea of the disabled item */
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_INDUSTRY, TC_GREY);
-						} else {
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_INDUSTRY, TC_BLACK);
-							GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, 0); // Outer border of the legend colour
-						}
-					} else if (this->map_type == SMT_OWNER && tbl->company != INVALID_COMPANY) {
-						SetDParam(0, tbl->company);
-						if (!tbl->show_on_map) {
-							/* Simply draw the string, not the black border of the legend colour.
-							 * This will enforce the idea of the disabled item */
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_COMPANY, TC_GREY);
-						} else {
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_COMPANY, TC_BLACK);
-							GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, 0); // Outer border of the legend colour
+						/* FALL THROUGH */
+					case SMT_OWNER:
+						if (this->map_type != SMT_OWNER || tbl->company != INVALID_COMPANY) {
+							if (this->map_type == SMT_OWNER) SetDParam(0, tbl->company);
+							if (!tbl->show_on_map) {
+								/* Simply draw the string, not the black border of the legend colour.
+								 * This will enforce the idea of the disabled item */
+								DrawString(x + text_left, x + text_right, y, string, TC_GREY);
+							} else {
+								DrawString(x + text_left, x + text_right, y, string, TC_BLACK);
+								GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, 0); // Outer border of the legend colour
+							}
+							break;
 						}
-					} else {
+						/* FALL_THROUGH */
+					default:
 						if (this->map_type == SMT_CONTOUR) SetDParam(0, tbl->height * TILE_HEIGHT_STEP);
-
 						/* Anything that is not an industry or a company is using normal process */
 						GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, 0);
 						DrawString(x + text_left, x + text_right, y, tbl->legend);
-					}
-					GfxFillRect(x + blob_left + 1, y + 2, x + blob_right - 1, y + row_height - 2, tbl->colour); // Legend colour
-
-					y += row_height;
+						break;
 				}
+				GfxFillRect(x + blob_left + 1, y + 2, x + blob_right - 1, y + row_height - 2, tbl->colour); // Legend colour
+
+				y += row_height;
 			}
 		}
 	}
+}
 
-	/**
-	 * Select a new map type.
-	 * @param map_type New map type.
-	 */
-	void SwitchMapType(SmallMapType map_type)
-	{
-		this->RaiseWidget(this->map_type + SM_WIDGET_CONTOUR);
-		this->map_type = map_type;
-		this->LowerWidget(this->map_type + SM_WIDGET_CONTOUR);
-
-		this->SetupWidgetData();
+/**
+ * Get the number of rows in the legend from the number of columns. Those
+ * are at least min_number_of_fixed_rows and possibly more if there are so
+ * many cargoes, industry types or companies that they won't fit in the
+ * available space.
+ * @param columns Number of columns in the legend.
+ * @return Number of rows needed for everything to fit in.
+ */
+FORCEINLINE uint SmallMapWindow::GetNumberRowsLegend(uint columns) const
+{
+	uint num_rows = CeilDiv(max(_smallmap_industry_count,_smallmap_company_count), columns);
+	return max(this->min_number_of_fixed_rows, num_rows);
+}
 
-		this->SetDirty();
+/**
+ * Select and toggle a legend item. When CTRL is pressed, disable all other
+ * items in the group defined by begin_legend_item and end_legend_item and
+ * keep the clicked one enabled even if it was already enabled before. If
+ * the other items in the group are all disabled already and CTRL is pressed
+ * enable them instead.
+ * @param click_pos the index of the item being selected
+ * @param legend the legend from which we select
+ * @param end_legend_item index one past the last item in the group to be inverted
+ * @param begin_legend_item index of the first item in the group to be inverted
+ */
+void SmallMapWindow::SelectLegendItem(int click_pos, LegendAndColour *legend, int end_legend_item, int begin_legend_item)
+{
+	if (_ctrl_pressed) {
+		/* Disable all, except the clicked one */
+		bool changes = false;
+		for (int i = begin_legend_item; i != end_legend_item; i++) {
+			bool new_state = (i == click_pos);
+			if (legend[i].show_on_map != new_state) {
+				changes = true;
+				legend[i].show_on_map = new_state;
+			}
+		}
+		if (!changes) {
+			/* Nothing changed? Then show all (again). */
+			for (int i = begin_legend_item; i != end_legend_item; i++) {
+				legend[i].show_on_map = true;
+			}
+		}
+	} else {
+		legend[click_pos].show_on_map = !legend[click_pos].show_on_map;
 	}
+}
 
-	virtual void OnClick(Point pt, int widget, int click_count)
-	{
-		/* User clicked something, notify the industry chain window to stop sending newly selected industries. */
-		InvalidateWindowClassesData(WC_INDUSTRY_CARGOES, NUM_INDUSTRYTYPES);
-
-		switch (widget) {
-			case SM_WIDGET_MAP: { // Map window
-				/*
-				 * XXX: scrolling with the left mouse button is done by subsequently
-				 * clicking with the left mouse button; clicking once centers the
-				 * large map at the selected point. So by unclicking the left mouse
-				 * button here, it gets reclicked during the next inputloop, which
-				 * would make it look like the mouse is being dragged, while it is
-				 * actually being (virtually) clicked every inputloop.
-				 */
-				_left_button_clicked = false;
-
-				const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
-				Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
-				int sub;
-				pt = this->PixelToTile(pt.x - wid->pos_x, pt.y - wid->pos_y, &sub);
-				pt = RemapCoords(this->scroll_x + pt.x * TILE_SIZE + this->zoom * (TILE_SIZE - sub * TILE_SIZE / 4),
-						this->scroll_y + pt.y * TILE_SIZE + sub * this->zoom * TILE_SIZE / 4, 0);
-
-				w->viewport->follow_vehicle = INVALID_VEHICLE;
-				w->viewport->dest_scrollpos_x = pt.x - (w->viewport->virtual_width  >> 1);
-				w->viewport->dest_scrollpos_y = pt.y - (w->viewport->virtual_height >> 1);
+/**
+ * Select a new map type.
+ * @param map_type New map type.
+ */
+void SmallMapWindow::SwitchMapType(SmallMapType map_type)
+{
+	this->RaiseWidget(this->map_type + SM_WIDGET_CONTOUR);
+	this->map_type = map_type;
+	this->LowerWidget(this->map_type + SM_WIDGET_CONTOUR);
 
-				this->SetDirty();
-				break;
-			}
+	this->SetupWidgetData();
 
-			case SM_WIDGET_ZOOM_IN:
-			case SM_WIDGET_ZOOM_OUT: {
-				const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
-				Point pt = {wid->current_x / 2, wid->current_y / 2};
-				this->SetZoomLevel((widget == SM_WIDGET_ZOOM_IN) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
-				SndPlayFx(SND_15_BEEP);
-				break;
-			}
+	this->SetDirty();
+}
 
-			case SM_WIDGET_CONTOUR:    // Show land contours
-			case SM_WIDGET_VEHICLES:   // Show vehicles
-			case SM_WIDGET_INDUSTRIES: // Show industries
-			case SM_WIDGET_ROUTES:     // Show transport routes
-			case SM_WIDGET_VEGETATION: // Show vegetation
-			case SM_WIDGET_OWNERS:     // Show land owners
-				this->SwitchMapType((SmallMapType)(widget - SM_WIDGET_CONTOUR));
-				SndPlayFx(SND_15_BEEP);
-				break;
+void SmallMapWindow::OnClick(Point pt, int widget, int click_count)
+{
+	/* User clicked something, notify the industry chain window to stop sending newly selected industries. */
+	InvalidateWindowClassesData(WC_INDUSTRY_CARGOES, NUM_INDUSTRYTYPES);
+
+	switch (widget) {
+		case SM_WIDGET_MAP: { // Map window
+			/*
+			 * XXX: scrolling with the left mouse button is done by subsequently
+			 * clicking with the left mouse button; clicking once centers the
+			 * large map at the selected point. So by unclicking the left mouse
+			 * button here, it gets reclicked during the next inputloop, which
+			 * would make it look like the mouse is being dragged, while it is
+			 * actually being (virtually) clicked every inputloop.
+			 */
+			_left_button_clicked = false;
 
-			case SM_WIDGET_CENTERMAP: // Center the smallmap again
-				this->SmallMapCenterOnCurrentPos();
-				this->HandleButtonClick(SM_WIDGET_CENTERMAP);
-				SndPlayFx(SND_15_BEEP);
-				break;
+			const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+			Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
+			int sub;
+			pt = this->PixelToTile(pt.x - wid->pos_x, pt.y - wid->pos_y, &sub);
+			pt = RemapCoords(this->scroll_x + pt.x * TILE_SIZE + this->zoom * (TILE_SIZE - sub * TILE_SIZE / 4),
+					this->scroll_y + pt.y * TILE_SIZE + sub * this->zoom * TILE_SIZE / 4, 0);
 
-			case SM_WIDGET_TOGGLETOWNNAME: // Toggle town names
-				this->show_towns = !this->show_towns;
-				this->SetWidgetLoweredState(SM_WIDGET_TOGGLETOWNNAME, this->show_towns);
+			w->viewport->follow_vehicle = INVALID_VEHICLE;
+			w->viewport->dest_scrollpos_x = pt.x - (w->viewport->virtual_width  >> 1);
+			w->viewport->dest_scrollpos_y = pt.y - (w->viewport->virtual_height >> 1);
 
-				this->SetDirty();
-				SndPlayFx(SND_15_BEEP);
-				break;
+			this->SetDirty();
+			break;
+		}
 
-			case SM_WIDGET_LEGEND: // Legend
-				/* If industry type small map*/
-				if (this->map_type == SMT_INDUSTRY) {
-					/* If click on industries label, find right industry type and enable/disable it */
-					const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_LEGEND); // Label panel
-					uint line = (pt.y - wi->pos_y - WD_FRAMERECT_TOP) / FONT_HEIGHT_SMALL;
-					uint columns = this->GetNumberColumnsLegend(wi->current_x);
-					uint number_of_rows = max(CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), columns), this->min_number_of_fixed_rows);
-					if (line >= number_of_rows) break;
-
-					bool rtl = _current_text_dir == TD_RTL;
-					int x = pt.x - wi->pos_x;
-					if (rtl) x = wi->current_x - x;
-					uint column = (x - WD_FRAMERECT_LEFT) / this->column_width;
-
-					/* Check if click is on industry label*/
-					int industry_pos = (column * number_of_rows) + line;
-					if (industry_pos < _smallmap_industry_count) {
-						if (_ctrl_pressed) {
-							/* Disable all, except the clicked one */
-							bool changes = false;
-							for (int i = 0; i != _smallmap_industry_count; i++) {
-								bool new_state = i == industry_pos;
-								if (_legend_from_industries[i].show_on_map != new_state) {
-									changes = true;
-									_legend_from_industries[i].show_on_map = new_state;
-								}
-							}
-							if (!changes) {
-								/* Nothing changed? Then show all (again). */
-								for (int i = 0; i != _smallmap_industry_count; i++) {
-									_legend_from_industries[i].show_on_map = true;
-								}
-							}
-						} else {
-							_legend_from_industries[industry_pos].show_on_map = !_legend_from_industries[industry_pos].show_on_map;
-						}
-					}
-					this->SetDirty();
-				} else if (this->map_type == SMT_OWNER) {
-					/* If click on companies label, find right company and enable/disable it. */
-					const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_LEGEND);
-					uint line = (pt.y - wi->pos_y - WD_FRAMERECT_TOP) / FONT_HEIGHT_SMALL;
-					uint columns = this->GetNumberColumnsLegend(wi->current_x);
-					uint number_of_rows = max(CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), columns), this->min_number_of_fixed_rows);
-					if (line >= number_of_rows) break;
-
-					bool rtl = _current_text_dir == TD_RTL;
-					int x = pt.x - wi->pos_x;
-					if (rtl) x = wi->current_x - x;
-					uint column = (x - WD_FRAMERECT_LEFT) / this->column_width;
-
-					/* Check if click is on company label. */
-					int company_pos = (column * number_of_rows) + line;
-					if (company_pos < NUM_NO_COMPANY_ENTRIES) break;
-					if (company_pos < _smallmap_company_count) {
-						if (_ctrl_pressed) {
-							/* Disable all, except the clicked one */
-							bool changes = false;
-							for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-								bool new_state = i == company_pos;
-								if (_legend_land_owners[i].show_on_map != new_state) {
-									changes = true;
-									_legend_land_owners[i].show_on_map = new_state;
-								}
-							}
-							if (!changes) {
-								/* Nothing changed? Then show all (again). */
-								for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-									_legend_land_owners[i].show_on_map = true;
-								}
-							}
-						} else {
-							_legend_land_owners[company_pos].show_on_map = !_legend_land_owners[company_pos].show_on_map;
-						}
-					}
-					this->SetDirty();
-				}
-				break;
+		case SM_WIDGET_ZOOM_IN:
+		case SM_WIDGET_ZOOM_OUT: {
+			const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+			Point pt = {wid->current_x / 2, wid->current_y / 2};
+			this->SetZoomLevel((widget == SM_WIDGET_ZOOM_IN) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
+			SndPlayFx(SND_15_BEEP);
+			break;
+		}
 
-			case SM_WIDGET_ENABLE_ALL:
-				if (this->map_type == SMT_INDUSTRY) {
-					for (int i = 0; i != _smallmap_industry_count; i++) {
-						_legend_from_industries[i].show_on_map = true;
-					}
-				} else if (this->map_type == SMT_OWNER) {
-					for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-						_legend_land_owners[i].show_on_map = true;
-					}
-				}
-				this->SetDirty();
-				break;
+		case SM_WIDGET_CONTOUR:    // Show land contours
+		case SM_WIDGET_VEHICLES:   // Show vehicles
+		case SM_WIDGET_INDUSTRIES: // Show industries
+		case SM_WIDGET_ROUTES:     // Show transport routes
+		case SM_WIDGET_VEGETATION: // Show vegetation
+		case SM_WIDGET_OWNERS:     // Show land owners
+			this->SwitchMapType((SmallMapType)(widget - SM_WIDGET_CONTOUR));
+			SndPlayFx(SND_15_BEEP);
+			break;
+
+		case SM_WIDGET_CENTERMAP: // Center the smallmap again
+			this->SmallMapCenterOnCurrentPos();
+			this->HandleButtonClick(SM_WIDGET_CENTERMAP);
+			SndPlayFx(SND_15_BEEP);
+			break;
+
+		case SM_WIDGET_TOGGLETOWNNAME: // Toggle town names
+			this->show_towns = !this->show_towns;
+			this->SetWidgetLoweredState(SM_WIDGET_TOGGLETOWNNAME, this->show_towns);
+
+			this->SetDirty();
+			SndPlayFx(SND_15_BEEP);
+			break;
+
+		case SM_WIDGET_LEGEND: // Legend
+			if (this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) {
+				/* If click on label, find right type and enable/disable it */
+				const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_LEGEND); // Label panel
+				uint line = (pt.y - wi->pos_y - WD_FRAMERECT_TOP) / FONT_HEIGHT_SMALL;
+				uint columns = this->GetNumberColumnsLegend(wi->current_x);
+				uint number_of_rows = this->GetNumberRowsLegend(columns);
+				if (line >= number_of_rows) break;
+
+				bool rtl = _current_text_dir == TD_RTL;
+				int x = pt.x - wi->pos_x;
+				if (rtl) x = wi->current_x - x;
+				uint column = (x - WD_FRAMERECT_LEFT) / this->column_width;
 
-			case SM_WIDGET_DISABLE_ALL:
+				/* Check if click is on label*/
+				int click_pos = (column * number_of_rows) + line;
 				if (this->map_type == SMT_INDUSTRY) {
-					for (int i = 0; i != _smallmap_industry_count; i++) {
-						_legend_from_industries[i].show_on_map = false;
+					if (click_pos < _smallmap_industry_count) {
+						this->SelectLegendItem(click_pos, _legend_from_industries, _smallmap_industry_count);
 					}
-				} else {
-					for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-						_legend_land_owners[i].show_on_map = false;
+				} else if (this->map_type == SMT_OWNER) {
+					if (click_pos < _smallmap_company_count) {
+						this->SelectLegendItem(click_pos, _legend_land_owners, _smallmap_company_count, NUM_NO_COMPANY_ENTRIES);
 					}
 				}
 				this->SetDirty();
-				break;
-
-			case SM_WIDGET_SHOW_HEIGHT: // Enable/disable showing of heightmap.
-				_smallmap_show_heightmap = !_smallmap_show_heightmap;
-				this->SetWidgetLoweredState(SM_WIDGET_SHOW_HEIGHT, _smallmap_show_heightmap);
-				this->SetDirty();
-				break;
+			}
+			break;
+
+		case SM_WIDGET_ENABLE_ALL:
+			/* FALL THROUGH */
+		case SM_WIDGET_DISABLE_ALL: {
+			LegendAndColour *tbl = NULL;
+			switch (this->map_type) {
+				case SMT_INDUSTRY:
+					tbl = _legend_from_industries;
+					break;
+				case SMT_OWNER:
+					tbl = &(_legend_land_owners[NUM_NO_COMPANY_ENTRIES]);
+					break;
+				default:
+					NOT_REACHED();
+			}
+			for (;!tbl->end; ++tbl) {
+				tbl->show_on_map = (widget == SM_WIDGET_ENABLE_ALL);
+			}
+			this->SetDirty();
+			break;
 		}
-	}
 
-	/**
-	 * Some data on this window has become invalid.
-	 * @param data Information about the changed data.
-	 * - data = 0: Displayed industries at the industry chain window have changed.
-	 * - data = 1: Companies have changed.
-	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
-	 */
-	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
-	{
-		if (!gui_scope) return;
-		switch (data) {
-			case 1:
-				/* The owner legend has already been rebuilt. */
-				this->ReInit();
-				break;
-
-			case 0: {
-				extern uint64 _displayed_industries;
-				if (this->map_type != SMT_INDUSTRY) this->SwitchMapType(SMT_INDUSTRY);
+		case SM_WIDGET_SHOW_HEIGHT: // Enable/disable showing of heightmap.
+			_smallmap_show_heightmap = !_smallmap_show_heightmap;
+			this->SetWidgetLoweredState(SM_WIDGET_SHOW_HEIGHT, _smallmap_show_heightmap);
+			this->SetDirty();
+			break;
+	}
+}
 
-				for (int i = 0; i != _smallmap_industry_count; i++) {
-					_legend_from_industries[i].show_on_map = HasBit(_displayed_industries, _legend_from_industries[i].type);
-				}
-				break;
+/**
+ * Some data on this window has become invalid.
+ * @param data Information about the changed data.
+ * - data = 0: Displayed industries at the industry chain window have changed.
+ * - data = 1: Companies have changed.
+ * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+ */
+void SmallMapWindow::OnInvalidateData(int data, bool gui_scope)
+{
+	if (!gui_scope) return;
+	switch (data) {
+		case 1:
+			/* The owner legend has already been rebuilt. */
+			this->ReInit();
+			break;
+
+		case 0: {
+			extern uint64 _displayed_industries;
+			if (this->map_type != SMT_INDUSTRY) this->SwitchMapType(SMT_INDUSTRY);
+
+			for (int i = 0; i != _smallmap_industry_count; i++) {
+				_legend_from_industries[i].show_on_map = HasBit(_displayed_industries, _legend_from_industries[i].type);
 			}
-
-			default: NOT_REACHED();
+			break;
 		}
-		this->SetDirty();
+
+		default: NOT_REACHED();
 	}
+	this->SetDirty();
+}
 
-	virtual bool OnRightClick(Point pt, int widget)
-	{
-		if (widget != SM_WIDGET_MAP || _scrolling_viewport) return false;
+bool SmallMapWindow::OnRightClick(Point pt, int widget)
+{
+	if (widget != SM_WIDGET_MAP || _scrolling_viewport) return false;
 
-		_scrolling_viewport = true;
-		return true;
-	}
+	_scrolling_viewport = true;
+	return true;
+}
 
-	virtual void OnMouseWheel(int wheel)
-	{
-		if (_settings_client.gui.scrollwheel_scrolling == 0) {
-			const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
-			int cursor_x = _cursor.pos.x - this->left - wid->pos_x;
-			int cursor_y = _cursor.pos.y - this->top  - wid->pos_y;
-			if (IsInsideMM(cursor_x, 0, wid->current_x) && IsInsideMM(cursor_y, 0, wid->current_y)) {
-				Point pt = {cursor_x, cursor_y};
-				this->SetZoomLevel((wheel < 0) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
-			}
+void SmallMapWindow::OnMouseWheel(int wheel)
+{
+	if (_settings_client.gui.scrollwheel_scrolling == 0) {
+		const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+		int cursor_x = _cursor.pos.x - this->left - wid->pos_x;
+		int cursor_y = _cursor.pos.y - this->top  - wid->pos_y;
+		if (IsInsideMM(cursor_x, 0, wid->current_x) && IsInsideMM(cursor_y, 0, wid->current_y)) {
+			Point pt = {cursor_x, cursor_y};
+			this->SetZoomLevel((wheel < 0) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
 		}
 	}
+}
 
-	virtual void OnTick()
-	{
-		/* Update the window every now and then */
-		if (--this->refresh != 0) return;
-
-		this->refresh = FORCE_REFRESH_PERIOD;
-		this->SetDirty();
-	}
+void SmallMapWindow::OnTick()
+{
+	/* Update the window every now and then */
+	if (--this->refresh != 0) return;
 
-	/**
-	 * Set new #scroll_x, #scroll_y, and #subscroll values after limiting them such that the center
-	 * of the smallmap always contains a part of the map.
-	 * @param sx  Proposed new #scroll_x
-	 * @param sy  Proposed new #scroll_y
-	 * @param sub Proposed new #subscroll
-	 */
-	void SetNewScroll(int sx, int sy, int sub)
-	{
-		const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
-		Point hv = InverseRemapCoords(wi->current_x * TILE_SIZE / 2, wi->current_y * TILE_SIZE / 2);
-		hv.x *= this->zoom;
-		hv.y *= this->zoom;
-
-		if (sx < -hv.x) {
-			sx = -hv.x;
-			sub = 0;
-		}
-		if (sx > (int)(MapMaxX() * TILE_SIZE) - hv.x) {
-			sx = MapMaxX() * TILE_SIZE - hv.x;
-			sub = 0;
-		}
-		if (sy < -hv.y) {
-			sy = -hv.y;
-			sub = 0;
-		}
-		if (sy > (int)(MapMaxY() * TILE_SIZE) - hv.y) {
-			sy = MapMaxY() * TILE_SIZE - hv.y;
-			sub = 0;
-		}
+	this->refresh = FORCE_REFRESH_PERIOD;
+	this->SetDirty();
+}
 
-		this->scroll_x = sx;
-		this->scroll_y = sy;
-		this->subscroll = sub;
+/**
+ * Set new #scroll_x, #scroll_y, and #subscroll values after limiting them such that the center
+ * of the smallmap always contains a part of the map.
+ * @param sx  Proposed new #scroll_x
+ * @param sy  Proposed new #scroll_y
+ * @param sub Proposed new #subscroll
+ */
+void SmallMapWindow::SetNewScroll(int sx, int sy, int sub)
+{
+	const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+	Point hv = InverseRemapCoords(wi->current_x * TILE_SIZE / 2, wi->current_y * TILE_SIZE / 2);
+	hv.x *= this->zoom;
+	hv.y *= this->zoom;
+
+	if (sx < -hv.x) {
+		sx = -hv.x;
+		sub = 0;
+	}
+	if (sx > (int)(MapMaxX() * TILE_SIZE) - hv.x) {
+		sx = MapMaxX() * TILE_SIZE - hv.x;
+		sub = 0;
+	}
+	if (sy < -hv.y) {
+		sy = -hv.y;
+		sub = 0;
+	}
+	if (sy > (int)(MapMaxY() * TILE_SIZE) - hv.y) {
+		sy = MapMaxY() * TILE_SIZE - hv.y;
+		sub = 0;
 	}
 
-	virtual void OnScroll(Point delta)
-	{
-		_cursor.fix_at = true;
+	this->scroll_x = sx;
+	this->scroll_y = sy;
+	this->subscroll = sub;
+}
 
-		/* While tile is at (delta.x, delta.y)? */
-		int sub;
-		Point pt = this->PixelToTile(delta.x, delta.y, &sub);
-		this->SetNewScroll(this->scroll_x + pt.x * TILE_SIZE, this->scroll_y + pt.y * TILE_SIZE, sub);
+void SmallMapWindow::OnScroll(Point delta)
+{
+	_cursor.fix_at = true;
 
-		this->SetDirty();
-	}
+	/* While tile is at (delta.x, delta.y)? */
+	int sub;
+	Point pt = this->PixelToTile(delta.x, delta.y, &sub);
+	this->SetNewScroll(this->scroll_x + pt.x * TILE_SIZE, this->scroll_y + pt.y * TILE_SIZE, sub);
 
-	void SmallMapCenterOnCurrentPos()
-	{
-		const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
-		Point pt = InverseRemapCoords(vp->virtual_left + vp->virtual_width  / 2, vp->virtual_top  + vp->virtual_height / 2);
+	this->SetDirty();
+}
+
+void SmallMapWindow::SmallMapCenterOnCurrentPos()
+{
+	const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
+	Point pt = InverseRemapCoords(vp->virtual_left + vp->virtual_width  / 2, vp->virtual_top  + vp->virtual_height / 2);
+
+	int sub;
+	const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+	Point sxy = this->ComputeScroll(pt.x / TILE_SIZE, pt.y / TILE_SIZE, max(0, (int)wid->current_x / 2 - 2), wid->current_y / 2, &sub);
+	this->SetNewScroll(sxy.x, sxy.y, sub);
+	this->SetDirty();
+}
 
-		int sub;
-		const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
-		Point sxy = this->ComputeScroll(pt.x / TILE_SIZE, pt.y / TILE_SIZE, max(0, (int)wid->current_x / 2 - 2), wid->current_y / 2, &sub);
-		this->SetNewScroll(sxy.x, sxy.y, sub);
-		this->SetDirty();
-	}
-};
 
 SmallMapWindow::SmallMapType SmallMapWindow::map_type = SMT_CONTOUR;
 bool SmallMapWindow::show_towns = true;
diff --git a/src/smallmap_gui.h b/src/smallmap_gui.h
index 572a175..4cf7168 100644
--- a/src/smallmap_gui.h
+++ b/src/smallmap_gui.h
@@ -12,9 +12,174 @@
 #ifndef SMALLMAP_GUI_H
 #define SMALLMAP_GUI_H
 
+#include "industry_type.h"
+#include "window_gui.h"
+#include "strings_func.h"
+#include "blitter/factory.hpp"
+
 void BuildIndustriesLegend();
 void ShowSmallMap();
 void BuildLandLegend();
 void BuildOwnerLegend();
 
+/** Structure for holding relevant data for legends in small map */
+struct LegendAndColour {
+	uint8 colour;              ///< Colour of the item on the map.
+	StringID legend;           ///< String corresponding to the coloured item.
+	IndustryType type;         ///< Type of industry. Only valid for industry entries.
+	uint8 height;              ///< Height in tiles. Only valid for height legend entries.
+	CompanyID company;         ///< Company to display. Only valid for company entries of the owner legend.
+	bool show_on_map;          ///< For filtering industries, if \c true, industry is shown on the map in colour.
+	bool end;                  ///< This is the end of the list.
+	bool col_break;            ///< Perform a column break and go further at the next column.
+};
+
+/** Widget numbers of the small map window. */
+enum SmallMapWindowWidgets {
+	SM_WIDGET_CAPTION,           ///< Caption widget.
+	SM_WIDGET_MAP_BORDER,        ///< Border around the smallmap.
+	SM_WIDGET_MAP,               ///< Panel containing the smallmap.
+	SM_WIDGET_LEGEND,            ///< Bottom panel to display smallmap legends.
+	SM_WIDGET_ZOOM_IN,           ///< Button to zoom in one step.
+	SM_WIDGET_ZOOM_OUT,          ///< Button to zoom out one step.
+	SM_WIDGET_CONTOUR,           ///< Button to select the contour view (height map).
+	SM_WIDGET_VEHICLES,          ///< Button to select the vehicles view.
+	SM_WIDGET_INDUSTRIES,        ///< Button to select the industries view.
+	SM_WIDGET_ROUTES,            ///< Button to select the routes view.
+	SM_WIDGET_VEGETATION,        ///< Button to select the vegetation view.
+	SM_WIDGET_OWNERS,            ///< Button to select the owners view.
+	SM_WIDGET_CENTERMAP,         ///< Button to move smallmap center to main window center.
+	SM_WIDGET_TOGGLETOWNNAME,    ///< Toggle button to display town names.
+	SM_WIDGET_SELECT_BUTTONS,    ///< Selection widget for the buttons present in some smallmap modes.
+	SM_WIDGET_ENABLE_ALL,        ///< Button to enable display of all legend entries.
+	SM_WIDGET_DISABLE_ALL,       ///< Button to disable display of all legend entries.
+	SM_WIDGET_SHOW_HEIGHT,       ///< Show heightmap toggle button.
+};
+
+/** Class managing the smallmap window. */
+class SmallMapWindow : public Window {
+protected:
+	/** Types of legends in the #SM_WIDGET_LEGEND widget. */
+	enum SmallMapType {
+		SMT_CONTOUR,
+		SMT_VEHICLES,
+		SMT_INDUSTRY,
+		SMT_ROUTES,
+		SMT_VEGETATION,
+		SMT_OWNER,
+	};
+
+	/** Available kinds of zoomlevel changes. */
+	enum ZoomLevelChange {
+		ZLC_INITIALIZE, ///< Initialize zoom level.
+		ZLC_ZOOM_OUT,   ///< Zoom out.
+		ZLC_ZOOM_IN,    ///< Zoom in.
+	};
+
+	static SmallMapType map_type; ///< Currently displayed legends.
+	static bool show_towns;       ///< Display town names in the smallmap.
+
+	static const uint LEGEND_BLOB_WIDTH = 8;              ///< Width of the coloured blob in front of a line text in the #SM_WIDGET_LEGEND widget.
+	static const uint INDUSTRY_MIN_NUMBER_OF_COLUMNS = 2; ///< Minimal number of columns in the #SM_WIDGET_LEGEND widget for the #SMT_INDUSTRY legend.
+	static const uint8 FORCE_REFRESH_PERIOD = 0x1F; ///< map is redrawn after that many ticks
+
+	uint min_number_of_fixed_rows; ///< Minimal number of rows in the legends for the fixed layouts only (all except #SMT_INDUSTRY).
+	uint column_width;             ///< Width of a column in the #SM_WIDGET_LEGEND widget.
+
+	int32 scroll_x;  ///< Horizontal world coordinate of the base tile left of the top-left corner of the smallmap display.
+	int32 scroll_y;  ///< Vertical world coordinate of the base tile left of the top-left corner of the smallmap display.
+	int32 subscroll; ///< Number of pixels (0..3) between the right end of the base tile and the pixel at the top-left corner of the smallmap display.
+	int zoom;        ///< Zoom level. Bigger number means more zoom-out (further away).
+
+	uint8 refresh;   ///< Refresh counter, zeroed every FORCE_REFRESH_PERIOD ticks.
+
+	/**
+	 * Draws vertical part of map indicator
+	 * @param x X coord of left/right border of main viewport
+	 * @param y Y coord of top border of main viewport
+	 * @param y2 Y coord of bottom border of main viewport
+	 */
+	static inline void DrawVertMapIndicator(int x, int y, int y2)
+	{
+		GfxFillRect(x, y,      x, y + 3, 69);
+		GfxFillRect(x, y2 - 3, x, y2,    69);
+	}
+
+	/**
+	 * Draws horizontal part of map indicator
+	 * @param x X coord of left border of main viewport
+	 * @param x2 X coord of right border of main viewport
+	 * @param y Y coord of top/bottom border of main viewport
+	 */
+	static inline void DrawHorizMapIndicator(int x, int x2, int y)
+	{
+		GfxFillRect(x,      y, x + 3, y, 69);
+		GfxFillRect(x2 - 3, y, x2,    y, 69);
+	}
+
+	void DrawMapIndicators() const;
+	void DrawSmallMapColumn(void *dst, uint xc, uint yc, int pitch, int reps, int start_pos, int end_pos, Blitter *blitter) const;
+	void DrawVehicles(const DrawPixelInfo *dpi, Blitter *blitter) const;
+	void DrawTowns(const DrawPixelInfo *dpi) const;
+	void DrawSmallMap(DrawPixelInfo *dpi) const;
+
+	Point RemapTile(int tile_x, int tile_y) const;
+	Point PixelToTile(int px, int py, int *sub, bool add_sub = true) const;
+	Point ComputeScroll(int tx, int ty, int x, int y, int *sub);
+	void SetZoomLevel(ZoomLevelChange change, const Point *zoom_pt);
+	void SetupWidgetData();
+	uint32 GetTileColours(const TileArea &ta) const;
+
+public:
+	uint min_number_of_columns;    ///< Minimal number of columns in legends.
+
+	SmallMapWindow(const WindowDesc *desc, int window_number);
+
+	/**
+	 * Compute minimal required width of the legends.
+	 * @return Minimally needed width for displaying the smallmap legends in pixels.
+	 */
+	inline uint GetMinLegendWidth() const
+	{
+		return WD_FRAMERECT_LEFT + this->min_number_of_columns * this->column_width;
+	}
+
+	/**
+	 * Return number of columns that can be displayed in \a width pixels.
+	 * @return Number of columns to display.
+	 */
+	inline uint GetNumberColumnsLegend(uint width) const
+	{
+		return width / this->column_width;
+	}
+
+	/**
+	 * Compute height given a number of columns.
+	 * @param Number of columns.
+	 * @return Needed height for displaying the smallmap legends in pixels.
+	 */
+	inline uint GetLegendHeight(uint num_columns) const
+	{
+		return WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM +
+				this->GetNumberRowsLegend(num_columns) * FONT_HEIGHT_SMALL;
+	}
+
+	uint GetNumberRowsLegend(uint columns) const;
+	void SwitchMapType(SmallMapType map_type);
+	void SetNewScroll(int sx, int sy, int sub);
+	void SelectLegendItem(int click_pos, LegendAndColour *legend, int end_legend_item, int begin_legend_item = 0);
+	void SmallMapCenterOnCurrentPos();
+
+	virtual void SetStringParameters(int widget) const;
+	virtual void OnInit();
+	virtual void OnPaint();
+	virtual void DrawWidget(const Rect &r, int widget) const;
+	virtual void OnClick(Point pt, int widget, int click_count);
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true);
+	virtual bool OnRightClick(Point pt, int widget);
+	virtual void OnMouseWheel(int wheel);
+	virtual void OnTick();
+	virtual void OnScroll(Point delta);
+};
+
 #endif /* SMALLMAP_GUI_H */
