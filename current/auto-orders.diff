diff --git a/src/order_base.h b/src/order_base.h
index 47f0b6d..6503c29 100644
--- a/src/order_base.h
+++ b/src/order_base.h
@@ -124,6 +124,12 @@ public:
 	void MakeConditional(VehicleOrderID order);
 
 	/**
+	 * Makes this order an automatic order.
+	 * @param destination the station to go to.
+	 */
+	void MakeAutomatic(StationID destination);
+
+	/**
 	 * Gets the destination of this order.
 	 * @pre IsType(OT_GOTO_WAYPOINT) || IsType(OT_GOTO_DEPOT) || IsType(OT_GOTO_STATION).
 	 * @return the destination of the order.
@@ -254,6 +260,9 @@ public:
 	void ConvertFromOldSavegame();
 };
 
+void InsertOrder(Vehicle *v, Order *new_o, VehicleOrderID sel_ord);
+void DeleteOrder(Vehicle *v, VehicleOrderID sel_ord);
+
 /**
  * Shared order list linking together the linked list of orders and the list
  *  of vehicles sharing this order list.
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
index ba8d51f..9c1eaa0 100644
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -99,6 +99,12 @@ void Order::MakeConditional(VehicleOrderID order)
 	this->dest = 0;
 }
 
+void Order::MakeAutomatic(StationID destination)
+{
+	this->type = OT_AUTOMATIC;
+	this->dest = destination;
+}
+
 void Order::SetRefit(CargoID cargo, byte subtype)
 {
 	this->refit_cargo = cargo;
@@ -663,53 +669,63 @@ CommandCost CmdInsertOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 	if (flags & DC_EXEC) {
 		Order *new_o = new Order();
 		new_o->AssignOrder(new_order);
+		InsertOrder(v, new_o, sel_ord);
+	}
 
-		/* Create new order and link in list */
-		if (v->orders.list == NULL) {
-			v->orders.list = new OrderList(new_o, v);
-		} else {
-			v->orders.list->InsertOrderAt(new_o, sel_ord);
-		}
+	return CommandCost();
+}
 
-		Vehicle *u = v->FirstShared();
-		DeleteOrderWarnings(u);
-		for (; u != NULL; u = u->NextShared()) {
-			assert(v->orders.list == u->orders.list);
+/**
+ * Insert a new order but skip the validation.
+ * @param v the vehicle to insert the order to
+ * @param new_o the new order
+ * @param sel_ord the position the order should be inserted at
+ */
+void InsertOrder(Vehicle *v, Order *new_o, VehicleOrderID sel_ord)
+{
+	/* Create new order and link in list */
+	if (v->orders.list == NULL) {
+		v->orders.list = new OrderList(new_o, v);
+	} else {
+		v->orders.list->InsertOrderAt(new_o, sel_ord);
+	}
 
-			/* If there is added an order before the current one, we need
-			to update the selected order */
-			if (sel_ord <= u->cur_order_index) {
-				uint cur = u->cur_order_index + 1;
-				/* Check if we don't go out of bound */
-				if (cur < u->GetNumOrders()) {
-					u->cur_order_index = cur;
-				}
+	Vehicle *u = v->FirstShared();
+	DeleteOrderWarnings(u);
+	for (; u != NULL; u = u->NextShared()) {
+		assert(v->orders.list == u->orders.list);
+
+		/* If there is added an order before the current one, we need
+		to update the selected order */
+		if (sel_ord <= u->cur_order_index) {
+			uint cur = u->cur_order_index + 1;
+			/* Check if we don't go out of bound */
+			if (cur < u->GetNumOrders()) {
+				u->cur_order_index = cur;
 			}
-			/* Update any possible open window of the vehicle */
-			InvalidateVehicleOrder(u, INVALID_VEH_ORDER_ID | (sel_ord << 8));
 		}
+		/* Update any possible open window of the vehicle */
+		InvalidateVehicleOrder(u, INVALID_VEH_ORDER_ID | (sel_ord << 8));
+	}
 
-		/* As we insert an order, the order to skip to will be 'wrong'. */
-		VehicleOrderID cur_order_id = 0;
-		Order *order;
-		FOR_VEHICLE_ORDERS(v, order) {
-			if (order->IsType(OT_CONDITIONAL)) {
-				VehicleOrderID order_id = order->GetConditionSkipToOrder();
-				if (order_id >= sel_ord) {
-					order->SetConditionSkipToOrder(order_id + 1);
-				}
-				if (order_id == cur_order_id) {
-					order->SetConditionSkipToOrder((order_id + 1) % v->GetNumOrders());
-				}
+	/* As we insert an order, the order to skip to will be 'wrong'. */
+	VehicleOrderID cur_order_id = 0;
+	Order *order;
+	FOR_VEHICLE_ORDERS(v, order) {
+		if (order->IsType(OT_CONDITIONAL)) {
+			VehicleOrderID order_id = order->GetConditionSkipToOrder();
+			if (order_id >= sel_ord) {
+				order->SetConditionSkipToOrder(order_id + 1);
+			}
+			if (order_id == cur_order_id) {
+				order->SetConditionSkipToOrder((order_id + 1) % v->GetNumOrders());
 			}
-			cur_order_id++;
 		}
-
-		/* Make sure to rebuild the whole list */
-		InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
+		cur_order_id++;
 	}
 
-	return CommandCost();
+	/* Make sure to rebuild the whole list */
+	InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
 }
 
 /**
@@ -755,48 +771,56 @@ CommandCost CmdDeleteOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 	order = v->GetOrder(sel_ord);
 	if (order == NULL) return CMD_ERROR;
 
-	if (flags & DC_EXEC) {
-		v->orders.list->DeleteOrderAt(sel_ord);
+	if (flags & DC_EXEC) DeleteOrder(v, sel_ord);
+	return CommandCost();
+}
 
-		Vehicle *u = v->FirstShared();
-		DeleteOrderWarnings(u);
-		for (; u != NULL; u = u->NextShared()) {
-			if (sel_ord < u->cur_order_index) u->cur_order_index--;
+/**
+ * Delete an order but skip the parameter validation
+ * @param v the vehicle to delete the order from
+ * @param sel_ord the id of the order to be deleted
+ */
+void DeleteOrder(Vehicle *v, VehicleOrderID sel_ord)
+{
+	v->orders.list->DeleteOrderAt(sel_ord);
+
+	Vehicle *u = v->FirstShared();
+	DeleteOrderWarnings(u);
+	for (; u != NULL; u = u->NextShared()) {
+		if (sel_ord < u->cur_order_index) u->cur_order_index--;
+
+		assert(v->orders.list == u->orders.list);
+
+		/* NON-stop flag is misused to see if a train is in a station that is
+		 * on his order list or not */
+		if (sel_ord == u->cur_order_index && u->current_order.IsType(OT_LOADING)) {
+			u->current_order.SetNonStopType(ONSF_STOP_EVERYWHERE);
+			/* When full loading, "cancel" that order so the vehicle doesn't
+			 * stay indefinitely at this station anymore. */
+			if (u->current_order.GetLoadType() & OLFB_FULL_LOAD) u->current_order.SetLoadType(OLF_LOAD_IF_POSSIBLE);
+		}
 
-			assert(v->orders.list == u->orders.list);
+		/* Update any possible open window of the vehicle */
+		InvalidateVehicleOrder(u, sel_ord | (INVALID_VEH_ORDER_ID << 8));
+	}
 
-			/* NON-stop flag is misused to see if a train is in a station that is
-			 * on his order list or not */
-			if (sel_ord == u->cur_order_index && u->current_order.IsType(OT_LOADING)) {
-				u->current_order.SetNonStopType(ONSF_STOP_EVERYWHERE);
-				/* When full loading, "cancel" that order so the vehicle doesn't
-				 * stay indefinitely at this station anymore. */
-				if (u->current_order.GetLoadType() & OLFB_FULL_LOAD) u->current_order.SetLoadType(OLF_LOAD_IF_POSSIBLE);
+	/* As we delete an order, the order to skip to will be 'wrong'. */
+	VehicleOrderID cur_order_id = 0;
+	Order *order = NULL;
+	FOR_VEHICLE_ORDERS(v, order) {
+		if (order->IsType(OT_CONDITIONAL)) {
+			VehicleOrderID order_id = order->GetConditionSkipToOrder();
+			if (order_id >= sel_ord) {
+				order->SetConditionSkipToOrder(max(order_id - 1, 0));
 			}
-
-			/* Update any possible open window of the vehicle */
-			InvalidateVehicleOrder(u, sel_ord | (INVALID_VEH_ORDER_ID << 8));
-		}
-
-		/* As we delete an order, the order to skip to will be 'wrong'. */
-		VehicleOrderID cur_order_id = 0;
-		FOR_VEHICLE_ORDERS(v, order) {
-			if (order->IsType(OT_CONDITIONAL)) {
-				VehicleOrderID order_id = order->GetConditionSkipToOrder();
-				if (order_id >= sel_ord) {
-					order->SetConditionSkipToOrder(max(order_id - 1, 0));
-				}
-				if (order_id == cur_order_id) {
-					order->SetConditionSkipToOrder((order_id + 1) % v->GetNumOrders());
-				}
+			if (order_id == cur_order_id) {
+				order->SetConditionSkipToOrder((order_id + 1) % v->GetNumOrders());
 			}
-			cur_order_id++;
 		}
-
-		InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
+		cur_order_id++;
 	}
 
-	return CommandCost();
+	InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
 }
 
 /**
@@ -1637,7 +1661,15 @@ bool UpdateOrderDest(Vehicle *v, const Order *order, int conditional_depth)
 	assert(v->cur_order_index < v->GetNumOrders());
 
 	/* Get the current order */
-	order = v->GetOrder(v->cur_order_index);
+	order = v->GetNextManualOrder(v->cur_order_index);
+	if (order == NULL) {
+		order = v->GetNextManualOrder(0);
+		if (order == NULL) {
+			v->current_order.Free();
+			v->dest_tile = 0;
+			return false;
+		}
+	}
 	v->current_order = *order;
 	return UpdateOrderDest(v, order, conditional_depth + 1);
 }
@@ -1692,7 +1724,7 @@ bool ProcessOrders(Vehicle *v)
 	/* Get the current order */
 	if (v->cur_order_index >= v->GetNumOrders()) v->cur_order_index = 0;
 
-	const Order *order = v->GetOrder(v->cur_order_index);
+	const Order *order = v->GetNextManualOrder(v->cur_order_index);
 
 	/* If no order, do nothing. */
 	if (order == NULL || (v->type == VEH_AIRCRAFT && !CheckForValidOrders(v))) {
diff --git a/src/order_gui.cpp b/src/order_gui.cpp
index a3ed0ce..8a15865 100644
--- a/src/order_gui.cpp
+++ b/src/order_gui.cpp
@@ -200,8 +200,15 @@ void DrawOrderString(const Vehicle *v, const Order *order, int order_index, int
 		DrawSprite(sprite, PAL_NONE, rtl ? right - sprite_size.width : left, y + ((int)FONT_HEIGHT_NORMAL - (int)sprite_size.height) / 2);
 	}
 
+	TextColour colour = TC_BLACK;
+	if (order->IsType(OT_AUTOMATIC)) {
+		colour =  selected ? TC_SILVER : TC_GREY;
+	} else if (selected) {
+		colour = TC_WHITE;
+	}
+
 	SetDParam(0, order_index + 1);
-	DrawString(left, rtl ? right - sprite_size.width - 3 : middle, y, STR_ORDER_INDEX, selected ? TC_WHITE : TC_BLACK, SA_RIGHT | SA_FORCE);
+	DrawString(left, rtl ? right - sprite_size.width - 3 : middle, y, STR_ORDER_INDEX, colour, SA_RIGHT | SA_FORCE);
 
 	SetDParam(5, STR_EMPTY);
 
@@ -211,6 +218,13 @@ void DrawOrderString(const Vehicle *v, const Order *order, int order_index, int
 			SetDParam(1, order->GetDestination());
 			break;
 
+		case OT_AUTOMATIC:
+			SetDParam(0, STR_ORDER_GO_TO_STATION);
+			SetDParam(1, STR_ORDER_GO_TO);
+			SetDParam(2, order->GetDestination());
+			SetDParam(3, STR_EMPTY);
+			break;
+
 		case OT_GOTO_STATION: {
 			OrderLoadFlags load = order->GetLoadType();
 			OrderUnloadFlags unload = order->GetUnloadType();
@@ -298,7 +312,7 @@ void DrawOrderString(const Vehicle *v, const Order *order, int order_index, int
 		default: NOT_REACHED();
 	}
 
-	DrawString(rtl ? left : middle, rtl ? middle : right, y, STR_ORDER_TEXT, selected ? TC_WHITE : TC_BLACK);
+	DrawString(rtl ? left : middle, rtl ? middle : right, y, STR_ORDER_TEXT, colour);
 }
 
 
diff --git a/src/order_type.h b/src/order_type.h
index 7b252ad..6d9b0f0 100644
--- a/src/order_type.h
+++ b/src/order_type.h
@@ -38,6 +38,7 @@ enum OrderType {
 	OT_DUMMY         = 5,
 	OT_GOTO_WAYPOINT = 6,
 	OT_CONDITIONAL   = 7,
+	OT_AUTOMATIC     = 8,
 	OT_END
 };
 
diff --git a/src/timetable_cmd.cpp b/src/timetable_cmd.cpp
index 0f8fc39..2d552d6 100644
--- a/src/timetable_cmd.cpp
+++ b/src/timetable_cmd.cpp
@@ -238,6 +238,7 @@ void UpdateVehicleTimetable(Vehicle *v, bool travelling)
 	v->current_order_time = 0;
 
 	if (!_settings_game.order.timetabling) return;
+	if (v->current_order.IsType(OT_AUTOMATIC)) return; // no timetabling of auto orders
 
 	bool just_started = false;
 
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index bc54690..efe1328 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -1231,7 +1231,7 @@ void VehicleEnterDepot(Vehicle *v)
 	if (v->current_order.IsType(OT_GOTO_DEPOT)) {
 		SetWindowDirty(WC_VEHICLE_VIEW, v->index);
 
-		const Order *real_order = v->GetOrder(v->cur_order_index);
+		const Order *real_order = v->GetNextManualOrder(v->cur_order_index);
 		Order t = v->current_order;
 		v->current_order.MakeDummy();
 
@@ -1747,6 +1747,12 @@ void Vehicle::BeginLoading()
 		current_order.MakeLoading(true);
 		UpdateVehicleTimetable(this, true);
 
+		for (Order *order = this->GetOrder(this->cur_order_index);
+				order != NULL && order->IsType(OT_AUTOMATIC);
+				order = order->next) {
+			DeleteOrder(this, this->cur_order_index);
+		}
+
 		/* Furthermore add the Non Stop flag to mark that this station
 		 * is the actual destination of the vehicle, which is (for example)
 		 * necessary to be known for HandleTrainLoading to determine
@@ -1755,6 +1761,15 @@ void Vehicle::BeginLoading()
 		this->current_order.SetNonStopType(ONSF_NO_STOP_AT_ANY_STATION);
 
 	} else {
+		Order *in_list = this->GetOrder(this->cur_order_index);
+		if ((in_list == NULL && this->cur_order_index == 0) || 
+				(in_list != NULL && (!in_list->IsType(OT_AUTOMATIC) || 
+				in_list->GetDestination() != this->last_station_visited))) {
+			Order *auto_order = new Order();
+			auto_order->MakeAutomatic(this->last_station_visited);
+			InsertOrder(this, auto_order, this->cur_order_index);
+			if (this->cur_order_index > 0) --this->cur_order_index;
+		}
 		current_order.MakeLoading(false);
 	}
 
@@ -1812,7 +1827,7 @@ void Vehicle::HandleLoading(bool mode)
 			this->LeaveStation();
 
 			/* If this was not the final order, don't remove it from the list. */
-			if (!at_destination_station) return;
+			if (!at_destination_station) break;
 			break;
 		}
 
@@ -2143,6 +2158,20 @@ void Vehicle::RemoveFromShared()
 	this->previous_shared = NULL;
 }
 
+/**
+ * Get the next manual (not OT_AUTOMATIC) order after the one at the given index.
+ * @param index the index to start searching at
+ * @return the next manual order at or after index or NULL if there is none.
+ */
+Order *Vehicle::GetNextManualOrder(int index) const
+{
+	Order *order = this->GetOrder(index);
+	while(order != NULL && order->IsType(OT_AUTOMATIC)) {
+		order = order->next;
+	}
+	return order;
+}
+
 void StopAllVehicles()
 {
 	Vehicle *v;
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index 381a5e3..2d59c37 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -662,6 +662,8 @@ public:
 		return (this->orders.list == NULL) ? NULL : this->orders.list->GetOrderAt(index);
 	}
 
+	Order *GetNextManualOrder(int index) const;
+
 	/**
 	 * Returns the last order of a vehicle, or NULL if it doesn't exists
 	 * @return last order of a vehicle, if available
