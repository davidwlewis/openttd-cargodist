diff --git a/docs/linkgraph.txt b/docs/linkgraph.txt
new file mode 100644
index 0000000..ddb125a
--- /dev/null
+++ b/docs/linkgraph.txt
@@ -0,0 +1,30 @@
+Some clarifications about the link graph
+----------------------------------------
+
+InitializeLinkGraphs joins all threads, so if the game is abendoned
+with some threads still running, they're joined as soon as the next game
+(possibly the title game) is started. see also InitializeGame.
+
+The MCF algorithm can be quite CPU-hungry as it's NP-hard and takes
+exponential time (though with a very small constant factor) in the number
+of nodes.
+This is why it is run in a separate thread where possible. However after
+some time the thread is joined and if it hasn't finished by then the game
+will hang. This problem gets worse if we are running on a platform without
+threads. However, as those are usually the ones with less CPU power I
+assume the contention for the CPU would make the game hard to play even
+with threads or even without cargodist (autosave ...). I might be wrong,
+but I won't put any work into this before someone shows me some problem.
+
+You can configure the link graph recalculation interval. A link graph
+recalculation interval of X days means that each link graph job has X days
+to run before it is joined. The downside is that the flow stats won't be
+updated before the job is finished and thus a long interval means less
+updates and longer times until changes in capacities are accounted for.
+If you play a very large map with a complicated link graph you may want to
+raise the interval to avoid lags. The same holds for systems with slow
+CPUs.
+
+Another option to avoid excessive lags is to reduce the accuracy of link
+graph calculations. Generally the accurace is inversely correlated to the
+CPU requirements of the MCF algorithm.
diff --git a/projects/openttd_vs100.vcxproj b/projects/openttd_vs100.vcxproj
index 7584a8c..06efd66 100644
--- a/projects/openttd_vs100.vcxproj
+++ b/projects/openttd_vs100.vcxproj
@@ -327,6 +327,10 @@
     <ClCompile Include="..\src\ini.cpp" />
     <ClCompile Include="..\src\ini_load.cpp" />
     <ClCompile Include="..\src\landscape.cpp" />
+    <ClCompile Include="..\src\linkgraph\demands.cpp" />
+    <ClCompile Include="..\src\linkgraph\flowmapper.cpp" />
+    <ClCompile Include="..\src\linkgraph\linkgraph.cpp" />
+    <ClCompile Include="..\src\linkgraph\mcf.cpp" />
     <ClCompile Include="..\src\map.cpp" />
     <ClCompile Include="..\src\misc.cpp" />
     <ClCompile Include="..\src\mixer.cpp" />
@@ -455,10 +459,18 @@
     <ClInclude Include="..\src\landscape.h" />
     <ClInclude Include="..\src\landscape_type.h" />
     <ClInclude Include="..\src\language.h" />
+    <ClInclude Include="..\src\linkgraph_gui.h" />
+    <ClInclude Include="..\src\linkgraph\demands.h" />
+    <ClInclude Include="..\src\linkgraph\flowmapper.h" />
+    <ClInclude Include="..\src\linkgraph\linkgraph.h" />
+    <ClInclude Include="..\src\linkgraph\linkgraph_type.h" />
+    <ClInclude Include="..\src\linkgraph\mcf.h" />
     <ClInclude Include="..\src\livery.h" />
     <ClInclude Include="..\src\map_func.h" />
     <ClInclude Include="..\src\map_type.h" />
     <ClInclude Include="..\src\mixer.h" />
+    <ClInclude Include="..\src\moving_average.h" />
+    <ClCompile Include="..\src\moving_average.cpp" />
     <ClInclude Include="..\src\network\network.h" />
     <ClInclude Include="..\src\network\network_admin.h" />
     <ClInclude Include="..\src\network\network_base.h" />
@@ -619,6 +631,7 @@
     <ClCompile Include="..\src\core\math_func.cpp" />
     <ClInclude Include="..\src\core\math_func.hpp" />
     <ClInclude Include="..\src\core\mem_func.hpp" />
+    <ClInclude Include="..\src\core\multimap.hpp" />
     <ClInclude Include="..\src\core\overflowsafe_type.hpp" />
     <ClCompile Include="..\src\core\pool_func.cpp" />
     <ClInclude Include="..\src\core\pool_func.hpp" />
@@ -648,6 +661,7 @@
     <ClCompile Include="..\src\highscore_gui.cpp" />
     <ClCompile Include="..\src\industry_gui.cpp" />
     <ClCompile Include="..\src\intro_gui.cpp" />
+    <ClCompile Include="..\src\linkgraph_gui.cpp" />
     <ClCompile Include="..\src\main_gui.cpp" />
     <ClCompile Include="..\src\misc_gui.cpp" />
     <ClCompile Include="..\src\music_gui.cpp" />
@@ -725,6 +739,7 @@
     <ClCompile Include="..\src\saveload\group_sl.cpp" />
     <ClCompile Include="..\src\saveload\industry_sl.cpp" />
     <ClCompile Include="..\src\saveload\labelmaps_sl.cpp" />
+    <ClCompile Include="..\src\saveload\linkgraph_sl.cpp" />
     <ClCompile Include="..\src\saveload\map_sl.cpp" />
     <ClCompile Include="..\src\saveload\misc_sl.cpp" />
     <ClCompile Include="..\src\saveload\newgrf_sl.cpp" />
diff --git a/projects/openttd_vs100.vcxproj.filters b/projects/openttd_vs100.vcxproj.filters
index 0020eb1..f020b56 100644
--- a/projects/openttd_vs100.vcxproj.filters
+++ b/projects/openttd_vs100.vcxproj.filters
@@ -201,6 +201,18 @@
     <ClCompile Include="..\src\landscape.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\linkgraph\demands.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\linkgraph\flowmapper.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\linkgraph\linkgraph.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\linkgraph\mcf.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -585,6 +597,24 @@
     <ClInclude Include="..\src\language.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\linkgraph_gui.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\demands.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\flowmapper.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\linkgraph.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\linkgraph_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\mcf.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\livery.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -597,6 +627,12 @@
     <ClInclude Include="..\src\mixer.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\moving_average.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClCompile Include="..\src\moving_average.cpp">
+      <Filter>Header Files</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\network\network.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -1077,6 +1113,9 @@
     <ClInclude Include="..\src\core\mem_func.hpp">
       <Filter>Core Source Code</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\core\multimap.hpp">
+      <Filter>Core Source Code</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\core\overflowsafe_type.hpp">
       <Filter>Core Source Code</Filter>
     </ClInclude>
@@ -1164,6 +1203,9 @@
     <ClCompile Include="..\src\intro_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\linkgraph_gui.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\main_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
@@ -1395,6 +1437,9 @@
     <ClCompile Include="..\src\saveload\labelmaps_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\saveload\linkgraph_sl.cpp">
+      <Filter>Save/Load handlers</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\saveload\map_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
diff --git a/projects/openttd_vs80.vcproj b/projects/openttd_vs80.vcproj
index fb84d3e..d0be3da 100644
--- a/projects/openttd_vs80.vcproj
+++ b/projects/openttd_vs80.vcproj
@@ -579,6 +579,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1095,6 +1111,30 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -1111,6 +1151,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -1755,6 +1803,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\core\multimap.hpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\core\overflowsafe_type.hpp"
 				>
 			</File>
@@ -1875,6 +1927,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\main_gui.cpp"
 				>
 			</File>
@@ -2195,6 +2251,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
diff --git a/projects/openttd_vs90.vcproj b/projects/openttd_vs90.vcproj
index 0ee6932..93258cb 100644
--- a/projects/openttd_vs90.vcproj
+++ b/projects/openttd_vs90.vcproj
@@ -576,6 +576,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1092,6 +1108,30 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -1108,6 +1148,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -1752,6 +1800,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\core\multimap.hpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\core\overflowsafe_type.hpp"
 				>
 			</File>
@@ -1872,6 +1924,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\main_gui.cpp"
 				>
 			</File>
@@ -2192,6 +2248,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
diff --git a/source.list b/source.list
index 970a53d..d776f17 100644
--- a/source.list
+++ b/source.list
@@ -35,6 +35,10 @@ hotkeys.cpp
 ini.cpp
 ini_load.cpp
 landscape.cpp
+linkgraph/demands.cpp
+linkgraph/flowmapper.cpp
+linkgraph/linkgraph.cpp
+linkgraph/mcf.cpp
 map.cpp
 misc.cpp
 mixer.cpp
@@ -188,10 +192,18 @@ ini_type.h
 landscape.h
 landscape_type.h
 language.h
+linkgraph_gui.h
+linkgraph/demands.h
+linkgraph/flowmapper.h
+linkgraph/linkgraph.h
+linkgraph/linkgraph_type.h
+linkgraph/mcf.h
 livery.h
 map_func.h
 map_type.h
 mixer.h
+moving_average.h
+moving_average.cpp
 network/network.h
 network/network_admin.h
 network/network_base.h
@@ -369,6 +381,7 @@ core/geometry_type.hpp
 core/math_func.cpp
 core/math_func.hpp
 core/mem_func.hpp
+core/multimap.hpp
 core/overflowsafe_type.hpp
 core/pool_func.cpp
 core/pool_func.hpp
@@ -400,6 +413,7 @@ group_gui.cpp
 highscore_gui.cpp
 industry_gui.cpp
 intro_gui.cpp
+linkgraph_gui.cpp
 main_gui.cpp
 misc_gui.cpp
 music_gui.cpp
@@ -483,6 +497,7 @@ saveload/gamelog_sl.cpp
 saveload/group_sl.cpp
 saveload/industry_sl.cpp
 saveload/labelmaps_sl.cpp
+saveload/linkgraph_sl.cpp
 saveload/map_sl.cpp
 saveload/misc_sl.cpp
 saveload/newgrf_sl.cpp
diff --git a/src/aircraft_cmd.cpp b/src/aircraft_cmd.cpp
index 098e30c..2c6b1e0 100644
--- a/src/aircraft_cmd.cpp
+++ b/src/aircraft_cmd.cpp
@@ -267,6 +267,7 @@ CommandCost CmdBuildAircraft(TileIndex tile, DoCommandFlag flags, const Engine *
 
 		v->name = NULL;
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 
 		v->acceleration = avi->acceleration;
 		v->engine_type = e->index;
diff --git a/src/autoreplace_cmd.cpp b/src/autoreplace_cmd.cpp
index 19a740d..e6307a1 100644
--- a/src/autoreplace_cmd.cpp
+++ b/src/autoreplace_cmd.cpp
@@ -119,7 +119,7 @@ static void TransferCargo(Vehicle *old_veh, Vehicle *new_head, bool part_of_chai
 			uint amount = min(src->cargo.Count(), dest->cargo_cap - dest->cargo.Count());
 			if (amount <= 0) continue;
 
-			src->cargo.MoveTo(&dest->cargo, amount, VehicleCargoList::MTA_UNLOAD, NULL);
+			src->cargo.MoveTo(&dest->cargo, amount);
 		}
 	}
 
diff --git a/src/cargopacket.cpp b/src/cargopacket.cpp
index 55c62cd..5ba4957 100644
--- a/src/cargopacket.cpp
+++ b/src/cargopacket.cpp
@@ -10,7 +10,9 @@
 /** @file cargopacket.cpp Implementation of the cargo packets. */
 
 #include "stdafx.h"
+#include "station_base.h"
 #include "core/pool_func.hpp"
+#include "core/random_func.hpp"
 #include "economy_base.h"
 
 /* Initialize the cargopacket-pool */
@@ -138,8 +140,8 @@ FORCEINLINE void CargoPacket::Merge(CargoPacket *cp)
 /**
  * Destroy the cargolist ("frees" all cargo packets).
  */
-template <class Tinst>
-CargoList<Tinst>::~CargoList()
+template <class Tinst, class Tcont>
+CargoList<Tinst, Tcont>::~CargoList()
 {
 	for (Iterator it(this->packets.begin()); it != this->packets.end(); ++it) {
 		delete *it;
@@ -150,8 +152,8 @@ CargoList<Tinst>::~CargoList()
  * Empty the cargo list, but don't free the cargo packets;
  * the cargo packets are cleaned by CargoPacket's CleanPool.
  */
-template <class Tinst>
-void CargoList<Tinst>::OnCleanPool()
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::OnCleanPool()
 {
 	this->packets.clear();
 }
@@ -161,8 +163,8 @@ void CargoList<Tinst>::OnCleanPool()
  * Decreases count and days_in_transit.
  * @param cp Packet to be removed from cache.
  */
-template <class Tinst>
-void CargoList<Tinst>::RemoveFromCache(const CargoPacket *cp)
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::RemoveFromCache(const CargoPacket *cp)
 {
 	this->count                 -= cp->count;
 	this->cargo_days_in_transit -= cp->days_in_transit * cp->count;
@@ -173,8 +175,8 @@ void CargoList<Tinst>::RemoveFromCache(const CargoPacket *cp)
  * Increases count and days_in_transit.
  * @param cp New packet to be inserted.
  */
-template <class Tinst>
-void CargoList<Tinst>::AddToCache(const CargoPacket *cp)
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::AddToCache(const CargoPacket *cp)
 {
 	this->count                 += cp->count;
 	this->cargo_days_in_transit += cp->days_in_transit * cp->count;
@@ -186,17 +188,17 @@ void CargoList<Tinst>::AddToCache(const CargoPacket *cp)
  * @warning After appending this packet may not exist anymore!
  * @note Do not use the cargo packet anymore after it has been appended to this CargoList!
  * @param cp Cargo packet to add.
+ * @param update_cache If false, the cache is not updated; used when loading from
+ *        the reservation list.
  * @pre cp != NULL
  */
-template <class Tinst>
-void CargoList<Tinst>::Append(CargoPacket *cp)
+void VehicleCargoList::Append(CargoPacket *cp, bool update_cache)
 {
 	assert(cp != NULL);
-	static_cast<Tinst *>(this)->AddToCache(cp);
-
-	for (List::reverse_iterator it(this->packets.rbegin()); it != this->packets.rend(); it++) {
+	if (update_cache) this->AddToCache(cp);
+	for (CargoPacketList::reverse_iterator it(this->packets.rbegin()); it != this->packets.rend(); it++) {
 		CargoPacket *icp = *it;
-		if (Tinst::AreMergable(icp, cp) && icp->count + cp->count <= CargoPacket::MAX_COUNT) {
+		if (VehicleCargoList::AreMergable(icp, cp) && icp->count + cp->count <= CargoPacket::MAX_COUNT) {
 			icp->Merge(cp);
 			return;
 		}
@@ -211,8 +213,8 @@ void CargoList<Tinst>::Append(CargoPacket *cp)
  * first count cargo entities and removes the rest.
  * @param max_remaining Maximum amount of entities to be in the list after the command.
  */
-template <class Tinst>
-void CargoList<Tinst>::Truncate(uint max_remaining)
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::Truncate(uint max_remaining)
 {
 	for (Iterator it(packets.begin()); it != packets.end(); /* done during loop*/) {
 		CargoPacket *cp = *it;
@@ -239,117 +241,424 @@ void CargoList<Tinst>::Truncate(uint max_remaining)
 }
 
 /**
- * Moves the given amount of cargo to another list.
- * Depending on the value of mta the side effects of this function differ:
- *  - MTA_FINAL_DELIVERY: Destroys the packets that do not originate from a specific station.
- *  - MTA_CARGO_LOAD:     Sets the loaded_at_xy value of the moved packets.
- *  - MTA_TRANSFER:       Just move without side effects.
- *  - MTA_UNLOAD:         Just move without side effects.
- * @param dest  Destination to move the cargo to.
- * @param count Amount of cargo entities to move.
- * @param mta   How to handle the moving (side effects).
- * @param data  Depending on mta the data of this variable differs:
- *              - MTA_FINAL_DELIVERY - Station ID of packet's origin not to remove.
- *              - MTA_CARGO_LOAD     - Station's tile index of load.
- *              - MTA_TRANSFER       - Unused.
- *              - MTA_UNLOAD         - Unused.
- * @param payment The payment helper.
- *
- * @pre mta == MTA_FINAL_DELIVERY || dest != NULL
- * @pre mta == MTA_UNLOAD || mta == MTA_CARGO_LOAD || payment != NULL
- * @return True if there are still packets that might be moved from this cargo list.
+ * Reserves a packet for later loading and adds it to the cache.
+ * @param cp Packet to be reserved.
  */
-template <class Tinst>
-template <class Tother_inst>
-bool CargoList<Tinst>::MoveTo(Tother_inst *dest, uint max_move, MoveToAction mta, CargoPayment *payment, uint data)
+void VehicleCargoList::Reserve(CargoPacket *cp)
 {
-	assert(mta == MTA_FINAL_DELIVERY || dest != NULL);
-	assert(mta == MTA_UNLOAD || mta == MTA_CARGO_LOAD || payment != NULL);
+	assert(cp != NULL);
+	this->AddToCache(cp);
+	this->reserved_count += cp->count;
+	this->reserved.push_back(cp);
+}
 
-	Iterator it(this->packets.begin());
-	while (it != this->packets.end() && max_move > 0) {
+/**
+ * Returns all reserved cargo to the station and removes it from the cache.
+ * @param ID of next the station the cargo wants to go next.
+ * @param dest Station the cargo is returned to.
+ */
+void VehicleCargoList::Unreserve(StationID next, StationCargoList *dest)
+{
+	Iterator it(this->reserved.begin());
+	while (it != this->reserved.end()) {
 		CargoPacket *cp = *it;
-		if (cp->source == data && mta == MTA_FINAL_DELIVERY) {
-			/* Skip cargo that originated from this station. */
-			++it;
-			continue;
-		}
+		this->RemoveFromCache(cp);
+		this->reserved_count -= cp->count;
+		dest->Append(next, cp);
+		this->reserved.erase(it++);
+	}
+}
 
+/**
+ * Load packets from the reservation list.
+ * @params max_move Number of cargo to load.
+ * @return Amount of cargo actually loaded.
+ */
+uint VehicleCargoList::LoadReserved(uint max_move)
+{
+	uint orig_max = max_move;
+	Iterator it(this->reserved.begin());
+	while (it != this->reserved.end() && max_move > 0) {
+		CargoPacket *cp = *it;
 		if (cp->count <= max_move) {
 			/* Can move the complete packet */
 			max_move -= cp->count;
-			this->packets.erase(it++);
-			static_cast<Tinst *>(this)->RemoveFromCache(cp);
-			switch (mta) {
-				case MTA_FINAL_DELIVERY:
-					payment->PayFinalDelivery(cp, cp->count);
-					delete cp;
-					continue; // of the loop
-
-				case MTA_CARGO_LOAD:
-					cp->loaded_at_xy = data;
-					break;
-
-				case MTA_TRANSFER:
-					cp->feeder_share += payment->PayTransfer(cp, cp->count);
-					break;
-
-				case MTA_UNLOAD:
-					break;
-			}
-			dest->Append(cp);
-			continue;
+			this->reserved.erase(it++);
+			this->reserved_count -= cp->count;
+			this->Append(cp, false);
+		} else if (CargoPacket::CanAllocateItem()) {
+			cp->count -= max_move;
+			CargoPacket *cp_new = new CargoPacket(max_move, cp->days_in_transit, cp->source, cp->source_xy, cp->loaded_at_xy, 0, cp->source_type, cp->source_id);
+			this->Append(cp_new, false);
+			this->reserved_count -= max_move;
+			max_move = 0;
 		}
+	}
+	return orig_max - max_move;
+}
 
-		/* Can move only part of the packet */
-		if (mta == MTA_FINAL_DELIVERY) {
-			/* Final delivery doesn't need package splitting. */
-			payment->PayFinalDelivery(cp, max_move);
+/**
+ * Move a single packet or part of it from this list to a vehicle and increment
+ * the given iterator.
+ * @param dest       Vehicle cargo list to move to.
+ * @param it         Iterator pointing to the packet.
+ * @param cap        Maximum amount of cargo to be moved.
+ * @param load_place New loaded_at for the packet.
+ * @param reserve    If the packet should be loaded on or reserved for the vehicle.
+ * @return           Actual amount of cargo which has been moved.
+ */
+template<class Tinst, class Tcont>
+uint CargoList<Tinst, Tcont>::MovePacket(VehicleCargoList *dest, Iterator &it, uint cap, TileIndex load_place, bool reserve)
+{
+	CargoPacket *packet = this->RemovePacket(it, cap, load_place);
+	uint ret = packet->count;
+	if (reserve) {
+		dest->Reserve(packet);
+	} else {
+		dest->Append(packet);
+	}
+	return ret;
+}
 
-			/* Remove the delivered data from the cache */
-			uint left = cp->count - max_move;
-			cp->count = max_move;
-			static_cast<Tinst *>(this)->RemoveFromCache(cp);
+/**
+ * Move a single packet or part of it from this list to a station and increment
+ * the given iterator.
+ * @param dest Station cargo list to move to.
+ * @param next Next station the packet will travel to.
+ * @param it Iterator pointing to the packet.
+ * @param cap Maximum amount of cargo to be moved.
+ * @return Actual amount of cargo which has been moved.
+ */
+template<class Tinst, class Tcont>
+uint CargoList<Tinst, Tcont>::MovePacket(StationCargoList *dest, StationID next, Iterator &it, uint cap)
+{
+	CargoPacket *packet = this->RemovePacket(it, cap);
+	uint ret = packet->count;
+	dest->Append(next, packet);
+	return ret;
+}
 
-			/* Final delivery payment pays the feeder share, so we have to
-			 * reset that so it is not 'shown' twice for partial unloads. */
-			cp->feeder_share = 0;
-			cp->count = left;
+/**
+ * Remove a single packet or part of it from this list and increment the given
+ * iterator.
+ * @param it Iterator pointing to the packet.
+ * @param cap Maximum amount of cargo to be moved.
+ * @param load_place New loaded_at for the packet or INVALID_TILE if the current
+ *        one shall be kept.
+ * @return Removed packet.
+ */
+template<class Tinst, class Tcont>
+CargoPacket *CargoList<Tinst, Tcont>::RemovePacket(Iterator &it, uint cap, TileIndex load_place)
+{
+	CargoPacket *packet = *it;
+	/* load the packet if possible */
+	if (packet->count > cap) {
+		/* packet needs to be split */
+		packet = packet->Split(cap);
+
+		/* We could not allocate a CargoPacket? Is the map that full?
+		 * Just remove the whole packet and drop some cargo then.
+		 */
+		if (packet == NULL) {
+			packet = *it;
+			uint dropped = packet->count - cap;
+			this->count -= dropped;
+			this->cargo_days_in_transit -= dropped * packet->days_in_transit;
+			packet->count = cap;
+			this->packets.erase(it++);
 		} else {
-			/* But... the rest needs package splitting. */
-			CargoPacket *cp_new = cp->Split(max_move);
+			assert(packet->count == cap);
+			++it;
+		}
+	} else {
+		this->packets.erase(it++);
+	}
+	static_cast<Tinst *>(this)->RemoveFromCache(packet);
+	if (load_place != INVALID_TILE) {
+		packet->loaded_at_xy = load_place;
+	}
+	return packet;
+}
 
-			/* We could not allocate a CargoPacket? Is the map that full? */
-			if (cp_new == NULL) return false;
+/**
+ * Invalidates the cached data and rebuilds it.
+ */
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::InvalidateCache()
+{
+	this->count = 0;
+	this->cargo_days_in_transit = 0;
 
-			static_cast<Tinst *>(this)->RemoveFromCache(cp_new); // this reflects the changes in cp.
+	for (ConstIterator it(this->packets.begin()); it != this->packets.end(); it++) {
+		static_cast<Tinst *>(this)->AddToCache(*it);
+	}
+}
 
-			if (mta == MTA_TRANSFER) {
-				/* Add the feeder share before inserting in dest. */
-				cp_new->feeder_share += payment->PayTransfer(cp_new, max_move);
-			} else if (mta == MTA_CARGO_LOAD) {
-				cp_new->loaded_at_xy = data;
-			}
+/**
+ * Delete a vehicle cargo list and clear its reservation list.
+ */
+VehicleCargoList::~VehicleCargoList()
+{
+	for (Iterator it(this->reserved.begin()); it != this->reserved.end(); ++it) {
+		delete *it;
+	}
+}
+
+/**
+ * Deliver a specific packet or part of it to a station and handle payment. The
+ * given iterator is incremented in the process.
+ * @param it      Iterator pointing to the packet to be delivered.
+ * @param cap     Maximum amount of cargo to be unloaded.
+ * @param payment Payment object to use for payment.
+ * @return        Amount of cargo actually unloaded.
+ */
+uint VehicleCargoList::DeliverPacket(Iterator &it, uint cap, CargoPayment *payment)
+{
+	CargoPacket *p = *it;
+	uint unloaded = 0;
+	if (p->count <= cap) {
+		payment->PayFinalDelivery(p, p->count);
+		this->packets.erase(it++);
+		this->RemoveFromCache(p);
+		unloaded = p->count;
+		delete p;
+	} else {
+		payment->PayFinalDelivery(p, cap);
+		this->count -= cap;
+		this->cargo_days_in_transit -= cap * p->days_in_transit;
+		this->feeder_share -= p->feeder_share;
+		p->feeder_share = 0;
+		p->count -= cap;
+		unloaded = cap;
+		++it;
+	}
+	return unloaded;
+}
+
+/**
+ * Keep a packet in the vehicle while unloading by temporarily moving it to the
+ * reservation list. The given iterator is incremented in the process.
+ * @param it Iterator pointing to the packet.
+ * @return Size of the packet.
+ */
+uint VehicleCargoList::KeepPacket(Iterator &it)
+{
+	CargoPacket *cp = *it;
+	this->reserved.push_back(cp);
+	this->reserved_count += cp->count;
+	this->packets.erase(it++);
+	return cp->count;
+}
 
-			dest->Append(cp_new);
+/**
+ * Transfer a packet to a station, but don't deliver it. Increment the given
+ * iterator in the process.
+ * @param it Iterator pointing to a packet in the list.
+ * @param cap Maximum amount of cargo to be transferred.
+ * @param dest Cargo list of the station the cargo should be transferred to.
+ * @param payment Payment object to be updated with the resulting transfer
+ *                credits.
+ * @param next ID of the station the cargo wants to go to next.
+ * @return Amount of cargo actually moved.
+ */
+uint VehicleCargoList::TransferPacket(Iterator &it, uint cap, StationCargoList *dest, CargoPayment *payment, StationID next)
+{
+	CargoPacket *cp = this->RemovePacket(it, cap);
+	cp->feeder_share += payment->PayTransfer(cp, cp->count);
+	uint ret = cp->count;
+	dest->Append(next, cp);
+	return ret;
+}
+
+/**
+ * Determine what a cargo packet arriving at the station this list belongs to
+ * will do, using the "old", non-cargodist algorithm.
+ * @param flags  Unload flags telling if the cargo is accepted and what order
+ *               flags there are.
+ * @param source ID of the packets source station.
+ * @return       Unload type (deliver, transfer, keep) telling what to do with
+ *               the packet.
+ */
+UnloadType StationCargoList::WillUnloadOld(byte flags, StationID source)
+{
+	/* try to unload cargo */
+	bool move = (flags & (UL_DELIVER | UL_ACCEPTED | UL_TRANSFER)) != 0;
+	/* try to deliver cargo if unloading */
+	bool deliver = (flags & UL_ACCEPTED) && !(flags & UL_TRANSFER) && (source != this->station->index);
+	/* transfer cargo if delivery was unsuccessful */
+	bool transfer = (flags & (UL_TRANSFER | UL_DELIVER)) != 0;
+	if (move) {
+		if(deliver) {
+			return UL_DELIVER;
+		} else if (transfer) {
+			return UL_TRANSFER;
+		} else {
+			/* this case is for (non-)delivery to the source station without special flags.
+			 * like the code in MoveTo did, we keep the packet in this case
+			 */
+			return UL_KEEP;
 		}
+	} else {
+		return UL_KEEP;
+	}
+}
 
-		max_move = 0;
+/**
+ * Determine what a cargo packet arriving at the station this list belongs to
+ * will do, using the Cargodist algorithm.
+ * @param flags  Unload flags telling if the cargo is accepted and what order
+ *               flags there are.
+ * @param next   Stations the vehicle the cargo is coming from might
+ *               visit next.
+ * @param via    Station the cargo wants to go to next. If that is this
+ *               station the cargo wants to be delivered.
+ * @param source ID of the packets source station.
+ * @return       Unload type (deliver, transfer, keep) telling what to do with
+ *               the packet.
+ */
+UnloadType StationCargoList::WillUnloadCargoDist(byte flags, const StationIDVector &next, StationID via, StationID source)
+{
+	if (via == this->station->index) {
+		/* this is the final destination, deliver ... */
+		if (flags & UL_TRANSFER) {
+			/* .. except if explicitly told not to do so ... */
+			return UL_TRANSFER;
+		} else if (flags & UL_ACCEPTED) {
+			return UL_DELIVER;
+		} else if (flags & UL_DELIVER) {
+			/* .. or if the station suddenly doesn't accept our cargo, but we have an explicit deliver order... */
+			return UL_TRANSFER;
+		} else {
+			/* .. or else if it doesn't accept. */
+			return UL_KEEP;
+		}
+	} else {
+		/* packet has to travel on, find out if it can stay on board */
+		if (flags & UL_DELIVER) {
+			/* order overrides cargodist:
+			 * play by the old loading rules here as player is interfering with cargodist
+			 * try to deliver, as move has been forced upon us */
+			if ((flags & UL_ACCEPTED) && !(flags & UL_TRANSFER) && source != this->station->index) {
+				return UL_DELIVER;
+			} else {
+				/* transfer cargo, as delivering didn't work */
+				return UL_TRANSFER;
+			}
+		} else if (flags & UL_TRANSFER) {
+			/* transfer forced */
+			return UL_TRANSFER;
+		} else if (next.Contains(via)) {
+			/* vehicle goes to the packet's next hop or has nondeterministic order: keep the packet*/
+			return UL_KEEP;
+		} else {
+			/* vehicle goes somewhere else, transfer the packet*/
+			return UL_TRANSFER;
+		}
 	}
+}
 
-	return it != packets.end();
+/**
+ * Swap the reserved and packets lists when starting to load cargo. Pull in the
+ * "kept" packets which were stored in the reservation list so that we don't
+ * have to iterate over them all the time.
+ * @pre this->packets.empty()
+ */
+void VehicleCargoList::SwapReserved()
+{
+	assert(this->packets.empty());
+	this->packets.swap(this->reserved);
+	this->reserved_count = 0;
 }
 
-/** Invalidates the cached data and rebuilds it. */
-template <class Tinst>
-void CargoList<Tinst>::InvalidateCache()
+/**
+ * Moves the given amount of cargo from a vehicle to a station.
+ * Depending on the value of flags the side effects of this function differ:
+ *  - OUFB_UNLOAD_IF_POSSIBLE and dest->acceptance_pickup & GoodsEntry::ACCEPTANCE:
+ *  	packets are accepted here and may be unloaded and/or delivered (=destroyed);
+ *  	if not using cargodist: all packets are unloaded and delivered
+ *  	if using cargodist: only packets which have this station as final destination are unloaded and delivered.
+ *  	if using cargodist: other packets may or may not be unloaded, depending on next_station.
+ *  	if GoodsEntry::ACCEPTANCE is not set and using cargodist: packets may still be unloaded, but not delivered.
+ *  - OUFB_UNLOAD: unload all packets unconditionally;
+ *  	if OUF_UNLOAD_IF_POSSIBLE set and OUFB_TRANSFER not set: also deliver packets (no matter if using cargodist).
+ *  - OUFB_TRANSFER: don't deliver any packets;
+ *  	overrides delivering aspect of OUFB_UNLOAD_IF_POSSIBLE.
+ * @param source       Vehicle cargo list to take the cargo from.
+ * @param max_unload   Maximum amount of cargo entities to move.
+ * @param flags        How to handle the moving (side effects).
+ * @param next         Next unloading stations in the vehicle's order list.
+ * @param has_stopped  Vehicle has stopped at this station before, so don't update the flow stats for kept cargo.
+ * @param payment      Payment object to be updated when delivering/transferring.
+ * @return Number of cargo entities actually moved.
+ */
+uint StationCargoList::TakeFrom(VehicleCargoList *source, uint max_unload, OrderUnloadFlags order_flags, const StationIDVector &next, bool has_stopped, CargoPayment *payment)
 {
-	this->count = 0;
-	this->cargo_days_in_transit = 0;
+	uint remaining_unload = max_unload;
+	uint unloaded;
+	byte flags = this->GetUnloadFlags(order_flags);
+	GoodsEntry *dest = &this->station->goods[this->cargo];
+	UnloadType action;
+
+	for (VehicleCargoList::Iterator c = source->packets.begin(); c != source->packets.end() && remaining_unload > 0;) {
+		StationID cargo_source = (*c)->source;
+		FlowStatSet &flows = dest->flows[cargo_source];
+		FlowStatSet::iterator begin = flows.begin();
+		StationID via = (begin != flows.end() ? begin->Via() : INVALID_STATION);
+		if (via != INVALID_STATION && next.Length() > 0) {
+			/* use cargodist unloading*/
+			action = this->WillUnloadCargoDist(flags, next, via, cargo_source);
+		} else {
+			/* there is no plan: use normal unloading */
+			action = this->WillUnloadOld(flags, cargo_source);
+		}
 
-	for (ConstIterator it(this->packets.begin()); it != this->packets.end(); it++) {
-		static_cast<Tinst *>(this)->AddToCache(*it);
+		switch (action) {
+			case UL_DELIVER:
+				unloaded = source->DeliverPacket(c, remaining_unload, payment);
+				if (via != INVALID_STATION) {
+					if (via == this->station->index) {
+						dest->UpdateFlowStats(flows, begin, unloaded);
+					} else {
+						dest->UpdateFlowStats(flows, unloaded, this->station->index);
+					}
+				}
+				remaining_unload -= unloaded;
+				break;
+			case UL_TRANSFER:
+				/* TransferPacket may split the packet and return the transferred part */
+				if (via == this->station->index) {
+					via = (++begin != flows.end()) ? begin->Via() : INVALID_STATION;
+				}
+				unloaded = source->TransferPacket(c, remaining_unload, this, payment, via);
+				if (via != INVALID_STATION) {
+					dest->UpdateFlowStats(flows, begin, unloaded);
+				}
+				remaining_unload -= unloaded;
+				break;
+			case UL_KEEP:
+				unloaded = source->KeepPacket(c);
+				if (via != INVALID_STATION && next.Length() > 0 && !has_stopped) {
+					if (next.Contains(via)) {
+						dest->UpdateFlowStats(flows, begin, unloaded);
+					} else if (next.Length() == 1) {
+						dest->UpdateFlowStats(flows, unloaded, next[0]);
+					}
+				}
+				break;
+			default:
+				NOT_REACHED();
+		}
 	}
+	return max_unload - remaining_unload;
+}
+
+/**
+ * Additionally empty the reservation list for vehicle cargo lists.
+ */
+void VehicleCargoList::OnCleanPool()
+{
+	this->reserved.clear();
+	this->Parent::OnCleanPool();
 }
 
 /**
@@ -375,6 +684,22 @@ void VehicleCargoList::AddToCache(const CargoPacket *cp)
 }
 
 /**
+ * Moves the given amount of cargo to another vehicle (during autoreplace).
+ * @param dest         Destination to move the cargo to.
+ * @param cap          Maximum amount of cargo entities to move.
+ * @return             Amount of cargo actually moved.
+ */
+uint VehicleCargoList::MoveTo(VehicleCargoList *dest, uint cap)
+{
+	uint orig_cap = cap;
+	Iterator it = packets.begin();
+	while (it != packets.end() && cap > 0) {
+		cap -= MovePacket(dest, it, cap);
+	}
+	return orig_cap - cap;
+}
+
+/**
  * Ages the all cargo in this list.
  */
 void VehicleCargoList::AgeCargo()
@@ -389,22 +714,192 @@ void VehicleCargoList::AgeCargo()
 	}
 }
 
-/** Invalidates the cached data and rebuild it. */
+/*
+ *
+ * Station cargo list implementation
+ *
+ */
+
+/**
+ * build unload flags from order flags and station acceptance.
+ * @param order_flags order flags to check for forced transfer/deliver
+ * @return some combination of UL_ACCEPTED, UL_DELIVER and UL_TRANSFER
+ */
+FORCEINLINE byte StationCargoList::GetUnloadFlags(OrderUnloadFlags order_flags)
+{
+	byte flags = 0;
+	if (HasBit(this->station->goods[this->cargo].acceptance_pickup, GoodsEntry::ACCEPTANCE)) {
+		flags |= UL_ACCEPTED;
+	}
+	if (order_flags & OUFB_UNLOAD) {
+		flags |= UL_DELIVER;
+	}
+	if (order_flags & OUFB_TRANSFER) {
+		flags |= UL_TRANSFER;
+	}
+	return flags;
+}
+
+/**
+ * Appends the given cargo packet to the range of packets with the same next station
+ * @warning After appending this packet may not exist anymore!
+ * @note Do not use the cargo packet anymore after it has been appended to this CargoList!
+ * @param next the next hop
+ * @param cp the cargo packet to add
+ * @pre cp != NULL
+ */
+void StationCargoList::Append(StationID next, CargoPacket *cp)
+{
+	assert(cp != NULL);
+	this->AddToCache(cp);
+
+	StationCargoPacketMap::List &list = this->packets[next];
+	for (StationCargoPacketMap::List::reverse_iterator it(list.rbegin()); it != list.rend(); it++) {
+		CargoPacket *icp = *it;
+		if (StationCargoList::AreMergable(icp, cp) && icp->count + cp->count <= CargoPacket::MAX_COUNT) {
+			icp->Merge(cp);
+			return;
+		}
+	}
+
+	/* The packet could not be merged with another one */
+	list.push_back(cp);
+}
+
+/**
+ * Move packets from a specific range in this list to a vehicle.
+ * @param dest Cargo list the packets will be moved to.
+ * @param cap Maximum amount of cargo to move.
+ * @param begin Begin of the range to take packets from.
+ * @param end End of the range to take packets from.
+ * @param reserve If the packets should be loaded on or reserved for the vehicle.
+ * @return Amount of cargo that has been moved.
+ */
+uint StationCargoList::MovePackets(VehicleCargoList *dest, uint cap, Iterator begin, Iterator end, bool reserve)
+{
+	uint orig_cap = cap;
+	while (begin != end && cap > 0) {
+		cap -= this->MovePacket(dest, begin, cap, this->station->xy, reserve);
+	}
+	return orig_cap - cap;
+}
+
+/**
+ * Move suitable packets from this list to a vehicle.
+ * @param dest Vehicle cargo list to move packets to.
+ * @param cap Maximum amount of cargo to be moved.
+ * @param next Next station the vehicle will stop at.
+ * @param reserve If the packets should be loaded on or reserved for the vehicle.
+ * @return Amount of cargo that has been moved.
+ */
+uint StationCargoList::MoveTo(VehicleCargoList *dest, uint cap, StationID next, bool reserve)
+{
+	uint orig_cap = cap;
+	if (next != INVALID_STATION) {
+		std::pair<Iterator, Iterator> bounds(this->packets.equal_range(next));
+		cap -= this->MovePackets(dest, cap, bounds.first, bounds.second, reserve);
+		if (cap > 0) {
+			bounds = this->packets.equal_range(INVALID_STATION);
+			cap -= this->MovePackets(dest, cap, bounds.first, bounds.second, reserve);
+		}
+	} else {
+		cap -= this->MovePackets(dest, cap, this->packets.begin(), this->packets.end(), reserve);
+	}
+	return orig_cap - cap;
+}
+
+/**
+ * Route all packets with station "to" as next hop to a different place.
+ * @param to station to exclude from routing.
+ */
+void StationCargoList::RerouteStalePackets(StationID to)
+{
+	std::pair<Iterator, Iterator> range(this->packets.equal_range(to));
+	for (Iterator it(range.first); it != range.second && it.GetKey() == to;) {
+		CargoPacket *packet = *it;
+		this->packets.erase(it++);
+		StationID next = this->station->goods[this->cargo].UpdateFlowStatsTransfer(packet->source, packet->count, this->station->index);
+		assert(next != to);
+
+		/* legal, as insert doesn't invalidate iterators in the MultiMap, however
+		 * this might insert the packet between range.first and range.second (which might be end())
+		 * This is why we check for GetKey above to avoid infinite loops
+		 */
+		this->packets.Insert(next, packet);
+	}
+}
+
+/**
+ * Truncate where each destination loses roughly the same percentage of its cargo.
+ * This is done by randomizing the selection of packets to be removed. Also count
+ * the cargo by origin station.
+ * @param max_remaining Maximum amount of cargo to keep in the station.
+ * @param cargo_per_source Container for counting the cargo by origin list.
+ */
+void StationCargoList::CountAndTruncate(uint max_remaining, StationCargoAmountMap &cargo_per_source)
+{
+	uint prev_count = this->count;
+	uint loop = 0;
+	while (this->count > max_remaining) {
+		for (Iterator it(this->packets.begin()); it != this->packets.end();) {
+			CargoPacket *packet = *it;
+			if (loop == 0) cargo_per_source[packet->source] += packet->count;
+
+			if (RandomRange(prev_count) < max_remaining) {
+				++it;
+				continue;
+			}
+
+			uint diff = this->count - max_remaining;
+			if (packet->count > diff) {
+				packet->count -= diff;
+				this->count = max_remaining;
+				this->cargo_days_in_transit -= packet->days_in_transit * diff;
+				if (loop > 0) {
+					return;
+				} else {
+					++it;
+				}
+			} else {
+				this->packets.erase(it++);
+				this->RemoveFromCache(packet);
+				delete packet;
+			}
+		}
+		loop++;
+	}
+}
+
+/**
+ * Invalidates the cached data and rebuilds it.
+ */
 void VehicleCargoList::InvalidateCache()
 {
 	this->feeder_share = 0;
+	this->reserved_count = 0;
 	this->Parent::InvalidateCache();
+	for (ConstIterator it(this->reserved.begin()); it != this->reserved.end(); it++) {
+		this->AddToCache(*it);
+		this->reserved_count += (*it)->count;
+	}
 }
 
+/**
+ * Assign the cargo list to a goods entry.
+ * @param station the station the cargo list is assigned to
+ * @param cargo the cargo the list is assigned to
+ */
+void StationCargoList::AssignTo(Station *station, CargoID cargo)
+{
+	assert(this->station == NULL);
+	assert(station != NULL && cargo != INVALID_CARGO);
+	this->station = station;
+	this->cargo = cargo;
+}
+
+
 /*
  * We have to instantiate everything we want to be usable.
  */
-template class CargoList<VehicleCargoList>;
-template class CargoList<StationCargoList>;
-
-/** Autoreplace Vehicle -> Vehicle 'transfer'. */
-template bool CargoList<VehicleCargoList>::MoveTo(VehicleCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
-/** Cargo unloading at a station. */
-template bool CargoList<VehicleCargoList>::MoveTo(StationCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
-/** Cargo loading at a station. */
-template bool CargoList<StationCargoList>::MoveTo(VehicleCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
+template class CargoList<VehicleCargoList, CargoPacketList>;
+template class CargoList<StationCargoList, StationCargoPacketMap>;
diff --git a/src/cargopacket.h b/src/cargopacket.h
index 0f2e461..c797c415 100644
--- a/src/cargopacket.h
+++ b/src/cargopacket.h
@@ -13,10 +13,14 @@
 #define CARGOPACKET_H
 
 #include "core/pool_type.hpp"
+#include "order_type.h"
 #include "economy_type.h"
 #include "station_type.h"
+#include "order_type.h"
 #include "cargo_type.h"
+#include "cargotype.h"
 #include "vehicle_type.h"
+#include "core/multimap.hpp"
 #include <list>
 
 /** Unique identifier for a single cargo packet. */
@@ -28,7 +32,9 @@ typedef Pool<CargoPacket, CargoPacketID, 1024, 0xFFF000, PT_NORMAL, true, false>
 /** The actual pool with cargo packets. */
 extern CargoPacketPool _cargopacket_pool;
 
-template <class Tinst> class CargoList;
+template <class Tinst, class Tcont> class CargoList;
+class StationCargoList; // forward-declare, so we can use it in VehicleCargoList::Unreserve
+class VehicleCargoList; // forward-declare, so we can use it in CargoList::MovePacket
 extern const struct SaveLoad *GetCargoPacketDesc();
 
 /**
@@ -46,7 +52,7 @@ private:
 	TileIndex loaded_at_xy;     ///< Location where this cargo has been loaded into the vehicle.
 
 	/** The CargoList caches, thus needs to know about it. */
-	template <class Tinst> friend class CargoList;
+	template <class Tinst, class Tcont> friend class CargoList;
 	friend class VehicleCargoList;
 	friend class StationCargoList;
 	/** We want this to be saved, right? */
@@ -140,7 +146,6 @@ public:
 		return this->loaded_at_xy;
 	}
 
-
 	static void InvalidateAllFrom(SourceType src_type, SourceID src);
 	static void InvalidateAllFrom(StationID sid);
 	static void AfterLoad();
@@ -159,38 +164,46 @@ public:
  */
 #define FOR_ALL_CARGOPACKETS(var) FOR_ALL_CARGOPACKETS_FROM(var, 0)
 
+/** Kind of actions that could be done with packets on unloading */
+enum UnloadType {
+	UL_KEEP     = 0,      ///< keep cargo on vehicle
+	UL_DELIVER  = 1 << 0, ///< deliver cargo
+	UL_TRANSFER = 1 << 1, ///< transfer cargo
+	UL_ACCEPTED = 1 << 2, ///< cargo is accepted
+};
+
 /**
  * Simple collection class for a list of cargo packets.
  * @tparam Tinst Actual instantation of this cargo list.
  */
-template <class Tinst>
+template <class Tinst, class Tcont>
 class CargoList {
 public:
-	/** Container with cargo packets. */
-	typedef std::list<CargoPacket *> List;
-	/** The iterator for our container. */
-	typedef List::iterator Iterator;
-	/** The const iterator for our container. */
-	typedef List::const_iterator ConstIterator;
-
-	/** Kind of actions that could be done with packets on move. */
-	enum MoveToAction {
-		MTA_FINAL_DELIVERY, ///< "Deliver" the packet to the final destination, i.e. destroy the packet.
-		MTA_CARGO_LOAD,     ///< Load the packet onto a vehicle, i.e. set the last loaded station ID.
-		MTA_TRANSFER,       ///< The cargo is moved as part of a transfer.
-		MTA_UNLOAD,         ///< The cargo is moved as part of a forced unload.
-	};
+	/** Iterator for our container. */
+	typedef typename Tcont::iterator Iterator;
+	/** Const iterator for our container. */
+	typedef typename Tcont::const_iterator ConstIterator;
+	/** Reverse iterator for our container. */
+	typedef typename Tcont::reverse_iterator ReverseIterator;
+	/** Const reverse iterator for our container. */
+	typedef typename Tcont::const_reverse_iterator ConstReverseIterator;
 
 protected:
 	uint count;                 ///< Cache for the number of cargo entities.
 	uint cargo_days_in_transit; ///< Cache for the sum of number of days in transit of each entity; comparable to man-hours.
 
-	List packets;               ///< The cargo packets in this list.
+	Tcont packets;              ///< The cargo packets in this list.
 
 	void AddToCache(const CargoPacket *cp);
 
 	void RemoveFromCache(const CargoPacket *cp);
 
+	CargoPacket *RemovePacket(Iterator &it, uint cap, TileIndex load_place = INVALID_TILE);
+
+	uint MovePacket(StationCargoList *dest, StationID next, Iterator &it, uint cap);
+
+	uint MovePacket(VehicleCargoList *dest, Iterator &it, uint cap, TileIndex load_place = INVALID_TILE, bool reserved = false);
+
 public:
 	/** Create the cargo list. */
 	CargoList() {}
@@ -203,7 +216,7 @@ public:
 	 * Returns a pointer to the cargo packet list (so you can iterate over it etc).
 	 * @return Pointer to the packet list.
 	 */
-	FORCEINLINE const List *Packets() const
+	FORCEINLINE const Tcont *Packets() const
 	{
 		return &this->packets;
 	}
@@ -227,15 +240,6 @@ public:
 	}
 
 	/**
-	 * Returns source of the first cargo packet in this list.
-	 * @return The before mentioned source.
-	 */
-	FORCEINLINE StationID Source() const
-	{
-		return this->Empty() ? INVALID_STATION : this->packets.front()->source;
-	}
-
-	/**
 	 * Returns average number of days in transit for a cargo entity.
 	 * @return The before mentioned number.
 	 */
@@ -244,35 +248,45 @@ public:
 		return this->count == 0 ? 0 : this->cargo_days_in_transit / this->count;
 	}
 
-
-	void Append(CargoPacket *cp);
+	void Append(CargoPacket *cp, bool update_cache = true);
 	void Truncate(uint max_remaining);
 
-	template <class Tother_inst>
-	bool MoveTo(Tother_inst *dest, uint count, MoveToAction mta, CargoPayment *payment, uint data = 0);
-
 	void InvalidateCache();
 };
 
+typedef std::list<CargoPacket *> CargoPacketList;
+
 /**
  * CargoList that is used for vehicles.
  */
-class VehicleCargoList : public CargoList<VehicleCargoList> {
+class VehicleCargoList : public CargoList<VehicleCargoList, CargoPacketList> {
 protected:
+	uint TransferPacket(Iterator &c, uint remaining_unload, StationCargoList *dest, CargoPayment *payment, StationID next);
+	uint DeliverPacket(Iterator &c, uint remaining_unload, CargoPayment *payment);
+	uint KeepPacket(Iterator &c);
+
 	/** The (direct) parent of this class. */
-	typedef CargoList<VehicleCargoList> Parent;
+	typedef CargoList<VehicleCargoList, CargoPacketList> Parent;
 
-	Money feeder_share; ///< Cache for the feeder share.
+	CargoPacketList reserved; ///< Packets reserved for unloading in this list.
+	Money feeder_share;       ///< Cache for the feeder share.
+	uint reserved_count;      ///< Cache for the number of reserved cargo entities.
 
 	void AddToCache(const CargoPacket *cp);
 	void RemoveFromCache(const CargoPacket *cp);
 
 public:
+	/** The station cargo list needs to control the unloading. */
+	friend class StationCargoList;
 	/** The super class ought to know what it's doing. */
-	friend class CargoList<VehicleCargoList>;
+	friend class CargoList<VehicleCargoList, CargoPacketList>;
 	/** The vehicles have a cargo list (and we want that saved). */
 	friend const struct SaveLoad *GetVehicleDescription(VehicleType vt);
 
+	~VehicleCargoList();
+
+	void OnCleanPool();
+
 	/**
 	 * Returns total sum of the feeder share for all packets.
 	 * @return The before mentioned number.
@@ -282,10 +296,68 @@ public:
 		return this->feeder_share;
 	}
 
+	void Append(CargoPacket *cp, bool update_cache = true);
+
+	/**
+	 * Returns sum of cargo on board the vehicle (ie not only
+	 * reserved).
+	 * @return Cargo on board the vehicle.
+	 */
+	FORCEINLINE uint OnboardCount() const
+	{
+		return this->count - this->reserved_count;
+	}
+
+	/**
+	 * Returns sum of cargo reserved for the vehicle.
+	 * @return Cargo reserved for the vehicle.
+	 */
+	FORCEINLINE uint ReservedCount() const
+	{
+		return this->reserved_count;
+	}
+
+	/**
+	 * Returns a pointer to the reserved cargo list.
+	 * @return Pointer to the reserved list.
+	 */
+	FORCEINLINE const CargoPacketList *Reserved() const
+	{
+		return &this->reserved;
+	}
+
+	/**
+	 * Returns source of the first cargo packet in this list.
+	 * If the regular packets list is empty but there are packets
+	 * in the reservation list it returns the source of the first
+	 * reserved packet.
+	 * @return The before mentioned source.
+	 */
+	FORCEINLINE StationID Source() const
+	{
+		if (this->Empty()) {
+			return INVALID_STATION;
+		} else if (this->packets.empty()) {
+			return this->reserved.front()->source;
+		} else {
+			return this->packets.front()->source;
+		}
+	}
+
+	void Reserve(CargoPacket *cp);
+
+	void Unreserve(StationID next, StationCargoList *dest);
+
+	uint LoadReserved(uint count);
+
+	void SwapReserved();
+
 	void AgeCargo();
 
 	void InvalidateCache();
 
+	uint MoveTo(VehicleCargoList *dest, uint cap);
+
 	/**
 	 * Are two the two CargoPackets mergeable in the context of
 	 * a list of CargoPackets for a Vehicle?
@@ -303,16 +375,21 @@ public:
 	}
 };
 
+typedef MultiMap<StationID, CargoPacket *> StationCargoPacketMap;
+typedef std::map<StationID, uint> StationCargoAmountMap;
+
 /**
  * CargoList that is used for stations.
  */
-class StationCargoList : public CargoList<StationCargoList> {
+class StationCargoList : public CargoList<StationCargoList, StationCargoPacketMap> {
 public:
 	/** The super class ought to know what it's doing. */
-	friend class CargoList<StationCargoList>;
+	friend class CargoList<StationCargoList, StationCargoPacketMap>;
 	/** The stations, via GoodsEntry, have a CargoList. */
 	friend const struct SaveLoad *GetGoodsDesc();
 
+	StationCargoList() : station(NULL), cargo(INVALID_CARGO) {}
+
 	/**
 	 * Are two the two CargoPackets mergeable in the context of
 	 * a list of CargoPackets for a Vehicle?
@@ -327,6 +404,40 @@ public:
 				cp1->source_type     == cp2->source_type &&
 				cp1->source_id       == cp2->source_id;
 	}
+
+	uint TakeFrom(VehicleCargoList *source, uint max_unload, OrderUnloadFlags flags, const StationIDVector &next, bool has_stopped, CargoPayment *payment);
+
+	uint MoveTo(VehicleCargoList *dest, uint cap, StationID next_station, bool reserve = false);
+
+	void Append(StationID next, CargoPacket *cp);
+
+	void RerouteStalePackets(StationID to);
+
+	void CountAndTruncate(uint max_remaining, StationCargoAmountMap &cargo_per_source);
+
+	/**
+	 * Returns source of the first cargo packet in this list.
+	 * @return The before mentioned source.
+	 */
+	FORCEINLINE StationID Source() const
+	{
+		return this->Empty() ? INVALID_STATION : this->packets.begin()->second.front()->source;
+	}
+
+	void AssignTo(Station *station, CargoID cargo);
+
+	static void InvalidateAllFrom(SourceType src_type, SourceID src);
+
+protected:
+	Station *station; ///< Station this cargo list belongs to.
+	CargoID cargo;    ///< Cargo type this list holds.
+
+	byte GetUnloadFlags(OrderUnloadFlags order_flags);
+
+	UnloadType WillUnloadOld(byte flags, StationID source);
+	UnloadType WillUnloadCargoDist(byte flags, const StationIDVector &next, StationID via, StationID source);
+
+	uint MovePackets(VehicleCargoList *dest, uint cap, Iterator begin, Iterator end, bool reserve);
 };
 
 #endif /* CARGOPACKET_H */
diff --git a/src/company_cmd.cpp b/src/company_cmd.cpp
index c4f6611..3a9a0c5 100644
--- a/src/company_cmd.cpp
+++ b/src/company_cmd.cpp
@@ -84,6 +84,7 @@ void Company::PostDestructor(size_t index)
 	InvalidateWindowData(WC_GRAPH_LEGEND, 0, (int)index);
 	InvalidateWindowData(WC_PERFORMANCE_DETAIL, 0, (int)index);
 	InvalidateWindowData(WC_COMPANY_LEAGUE, 0, 0);
+	InvalidateWindowData(WC_LINKGRAPH_LEGEND, 0);
 	/* If the currently shown error message has this company in it, then close it. */
 	InvalidateWindowData(WC_ERRMSG, 0);
 }
@@ -558,6 +559,7 @@ Company *DoStartupNewCompany(bool is_ai, CompanyID company = INVALID_COMPANY)
 	SetWindowDirty(WC_GRAPH_LEGEND, 0);
 	SetWindowDirty(WC_TOOLBAR_MENU, 0);
 	SetWindowDirty(WC_CLIENT_LIST, 0);
+	InvalidateWindowData(WC_LINKGRAPH_LEGEND, 0);
 	BuildOwnerLegend();
 	InvalidateWindowData(WC_SMALLMAP, 0, 1);
 
@@ -1030,6 +1032,7 @@ CommandCost CmdSetCompanyColour(TileIndex tile, DoCommandFlag flags, uint32 p1,
 		InvalidateWindowData(WC_DELIVERED_CARGO, 0);
 		InvalidateWindowData(WC_PERFORMANCE_HISTORY, 0);
 		InvalidateWindowData(WC_COMPANY_VALUE, 0);
+		InvalidateWindowData(WC_LINKGRAPH_LEGEND, 0);
 		/* The smallmap owner view also stores the company colours. */
 		BuildOwnerLegend();
 		InvalidateWindowData(WC_SMALLMAP, 0, 1);
diff --git a/src/core/math_func.cpp b/src/core/math_func.cpp
index 7f0630a..bcddbfa 100644
--- a/src/core/math_func.cpp
+++ b/src/core/math_func.cpp
@@ -46,3 +46,24 @@ int GreatestCommonDivisor(int a, int b)
 	return a;
 
 }
+
+/**
+ * Deterministic approximate division.
+ * Cancels out division errors stemming from the integer nature of the division over multiple runs.
+ * @param a Dividend.
+ * @param b Divisor.
+ * @return a/b or (a/b)+1.
+ */
+int DivideApprox(int a, int b)
+{
+	int random_like = ((a + b) * (a - b)) % b;
+
+	int remainder = a % b;
+
+	int ret = a / b;
+	if (abs(random_like) < abs(remainder)) {
+		ret += ((a < 0) ^ (b < 0)) ? -1 : 1;
+	}
+
+	return ret;
+}
diff --git a/src/core/math_func.hpp b/src/core/math_func.hpp
index 19f2f53..a824af3 100644
--- a/src/core/math_func.hpp
+++ b/src/core/math_func.hpp
@@ -317,6 +317,7 @@ static FORCEINLINE uint ToPercent16(uint i)
 
 int LeastCommonMultiple(int a, int b);
 int GreatestCommonDivisor(int a, int b);
+int DivideApprox(int a, int b);
 
 /**
  * Computes ceil(a / b) for non-negative a and b.
diff --git a/src/core/multimap.hpp b/src/core/multimap.hpp
new file mode 100644
index 0000000..69772f8
--- /dev/null
+++ b/src/core/multimap.hpp
@@ -0,0 +1,393 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file multimap.hpp Multimap with deterministic ordering of items with equal keys. */
+
+#ifndef MULTIMAP_HPP_
+#define MULTIMAP_HPP_
+
+#include <map>
+#include <list>
+
+template<typename Tkey, typename Tvalue, typename Tcompare>
+class MultiMap;
+
+/**
+ * STL-style iterator for MultiMap.
+ * @tparam Tmap_iter Iterator type for the map in the MultiMap.
+ * @tparam Tlist_iter Iterator type for the lists in the MultiMap.
+ * @tparam Tkey Key type of the MultiMap.
+ * @tparam Tvalue Value type of the MultMap.
+ * @tparam Tcompare Comparator type for keys of the MultiMap.
+ */
+template<class Tmap_iter, class Tlist_iter, class Tkey, class Tvalue, class Tcompare>
+class MultiMapIterator {
+protected:
+	friend class MultiMap<Tkey, Tvalue, Tcompare>;
+	typedef MultiMapIterator<Tmap_iter, Tlist_iter, Tkey, Tvalue, Tcompare> Self;
+
+	Tlist_iter list_iter; ///< Iterator pointing to current position in the current list of items with equal keys.
+	Tmap_iter map_iter;   ///< Iterator pointing to the position of the current list of items with equal keys in the map.
+
+	/**
+	 * Flag to show that the iterator has just "walked" a step in the map.
+	 * We cannot check the current list for that as we might have reached end() of the map. In that case we'd need to
+	 * set list_iter to some sort of "invalid" state, but that's impossible as operator== yields undefined behaviour
+	 * if the iterators don't belong to the same list and there is no list at end(). So if we created a static empty
+	 * list and an "invalid" iterator in that we could not determine if the iterator is invalid while it's valid. We
+	 * can also not determine if the map iterator is valid while we don't have the map; so in the end it's easiest to
+	 * just introduce an extra flag.
+	 */
+	bool list_valid;
+
+public:
+	/**
+	 * Simple, dangerous constructor to allow later assignment with operator=.
+	 */
+	MultiMapIterator() : list_valid(false) {}
+
+	/**
+	 * Constructor to allow possibly const iterators to be assigned from possibly
+	 * non-const map iterators. You can assign end() like this.
+	 * @tparam Tnon_const Iterator type assignable to Tmap_iter (which might be const).
+	 * @param mi One such iterator.
+	 */
+	template<class Tnon_const>
+	MultiMapIterator(Tnon_const mi) : map_iter(mi), list_valid(false) {}
+
+	/**
+	 * Constructor to allow specifying an exact position in map and list. You cannot
+	 * construct end() like this as the constructor will actually check li and mi->second
+	 * for list_valid.
+	 * @param mi Iterator in the map.
+	 * @param li Iterator in the list.
+	 */
+	MultiMapIterator(Tmap_iter mi, Tlist_iter li) : list_iter(li), map_iter(mi)
+	{
+		this->list_valid = (this->list_iter != this->map_iter->second.begin());
+	}
+
+	/**
+	 * Assignment iterator like constructor with the same signature.
+	 * @tparam Tnon_const Iterator type assignable to Tmap_iter (which might be const).
+	 * @param mi One such iterator.
+	 * @return This iterator.
+	 */
+	template<class Tnon_const>
+	Self &operator=(Tnon_const mi)
+	{
+		this->map_iter = mi;
+		this->list_valid = false;
+		return *this;
+	}
+
+	/**
+	 * Dereference operator. Works just like usual STL operator*() on various containers.
+	 * Doesn't do a lot of checks for sanity, just like STL.
+	 * @return The value associated with the item this iterator points to.
+	 */
+	Tvalue &operator*() const
+	{
+		assert(!this->map_iter->second.empty());
+		if (this->list_valid) {
+			return this->list_iter.operator*();
+		} else {
+			return this->map_iter->second.begin().operator*();
+		}
+	}
+
+	/**
+	 * Same as operator*(), but returns a pointer.
+	 * @return Pointer to the value this iterator points to.
+	 */
+	Tvalue *operator->() const
+	{
+		assert(!this->map_iter->second.empty());
+		if (this->list_valid) {
+			return this->list_iter.operator->();
+		} else {
+			return this->map_iter->second.begin().operator->();
+		}
+	}
+
+	inline const Tmap_iter &GetMapIter() const {return this->map_iter;}
+	inline const Tlist_iter &GetListIter() const {return this->list_iter;}
+	inline bool ListValid() const {return this->list_valid;}
+
+	const Tkey &GetKey() const {return this->map_iter->first;}
+
+	/**
+	 * Prefix increment operator. Increment the iterator and set it to the
+	 * next item in the MultiMap. This either increments the list iterator
+	 * or the map iterator and sets list_valid accordingly.
+	 * @return This iterator after incrementing.
+	 */
+	Self &operator++()
+	{
+		assert(!this->map_iter->second.empty());
+		if (this->list_valid) {
+			if(++this->list_iter == this->map_iter->second.end()) {
+				++this->map_iter;
+				this->list_valid = false;
+			}
+		} else {
+			this->list_iter = ++(this->map_iter->second.begin());
+			if (this->list_iter == this->map_iter->second.end()) {
+				++this->map_iter;
+			} else {
+				this->list_valid = true;
+			}
+		}
+		return *this;
+	}
+
+	/**
+	 * Postfix increment operator. Same as prefix increment, but return the
+	 * previous state.
+	 * @param dummy param to mark postfix.
+	 * @return This iterator before incrementing.
+	 */
+	Self operator++(int)
+	{
+		Self tmp = *this;
+		this->operator++();
+		return tmp;
+	}
+
+	/**
+	 * Prefix decrement operator. Decrement the iterator and set it to the
+	 * previous item in the MultiMap.
+	 * @return This iterator after decrementing.
+	 */
+	Self &operator--()
+	{
+		assert(!this->map_iter->second.empty());
+		if (!this->list_valid) {
+			--this->map_iter;
+			this->list_iter = this->map_iter->second.end();
+			assert(!this->map_iter->second.empty());
+		}
+
+		this->list_valid = (--this->list_iter != this->map_iter->second.begin());
+		return *this;
+	}
+
+	/**
+	 * Postfix decrement operator. Same as prefix decrement, but return the
+	 * previous state.
+	 * @param dummy param to mark postfix.
+	 * @return This iterator before decrementing.
+	 */
+	Self operator--(int)
+	{
+		Self tmp = *this;
+		this->operator--();
+		return tmp;
+	}
+};
+
+/* generic comparison functions for const/non-const MultiMap iterators and map iterators */
+
+/**
+ * Compare two MultiMap iterators. Iterators are equal if
+ * 1. Their map iterators are equal.
+ * 2. They agree about list_valid.
+ * 3. If list_valid they agree about list_iter.
+ * Lots of template parameters to make all possible const and non-const types of MultiMap iterators
+ * (on maps with const and non-const values) comparable to each other.
+ * @param iter1 First iterator to compare.
+ * @param iter2 Second iterator to compare.
+ * @return If iter1 and iter2 are equal.
+ */
+template<class Tmap_iter1, class Tlist_iter1, class Tmap_iter2, class Tlist_iter2, class Tkey, class Tvalue1, class Tvalue2, class Tcompare>
+bool operator==(const MultiMapIterator<Tmap_iter1, Tlist_iter1, Tkey, Tvalue1, Tcompare> &iter1, const MultiMapIterator<Tmap_iter2, Tlist_iter2, Tkey, Tvalue2, Tcompare> &iter2)
+{
+	if (iter1.GetMapIter() != iter2.GetMapIter()) return false;
+	if (iter1.ListValid()) {
+		if (!iter2.ListValid()) {
+			return false;
+		} else {
+			return iter1.GetListIter() == iter2.GetListIter();
+		}
+	} else {
+		return !iter2.ListValid();
+	}
+}
+
+/**
+ * Inverse of operator==().
+ * Lots of template parameters to make all possible const and non-const types of MultiMap iterators
+ * (on maps with const and non-const values) comparable to each other.
+ * @param iter1 First iterator to compare.
+ * @param iter2 Second iterator to compare.
+ * @return If iter1 and iter2 are not equal.
+ */
+template<class Tmap_iter1, class Tlist_iter1, class Tmap_iter2, class Tlist_iter2, class Tkey, class Tvalue1, class Tvalue2, class Tcompare>
+bool operator!=(const MultiMapIterator<Tmap_iter1, Tlist_iter1, Tkey, Tvalue1, Tcompare> &iter1, const MultiMapIterator<Tmap_iter2, Tlist_iter2, Tkey, Tvalue2, Tcompare> &iter2)
+{
+	return !(iter1 == iter2);
+}
+
+/**
+ * Check if a MultiMap iterator is at the begin of a list pointed to by the given map iterator.
+ * Lots of template parameters to make all possible const and non-const types of MultiMap iterators
+ * (on maps with const and non-const values) comparable to all possible types of map iterators.
+ * @param iter1 MultiMap iterator.
+ * @param iter2 Map iterator.
+ * @return If iter1 points to the begin of the list pointed to by iter2.
+ */
+template<class Tmap_iter1, class Tlist_iter1, class Tmap_iter2, class Tkey, class Tvalue, class Tcompare >
+bool operator==(const MultiMapIterator<Tmap_iter1, Tlist_iter1, Tkey, Tvalue, Tcompare> &iter1, const Tmap_iter2 &iter2)
+{
+	return !iter1.ListValid() && iter1.GetMapIter() == iter2;
+}
+
+/**
+ * Inverse of operator==() with same signature.
+ * @param iter1 MultiMap iterator.
+ * @param iter2 Map iterator.
+ * @return If iter1 doesn't point to the begin of the list pointed to by iter2.
+ */
+template<class Tmap_iter1, class Tlist_iter1, class Tmap_iter2, class Tkey, class Tvalue, class Tcompare >
+bool operator!=(const MultiMapIterator<Tmap_iter1, Tlist_iter1, Tkey, Tvalue, Tcompare> &iter1, const Tmap_iter2 &iter2)
+{
+	return iter1.ListValid() || iter1.GetMapIter() != iter2;
+}
+
+/**
+ * Same as operator==() with reversed order of arguments.
+ * @param iter2 Map iterator.
+ * @param iter1 MultiMap iterator.
+ * @return If iter1 points to the begin of the list pointed to by iter2.
+ */
+template<class Tmap_iter1, class Tlist_iter1, class Tmap_iter2, class Tkey, class Tvalue, class Tcompare >
+bool operator==(const Tmap_iter2 &iter2, const MultiMapIterator<Tmap_iter1, Tlist_iter1, Tkey, Tvalue, Tcompare> &iter1)
+{
+	return !iter1.ListValid() && iter1.GetMapIter() == iter2;
+}
+
+/**
+ * Same as operator!=() with reversed order of arguments.
+ * @param iter2 Map iterator.
+ * @param iter1 MultiMap iterator.
+ * @return If iter1 doesn't point to the begin of the list pointed to by iter2.
+ */
+template<class Tmap_iter1, class Tlist_iter1, class Tmap_iter2, class Tkey, class Tvalue, class Tcompare >
+bool operator!=(const Tmap_iter2 &iter2, const MultiMapIterator<Tmap_iter1, Tlist_iter1, Tkey, Tvalue, Tcompare> &iter1)
+{
+	return iter1.ListValid() || iter1.GetMapIter() != iter2;
+}
+
+
+/**
+ * Hand-rolled multimap as map of lists. Behaves mostly like a list, but is sorted
+ * by Tkey so that you can easily look up ranges of equal keys. Those ranges are
+ * internally ordered in a deterministic way (contrary to STL multimap). All
+ * STL-compatible members are named in STL style, all others are named in OpenTTD
+ * style.
+ */
+template<typename Tkey, typename Tvalue, typename Tcompare = std::less<Tkey> >
+class MultiMap : public std::map<Tkey, std::list<Tvalue>, Tcompare > {
+public:
+	typedef typename std::list<Tvalue> List;
+	typedef typename List::iterator ListIterator;
+	typedef typename List::const_iterator ConstListIterator;
+
+	typedef typename std::map<Tkey, List, Tcompare > Map;
+	typedef typename Map::iterator MapIterator;
+	typedef typename Map::const_iterator ConstMapIterator;
+
+	typedef MultiMapIterator<MapIterator, ListIterator, Tkey, Tvalue, Tcompare> iterator;
+	typedef MultiMapIterator<ConstMapIterator, ConstListIterator, Tkey, const Tvalue, Tcompare> const_iterator;
+
+	/**
+	 * Erase the value pointed to by an iterator. The iterator may be invalid afterwards.
+	 * @param it Iterator pointing at some value.
+	 */
+	void erase(iterator it)
+	{
+		List &list = it.map_iter->second;
+		assert(!list.empty());
+		if (it.ListValid()) {
+			list.erase(it.list_iter);
+		} else {
+			list.erase(list.begin());
+		}
+
+		if (list.empty()) this->Map::erase(it.map_iter);
+	}
+
+	/**
+	 * Insert a value at the end of the range with the specified key.
+	 * @param key Key to be inserted at.
+	 * @param val Value to be inserted.
+	 */
+	void Insert(const Tkey &key, const Tvalue &val)
+	{
+		List &list = (*this)[key];
+		list.push_back(val);
+		assert(!list.empty());
+	}
+
+	/**
+	 * Count all items in this MultiMap. This involves iterating over the map.
+	 * @return Number of items in the MultiMap.
+	 */
+	size_t size() const
+	{
+		size_t ret = 0;
+		for (ConstMapIterator it = this->Map::begin(); it != this->Map::end(); ++it) {
+			ret += it->second.size();
+		}
+		return ret;
+	}
+
+	/**
+	 * Count the number of ranges with equal keys in this MultiMap.
+	 * @return Number of ranges with equal keys.
+	 */
+	size_t MapSize() const
+	{
+		return this->Map::size();
+	}
+
+	/**
+	 * Get a pair of iterators specifying a range of items with equal keys.
+	 * @param key Key to look for.
+	 * @return Range of items with given key.
+	 */
+	std::pair<iterator, iterator> equal_range(const Tkey &key)
+	{
+		MapIterator begin(lower_bound(key));
+		if (begin != this->Map::end() && begin->first == key) {
+			MapIterator end = begin;
+			return std::make_pair(begin, ++end);
+		} else {
+			return std::make_pair(begin, begin);
+		}
+	}
+
+	/**
+	 * Get a pair of constant iterators specifying a range of items with equal keys.
+	 * @param key Key to look for.
+	 * @return Constant range of items with given key.
+	 */
+	std::pair<const_iterator, const_iterator> equal_range(const Tkey &key) const
+	{
+		ConstMapIterator begin(lower_bound(key));
+		if (begin != this->Map::end() && begin->first == key) {
+			ConstMapIterator end = begin;
+			return std::make_pair(begin, ++end);
+		} else {
+			return std::make_pair(begin, begin);
+		}
+	}
+};
+
+#endif /* MULTIMAP_HPP_ */
diff --git a/src/economy.cpp b/src/economy.cpp
index 584eea7..94405cd 100644
--- a/src/economy.cpp
+++ b/src/economy.cpp
@@ -46,6 +46,7 @@
 #include "core/pool_func.hpp"
 #include "newgrf.h"
 #include "core/backup_type.hpp"
+#include "cargo_type.h"
 
 #include "table/strings.h"
 #include "table/pricebase.h"
@@ -1013,21 +1014,23 @@ CargoPayment::~CargoPayment()
 
 	this->front->cargo_payment = NULL;
 
-	if (this->visual_profit == 0) return;
+	if (this->visual_profit == 0 && this->visual_transfer == 0) return;
 
 	Backup<CompanyByte> cur_company(_current_company, this->front->owner, FILE_LINE);
 
 	SubtractMoneyFromCompany(CommandCost(this->front->GetExpenseType(true), -this->route_profit));
-	this->front->profit_this_year += this->visual_profit << 8;
+	this->front->profit_this_year += (this->visual_profit + this->visual_transfer) << 8;
 
-	if (this->route_profit != 0) {
-		if (IsLocalCompany() && !PlayVehicleSound(this->front, VSE_LOAD_UNLOAD)) {
-			SndPlayVehicleFx(SND_14_CASHTILL, this->front);
-		}
+	if (this->route_profit != 0 && IsLocalCompany() && !PlayVehicleSound(this->front, VSE_LOAD_UNLOAD)) {
+		SndPlayVehicleFx(SND_14_CASHTILL, this->front);
+	}
 
-		ShowCostOrIncomeAnimation(this->front->x_pos, this->front->y_pos, this->front->z_pos, -this->visual_profit);
-	} else {
-		ShowFeederIncomeAnimation(this->front->x_pos, this->front->y_pos, this->front->z_pos, this->visual_profit);
+	if (this->visual_transfer != 0) {
+		ShowFeederIncomeAnimation(this->front->x_pos, this->front->y_pos,
+				this->front->z_pos, this->visual_transfer, -this->visual_profit);
+	} else if (this->visual_profit != 0) {
+		ShowCostOrIncomeAnimation(this->front->x_pos, this->front->y_pos,
+				this->front->z_pos, -this->visual_profit);
 	}
 
 	cur_company.Restore();
@@ -1069,23 +1072,41 @@ Money CargoPayment::PayTransfer(const CargoPacket *cp, uint count)
 
 	profit = profit * _settings_game.economy.feeder_payment_share / 100;
 
-	this->visual_profit += profit; // accumulate transfer profits for whole vehicle
+	this->visual_transfer += profit; // accumulate transfer profits for whole vehicle
 	return profit; // account for the (virtual) profit already made for the cargo packet
 }
 
 /**
  * Prepare the vehicle to be unloaded.
+ * @param curr_station the station where the consist is at the moment
  * @param front_v the vehicle to be unloaded
  */
-void PrepareUnload(Vehicle *front_v)
+void PrepareUnload(Station *curr_station, Vehicle *front_v)
 {
 	/* At this moment loading cannot be finished */
 	ClrBit(front_v->vehicle_flags, VF_LOADING_FINISHED);
 
-	/* Start unloading in at the first possible moment */
+	/* Start unloading at the first possible moment */
 	front_v->load_unload_ticks = 1;
 
-	if ((front_v->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
+	if (front_v->orders.list != NULL && (front_v->current_order.GetUnloadType() & OUFB_NO_UNLOAD) != 0) {
+		/* vehicle will keep all its cargo and LoadUnloadVehicle will never call MoveToStation,
+		 * so we have to update the flow stats here.
+		 */
+		StationID next_station_id = front_v->orders.list->GetNextStoppingStation(
+				front_v->cur_auto_order_index, curr_station->index);
+		if (next_station_id == INVALID_STATION) {
+			return;
+		} else {
+			for (Vehicle *v = front_v; v != NULL; v = v->Next()) {
+				const CargoPacketList *packets = v->cargo.Packets();
+				for (VehicleCargoList::ConstIterator i(packets->begin()); i != packets->end(); ++i) {
+					curr_station->goods[v->cargo_type].UpdateFlowStats(
+							(*i)->SourceStation(), (*i)->Count(), next_station_id);
+				}
+			}
+		}
+	} else {
 		for (Vehicle *v = front_v; v != NULL; v = v->Next()) {
 			if (v->cargo_cap > 0 && !v->cargo.Empty()) {
 				SetBit(v->vehicle_flags, VF_CARGO_UNLOADING);
@@ -1102,38 +1123,87 @@ void PrepareUnload(Vehicle *front_v)
 }
 
 /**
+ * Reserves cargo if the full load order and improved_load is set.
+ * @param st The station where the consist is loading at the moment.
+ * @param u The front of the loading vehicle consist.
+ * @param next_stations Station the vehicle might stop at next.
+ * @return Bit field for the cargo classes with bits for the reserved cargos set (if anything was reserved).
+ */
+uint32 ReserveConsist(Station *st, Vehicle *u, const StationIDVector &next_stations)
+{
+	uint32 ret = 0;
+	if (_settings_game.order.improved_load && (u->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
+		/* Update reserved cargo */
+		for (Vehicle *v = u; v != NULL; v = v->Next()) {
+			/* Only reserve if the vehicle is not unloading anymore.
+			 *
+			 * The packets that are kept in the vehicle because they have the
+			 * same destination as the vehicle are stored in the reservation
+			 * list while unloading for performance reasons. The reservation
+			 * list is swapped with the onboard list after unloading. This
+			 * doesn't increase the load/unload time. So if we start reserving
+			 * cargo before unloading has stopped we'll load that cargo for free
+			 * later. Like this there is a slightly increased probability that
+			 * another vehicle which has arrived later loads cargo that should
+			 * be loaded by this vehicle but as the algorithm isn't perfect in
+			 * that regard anyway we can tolerate it.
+			 *
+			 * The algorithm isn't perfect as it only counts free capacity for
+			 * reservation. If another vehicle arrives later but unloads faster
+			 * than this one, this vehicle won't reserve all the cargo it may
+			 * be able to take after fully unloading. So the other vehicle may
+			 * load it even if it has arrived later.
+			 */
+			if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING)) continue;
+
+			int cap = v->cargo_cap - v->cargo.Count();
+			if (cap > 0) {
+				for (const StationID *next = next_stations.Begin(); next != next_stations.End(); ++next) {
+					int reserved = st->goods[v->cargo_type].cargo.MoveTo(&v->cargo, cap, *next, true);
+					if (reserved > 0) {
+						cap -= reserved;
+						SetBit(ret, v->cargo_type);
+					}
+				}
+			}
+		}
+	}
+	return ret;
+}
+
+/**
  * Loads/unload the vehicle if possible.
  * @param v the vehicle to be (un)loaded
- * @param cargo_left the amount of each cargo type that is
- *                   virtually left on the platform to be
- *                   picked up by another vehicle when all
- *                   previous vehicles have loaded.
+ * @param cargos_reserved bit field: the cargo classes for which cargo has been reserved in this loading cycle
+ * @return the updated cargo_reserved
  */
-static void LoadUnloadVehicle(Vehicle *v, int *cargo_left)
+static uint32 LoadUnloadVehicle(Vehicle *v, uint32 cargos_reserved)
 {
 	assert(v->current_order.IsType(OT_LOADING));
 
+	StationID last_visited = v->last_station_visited;
+	Station *st = Station::Get(last_visited);
+
+	StationIDVector next_stations;
+	OrderList *orders = v->orders.list;
+	if (orders != NULL) {
+		orders->GetNextStoppingStation(v->cur_auto_order_index, last_visited, &next_stations);
+	}
+
 	/* We have not waited enough time till the next round of loading/unloading */
 	if (v->load_unload_ticks != 0) {
-		if (_settings_game.order.improved_load && (v->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
-			/* 'Reserve' this cargo for this vehicle, because we were first. */
-			for (; v != NULL; v = v->Next()) {
-				int cap_left = v->cargo_cap - v->cargo.Count();
-				if (cap_left > 0) cargo_left[v->cargo_type] -= cap_left;
-			}
-		}
-		return;
+		uint32 new_reserved = ReserveConsist(st, v, next_stations);
+		return cargos_reserved | new_reserved;
 	}
 
-	StationID last_visited = v->last_station_visited;
-	Station *st = Station::Get(last_visited);
+	OrderUnloadFlags unload_flags = v->current_order.GetUnloadType();
 
 	if (v->type == VEH_TRAIN && (!IsTileType(v->tile, MP_STATION) || GetStationIndex(v->tile) != st->index)) {
 		/* The train reversed in the station. Take the "easy" way
 		 * out and let the train just leave as it always did. */
 		SetBit(v->vehicle_flags, VF_LOADING_FINISHED);
 		v->load_unload_ticks = 1;
-		return;
+		return cargos_reserved;
 	}
 
 	int unloading_time = 0;
@@ -1152,6 +1222,8 @@ static void LoadUnloadVehicle(Vehicle *v, int *cargo_left)
 
 	CargoPayment *payment = v->cargo_payment;
 
+	SmallMap<CargoID, uint, 1> capacities;
+	
 	for (; v != NULL; v = v->Next()) {
 		if (v->cargo_cap == 0) continue;
 
@@ -1168,59 +1240,42 @@ static void LoadUnloadVehicle(Vehicle *v, int *cargo_left)
 
 		GoodsEntry *ge = &st->goods[v->cargo_type];
 
-		if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING) && (u->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
-			uint cargo_count = v->cargo.Count();
+		if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING)) {
+			/* vehicle wants to unload something */
+
+			uint cargo_count = v->cargo.OnboardCount();
 			uint amount_unloaded = _settings_game.order.gradual_loading ? min(cargo_count, load_amount) : cargo_count;
-			bool remaining = false; // Are there cargo entities in this vehicle that can still be unloaded here?
-			bool accepted  = false; // Is the cargo accepted by the station?
 
+			uint prev_count = ge->cargo.Count();
 			payment->SetCargo(v->cargo_type);
+			uint delivered = ge->cargo.TakeFrom(&v->cargo, amount_unloaded, unload_flags,
+					next_stations, u->last_loading_station == last_visited, payment);
 
-			if (HasBit(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE) && !(u->current_order.GetUnloadType() & OUFB_TRANSFER)) {
-				/* The cargo has reached its final destination, the packets may now be destroyed */
-				remaining = v->cargo.MoveTo<StationCargoList>(NULL, amount_unloaded, VehicleCargoList::MTA_FINAL_DELIVERY, payment, last_visited);
-
-				dirty_vehicle = true;
-				accepted = true;
-			}
+			st->time_since_unload = 0;
+			unloading_time += delivered;
 
-			/* The !accepted || v->cargo.Count == cargo_count clause is there
-			 * to make it possible to force unload vehicles at the station where
-			 * they were loaded, but to not force unload the vehicle when the
-			 * station is still accepting the cargo in the vehicle. It doesn't
-			 * accept cargo that was loaded at the same station. */
-			if ((u->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) && (!accepted || v->cargo.Count() == cargo_count)) {
-				remaining = v->cargo.MoveTo(&ge->cargo, amount_unloaded, u->current_order.GetUnloadType() & OUFB_TRANSFER ? VehicleCargoList::MTA_TRANSFER : VehicleCargoList::MTA_UNLOAD, payment);
+			if (ge->cargo.Count() > prev_count) {
+				/* something has been transferred. The station windows need updating. */
+				dirty_station = true;
 				if (!HasBit(ge->acceptance_pickup, GoodsEntry::PICKUP)) {
 					InvalidateWindowData(WC_STATION_LIST, last_visited);
 					SetBit(ge->acceptance_pickup, GoodsEntry::PICKUP);
 				}
-
-				dirty_vehicle = dirty_station = true;
-			} else if (!accepted) {
-				/* The order changed while unloading (unset unload/transfer) or the
-				 * station does not accept our goods. */
-				ClrBit(v->vehicle_flags, VF_CARGO_UNLOADING);
-
-				/* Say we loaded something, otherwise we'll think we didn't unload
-				 * something and we didn't load something, so we must be finished
-				 * at this station. Setting the unloaded means that we will get a
-				 * retry for loading in the next cycle. */
-				anything_unloaded = true;
-				continue;
 			}
 
-			/* Deliver goods to the station */
-			st->time_since_unload = 0;
-
-			unloading_time += amount_unloaded;
-
 			anything_unloaded = true;
-			if (_settings_game.order.gradual_loading && remaining) {
-				completely_emptied = false;
-			} else {
-				/* We have finished unloading (cargo count == 0) */
+			dirty_vehicle = true;
+
+			/* load_amount might (theoretically) be 0, which would make delivered == 0 even though there is still cargo
+			 * in the vehicle. Thus OnboardCount > 0. In that case we can't stop unloading as SwapReserved wouldn't work.
+			 * v->cargo also contains the cargo reserved for the vehicle which is not on board at the moment, but will be
+			 * swapped back when done unloading.
+			 */
+			if (v->cargo.OnboardCount() == 0) {
+				/* done delivering */
+				if (!v->cargo.Empty()) completely_emptied = false;
 				ClrBit(v->vehicle_flags, VF_CARGO_UNLOADING);
+				v->cargo.SwapReserved();
 			}
 
 			continue;
@@ -1228,6 +1283,7 @@ static void LoadUnloadVehicle(Vehicle *v, int *cargo_left)
 
 		/* Do not pick up goods when we have no-load set or loading is stopped. */
 		if (u->current_order.GetLoadType() & OLFB_NO_LOAD || HasBit(u->vehicle_flags, VF_STOP_LOADING)) continue;
+		capacities[v->cargo_type] += v->cargo_cap;
 
 		/* update stats */
 		int t;
@@ -1255,39 +1311,28 @@ static void LoadUnloadVehicle(Vehicle *v, int *cargo_left)
 
 		/* If there's goods waiting at the station, and the vehicle
 		 * has capacity for it, load it on the vehicle. */
-		int cap_left = v->cargo_cap - v->cargo.Count();
-		if (!ge->cargo.Empty() && cap_left > 0) {
-			uint cap = cap_left;
-			uint count = ge->cargo.Count();
-
-			/* Skip loading this vehicle if another train/vehicle is already handling
-			 * the same cargo type at this station */
-			if (_settings_game.order.improved_load && cargo_left[v->cargo_type] <= 0) {
-				SetBit(cargo_not_full, v->cargo_type);
-				continue;
-			}
+		int cap_left = v->cargo_cap - v->cargo.OnboardCount();
+		if (cap_left > 0) {
+			if (_settings_game.order.gradual_loading) cap_left = min(cap_left, load_amount);
+			if (v->cargo.Empty()) TriggerVehicle(v, VEHICLE_TRIGGER_NEW_CARGO);
 
-			if (cap > count) cap = count;
-			if (_settings_game.order.gradual_loading) {
-				cap = min(cap, load_amount);
-				cap_left = min(cap_left, load_amount);
-			}
+			int loaded = 0;
 			if (_settings_game.order.improved_load) {
-				/* Don't load stuff that is already 'reserved' for other vehicles */
-				cap = min((uint)cargo_left[v->cargo_type], cap);
-				count = cargo_left[v->cargo_type];
-				cargo_left[v->cargo_type] -= cap;
+				loaded += v->cargo.LoadReserved(cap_left);
+			}
+
+			for (const StationID *next = next_stations.Begin();
+					loaded < cap_left && next != next_stations.End(); ++next) {
+				loaded += ge->cargo.MoveTo(&v->cargo, cap_left - loaded, *next);
 			}
 
 			/* Store whether the maximum possible load amount was loaded or not.*/
-			if (count >= (uint)cap_left) {
+			if (loaded == cap_left) {
 				SetBit(full_load_amount, v->cargo_type);
 			} else {
 				ClrBit(full_load_amount, v->cargo_type);
 			}
 
-			if (v->cargo.Empty()) TriggerVehicle(v, VEHICLE_TRIGGER_NEW_CARGO);
-
 			/* TODO: Regarding this, when we do gradual loading, we
 			 * should first unload all vehicles and then start
 			 * loading them. Since this will cause
@@ -1295,43 +1340,43 @@ static void LoadUnloadVehicle(Vehicle *v, int *cargo_left)
 			 * the whole vehicle chain is really totally empty, the
 			 * completely_emptied assignment can then be safely
 			 * removed; that's how TTDPatch behaves too. --pasky */
-			completely_emptied = false;
-			anything_loaded = true;
-
-			ge->cargo.MoveTo(&v->cargo, cap, StationCargoList::MTA_CARGO_LOAD, NULL, st->xy);
+			if (loaded > 0) {
+				completely_emptied = false;
+				anything_loaded = true;
 
-			st->time_since_load = 0;
-			st->last_vehicle_type = v->type;
+				st->time_since_load = 0;
+				st->last_vehicle_type = v->type;
 
-			TriggerStationAnimation(st, st->xy, SAT_CARGO_TAKEN, v->cargo_type);
-			AirportAnimationTrigger(st, AAT_STATION_CARGO_TAKEN, v->cargo_type);
+				TriggerStationAnimation(st, st->xy, SAT_CARGO_TAKEN, v->cargo_type);
+				AirportAnimationTrigger(st, AAT_STATION_CARGO_TAKEN, v->cargo_type);
 
-			unloading_time += cap;
+				unloading_time += loaded;
 
-			dirty_vehicle = dirty_station = true;
+				dirty_vehicle = dirty_station = true;
+			} else if (_settings_game.order.improved_load && HasBit(cargos_reserved, v->cargo_type)) {
+				/* Skip loading this vehicle if another train/vehicle is already handling
+				 * the same cargo type at this station */
+				SetBit(cargo_not_full, v->cargo_type);
+				continue;
+			}
 		}
 
-		if (v->cargo.Count() >= v->cargo_cap) {
+		if (v->cargo.OnboardCount() >= v->cargo_cap) {
 			SetBit(cargo_full, v->cargo_type);
 		} else {
 			SetBit(cargo_not_full, v->cargo_type);
 		}
 	}
 
-	/* Only set completely_emptied, if we just unloaded all remaining cargo */
-	completely_emptied &= anything_unloaded;
-
-	/* We update these variables here, so gradual loading still fills
-	 * all wagons at the same time instead of using the same 'improved'
-	 * loading algorithm for the wagons (only fill wagon when there is
-	 * enough to fill the previous wagons) */
-	if (_settings_game.order.improved_load && (u->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
-		/* Update left cargo */
-		for (v = u; v != NULL; v = v->Next()) {
-			int cap_left = v->cargo_cap - v->cargo.Count();
-			if (cap_left > 0) cargo_left[v->cargo_type] -= cap_left;
+	for (const SmallPair<CargoID, uint> *i = capacities.Begin(); i != capacities.End(); ++i) {
+		for (const StationID *next = next_stations.Begin(); next != next_stations.End(); ++next) {
+			/* Refresh the link and give it a minimum capacity. */
+			IncreaseStats(st, i->first, *next, i->second / next_stations.Length(), UINT_MAX);
 		}
 	}
+	
+	/* Only set completely_emptied, if we just unloaded all remaining cargo */
+	completely_emptied &= anything_unloaded;
 
 	v = u;
 
@@ -1358,7 +1403,7 @@ static void LoadUnloadVehicle(Vehicle *v, int *cargo_left)
 			if (v->current_order.GetLoadType() == OLF_FULL_LOAD_ANY) {
 				/* if the aircraft carries passengers and is NOT full, then
 				 * continue loading, no matter how much mail is in */
-				if ((v->type == VEH_AIRCRAFT && IsCargoInClass(v->cargo_type, CC_PASSENGERS) && v->cargo_cap > v->cargo.Count()) ||
+				if ((v->type == VEH_AIRCRAFT && IsCargoInClass(v->cargo_type, CC_PASSENGERS) && v->cargo_cap > v->cargo.OnboardCount()) ||
 						(cargo_not_full && (cargo_full & ~cargo_not_full) == 0)) { // There are still non-full cargoes
 					finished_loading = false;
 				}
@@ -1412,6 +1457,7 @@ static void LoadUnloadVehicle(Vehicle *v, int *cargo_left)
 		st->MarkTilesDirty(true);
 		SetWindowDirty(WC_STATION_VIEW, last_visited);
 	}
+	return cargos_reserved;
 }
 
 /**
@@ -1446,13 +1492,11 @@ void LoadUnloadStation(Station *st)
 	 */
 	if (last_loading == NULL) return;
 
-	int cargo_left[NUM_CARGO];
-
-	for (uint i = 0; i < NUM_CARGO; i++) cargo_left[i] = st->goods[i].cargo.Count();
+	uint cargos_reserved = 0;
 
 	for (iter = st->loading_vehicles.begin(); iter != st->loading_vehicles.end(); ++iter) {
 		Vehicle *v = *iter;
-		if (!(v->vehstatus & (VS_STOPPED | VS_CRASHED))) LoadUnloadVehicle(v, cargo_left);
+		if (!(v->vehstatus & (VS_STOPPED | VS_CRASHED))) cargos_reserved = LoadUnloadVehicle(v, cargos_reserved);
 		if (v == last_loading) break;
 	}
 
diff --git a/src/economy_base.h b/src/economy_base.h
index edad76e..acbcff8 100644
--- a/src/economy_base.h
+++ b/src/economy_base.h
@@ -24,9 +24,10 @@ extern CargoPaymentPool _cargo_payment_pool;
  * Helper class to perform the cargo payment.
  */
 struct CargoPayment : CargoPaymentPool::PoolItem<&_cargo_payment_pool> {
-	Vehicle *front;      ///< The front vehicle to do the payment of
-	Money route_profit;  ///< The amount of money to add/remove from the bank account
-	Money visual_profit; ///< The visual profit to show
+	Vehicle *front;        ///< The front vehicle to do the payment of
+	Money route_profit;    ///< The amount of money to add/remove from the bank account
+	Money visual_profit;   ///< The visual profit to show
+	Money visual_transfer; ///< The transfer credits to be shown
 
 	/* Unsaved variables */
 	Company *owner;            ///< The owner of the vehicle
diff --git a/src/economy_func.h b/src/economy_func.h
index e9c9c17..8688b04 100644
--- a/src/economy_func.h
+++ b/src/economy_func.h
@@ -33,7 +33,7 @@ void StartupIndustryDailyChanges(bool init_counter);
 Money GetTransportedGoodsIncome(uint num_pieces, uint dist, byte transit_days, CargoID cargo_type);
 uint MoveGoodsToStation(CargoID type, uint amount, SourceType source_type, SourceID source_id, const StationList *all_stations);
 
-void PrepareUnload(Vehicle *front_v);
+void PrepareUnload(Station *curr_station, Vehicle *front_v);
 void LoadUnloadStation(Station *st);
 
 Money GetPrice(Price index, uint cost_factor, const struct GRFFile *grf_file, int shift = 0);
diff --git a/src/landscape.cpp b/src/landscape.cpp
index c60bf8b..421c3e4 100644
--- a/src/landscape.cpp
+++ b/src/landscape.cpp
@@ -1004,6 +1004,7 @@ void OnTick_Station();
 void OnTick_Industry();
 
 void OnTick_Companies();
+void OnTick_LinkGraph();
 
 void CallLandscapeTick()
 {
@@ -1013,4 +1014,5 @@ void CallLandscapeTick()
 	OnTick_Industry();
 
 	OnTick_Companies();
+	OnTick_LinkGraph();
 }
diff --git a/src/lang/english.txt b/src/lang/english.txt
index d487580..3743035 100644
--- a/src/lang/english.txt
+++ b/src/lang/english.txt
@@ -220,6 +220,7 @@ STR_UNITS_HEIGHT_SI                                             :{COMMA} m
 STR_LIST_FILTER_OSKTITLE                                        :{BLACK}Enter filter string
 STR_LIST_FILTER_TOOLTIP                                         :{BLACK}Enter a keyword to filter the list for
 
+STR_TOOLTIP_GROUP_ORDER                                         :{BLACK}Select grouping order
 STR_TOOLTIP_SORT_ORDER                                          :{BLACK}Select sorting order (descending/ascending)
 STR_TOOLTIP_SORT_CRITERIA                                       :{BLACK}Select sorting criteria
 STR_TOOLTIP_FILTER_CRITERIA                                     :{BLACK}Select filtering criteria
@@ -371,6 +372,7 @@ STR_FILE_MENU_EXIT                                              :Exit
 ############ range for map menu starts
 STR_MAP_MENU_MAP_OF_WORLD                                       :Map of world
 STR_MAP_MENU_EXTRA_VIEW_PORT                                    :Extra viewport
+STR_MAP_MENU_LINGRAPH_LEGEND                                    :Link graph legend
 STR_MAP_MENU_SIGN_LIST                                          :Sign list
 ############ range for town menu starts, yet the town directory is shown in the map menu in the scenario editor
 STR_TOWN_MENU_TOWN_DIRECTORY                                    :Town directory
@@ -655,17 +657,20 @@ STR_SMALLMAP_CAPTION                                            :{WHITE}Map - {S
 STR_SMALLMAP_TYPE_CONTOURS                                      :Contours
 STR_SMALLMAP_TYPE_VEHICLES                                      :Vehicles
 STR_SMALLMAP_TYPE_INDUSTRIES                                    :Industries
+STR_SMALLMAP_TYPE_ROUTEMAP                                      :Link Statistics
 STR_SMALLMAP_TYPE_ROUTES                                        :Routes
 STR_SMALLMAP_TYPE_VEGETATION                                    :Vegetation
 STR_SMALLMAP_TYPE_OWNERS                                        :Owners
 STR_SMALLMAP_TOOLTIP_SHOW_LAND_CONTOURS_ON_MAP                  :{BLACK}Show land contours on map
 STR_SMALLMAP_TOOLTIP_SHOW_VEHICLES_ON_MAP                       :{BLACK}Show vehicles on map
 STR_SMALLMAP_TOOLTIP_SHOW_INDUSTRIES_ON_MAP                     :{BLACK}Show industries on map
+STR_SMALLMAP_TOOLTIP_SHOW_LINK_STATS_ON_MAP                     :{BLACK}Show link statistics on map
 STR_SMALLMAP_TOOLTIP_SHOW_TRANSPORT_ROUTES_ON                   :{BLACK}Show transport routes on map
 STR_SMALLMAP_TOOLTIP_SHOW_VEGETATION_ON_MAP                     :{BLACK}Show vegetation on map
 STR_SMALLMAP_TOOLTIP_SHOW_LAND_OWNERS_ON_MAP                    :{BLACK}Show land owners on map
 STR_SMALLMAP_TOOLTIP_INDUSTRY_SELECTION                         :{BLACK}Click on an industry type to toggle displaying it. Ctrl+Click disables all types except the selected one. Ctrl+Click on it again to enable all industry types
 STR_SMALLMAP_TOOLTIP_COMPANY_SELECTION                          :{BLACK}Click on a company to toggle displaying its property. Ctrl+Click disables all companies except the selected one. Ctrl+Click on it again to enable all companies
+STR_SMALLMAP_TOOLTIP_CARGO_SELECTION                            :{BLACK}Click on a cargo to toggle displaying its property. Ctrl+Click disables all cargos except the selected one. Ctrl+Click on it again to enable all cargos
 
 STR_SMALLMAP_LEGENDA_ROADS                                      :{TINYFONT}{BLACK}Roads
 STR_SMALLMAP_LEGENDA_RAILROADS                                  :{TINYFONT}{BLACK}Railways
@@ -699,6 +704,7 @@ STR_SMALLMAP_LEGENDA_SNOW                                       :{TINYFONT}{BLAC
 STR_SMALLMAP_TOOLTIP_TOGGLE_TOWN_NAMES_ON_OFF                   :{BLACK}Toggle town names on/off on map
 STR_SMALLMAP_CENTER                                             :{BLACK}Centre the smallmap on the current position
 STR_SMALLMAP_INDUSTRY                                           :{TINYFONT}{STRING} ({NUM})
+STR_SMALLMAP_LINKSTATS                                          :{TINYFONT}{STRING}
 STR_SMALLMAP_COMPANY                                            :{TINYFONT}{COMPANY}
 STR_SMALLMAP_TOWN                                               :{TINYFONT}{WHITE}{TOWN}
 STR_SMALLMAP_DISABLE_ALL                                        :{BLACK}Disable all
@@ -709,6 +715,8 @@ STR_SMALLMAP_TOOLTIP_ENABLE_ALL_INDUSTRIES                      :{BLACK}Display
 STR_SMALLMAP_TOOLTIP_SHOW_HEIGHT                                :{BLACK}Toggle display of heightmap
 STR_SMALLMAP_TOOLTIP_DISABLE_ALL_COMPANIES                      :{BLACK}Display no company property on the map
 STR_SMALLMAP_TOOLTIP_ENABLE_ALL_COMPANIES                       :{BLACK}Display all company property on the map
+STR_SMALLMAP_TOOLTIP_DISABLE_ALL_CARGOS                         :{BLACK}Display no cargos on the map
+STR_SMALLMAP_TOOLTIP_ENABLE_ALL_CARGOS                          :{BLACK}Display all cargos on the map
 
 # Status bar messages
 STR_STATUSBAR_TOOLTIP_SHOW_LAST_NEWS                            :{BLACK}Show last message or news report
@@ -1322,11 +1330,25 @@ STR_CONFIG_SETTING_LARGER_TOWNS_DISABLED                        :{LTBLUE}Proport
 STR_CONFIG_SETTING_CITY_SIZE_MULTIPLIER                         :{LTBLUE}Initial city size multiplier: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD                        :{LTBLUE}Remove absurd road-elements during the road construction: {ORANGE}{STRING1}
 
+STR_CONFIG_SETTING_LINKGRAPH_INTERVAL                           :{LTBLUE}Link graph recalculation interval: {ORANGE}{STRING1} days
+STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC                       :symmetric
+STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC                      :asymmetric
+STR_CONFIG_SETTING_DISTRIBUTION_MANUAL                          :manual
+STR_CONFIG_SETTING_DISTRIBUTION_PAX                             :{LTBLUE}Distribution for passengers: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_MAIL                            :{LTBLUE}Distribution for mail: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED                        :{LTBLUE}Distribution for the ARMOURED cargo class: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT                         :{LTBLUE}Distribution for other cargo classes: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_LINKGRAPH_ACCURACY                           :{LTBLUE}Accuracy when calculating things on the link graph: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_DISTANCE                              :{LTBLUE}Effect of distance on demands: {ORANGE}{STRING1}%
+STR_CONFIG_SETTING_DEMAND_SIZE                                  :{LTBLUE}Effect of remote station's popularity on symmetric demands: {ORANGE}{STRING1}%
+STR_CONFIG_SETTING_SHORT_PATH_SATURATION                        :{LTBLUE}Saturation of short paths before using capacious paths: {ORANGE}{STRING1}%
+
 STR_CONFIG_SETTING_GUI                                          :{ORANGE}Interface
 STR_CONFIG_SETTING_CONSTRUCTION                                 :{ORANGE}Construction
 STR_CONFIG_SETTING_VEHICLES                                     :{ORANGE}Vehicles
 STR_CONFIG_SETTING_STATIONS                                     :{ORANGE}Stations
 STR_CONFIG_SETTING_ECONOMY                                      :{ORANGE}Economy
+STR_CONFIG_SETTING_LINKGRAPH                                    :{ORANGE}Link graph
 STR_CONFIG_SETTING_AI                                           :{ORANGE}Competitors
 STR_CONFIG_SETTING_DISPLAY_OPTIONS                              :{ORANGE}Display options
 STR_CONFIG_SETTING_INTERACTION                                  :{ORANGE}Interaction
@@ -1879,6 +1901,15 @@ STR_TRANSPARENT_CATENARY_TOOLTIP                                :{BLACK}Toggle t
 STR_TRANSPARENT_LOADING_TOOLTIP                                 :{BLACK}Toggle transparency for loading indicators. Ctrl+Click to lock
 STR_TRANSPARENT_INVISIBLE_TOOLTIP                               :{BLACK}Set objects invisible instead of transparent
 
+# Linkgraph legend window
+STR_LINKGRAPH_LEGEND_CAPTION                                    :{BLACK}Link graph legend
+STR_LINKGRAPH_LEGEND_ALL                                        :{BLACK}All
+STR_LINKGRAPH_LEGEND_NONE                                       :{BLACK}None
+STR_LINKGRAPH_LEGEND_SELECT_COMPANIES                           :{BLACK}Select companies to be displayed
+STR_LINKGRAPH_LEGEND_UNUSED                                     :{TINYFONT}{BLACK}unused
+STR_LINKGRAPH_LEGEND_SATURATED                                  :{TINYFONT}{BLACK}saturated
+STR_LINKGRAPH_LEGEND_OVERLOADED                                 :{TINYFONT}{BLACK}overloaded
+
 # Base for station construction window(s)
 STR_STATION_BUILD_COVERAGE_AREA_TITLE                           :{BLACK}Coverage area highlight
 STR_STATION_BUILD_COVERAGE_OFF                                  :{BLACK}Off
@@ -2608,8 +2639,32 @@ STR_STATION_VIEW_ACCEPTS_CARGO                                  :{BLACK}Accepts:
 
 STR_STATION_VIEW_RATINGS_BUTTON                                 :{BLACK}Ratings
 STR_STATION_VIEW_RATINGS_TOOLTIP                                :{BLACK}Show station ratings
-STR_STATION_VIEW_CARGO_RATINGS_TITLE                            :{BLACK}Local rating of transport service:
+STR_STATION_VIEW_CARGO_RATINGS_TITLE                            :{BLACK}Monthly supply and local rating:
 STR_STATION_VIEW_CARGO_RATING                                   :{WHITE}{STRING}: {YELLOW}{STRING} ({COMMA}%)
+STR_STATION_VIEW_CARGO_SUPPLY_RATING                            :{WHITE}{STRING}: {YELLOW}{COMMA} / {STRING} ({COMMA}%)
+
+STR_STATION_VIEW_GROUP                                          :{BLACK}Group by
+STR_STATION_VIEW_WAITING_STATION                                :Station: Waiting
+STR_STATION_VIEW_WAITING_AMOUNT                                 :Amount: Waiting
+STR_STATION_VIEW_PLANNED_STATION                                :Station: Planned
+STR_STATION_VIEW_PLANNED_AMOUNT                                 :Amount: Planned
+STR_STATION_VIEW_FROM                                           :{YELLOW}{SHORTCARGO} from {STATION}
+STR_STATION_VIEW_VIA                                            :{YELLOW}{SHORTCARGO} via {STATION}
+STR_STATION_VIEW_TO                                             :{YELLOW}{SHORTCARGO} to {STATION}
+STR_STATION_VIEW_FROM_ANY                                       :{RED}{SHORTCARGO} from unknown station
+STR_STATION_VIEW_TO_ANY                                         :{RED}{SHORTCARGO} to any station
+STR_STATION_VIEW_VIA_ANY                                        :{RED}{SHORTCARGO} via any station
+STR_STATION_VIEW_FROM_HERE                                      :{GREEN}{SHORTCARGO} from this station
+STR_STATION_VIEW_VIA_HERE                                       :{GREEN}{SHORTCARGO} stopping at this station
+STR_STATION_VIEW_TO_HERE                                        :{GREEN}{SHORTCARGO} to this station
+STR_STATION_VIEW_NONSTOP                                        :{YELLOW}{SHORTCARGO} non-stop
+
+STR_STATION_VIEW_GROUP_S_V_D                                    :Source-Via-Destination
+STR_STATION_VIEW_GROUP_S_D_V                                    :Source-Destination-Via
+STR_STATION_VIEW_GROUP_V_S_D                                    :Via-Source-Destination
+STR_STATION_VIEW_GROUP_V_D_S                                    :Via-Destination-Source
+STR_STATION_VIEW_GROUP_D_S_V                                    :Destination-Source-Via
+STR_STATION_VIEW_GROUP_D_V_S                                    :Destination-Via-Source
 
 ############ range for rating starts
 STR_CARGO_RATING_APPALLING                                      :Appalling
@@ -3392,6 +3447,10 @@ STR_INCOME_FLOAT_INCOME_SMALL                                   :{TINYFONT}{GREE
 STR_INCOME_FLOAT_INCOME                                         :{GREEN}Income: {CURRENCY}
 STR_FEEDER_TINY                                                 :{TINYFONT}{YELLOW}Transfer: {CURRENCY}
 STR_FEEDER                                                      :{YELLOW}Transfer: {CURRENCY}
+STR_FEEDER_INCOME_TINY                                          :{TINYFONT}{YELLOW}Transfer: {CURRENCY}{WHITE} / {GREEN}Income: {CURRENCY}
+STR_FEEDER_INCOME                                               :{YELLOW}Transfer: {CURRENCY}{WHITE} / {GREEN}Income: {CURRENCY}
+STR_FEEDER_COST_TINY                                            :{TINYFONT}{YELLOW}Transfer: {CURRENCY}{WHITE} / {RED}Cost: {CURRENCY}
+STR_FEEDER_COST                                                 :{YELLOW}Transfer: {CURRENCY}{WHITE} / {RED}Cost: {CURRENCY}
 STR_MESSAGE_ESTIMATED_COST                                      :{WHITE}Estimated Cost: {CURRENCY}
 STR_MESSAGE_ESTIMATED_INCOME                                    :{WHITE}Estimated Income: {CURRENCY}
 
diff --git a/src/linkgraph/demands.cpp b/src/linkgraph/demands.cpp
new file mode 100644
index 0000000..93f6941
--- /dev/null
+++ b/src/linkgraph/demands.cpp
@@ -0,0 +1,184 @@
+/** @file demands.h Definition of demand calculating link graph handler. */
+
+#include "../stdafx.h"
+#include "../station_base.h"
+#include "../settings_type.h"
+#include "../newgrf_cargo.h"
+#include "../cargotype.h"
+#include "../core/math_func.hpp"
+#include "demands.h"
+#include <list>
+
+typedef std::list<NodeID> NodeList;
+
+/**
+ * Set the demands between two nodes using the given base demand. In symmetric mode
+ * this sets demands in both directions.
+ * @param graph The link graph.
+ * @param from_id The supplying node.
+ * @aram to_id The receiving node.
+ * @param demand_forw Demand calculated for the "forward" direction.
+ */
+void SymmetricScaler::SetDemands(LinkGraphComponent *graph, NodeID from_id, NodeID to_id, uint demand_forw)
+{
+	if (graph->GetNode(from_id).demand > 0) {
+		uint demand_back = demand_forw * this->mod_size / 100;
+		uint undelivered = graph->GetNode(to_id).undelivered_supply;
+		if (demand_back > undelivered) {
+			demand_back = undelivered;
+			demand_forw = max(1U, demand_back * 100 / this->mod_size);
+		}
+		this->Scaler::SetDemands(graph, to_id, from_id, demand_back);
+	}
+
+	this->Scaler::SetDemands(graph, from_id, to_id, demand_forw);
+}
+
+/**
+ * Set the demands between two nodes using the given base demand. In asymmetric mode
+ * this only sets demand in the "forward" direction.
+ * @param graph The link graph.
+ * @param from_id The supplying node.
+ * @aram to_id The receiving node.
+ * @param demand_forw Demand calculated for the "forward" direction.
+ */
+FORCEINLINE void Scaler::SetDemands(LinkGraphComponent *graph, NodeID from_id, NodeID to_id, uint demand_forw)
+{
+	Edge &forward = graph->GetEdge(from_id, to_id);
+	forward.demand += demand_forw;
+	forward.unsatisfied_demand += demand_forw;
+	graph->GetNode(from_id).undelivered_supply -= demand_forw;
+}
+
+/**
+ * Do the actual demand calculation, called from constructor.
+ * @param graph Component to calculate the demands for.
+ */
+template<class Tscaler>
+void DemandCalculator::CalcDemand(LinkGraphComponent *graph, Tscaler scaler)
+{
+	NodeList supplies;
+	NodeList demands;
+	uint num_supplies = 0;
+	uint num_demands = 0;
+
+	for (NodeID node = 0; node < graph->GetSize(); node++) {
+		Node &n = graph->GetNode(node);
+		scaler.AddNode(n);
+		if (n.supply > 0) {
+			supplies.push_back(node);
+			num_supplies++;
+		}
+		if (n.demand > 0) {
+			demands.push_back(node);
+			num_demands++;
+		}
+	}
+
+	if (num_supplies == 0 || num_demands == 0) return;
+
+	/* mean acceptance attributed to each node. If the distribution is
+	 * symmetric this is relative to remote supply, otherwise it is
+	 * relative to remote demand.
+	 */
+	scaler.SetDemandPerNode(num_demands);
+	uint chance = 0;
+
+	while (!supplies.empty() && !demands.empty()) {
+		NodeID node1 = supplies.front();
+		supplies.pop_front();
+
+		Node &from = graph->GetNode(node1);
+
+		for (uint i = 0; i < num_demands; ++i) {
+			assert(!demands.empty());
+			NodeID node2 = demands.front();
+			demands.pop_front();
+			if (node1 == node2) {
+				if (demands.empty() && supplies.empty()) {
+					/* only one node with supply and demand left */
+					return;
+				} else {
+					demands.push_back(node2);
+					continue;
+				}
+			}
+			Node &to = graph->GetNode(node2);
+
+			int32 supply = scaler.EffectiveSupply(from, to);
+			assert(supply > 0);
+
+			/* scale the distance by mod_dist around max_distance */
+			int32 distance = this->max_distance - (this->max_distance -
+					(int32)graph->GetEdge(node1, node2).distance) * this->mod_dist / 100;
+
+			/* scale the accuracy by distance around accuracy / 2 */
+			int32 divisor = this->accuracy * (this->mod_dist - 50) / 100 +
+					this->accuracy * distance / this->max_distance + 1;
+
+			assert(divisor > 0);
+
+			uint demand_forw = 0;
+			if (divisor <= supply) {
+				/* at first only distribute demand if
+				 * effective supply / accuracy divisor >= 1
+				 * Others are too small or too far away to be considered.
+				 */
+				demand_forw = supply / divisor;
+			} else if (++chance > this->accuracy * num_demands * num_supplies) {
+				/* After some trying, if there is still supply left, distribute
+				 * demand also to other nodes.
+				 */
+				demand_forw = 1;
+			}
+
+			demand_forw = min(demand_forw, from.undelivered_supply);
+
+			scaler.SetDemands(graph, node1, node2, demand_forw);
+
+			if (scaler.DemandLeft(to)) {
+				demands.push_back(node2);
+			} else {
+				num_demands--;
+			}
+
+			if (from.undelivered_supply == 0) break;
+
+		}
+		if (from.undelivered_supply != 0) {
+			supplies.push_back(node1);
+		} else {
+			num_supplies--;
+		}
+	}
+}
+
+/**
+ * Create the DemandCalculator and immediately do the calculation.
+ * @param graph Component to calculate the demands for.
+ */
+DemandCalculator::DemandCalculator(LinkGraphComponent *graph) :
+	max_distance(MapSizeX() + MapSizeY() + 1)
+{
+	CargoID cargo = graph->GetCargo();
+	const LinkGraphSettings &settings = graph->GetSettings();
+
+	this->accuracy = settings.accuracy;
+	this->mod_dist = settings.demand_distance;
+	if (this->mod_dist > 100) {
+		/* increase effect of mod_dist > 100 */
+		int over100 = this->mod_dist - 100;
+		this->mod_dist = 100 + over100 * over100;
+	}
+
+	switch (settings.GetDistributionType(cargo)) {
+		case DT_SYMMETRIC:
+			this->CalcDemand<SymmetricScaler>(graph, SymmetricScaler(settings.demand_size));
+			break;
+		case DT_ASYMMETRIC:
+			this->CalcDemand<AsymmetricScaler>(graph, AsymmetricScaler());
+			break;
+		default:
+			NOT_REACHED();
+	}
+}
diff --git a/src/linkgraph/demands.h b/src/linkgraph/demands.h
new file mode 100644
index 0000000..009019c
--- /dev/null
+++ b/src/linkgraph/demands.h
@@ -0,0 +1,159 @@
+/** @file demands.h Declaration of demand calculating link graph handler. */
+
+#ifndef DEMANDS_H_
+#define DEMANDS_H_
+
+#include "linkgraph.h"
+#include "../cargo_type.h"
+#include "../map_func.h"
+
+/**
+ * Scale various things according to symmetric/asymmetric distribution.
+ */
+class Scaler {
+public:
+	Scaler() : demand_per_node(0) {}
+
+	void SetDemands(LinkGraphComponent * graph, NodeID from, NodeID to, uint demand_forw);
+protected:
+	uint demand_per_node; ///< Mean demand associated with each node.
+};
+
+/**
+ * Scaler for symmetric distribution.
+ */
+class SymmetricScaler : public Scaler {
+public:
+	FORCEINLINE SymmetricScaler(uint mod_size) : mod_size(mod_size), supply_sum(0) {}
+
+	/**
+	 * Count a node's supply into the sum of supplies.
+	 * @param node Node.
+	 */
+	FORCEINLINE void AddNode(const Node &node)
+	{
+		this->supply_sum += node.supply;
+	}
+
+	/**
+	 * Calculate the mean demand per node using the sum of supplies.
+	 * @param num_demands Number of accepting nodes.
+	 */
+	FORCEINLINE void SetDemandPerNode(uint num_demands)
+	{
+		this->demand_per_node = max(this->supply_sum / num_demands, 1U);
+	}
+
+	/**
+	 * Get the effective supply of one node towards another one. In symmetric
+	 * distribution the supply of the other node is weighed in.
+	 * @param from The supplying node.
+	 * @param to The receiving node.
+	 * @return Effective supply.
+	 */
+	FORCEINLINE uint EffectiveSupply(const Node &from, const Node &to)
+	{
+		return max(from.supply * max(1U, to.supply) * this->mod_size / 100 / this->demand_per_node, 1U);
+	}
+
+	/**
+	 * Check if there is any acceptance left for this node. In symmetric distribution
+	 * nodes only accept anything if they also supply something. So if
+	 * undelivered_supply == 0 at the node there isn't any demand left either.
+	 * @param to The node to be checked.
+	 */
+	FORCEINLINE bool DemandLeft(Node &to)
+	{
+		return (to.supply == 0 || to.undelivered_supply > 0) && to.demand > 0;
+	}
+
+	void SetDemands(LinkGraphComponent *graph, NodeID from, NodeID to, uint demand_forw);
+
+private:
+	uint mod_size;   ///< Size modifier. Determines how much demands increase with the supply of the remote station
+	uint supply_sum; ///< Sum of all supplies in the component.
+};
+
+/**
+ * A scaler for asymmetric distribution.
+ */
+class AsymmetricScaler : public Scaler {
+public:
+	AsymmetricScaler() : demand_sum(0) {}
+
+	/**
+	 * Count a node's demand into the sum of demands.
+	 * @param node The node to be counted.
+	 */
+	FORCEINLINE void AddNode(const Node &node)
+	{
+		this->demand_sum += node.demand;
+	}
+
+	/**
+	 * Calculate the mean demand per node using the sum of demands.
+	 * @param num_demands Number of accepting nodes.
+	 */
+	FORCEINLINE void SetDemandPerNode(uint num_demands)
+	{
+		this->demand_per_node = max(this->demand_sum / num_demands, (uint)1);
+	}
+
+	/**
+	 * Get the effective supply of one node towards another one. In asymmetric
+	 * distribution the demand of the other node is weighed in.
+	 * @param from The supplying node.
+	 * @param to The receiving node.
+	 */
+	FORCEINLINE uint EffectiveSupply(const Node &from, const Node &to)
+	{
+		return max(from.supply * to.demand / this->demand_per_node, (uint)1);
+	}
+
+	/**
+	 * Check if there is any acceptance left for this node. In asymmetric distribution
+	 * nodes always accept as long as their demand > 0.
+	 * @param to The node to be checked.
+	 */
+	FORCEINLINE bool DemandLeft(Node &to) { return to.demand > 0; }
+
+private:
+	uint demand_sum; ///< Sum of all demands in the component.
+};
+
+/**
+ * Calculate the demands. This class has a state, but is recreated for each
+ * call to of DemandHandler::Run.
+ */
+class DemandCalculator {
+public:
+	DemandCalculator(LinkGraphComponent *graph);
+
+private:
+	int32 max_distance; ///< Maximum distance possible on the map.
+	int32 mod_dist;     ///< Distance modifier, determines how much demands decrease with distance.
+	int32 accuracy;     ///< Accuracy of the calculation.
+
+	template<class Tscaler>
+	void CalcDemand(LinkGraphComponent *graph, Tscaler scaler);
+};
+
+/**
+ * Stateless, thread safe demand hander. Doesn't do anything but call DemandCalculator.
+ */
+class DemandHandler : public ComponentHandler {
+public:
+
+	/**
+	 * Call the demand calculator on the given component.
+	 * @param graph Component to calculate the demands for.
+	 */
+	virtual void Run(LinkGraphComponent *graph) { DemandCalculator c(graph); }
+
+	/**
+	 * Virtual destructor has to be defined because of virtual Run().
+	 */
+	virtual ~DemandHandler() {}
+};
+
+#endif /* DEMANDS_H_ */
diff --git a/src/linkgraph/flowmapper.cpp b/src/linkgraph/flowmapper.cpp
new file mode 100644
index 0000000..8b45147
--- /dev/null
+++ b/src/linkgraph/flowmapper.cpp
@@ -0,0 +1,54 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file flowmapper.cpp Definition of flowmapper. */
+
+#include "../stdafx.h"
+#include "flowmapper.h"
+
+/**
+ * Map the paths generated by the MCF solver into flows associated with nodes.
+ * @param component the link graph component to be used.
+ */
+void FlowMapper::Run(LinkGraphComponent *component)
+{
+	for (NodeID node_id = 0; node_id < component->GetSize(); ++node_id) {
+		Node &prev_node = component->GetNode(node_id);
+		StationID prev = prev_node.station;
+		PathSet &paths = prev_node.paths;
+		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
+			Path *path = *i;
+			uint flow = path->GetFlow();
+			if (flow == 0) continue;
+			Node &node = component->GetNode(path->GetNode());
+			StationID via = node.station;
+			assert(prev != via);
+			StationID origin = component->GetNode(path->GetOrigin()).station;
+			assert(via != origin);
+			/* mark all of the flow for local consumption at "first" */
+			node.flows[origin][via] += flow;
+			/* pass some of the flow marked for local consumption at "prev" on
+			 * to this node
+			 */
+			prev_node.flows[origin][via] += flow;
+			/* find simple circular flows ... */
+			assert(node.flows[origin][prev] == 0);
+			if (prev != origin) {
+				prev_node.flows[origin][prev] -= flow;
+			}
+		}
+	}
+	for (NodeID node_id = 0; node_id < component->GetSize(); ++node_id) {
+		PathSet &paths = component->GetNode(node_id).paths;
+		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
+			delete *i;
+		}
+		paths.clear();
+	}
+}
diff --git a/src/linkgraph/flowmapper.h b/src/linkgraph/flowmapper.h
new file mode 100644
index 0000000..a2b6bc0
--- /dev/null
+++ b/src/linkgraph/flowmapper.h
@@ -0,0 +1,30 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file flowmapper.h Declaration of flow mapper; maps paths into flows at nodes. */
+
+#ifndef FLOWMAPPER_H_
+#define FLOWMAPPER_H_
+
+#include "linkgraph.h"
+
+/**
+ * Map the path trees generated by the MCF solver into flows. The path tree is
+ * useful to cache capacities and distances and allow quick disconnecting and
+ * reconnecting to other paths. The flows show how much cargo from which nodes
+ * is to be routed in which direction at a given node. This is what we need in
+ * the end.
+ */
+class FlowMapper : public ComponentHandler {
+public:
+	virtual ~FlowMapper() {}
+	virtual void Run(LinkGraphComponent *component);
+};
+
+#endif /* FLOWMAPPER_H_ */
diff --git a/src/linkgraph/linkgraph.cpp b/src/linkgraph/linkgraph.cpp
new file mode 100644
index 0000000..61c0c2e
--- /dev/null
+++ b/src/linkgraph/linkgraph.cpp
@@ -0,0 +1,545 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph.cpp Definition of link graph classes used for cargo distribution. */
+
+#include "../stdafx.h"
+#include "../map_func.h"
+#include "../core/bitmath_func.hpp"
+#include "../debug.h"
+#include "../window_func.h"
+#include "../window_gui.h"
+#include "../moving_average.h"
+#include "linkgraph.h"
+#include "demands.h"
+#include "mcf.h"
+#include "flowmapper.h"
+#include <queue>
+
+/**
+ * Global array of link graphs, one for each cargo.
+ */
+LinkGraph _link_graphs[NUM_CARGO];
+
+/**
+ * Handlers to be run for each job.
+ */
+LinkGraphJob::HandlerList LinkGraphJob::_handlers;
+
+/**
+ * Create a node or clear it.
+ * @param st ID of the associated station.
+ * @param sup Supply of cargo at the station last month.
+ * @param dem Acceptance for cargo at the station.
+ */
+void Node::Init(StationID st, uint sup, uint dem)
+{
+	this->supply = sup;
+	this->undelivered_supply = sup;
+	this->demand = dem;
+	this->station = st;
+
+	for (PathSet::iterator i = this->paths.begin(); i != this->paths.end(); ++i) {
+		delete *i;
+	}
+	this->paths.clear();
+	this->flows.clear();
+}
+
+/**
+ * Create an edge.
+ * @param distance Length of the link as manhattan distance.
+ * @param capacity Capacity of the link.
+ */
+FORCEINLINE void Edge::Init(uint distance, uint capacity)
+{
+	this->distance = distance;
+	this->capacity = capacity;
+	this->demand = 0;
+	this->unsatisfied_demand = 0;
+	this->flow = 0;
+	this->next_edge = INVALID_NODE;
+}
+
+
+/**
+ * 1. Build the link graph component containing the given station by using BFS on the link stats.
+ * 2. Set every included station's last_component to the new component's ID (this->current_component_id).
+ * 3. Start a link graph job with the new component.
+ * @param first Station to start the search at.
+ */
+void LinkGraph::CreateComponent(Station *first)
+{
+	std::map<Station *, NodeID> index;
+	index[first] = this->AddNode(first);
+
+	std::queue<Station *> search_queue;
+	search_queue.push(first);
+
+	/* find all stations belonging to the current component */
+	while (!search_queue.empty()) {
+		Station *source = search_queue.front();
+		search_queue.pop();
+
+		const LinkStatMap &links = source->goods[this->cargo].link_stats;
+		for (LinkStatMap::const_iterator i = links.begin(); i != links.end(); ++i) {
+			Station *target = Station::GetIfValid(i->first);
+			if (target == NULL) continue;
+
+			std::map<Station *, NodeID>::iterator index_it = index.find(target);
+			if (index_it == index.end()) {
+				search_queue.push(target);
+				NodeID node = this->AddNode(target);
+				index[target] = node;
+
+				this->AddEdge(index[source], node, i->second.Capacity());
+			} else {
+				this->AddEdge(index[source], index_it->second, i->second.Capacity());
+			}
+		}
+	}
+
+	/* here the list of nodes and edges for this component is complete. */
+	this->SpawnThread();
+}
+
+/**
+ * Looks for a suitable station to create the next link graph component from.
+ * Linearly searches all stations starting from current_station_id for one that
+ * hasn't been visited in this run over the link graph. The current run and the
+ * last run are differentiated by giving the components IDs divisible by 2
+ * every second run and ones not divisible by 2 on the other runs.
+ *
+ * If such a station is found current_station_id is set to that station's ID
+ * and CreateComponent is called with it.
+ *
+ * The search wraps around and changes current_component_id to 0 or 1
+ * accordingly. If the starting point is reached again it stops.
+ */
+void LinkGraph::NextComponent()
+{
+	if (this->GetSize() > 0) return; // don't mess with running jobs (might happen when changing interval)
+	StationID last_station_id = this->current_station_id;
+	LinkGraphComponentID current_component_id = this->LinkGraphComponent::index;
+
+	do {
+		if (++this->current_station_id >= Station::GetPoolSize()) {
+			/* Wrap around and recycle the component IDs. Use different
+			 * divisibility by 2 than in the last run so that we can find out
+			 * which stations haven't been seen in this run.
+			 */
+			this->current_station_id = 0;
+			if (current_component_id % 2 == 0) {
+				current_component_id = 1;
+			} else {
+				current_component_id = 0;
+			}
+		}
+
+		/* find first station of next component */
+		Station *station = Station::GetIfValid(this->current_station_id);
+		if (station != NULL) {
+			GoodsEntry &ge = station->goods[this->cargo];
+			if (ge.last_component == INVALID_LINKGRAPH_COMPONENT ||
+					(ge.last_component + current_component_id) % 2 != 0) {
+				/* Different divisibility by 2: This station has not been seen
+				 * in the current run over the link graph.
+				 */
+
+				if (!ge.link_stats.empty()) {
+					this->LinkGraphComponent::Init(current_component_id + 2);
+					CreateComponent(station);
+					return;
+				}
+			}
+		}
+
+	} while (this->current_station_id != last_station_id);
+}
+
+/**
+ * Spawn or join a link graph component if any link graph is due to do so.
+ * Spawning is done on COMPONENTS_SPAWN_TICK every day, joining on
+ * COMPONENT_JOIN_TICK. Each link graph is due every recalc_interval days.
+ */
+void OnTick_LinkGraph()
+{
+	if (_date_fract == LinkGraph::COMPONENTS_SPAWN_TICK ||
+			_date_fract == LinkGraph::COMPONENTS_JOIN_TICK) {
+
+		/* This creates a fair distribution of all link graphs' turns over
+		 * the available dates.
+		 */
+		for (uint cargo = _date % _settings_game.linkgraph.recalc_interval; cargo < NUM_CARGO;
+				cargo += _settings_game.linkgraph.recalc_interval) {
+
+			/* don't calculate a link graph if the distribution is manual */
+			if (_settings_game.linkgraph.GetDistributionType(cargo) == DT_MANUAL) continue;
+
+			if (_date_fract == LinkGraph::COMPONENTS_SPAWN_TICK) {
+				_link_graphs[cargo].NextComponent();
+			} else /* LinkGraph::COMPONENTS_JOIN_TICK */ {
+				_link_graphs[cargo].Join();
+			}
+		}
+	}
+}
+
+/**
+ * Add a node to the component and create empty edges associated with it. Set
+ * the station's last_component to this component. Calculate the distances to all
+ * other nodes. The distances to _all_ nodes are important as the demand
+ * calculator relies on their availability.
+ * @param st New node's station.
+ * @return New node's ID.
+ */
+NodeID LinkGraphComponent::AddNode(Station *st)
+{
+	GoodsEntry &good = st->goods[this->cargo];
+	good.last_component = this->index;
+
+	bool do_resize = (this->nodes.size() == this->num_nodes);
+
+	if (do_resize) {
+		this->nodes.push_back(Node());
+		this->edges.push_back(std::vector<Edge>(this->num_nodes + 1));
+	}
+
+	this->nodes[this->num_nodes].Init(st->index, good.supply,
+			HasBit(good.acceptance_pickup, GoodsEntry::ACCEPTANCE));
+
+	std::vector<Edge> &new_edges = this->edges[this->num_nodes];
+
+	/* reset the first edge starting at the new node */
+	new_edges[this->num_nodes].next_edge = INVALID_NODE;
+
+	for (NodeID i = 0; i < this->num_nodes; ++i) {
+		uint distance = DistanceManhattan(st->xy, Station::Get(this->nodes[i].station)->xy);
+		if (do_resize) this->edges[i].push_back(Edge());
+		new_edges[i].Init(distance);
+		this->edges[i][this->num_nodes].Init(distance);
+	}
+	return this->num_nodes++;
+}
+
+/**
+ * Fill an edge with values from a link.
+ * @param from Source node of the link.
+ * @param to Destination node of the link.
+ * @param capacity Capacity of the link.
+ */
+FORCEINLINE void LinkGraphComponent::AddEdge(NodeID from, NodeID to, uint capacity)
+{
+	assert(from != to);
+	Edge &edge = this->edges[from][to];
+	Edge &first = this->edges[from][from];
+	edge.capacity = capacity;
+	edge.next_edge = first.next_edge;
+	first.next_edge = to;
+}
+
+/**
+ * Resize the component and fill it with empty nodes and edges. Used when
+ * loading from save games.
+ *
+ * WARNING: The nodes and edges are expected to contain anything while
+ * num_nodes is expected to contain the desired size. Normally this is an
+ * invalid state, but just after loading the component's structure it is valid.
+ * This method should only be called from Load_LGRP.
+ */
+void LinkGraphComponent::SetSize()
+{
+	if (this->nodes.size() < this->num_nodes) {
+		for (EdgeMatrix::iterator i = this->edges.begin(); i != this->edges.end(); ++i) {
+			i->resize(this->num_nodes);
+		}
+		this->nodes.resize(this->num_nodes);
+		this->edges.resize(this->num_nodes, std::vector<Edge>(this->num_nodes));
+	}
+
+	for (uint i = 0; i < this->num_nodes; ++i) {
+		this->nodes[i].Init();
+		for (uint j = 0; j < this->num_nodes; ++j) {
+			this->edges[i][j].Init();
+		}
+	}
+}
+
+/**
+ * Create an empty component.
+ */
+LinkGraphComponent::LinkGraphComponent() :
+		settings(_settings_game.linkgraph),
+		cargo(INVALID_CARGO),
+		num_nodes(0),
+		index(INVALID_LINKGRAPH_COMPONENT)
+{}
+
+/**
+ * (Re-)initialize this component with a new ID and a new copy of the settings.
+ */
+void LinkGraphComponent::Init(LinkGraphComponentID id)
+{
+	assert(this->num_nodes == 0);
+	this->index = id;
+	this->settings = _settings_game.linkgraph;
+}
+
+
+/**
+ * Exports all entries in the FlowViaMap pointed to by "source_flows_it", erases the source
+ * flows and increments the iterator afterwards.
+ * @param it Iterator pointing to the flows to be exported into the main game state.
+ * @param dest Flow stats to which the flows shall be exported.
+ * @param cargo Cargo we're exporting flows for (used to check if the link stats for the new
+ *        flows still exist).
+ */
+void Node::ExportNewFlows(FlowMap::iterator &it, FlowStatSet &dest, CargoID cargo)
+{
+	StationID source = it->first;
+	FlowViaMap &source_flows = it->second;
+	if (!Station::IsValidID(source)) {
+		source_flows.clear();
+	} else {
+		Station *curr_station = Station::Get(this->station);
+		for (FlowViaMap::iterator update = source_flows.begin(); update != source_flows.end();) {
+			StationID next = update->first;
+			int planned = update->second;
+			assert(planned >= 0);
+
+			Station *via = Station::GetIfValid(next);
+			if (planned > 0 && via != NULL) {
+				uint distance = GetMovingAverageLength(curr_station, via);
+				if (next != this->station) {
+					const LinkStatMap &ls = curr_station->goods[cargo].link_stats;
+					if (ls.find(next) != ls.end()) {
+						dest.insert(FlowStat(distance, next, planned, 0));
+					}
+				} else {
+					dest.insert(FlowStat(distance, next, planned, 0));
+				}
+			}
+			source_flows.erase(update++);
+		}
+	}
+	assert(source_flows.empty());
+
+	this->flows.erase(it++);
+}
+
+/**
+ * Export all flows of this node to the main game state.
+ * @param cargo the cargo we're exporting flows for.
+ */
+void Node::ExportFlows(CargoID cargo)
+{
+	FlowStatMap &station_flows = Station::Get(this->station)->goods[cargo].flows;
+	FlowStatSet new_flows;
+	/* loop over all existing flows in the station and update them */
+	for (FlowStatMap::iterator station_outer_it(station_flows.begin()); station_outer_it != station_flows.end();) {
+		FlowMap::iterator node_outer_it(this->flows.find(station_outer_it->first));
+		if (node_outer_it == this->flows.end()) {
+			/* there are no flows for this source node anymore */
+			station_flows.erase(station_outer_it++);
+		} else {
+			FlowViaMap &source = node_outer_it->second;
+			FlowStatSet &dest = station_outer_it->second;
+			/* loop over the station's flow stats for this source node and update them */
+			for (FlowStatSet::iterator station_inner_it(dest.begin()); station_inner_it != dest.end();) {
+				FlowViaMap::iterator node_inner_it(source.find(station_inner_it->Via()));
+				if (node_inner_it != source.end()) {
+					assert(node_inner_it->second >= 0);
+					if (node_inner_it->second > 0) {
+						new_flows.insert(FlowStat(*station_inner_it, node_inner_it->second));
+					}
+					source.erase(node_inner_it);
+				}
+				dest.erase(station_inner_it++);
+			}
+			/* swap takes constant time, so we swap instead of adding all entries */
+			dest.swap(new_flows);
+			assert(new_flows.empty());
+			/* insert remaining flows for this source node */
+			ExportNewFlows(node_outer_it, dest, cargo);
+			/* careful: source_flows is dangling here */
+			++station_outer_it;
+		}
+	}
+	/* loop over remaining flows (for other sources) in the node's map and insert them into the station */
+	for (FlowMap::iterator it(this->flows.begin()); it != this->flows.end();) {
+		ExportNewFlows(it, station_flows[it->first], cargo);
+	}
+	assert(this->flows.empty());
+}
+
+/**
+ * Merge the current job's results into the main game state.
+ */
+void LinkGraph::Join()
+{
+	this->LinkGraphJob::Join();
+
+	for (NodeID node_id = 0; node_id < this->GetSize(); ++node_id) {
+		Node &node = this->GetNode(node_id);
+		if (Station::IsValidID(node.station)) {
+			node.ExportFlows(this->cargo);
+			InvalidateWindowData(WC_STATION_VIEW, node.station, this->GetCargo());
+		}
+	}
+
+	this->LinkGraphComponent::Clear();
+}
+
+/**
+ * Run all handlers for the given Job.
+ * @param j Pointer to a link graph job.
+ */
+/* static */ void LinkGraphJob::RunLinkGraphJob(void *j)
+{
+	LinkGraphJob *job = (LinkGraphJob *)j;
+	for (HandlerList::iterator i = _handlers.begin(); i != _handlers.end(); ++i) {
+		(*i)->Run(job);
+	}
+}
+
+/**
+ * Clear the handlers.
+ */
+/* static */ void LinkGraphJob::ClearHandlers()
+{
+	for (HandlerList::iterator i = _handlers.begin(); i != _handlers.end(); ++i) {
+		delete *i;
+	}
+	_handlers.clear();
+}
+
+/**
+ * Add this path as a new child to the given base path, thus making this path
+ * a "fork" of the base path.
+ * @param base the path to fork from
+ * @param cap maximum capacity of the new path
+ * @param dist distance of the new leg
+ */
+void Path::Fork(Path *base, uint cap, int free_cap, uint dist)
+{
+	this->capacity = min(base->capacity, cap);
+	this->free_capacity = min(base->free_capacity, free_cap);
+	this->distance = base->distance + dist;
+	assert(this->distance > 0);
+	if (this->parent != base) {
+		this->Detach();
+		this->parent = base;
+		this->parent->num_children++;
+	}
+	this->origin = base->origin;
+}
+
+/**
+ * Push some flow along a path and register the path in the nodes it passes if
+ * successful.
+ * @param new_flow amount of flow to push
+ * @param graph the link graph component this node belongs to
+ * @param only_positive if true, don't push more flow than there is capacity
+ * @return the amount of flow actually pushed
+ */
+uint Path::AddFlow(uint new_flow, LinkGraphComponent *graph, bool only_positive)
+{
+	if (this->parent != NULL) {
+		Edge &edge = graph->GetEdge(this->parent->node, this->node);
+		if (only_positive) {
+			uint usable_cap = edge.capacity * graph->GetSettings().short_path_saturation / 100;
+			if (usable_cap > edge.flow) {
+				new_flow = min(new_flow, usable_cap - edge.flow);
+			} else {
+				return 0;
+			}
+		}
+		new_flow = this->parent->AddFlow(new_flow, graph, only_positive);
+		if (new_flow > 0) {
+			graph->GetNode(this->parent->node).paths.insert(this);
+		}
+		edge.flow += new_flow;
+	}
+	this->flow += new_flow;
+	return new_flow;
+}
+
+/**
+ * create a leg of a path in the link graph.
+ * @param n id of the link graph node this path passes
+ * @param source if true, this is the first leg of the path
+ */
+Path::Path(NodeID n, bool source) :
+	distance(source ? 0 : UINT_MAX),
+	capacity(0),
+	free_capacity(source ? INT_MAX : INT_MIN),
+	flow(0), node(n), origin(source ? n : INVALID_NODE),
+	num_children(0), parent(NULL)
+{}
+
+/**
+ * Join the calling thread with this job's thread if threading is enabled.
+ */
+FORCEINLINE void LinkGraphJob::Join()
+{
+	if (this->thread == NULL) return;
+	this->thread->Join();
+	delete this->thread;
+	this->thread = NULL;
+}
+
+/**
+ * Spawn a thread if possible and run the link graph job in the thread. If
+ * that's not possible run the job right now in the current thread.
+ */
+void LinkGraphJob::SpawnThread()
+{
+	assert(this->thread == NULL);
+	if (!ThreadObject::New(&(LinkGraphJob::RunLinkGraphJob), this, &(this->thread))) {
+		this->thread = NULL;
+		/* Of course this will hang a bit.
+		 * On the other hand, if you want to play games which make this hang noticably
+		 * on a platform without threads then you'll probably get other problems first.
+		 * OK:
+		 * If someone comes and tells me that this hangs for him/her, I'll implement a
+		 * smaller grained "Step" method for all handlers and add some more ticks where
+		 * "Step" is called. No problem in principle.
+		 */
+		LinkGraphJob::RunLinkGraphJob(this);
+	}
+}
+
+/**
+ * (Re-)Initialize the link graph: join all jobs and set current_station_id and
+ * cargo to their start values.
+ * @param cargo New cargo ID for the link graph.
+ */
+void LinkGraph::Init(CargoID cargo)
+{
+	this->LinkGraphJob::Join();
+	this->LinkGraphComponent::Clear();
+
+	this->current_station_id = 0;
+	this->LinkGraphComponent::cargo = cargo;
+}
+
+/**
+ * Initialize all link graphs. Used when loading a game.
+ */
+void InitializeLinkGraphs()
+{
+	for (CargoID c = 0; c < NUM_CARGO; ++c) _link_graphs[c].Init(c);
+
+	LinkGraphJob::ClearHandlers();
+	LinkGraphJob::AddHandler(new DemandHandler);
+	LinkGraphJob::AddHandler(new MCFHandler<MCF1stPass>);
+	LinkGraphJob::AddHandler(new FlowMapper);
+	LinkGraphJob::AddHandler(new MCFHandler<MCF2ndPass>);
+	LinkGraphJob::AddHandler(new FlowMapper);
+}
diff --git a/src/linkgraph/linkgraph.h b/src/linkgraph/linkgraph.h
new file mode 100644
index 0000000..acea738
--- /dev/null
+++ b/src/linkgraph/linkgraph.h
@@ -0,0 +1,348 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph.h Declaration of link graph classes used for cargo distribution. */
+
+#ifndef LINKGRAPH_H_
+#define LINKGRAPH_H_
+
+#include "../station_base.h"
+#include "../cargo_type.h"
+#include "../thread/thread.h"
+#include "../settings_type.h"
+#include "../date_func.h"
+#include "linkgraph_type.h"
+#include <list>
+#include <vector>
+#include <set>
+
+struct SaveLoad;
+class Path;
+
+typedef std::set<Path *> PathSet;
+typedef std::map<NodeID, Path *> PathViaMap;
+typedef std::map<StationID, int> FlowViaMap;
+typedef std::map<StationID, FlowViaMap> FlowMap;
+
+/**
+ * Node of the link graph. contains all relevant information from the associated
+ * station. It's copied so that the link graph job can work on its own data set
+ * in a separate thread.
+ */
+class Node {
+public:
+	uint supply;             ///< Supply at the station.
+	uint undelivered_supply; ///< Amount of supply that hasn't been distributed yet.
+	uint demand;             ///< Acceptance at the station.
+	StationID station;       ///< Station ID.
+	PathSet paths;           ///< Paths through this node.
+	FlowMap flows;           ///< Planned flows to other nodes.
+
+	/**
+	 * Clear a node on destruction to delete paths that might remain.
+	 */
+	~Node() {this->Init();}
+
+	void Init(StationID st = INVALID_STATION, uint sup = 0, uint dem = 0);
+	void ExportFlows(CargoID cargo);
+
+private:
+	void ExportNewFlows(FlowMap::iterator &it, FlowStatSet &via_set, CargoID cargo);
+};
+
+/**
+ * An edge in the link graph. Corresponds to a link between two stations or at
+ * least the distance between them. Edges from one node to itself contain the
+ * ID of the opposite Node of the first active edge (i.e. not just distance) in
+ * the column as next_edge.
+ */
+class Edge {
+public:
+	uint distance;           ///< Length of the link.
+	uint capacity;           ///< Capacity of the link.
+	uint demand;             ///< Transport demand between the nodes.
+	uint unsatisfied_demand; ///< Demand over this edge that hasn't been satisfied yet.
+	uint flow;               ///< Planned flow over this edge.
+	NodeID next_edge;        ///< Destination of next valid edge starting at the same source node.
+
+	void Init(uint distance = 0, uint capacity = 0);
+};
+
+/**
+ * A connected component of a link graph. Contains a complete set of stations
+ * connected by links as nodes and edges. Each component also holds a copy of
+ * the link graph settings at the time of its creation. The global settings
+ * might change between the creation and join time so we can't rely on them.
+ */
+class LinkGraphComponent {
+private:
+	typedef std::vector<Node> NodeVector;
+	typedef std::vector<std::vector<Edge> > EdgeMatrix;
+
+public:
+	LinkGraphComponent();
+
+	void Init(LinkGraphComponentID id);
+
+	/**
+	 * Get a reference to an edge.
+	 * @param from Origin node.
+	 * @param to Destination node.
+	 * @return Edge between from and to.
+	 */
+	FORCEINLINE Edge &GetEdge(NodeID from, NodeID to)
+	{
+		return this->edges[from][to];
+	}
+
+	/**
+	 * Get a reference to a node with the specified id.
+	 * @param num ID of the node.
+	 * @return the Requested node.
+	 */
+	FORCEINLINE Node &GetNode(NodeID num)
+	{
+		return this->nodes[num];
+	}
+
+	/**
+	 * Get the current size of the component.
+	 * @return Size.
+	 */
+	FORCEINLINE uint GetSize() const
+	{
+		return this->num_nodes;
+	}
+
+	void SetSize();
+
+	NodeID AddNode(Station *st);
+
+	void AddEdge(NodeID from, NodeID to, uint capacity);
+
+	/**
+	 * Get the ID of this component.
+	 * @return ID.
+	 */
+	FORCEINLINE LinkGraphComponentID GetIndex() const
+	{
+		return this->index;
+	}
+
+	/**
+	 * Get the cargo ID this component's link graph refers to.
+	 * @return Cargo ID.
+	 */
+	FORCEINLINE CargoID GetCargo() const
+	{
+		return this->cargo;
+	}
+
+	/**
+	 * Get the link graph settings for this component.
+	 * @return Settings.
+	 */
+	FORCEINLINE const LinkGraphSettings &GetSettings() const
+	{
+		return this->settings;
+	}
+
+	/**
+	 * Get the first valid edge starting at the specified node.
+	 * @param from ID of the source node
+	 * @return ID of the destination node
+	 */
+	FORCEINLINE NodeID GetFirstEdge(NodeID from) {return edges[from][from].next_edge;}
+
+	/**
+	 * Set the number of nodes to 0 to mark this component as done.
+	 */
+	FORCEINLINE void Clear()
+	{
+		this->num_nodes = 0;
+	}
+
+protected:
+	LinkGraphSettings settings; ///< Copy of _settings_game.linkgraph at creation time.
+	CargoID cargo;              ///< Cargo of this component's link graph.
+	uint num_nodes;             ///< Number of nodes in the component.
+	LinkGraphComponentID index; ///< ID of the component.
+	NodeVector nodes;           ///< Nodes in the component.
+	EdgeMatrix edges;           ///< Edges in the component.
+};
+
+/**
+ * A handler doing "something" on a link graph component. It must not keep any
+ * state as it is called concurrently from different threads.
+ */
+class ComponentHandler {
+public:
+	/**
+	 * Destroy the handler. Must be given due to virtual Run.
+	 */
+	virtual ~ComponentHandler() {}
+
+	/**
+	 * Run the handler. A link graph handler must not read or write any data
+	 * outside the given component as that would create a potential desync.
+	 * @param component Link graph component to run the handler on.
+	 */
+	virtual void Run(LinkGraphComponent *component) = 0;
+};
+
+/**
+ * A job to be executed on a link graph component. It inherits a component and
+ * keeps a static list of handlers to be run on it. It may or may not run in a
+ * thread and contains a thread object for this option.
+ */
+class LinkGraphJob : public LinkGraphComponent {
+private:
+	typedef std::list<ComponentHandler *> HandlerList;
+
+public:
+
+	LinkGraphJob() : thread(NULL) {}
+
+	/**
+	 * Destructor; Clean up the thread if it's there.
+	 */
+	~LinkGraphJob()
+	{
+		this->Join();
+	}
+
+	static void RunLinkGraphJob(void *j);
+
+	/**
+	 * Add a handler to the end of the list.
+	 * @param handler Handler to be added.
+	 */
+	static void AddHandler(ComponentHandler *handler)
+	{
+		LinkGraphJob::_handlers.push_back(handler);
+	}
+
+	static void ClearHandlers();
+
+	void SpawnThread();
+
+	void Join();
+
+private:
+	static HandlerList _handlers;   ///< Handlers the job is executing.
+	ThreadObject *thread;           ///< Thread the job is running in or NULL if it's running in the main thread.
+
+	/**
+	 * Private Copy-Constructor: there cannot be two identical LinkGraphJobs.
+	 * @param other hypothetical other job to be copied.
+	 * @note It's necessary to explicitly initialize the link graph component in order to silence some compile warnings.
+	 */
+	LinkGraphJob(const LinkGraphJob &other) : LinkGraphComponent(other) {NOT_REACHED();}
+};
+
+/**
+ * A link graph, inheriting one job.
+ */
+class LinkGraph : public LinkGraphJob {
+public:
+	/* Those are ticks where not much else is happening, so a small lag might go unnoticed. */
+	static const uint COMPONENTS_JOIN_TICK  = 21; ///< Tick when jobs are joined every day.
+	static const uint COMPONENTS_SPAWN_TICK = 58; ///< Tick when jobs are spawned every day.
+
+	/**
+	 * Create a link graph.
+	 */
+	LinkGraph() : current_station_id(0) {}
+
+	void Init(CargoID cargo);
+
+	void NextComponent();
+
+	void Join();
+
+private:
+	StationID current_station_id; ///< ID of the last station examined while creating components.
+
+	friend const SaveLoad *GetLinkGraphDesc();
+
+	void CreateComponent(Station *first);
+};
+
+/**
+ * A leg of a path in the link graph. Paths can form trees by being "forked".
+ */
+class Path {
+public:
+	Path(NodeID n, bool source = false);
+
+	/** Get the node this leg passes. */
+	FORCEINLINE NodeID GetNode() const {return this->node;}
+
+	/** Get the overall origin of the path. */
+	FORCEINLINE NodeID GetOrigin() const {return this->origin;}
+
+	/** Get the parent leg of this one. */
+	FORCEINLINE Path *GetParent() {return this->parent;}
+
+	/** Get the overall capacity of the path. */
+	FORCEINLINE uint GetCapacity() const {return this->capacity;}
+
+	/** Get the free capacity of the path. */
+	FORCEINLINE int GetFreeCapacity() const {return this->free_capacity;}
+
+	/**
+	 * Get ratio of free * 16 (so that we get fewer 0) /
+	 * overall capacity + 1 (so that we don't divide by 0).
+	 */
+	FORCEINLINE int GetCapacityRatio() const {return (this->free_capacity << 4) / (this->capacity + 1);}
+
+	/** Get the overall distance of the path. */
+	FORCEINLINE uint GetDistance() const {return this->distance;}
+
+	/** Reduce the flow on this leg only by the specified amount. */
+	FORCEINLINE void ReduceFlow(uint f) {this->flow -= f;}
+
+	/** Increase the flow on this leg only by the specified amount. */
+	FORCEINLINE void AddFlow(uint f) {this->flow += f;}
+
+	/** Get the flow on this leg. */
+	FORCEINLINE uint GetFlow() const {return this->flow;}
+
+	/** Get the number of "forked off" child legs of this one. */
+	FORCEINLINE uint GetNumChildren() const {return this->num_children;}
+
+	/**
+	 * Detach this path from its parent.
+	 */
+	FORCEINLINE void Detach()
+	{
+		if (this->parent != NULL) {
+			this->parent->num_children--;
+			this->parent = NULL;
+		}
+	}
+
+	uint AddFlow(uint f, LinkGraphComponent *graph, bool only_positive);
+	void Fork(Path *base, uint cap, int free_cap, uint dist);
+
+protected:
+	uint distance;     ///< Sum(distance of all legs up to this one).
+	uint capacity;     ///< This capacity is min(capacity) fom all edges.
+	int free_capacity; ///< This capacity is min(edge.capacity - edge.flow) for the current run of Dijkstra.
+	uint flow;         ///< Flow the current run of the mcf solver assigns.
+	NodeID node;       ///< Link graph node this leg passes.
+	NodeID origin;     ///< Link graph node this path originates from.
+	uint num_children; ///< Number of child legs that have been forked from this path.
+	Path *parent;      ///< Parent leg of this one.
+};
+
+void InitializeLinkGraphs();
+extern LinkGraph _link_graphs[NUM_CARGO];
+
+#endif /* LINKGRAPH_H_ */
diff --git a/src/linkgraph/linkgraph_type.h b/src/linkgraph/linkgraph_type.h
new file mode 100644
index 0000000..cd73b1c
--- /dev/null
+++ b/src/linkgraph/linkgraph_type.h
@@ -0,0 +1,36 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_type.h Declaration of link graph types used for cargo distribution. */
+
+#ifndef LINKGRAPH_TYPE_H_
+#define LINKGRAPH_TYPE_H_
+
+typedef uint16 LinkGraphComponentID;
+static const LinkGraphComponentID INVALID_LINKGRAPH_COMPONENT = UINT16_MAX;
+
+typedef uint NodeID;
+static const NodeID INVALID_NODE = UINT_MAX;
+
+enum DistributionType {
+	DT_BEGIN = 0,
+	DT_SYMMETRIC = 0, ///< symmetric distribution. The same amount of cargo travels in each direction between each pair of nodes.
+	DT_ASYMMETRIC,    ///< asymmetric distribution. Usually cargo will only travel in one direction.
+	DT_MANUAL,        ///< manual distribution. No link graph calculations are run.
+	DT_NUM = 3,
+	DT_END = 3
+};
+
+/* It needs to be 8bits, because we save and load it as such
+ * Define basic enum properties
+ */
+template <> struct EnumPropsT<DistributionType> : MakeEnumPropsT<DistributionType, byte, DT_BEGIN, DT_END, DT_NUM> {};
+typedef TinyEnumT<DistributionType> DistributionTypeByte; // typedefing-enumification of DistributionType
+
+#endif /* LINKGRAPH_TYPE_H_ */
diff --git a/src/linkgraph/mcf.cpp b/src/linkgraph/mcf.cpp
new file mode 100644
index 0000000..a4481d3
--- /dev/null
+++ b/src/linkgraph/mcf.cpp
@@ -0,0 +1,417 @@
+/** @file mcf.cpp Definition of Multi-Commodity-Flow solver. */
+
+#include "../stdafx.h"
+#include "../core/math_func.hpp"
+#include "mcf.h"
+
+/**
+ * Determines if an extension to the given Path with the given parameters is
+ * better than this path.
+ * @param base Other path.
+ * @param cap Capacity of the new edge to be added to base.
+ * @param dist Distance of the new edge.
+ * @return True if base + the new edge would be better than the path associated
+ * with this annotation.
+ */
+bool DistanceAnnotation::IsBetter(const DistanceAnnotation *base, uint cap,
+		int free_cap, uint dist) const
+{
+	/* If any of the paths is disconnected, the other one is better. If both
+	 * are disconnected, this path is better.
+	 */
+	if (base->distance == UINT_MAX) {
+		return false;
+	} else if (this->distance == UINT_MAX) {
+		return true;
+	}
+
+	if (free_cap > 0 && base->free_capacity > 0) {
+		/* If both paths have capacity left, compare their distances.
+		 * If the other path has capacity left and this one hasn't, the
+		 * other one's better.
+		 */
+		return this->free_capacity > 0 ? (base->distance + dist < this->distance) : true;
+	} else {
+		/* If the other path doesn't have capacity left, but this one has,
+		 * this one is better.
+		 * If both paths are out of capacity, do the regular distance
+		 * comparison.
+		 */
+		return this->free_capacity > 0 ? false : (base->distance + dist < this->distance);
+	}
+}
+
+/**
+ * Determines if an extension to the given Path with the given parameters is
+ * better than this path.
+ * @param base Other path.
+ * @param cap Capacity of the new edge to be added to base.
+ * @param dist Distance of the new edge.
+ * @return True if base + the new edge would be better than the path associated
+ * with this annotation.
+ */
+bool CapacityAnnotation::IsBetter(const CapacityAnnotation *base, uint cap,
+		int free_cap, uint dist) const
+{
+	int min_cap = (min(base->free_capacity, free_cap) << 4) / (min(base->capacity, cap) + 1);
+	int this_cap = this->GetCapacityRatio();
+	if (min_cap == this_cap) {
+		/* If the capacities are the same and the other path isn't disconnected
+		 * choose the shorter path.
+		 */
+		return base->distance == UINT_MAX ? false : (base->distance + dist < this->distance);
+	} else {
+		return min_cap > this_cap;
+	}
+}
+
+/**
+ * A slightly modified Dijkstra algorithm. Grades the paths not necessarily by
+ * distance, but by the value Tannotation computes. It can also be configured
+ * to only use paths already created before and not create new ones. If this is
+ * not done it uses the short_path_saturation setting to artificially decrease
+ * capacities. If a path has already been created is determined by checking the
+ * flows associated with its nodes.
+ * @tparam Tannotation Annotation to be used.
+ * @param source_node Node where the algorithm starts.
+ * @param paths Container for the paths to be calculated.
+ * @param create_new_paths If false, only use paths already seen before,
+ *                         otherwise artificially limit the capacity.
+ */
+template<class Tannotation>
+void MultiCommodityFlow::Dijkstra(NodeID source_node, PathVector &paths,
+		bool create_new_paths)
+{
+	typedef std::set<Tannotation *, typename Tannotation::Comparator> AnnoSet;
+	uint size = this->graph->GetSize();
+	StationID source_station = this->graph->GetNode(source_node).station;
+	AnnoSet annos;
+	paths.resize(size, NULL);
+	for (NodeID node = 0; node < size; ++node) {
+		Tannotation *anno = new Tannotation(node, node == source_node);
+		annos.insert(anno);
+		paths[node] = anno;
+	}
+	while (!annos.empty()) {
+		typename AnnoSet::iterator i = annos.begin();
+		Tannotation *source = *i;
+		annos.erase(i);
+		NodeID from = source->GetNode();
+		NodeID to = this->graph->GetFirstEdge(from);
+		while (to != INVALID_NODE) {
+			Edge &edge = this->graph->GetEdge(from, to);
+			assert(edge.distance < UINT_MAX);
+			if (create_new_paths || this->graph->GetNode(from)
+					.flows[source_station][this->graph->GetNode(to).station] > 0) {
+				uint capacity = edge.capacity;
+				if (create_new_paths) {
+					capacity *= this->graph->GetSettings().short_path_saturation;
+					capacity /= 100;
+					if (capacity == 0) capacity = 1;
+				}
+				/* punish in-between stops a little */
+				uint distance = edge.distance + 1;
+				Tannotation *dest = static_cast<Tannotation *>(paths[to]);
+				if (dest->IsBetter(source, capacity, capacity - edge.flow, distance)) {
+					annos.erase(dest);
+					dest->Fork(source, capacity, capacity - edge.flow, distance);
+					annos.insert(dest);
+				}
+			}
+			to = edge.next_edge;
+		}
+	}
+}
+
+/**
+ * Clean up paths that lead nowhere and the root path.
+ * @param source_id ID of the root node.
+ * @param paths Paths to be cleaned up.
+ */
+void MultiCommodityFlow::CleanupPaths(NodeID source_id, PathVector &paths)
+{
+	Path *source = paths[source_id];
+	paths[source_id] = NULL;
+	for (PathVector::iterator i = paths.begin(); i != paths.end(); ++i) {
+		Path *path = *i;
+		if (path == NULL) continue;
+		if (path->GetParent() == source) path->Detach();
+		while (path != source && path != NULL && path->GetFlow() == 0) {
+			Path *parent = path->GetParent();
+			path->Detach();
+			if (path->GetNumChildren() == 0) {
+				paths[path->GetNode()] = NULL;
+				delete path;
+			}
+			path = parent;
+		}
+	}
+	delete source;
+	paths.clear();
+}
+
+/**
+ * Push flow along a path and update the unsatisfied_demand of the associated
+ * edge.
+ * @param edge Edge whose ends the path connects.
+ * @param path End of the path the flow should be pushed on.
+ * @param accuracy Accuracy of the calculation.
+ * @param positive_cap If true only push flow up to the paths capacity,
+ *                     otherwise the path can be "overloaded".
+ */
+uint MultiCommodityFlow::PushFlow(Edge &edge, Path *path, uint accuracy,
+		bool positive_cap)
+{
+	assert(edge.unsatisfied_demand > 0);
+	uint flow = Clamp(edge.demand / accuracy, 1, edge.unsatisfied_demand);
+	flow = path->AddFlow(flow, this->graph, positive_cap);
+	edge.unsatisfied_demand -= flow;
+	return flow;
+}
+
+/**
+ * Find the flow along a cycle including cycle_begin in path.
+ * @param path Set of paths that form the cycle.
+ * @param cycle_begin Path to start at.
+ * @return Flow along the cycle.
+ */
+uint MCF1stPass::FindCycleFlow(const PathVector &path, const Path *cycle_begin)
+{
+	uint flow = UINT_MAX;
+	const Path *cycle_end = cycle_begin;
+	do {
+		flow = min(flow, cycle_begin->GetFlow());
+		cycle_begin = path[cycle_begin->GetNode()];
+	} while (cycle_begin != cycle_end);
+	return flow;
+}
+
+/**
+ * Eliminate a cycle of the given flow in the given set of paths.
+ * @param path Set of paths containing the cycle.
+ * @param cycle_begin Part of the cycle to start at.
+ * @param flow Flow along the cycle.
+ */
+void MCF1stPass::EliminateCycle(PathVector &path, Path *cycle_begin, uint flow)
+{
+	Path *cycle_end = cycle_begin;
+	do {
+		NodeID prev = cycle_begin->GetNode();
+		cycle_begin->ReduceFlow(flow);
+		cycle_begin = path[cycle_begin->GetNode()];
+		Edge &edge = this->graph->GetEdge(prev, cycle_begin->GetNode());
+		edge.flow -= flow;
+	} while (cycle_begin != cycle_end);
+}
+
+/**
+ * Eliminate cycles for origin_id in the graph. Start searching at next_id and
+ * work recursively. Also "summarize" paths: Add up the flows along parallel
+ * paths in one.
+ * @param path Paths checked in parent calls to this method.
+ * @param origin_id Origin of the paths to be checked.
+ * @param next_id Next node to be checked.
+ * @return If any cycles have been found and eliminated.
+ */
+bool MCF1stPass::EliminateCycles(PathVector &path, NodeID origin_id, NodeID next_id)
+{
+	static Path *invalid_path = new Path(INVALID_NODE, true);
+	Path *at_next_pos = path[next_id];
+	if (at_next_pos == invalid_path) {
+		/* this node has already been searched */
+		return false;
+	} else if (at_next_pos == NULL) {
+		/* summarize paths; add up the paths with the same source and next hop
+		 * in one path each
+		 */
+		PathSet &paths = this->graph->GetNode(next_id).paths;
+		PathViaMap next_hops;
+		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
+			Path *new_child = *i;
+			if (new_child->GetOrigin() == origin_id) {
+				PathViaMap::iterator via_it = next_hops.find(new_child->GetNode());
+				if (via_it == next_hops.end()) {
+					next_hops[new_child->GetNode()] = new_child;
+				} else {
+					Path *child = via_it->second;
+					uint new_flow = new_child->GetFlow();
+					child->AddFlow(new_flow);
+					new_child->ReduceFlow(new_flow);
+				}
+			}
+		}
+		bool found = false;
+		/* search the next hops for nodes we have already visited */
+		for (PathViaMap::iterator via_it = next_hops.begin();
+				via_it != next_hops.end(); ++via_it) {
+			Path *child = via_it->second;
+			if (child->GetFlow() > 0) {
+				/* push one child into the path vector and search this child's
+				 * children
+				 */
+				path[next_id] = child;
+				found = this->EliminateCycles(path, origin_id, child->GetNode()) || found;
+			}
+		}
+		/* All paths departing from this node have been searched. Mark as
+		 * resolved if no cycles found. If cycles were found further cycles
+		 * could be found in this branch, thus it has to be searched again next
+		 * time we spot it.
+		 */
+		path[next_id] = found ? NULL : invalid_path;
+		return found;
+	} else {
+		/* this node has already been visited => we have a cycle
+		 * backtrack to find the exact flow
+		 */
+		uint flow = this->FindCycleFlow(path, at_next_pos);
+		if (flow > 0) {
+			this->EliminateCycle(path, at_next_pos, flow);
+			return true;
+		} else {
+			return false;
+		}
+	}
+}
+
+/**
+ * Eliminate all cycles in the graph. Check paths starting at each node for
+ * potential cycles.
+ * @return If any cycles have been found and eliminated.
+ */
+bool MCF1stPass::EliminateCycles()
+{
+	bool cycles_found = false;
+	uint size = this->graph->GetSize();
+	PathVector path(size, NULL);
+	for (NodeID node = 0; node < size; ++node) {
+		/* starting at each node in the graph find all cycles involving this
+		 * node
+		 */
+		std::fill(path.begin(), path.end(), (Path *)NULL);
+		cycles_found = this->EliminateCycles(path, node, node) || cycles_found;
+	}
+	return cycles_found;
+}
+
+/**
+ * Run the first pass of the MCF calculation.
+ * @param graph Component to calculate.
+ */
+MCF1stPass::MCF1stPass(LinkGraphComponent *graph) : MultiCommodityFlow(graph)
+{
+	PathVector paths;
+	uint size = this->graph->GetSize();
+	uint accuracy = this->graph->GetSettings().accuracy;
+	bool more_loops = true;
+
+	while (more_loops) {
+		more_loops = false;
+
+		for (NodeID source = 0; source < size; ++source) {
+			/* first saturate the shortest paths */
+			this->Dijkstra<DistanceAnnotation>(source, paths, true);
+
+			for (NodeID dest = 0; dest < size; ++dest) {
+				Edge &edge = this->graph->GetEdge(source, dest);
+				if (edge.unsatisfied_demand > 0) {
+					Path *path = paths[dest];
+					assert(path != NULL);
+					/* generally only allow paths that don't exceed the
+					 * available capacity. But if no demand has been assigned
+					 * yet, make an exception and allow any valid path *once*.
+					 */
+					if (path->GetFreeCapacity() > 0 && this->PushFlow(edge, path,
+							accuracy, true) > 0) {
+						/* if a path has been found there is a chance we can
+						 * find more
+						 */
+						more_loops = (edge.unsatisfied_demand > 0);
+					} else if (edge.unsatisfied_demand == edge.demand &&
+							path->GetFreeCapacity() > INT_MIN) {
+						this->PushFlow(edge, path, accuracy, false);
+					}
+				}
+			}
+			CleanupPaths(source, paths);
+		}
+		if (!more_loops) more_loops = EliminateCycles();
+	}
+}
+
+/**
+ * Run the second pass of the MCF calculation which assigns all remaining
+ * demands to existing paths.
+ * @param graph Component to calculate.
+ */
+MCF2ndPass::MCF2ndPass(LinkGraphComponent *graph) : MultiCommodityFlow(graph)
+{
+	PathVector paths;
+	uint size = this->graph->GetSize();
+	uint accuracy = this->graph->GetSettings().accuracy;
+	bool demand_left = true;
+	while (demand_left) {
+		demand_left = false;
+		for (NodeID source = 0; source < size; ++source) {
+			this->Dijkstra<CapacityAnnotation>(source, paths, false);
+			for (NodeID dest = 0; dest < size; ++dest) {
+				Edge &edge = this->graph->GetEdge(source, dest);
+				Path *path = paths[dest];
+				if (edge.unsatisfied_demand > 0 && path->GetFreeCapacity() > INT_MIN) {
+					this->PushFlow(edge, path, accuracy, false);
+					if (edge.unsatisfied_demand > 0) demand_left = true;
+				}
+			}
+			CleanupPaths(source, paths);
+		}
+	}
+}
+
+/**
+ * Relation that creates a weak order without duplicates.
+ * Avoid accidentally deleting different paths of the same capacity/distance in
+ * a set. When the annotation is the same node IDs are compared, so there are
+ * no equal ranges.
+ * @tparam T Type to be compared on.
+ * @param x_anno First value.
+ * @param y_anno Second value.
+ * @param x Node id associated with the first value.
+ * @param y Node id associated with the second value.
+ */
+template <typename T>
+bool greater(T x_anno, T y_anno, NodeID x, NodeID y)
+{
+	if (x_anno > y_anno) {
+		return true;
+	} else if (x_anno < y_anno) {
+		return false;
+	} else {
+		return x > y;
+	}
+}
+
+/**
+ * Compare two capacity annotations.
+ * @param x First capacity annotation.
+ * @param y Second capacity annotation.
+ * @return If x is better than y.
+ */
+bool CapacityAnnotation::Comparator::operator()(const CapacityAnnotation *x,
+		const CapacityAnnotation *y) const
+{
+	return x != y && greater<int>(x->GetAnnotation(), y->GetAnnotation(),
+			x->GetNode(), y->GetNode());
+}
+
+/**
+ * Compare two distance annotations.
+ * @param x First distance annotation.
+ * @param y Second distance annotation.
+ * @return If x is better than y.
+ */
+bool DistanceAnnotation::Comparator::operator()(const DistanceAnnotation *x,
+		const DistanceAnnotation *y) const
+{
+	return x != y && !greater<uint>(x->GetAnnotation(), y->GetAnnotation(),
+			x->GetNode(), y->GetNode());
+}
diff --git a/src/linkgraph/mcf.h b/src/linkgraph/mcf.h
new file mode 100644
index 0000000..f1a6349
--- /dev/null
+++ b/src/linkgraph/mcf.h
@@ -0,0 +1,129 @@
+/** @file mcf.h Declaration of Multi-Commodity-Flow solver */
+
+#ifndef MCF_H_
+#define MCF_H_
+
+#include "linkgraph.h"
+#include <vector>
+
+/**
+ * Distance-based annotation for use in the Dijkstra algorithm. This is close
+ * to the original meaning of "annotation" in this context. Paths are rated
+ * according to the sum of distances of their edges.
+ */
+class DistanceAnnotation : public Path {
+public:
+
+	DistanceAnnotation(NodeID n, bool source = false) : Path(n, source) {}
+
+	bool IsBetter(const DistanceAnnotation *base, uint cap, int free_cap, uint dist) const;
+
+	/**
+	 * Return the actual value of the annotation, in this case the distance.
+	 * @return Distance.
+	 */
+	FORCEINLINE  uint GetAnnotation() const {return this->distance;}
+
+	struct Comparator {
+		bool operator()(const DistanceAnnotation *x, const DistanceAnnotation *y) const;
+	};
+};
+
+/**
+ * Capacity-based annotation for use in the Dijkstra algorithm. This annotation
+ * rates paths according to the maximum capacity of their edges. The Dijkstra
+ * algorithm still gives meaningful results like this as the capacity of a path
+ * can only decrease or stay the same if you add more edges.
+ */
+class CapacityAnnotation : public Path {
+public:
+
+	CapacityAnnotation(NodeID n, bool source = false) : Path(n, source) {}
+
+	bool IsBetter(const CapacityAnnotation *base, uint cap, int free_cap, uint dist) const;
+
+	/**
+	 * Return the actual value of the annotation, in this case the capacity.
+	 * @return Capacity.
+	 */
+	FORCEINLINE int GetAnnotation() const {return this->GetCapacityRatio();}
+
+	struct Comparator {
+		bool operator()(const CapacityAnnotation *x, const CapacityAnnotation *y) const;
+	};
+};
+
+
+typedef std::vector<Path *> PathVector;
+
+/**
+ * Multi-commodity flow calculating base class.
+ */
+class MultiCommodityFlow {
+protected:
+	MultiCommodityFlow(LinkGraphComponent *graph) : graph(graph) {}
+
+	template<class ANNOTATION> void Dijkstra(NodeID from, PathVector &paths, bool create_new_paths);
+
+	uint PushFlow(Edge &edge, Path *path, uint accuracy, bool positive_cap);
+
+	void CleanupPaths(NodeID source, PathVector &paths);
+
+	LinkGraphComponent *graph; ///< Component we're working with.
+};
+
+/**
+ * First pass of the MCF calculation. Saturates shortest paths first, creates
+ * new paths if needed, eliminates cycles. This calculation is of exponential
+ * complexity in the number of nodes but the constant factors are sufficiently
+ * small to make it usable for most real-life link graph components. You can
+ * deal with performance problems that might occur here in multiple ways:
+ * - The overall accuracy is used here to determine how much flow is assigned
+ *   in each loop. The lower the accuracy, the more flow is assigned, the less
+ *   loops it takes to assign all flow.
+ * - The short_path_saturation setting determines when this pass stops. The
+ *   lower you set it, the less flow will be assigned in this pass, the less
+ *   time it will take.
+ * - You can increase the recalculation interval to allow for longer running
+ *   times without creating lags.
+ */
+class MCF1stPass : public MultiCommodityFlow {
+private:
+	bool EliminateCycles();
+	bool EliminateCycles(PathVector &path, NodeID origin_id, NodeID next_id);
+	void EliminateCycle(PathVector &path, Path *cycle_begin, uint flow);
+	uint FindCycleFlow(const PathVector &path, const Path *cycle_begin);
+public:
+	MCF1stPass(LinkGraphComponent *graph);
+};
+
+/**
+ * Second pass of the MCF calculation. Saturates paths with most capacity left
+ * first and doesn't create any paths along edges that haven't been visited in
+ * the first pass. This is why it doesn't have to do any cycle detection and
+ * elimination. As cycle detection is the most intense problem in the first
+ * pass this pass is cheaper. The accuracy is used here, too.
+ */
+class MCF2ndPass : public MultiCommodityFlow {
+public:
+	MCF2ndPass(LinkGraphComponent *graph);
+};
+
+/**
+ * Link graph handler for MCF. Creates MultiCommodityFlow instance according to
+ * the template parameter.
+ */
+template<class Tpass>
+class MCFHandler : public ComponentHandler {
+public:
+
+	/**
+	 * Run the calculation.
+	 * @param graph Component to be calculated.
+	 */
+	virtual void Run(LinkGraphComponent *graph) {Tpass pass(graph);}
+
+	virtual ~MCFHandler() {}
+};
+
+#endif /* MCF_H_ */
diff --git a/src/linkgraph_gui.cpp b/src/linkgraph_gui.cpp
new file mode 100644
index 0000000..db42501
--- /dev/null
+++ b/src/linkgraph_gui.cpp
@@ -0,0 +1,543 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_gui.cpp Implementation of linkgraph overlay GUI. */
+
+#include "stdafx.h"
+#include "window_func.h"
+#include "window_gui.h"
+#include "company_base.h"
+#include "company_gui.h"
+#include "date_func.h"
+#include "viewport_func.h"
+#include "linkgraph_gui.h"
+#include "smallmap_gui.h"
+
+/**
+ * Colours for the various "load" states of links. Ordered from "unused" to
+ * "overloaded".
+ */
+const uint8 LinkGraphOverlay::LINK_COLOURS[] = {
+	0x0f, 0xd1, 0xd0, 0x57,
+	0x55, 0x53, 0xbf, 0xbd,
+	0xba, 0xb9, 0xb7, 0xb5
+};
+
+/**
+ * Get a DPI for the widget we will be drawing to.
+ * @param dpi DrawPixelInfo to fill with the desired dimensions.
+ */ 
+void LinkGraphOverlay::GetWidgetDpi(DrawPixelInfo *dpi) const
+{
+	const NWidgetBase *wi = this->window->GetWidget<NWidgetBase>(this->widget_id);
+	dpi->left = dpi->top = 0;
+	dpi->width = wi->current_x;
+	dpi->height = wi->current_y;
+}
+
+/**
+ * Rebuild the cache and recalculate which links and stations to be shown.
+ */
+void LinkGraphOverlay::RebuildCache()
+{
+	this->cached_links.clear();
+	this->cached_stations.clear();
+
+	DrawPixelInfo dpi;
+	this->GetWidgetDpi(&dpi);
+
+	const Station *sta;
+	FOR_ALL_STATIONS(sta) {
+		/* Show links between stations of selected companies or "neutral" ones like oilrigs. */
+		if (sta->owner != INVALID_COMPANY && !HasBit(this->company_mask, sta->owner)) continue;
+		if (sta->rect.IsEmpty()) continue;
+
+		Point pta = this->GetStationMiddle(sta);
+
+		StationID from = sta->index;
+		StationLinkMap &seen_links = this->cached_links[from];
+
+		uint supply = 0;
+		CargoID c;
+		FOR_EACH_SET_CARGO_ID(c, this->cargo_mask) {
+			if (!CargoSpec::Get(c)->IsValid()) continue;
+
+			supply += sta->goods[c].supply;
+			const LinkStatMap &links = sta->goods[c].link_stats;
+			for (LinkStatMap::const_iterator i = links.begin(); i != links.end(); ++i) {
+				StationID to = i->first;
+				if (seen_links.find(to) != seen_links.end()) continue;
+
+				if (!Station::IsValidID(to)) continue;
+				const Station *stb = Station::Get(to);
+				if (stb->owner != INVALID_COMPANY && !HasBit(this->company_mask, stb->owner)) continue;
+				if (stb->rect.IsEmpty()) continue;
+
+				if (!this->IsLinkVisible(pta, this->GetStationMiddle(stb), &dpi)) continue;
+
+				this->AddLinks(sta, stb);
+				this->AddLinks(stb, sta);
+				seen_links[to]; // make sure it is created and marked as seen
+			}
+		}
+		if (this->IsPointVisible(pta, &dpi)) {
+			this->cached_stations.push_back(std::make_pair(from, supply));
+		}
+	}
+}
+
+/**
+ * Determine if a certain point is inside the given DPI, with some lee way.
+ * @param pt Point we are looking for.
+ * @param dpi Visible area.
+ * @param padding Extent of the point.
+ * @return If the point or any of its 'extent' is inside the dpi.
+ */
+FORCEINLINE bool LinkGraphOverlay::IsPointVisible(Point pt, const DrawPixelInfo *dpi, int padding) const
+{
+	return pt.x > dpi->left - padding && pt.y > dpi->top - padding &&
+			pt.x < dpi->left + dpi->width + padding &&
+			pt.y < dpi->top + dpi->height + padding;
+}
+
+/**
+ * Determine if a certain link crosses through the area given by the dpi with some lee way.
+ * @param pta First end of the link.
+ * @param ptb Second end of the link.
+ * @param dpi Visible area.
+ * @param padding Width or thickness of the link.
+ * @return If the link or any of its "thickness" is visible. This may return false positives.
+ */
+FORCEINLINE bool LinkGraphOverlay::IsLinkVisible(Point pta, Point ptb, const DrawPixelInfo *dpi, int padding) const
+{
+	return !((pta.x < dpi->left - padding && ptb.x < dpi->left - padding) ||
+			(pta.y < dpi->top - padding && ptb.y < dpi->top - padding) ||
+			(pta.x > dpi->left + dpi->width + padding &&
+					ptb.x > dpi->left + dpi->width + padding) ||
+			(pta.y > dpi->top + dpi->height + padding &&
+					ptb.y > dpi->top + dpi->height + padding));
+}
+
+/**
+ * Add all "interesting" links between the given stations to the cache.
+ * @param from The source station.
+ * @param to The destination station.
+ */
+void LinkGraphOverlay::AddLinks(const Station *from, const Station *to)
+{
+	CargoID c;
+	FOR_EACH_SET_CARGO_ID(c, this->cargo_mask) {
+		if (!CargoSpec::Get(c)->IsValid()) continue;
+		const GoodsEntry &ge = from->goods[c];
+		FlowStat sum_flows = ge.GetSumFlowVia(to->index);
+		const LinkStatMap &ls_map = ge.link_stats;
+		LinkStatMap::const_iterator i = ls_map.find(to->index);
+		if (i != ls_map.end()) {
+			const LinkStat &link_stat = i->second;
+			this->AddStats(link_stat, sum_flows, this->cached_links[from->index][to->index]);
+		}
+	}
+}
+
+/**
+ * Add information from a given pair of link stat and flow stat to the given link properties.
+ * @param orig_link Link stat to read the information from.
+ * @param orig_flow Flow stat to read the information from.
+ * @param cargo LinkProperties to write the information to.
+ */
+/* static */ void LinkGraphOverlay::AddStats(const LinkStat &orig_link, const FlowStat &orig_flow, LinkProperties &cargo)
+{
+	uint new_cap = orig_link.Capacity();
+	uint new_usg = orig_link.Usage();
+	uint new_plan = orig_flow.Planned();
+
+	/* multiply the numbers by 32 in order to avoid comparing to 0 too often. */
+	if (cargo.capacity == 0 ||
+			max(cargo.usage, cargo.planned) * 32 / (cargo.capacity + 1) < max(new_usg, new_plan) * 32 / (new_cap + 1)) {
+		cargo.capacity = new_cap;
+		cargo.usage = new_usg;
+		cargo.planned = new_plan;
+	}
+}
+
+/**
+ * Draw the linkgraph overlay or some part of it, in the area given.
+ * @param dpi Area to be drawn to.
+ */
+void LinkGraphOverlay::Draw(const DrawPixelInfo *dpi) const
+{
+	this->DrawLinks(dpi);
+	this->DrawStationDots(dpi);
+}
+
+/**
+ * Draw the cached links or part of them into the given area.
+ * @param dpi Area to be drawn to.
+ */
+void LinkGraphOverlay::DrawLinks(const DrawPixelInfo *dpi) const
+{
+	for (LinkMap::const_iterator i(this->cached_links.begin()); i != this->cached_links.end(); ++i) {
+		if (!Station::IsValidID(i->first)) continue;
+		Point pta = this->GetStationMiddle(Station::Get(i->first));
+		for (StationLinkMap::const_iterator j(i->second.begin()); j != i->second.end(); ++j) {
+			if (!Station::IsValidID(j->first)) continue;
+			Point ptb = this->GetStationMiddle(Station::Get(j->first));
+			if (!this->IsLinkVisible(pta, ptb, dpi, this->scale + 2)) continue;
+			this->DrawContent(pta, ptb, j->second);
+		}
+	}
+}
+
+/**
+ * Draw one specific link.
+ * @param pta Source of the link.
+ * @param ptb Destination of the link.
+ * @param cargo Properties of the link.
+ */
+void LinkGraphOverlay::DrawContent(Point pta, Point ptb, const LinkProperties &cargo) const
+{
+	if (cargo.capacity <= 0) return;
+	int direction_y = (pta.x < ptb.x ? 1 : -1);
+	int direction_x = (pta.y > ptb.y ? 1 : -1);
+	uint thick_middle_line = this->scale > 1 ? 1 : 0;
+
+	uint usage_or_plan = min(cargo.capacity * 2, max(cargo.usage, cargo.planned));
+	int colour = LinkGraphOverlay::LINK_COLOURS[usage_or_plan * lengthof(LinkGraphOverlay::LINK_COLOURS) / (cargo.capacity * 2 + 1)];
+	for (uint i = 1 + thick_middle_line; i <= this->scale + thick_middle_line; ++i) {
+		GfxDrawLine(pta.x + direction_x * i, pta.y, ptb.x + direction_x * i, ptb.y, colour);
+		GfxDrawLine(pta.x, pta.y + direction_y * i, ptb.x, ptb.y + direction_y * i, colour);
+	}
+	GfxDrawLine(pta.x, pta.y, ptb.x, ptb.y, _colour_gradient[COLOUR_GREY][1]);
+	if (thick_middle_line) {
+		GfxDrawLine(pta.x + direction_x, pta.y, ptb.x + direction_x, ptb.y, _colour_gradient[COLOUR_GREY][1]);
+		GfxDrawLine(pta.x, pta.y + direction_y, ptb.x, ptb.y + direction_y, _colour_gradient[COLOUR_GREY][1]);
+	}
+}
+
+/**
+ * Draw dots for stations into the smallmap. The dots' sizes are determined by the amount of
+ * cargo produced there, their colours by the type of cargo produced.
+ */
+void LinkGraphOverlay::DrawStationDots(const DrawPixelInfo *dpi) const
+{
+	for (StationSupplyList::const_iterator i(this->cached_stations.begin()); i != this->cached_stations.end(); ++i) {
+		const Station *st = Station::GetIfValid(i->first);
+		if (st == NULL) continue;
+		Point pt = this->GetStationMiddle(st);
+		if (!this->IsPointVisible(pt, dpi, 4 * this->scale)) continue;
+
+		uint r = this->scale * 3 + this->scale * 3 * min(200, i->second) / 200;
+
+		LinkGraphOverlay::DrawVertex(pt.x, pt.y, r,
+				_colour_gradient[Company::Get(st->owner)->colour][5],
+				_colour_gradient[COLOUR_GREY][1]);
+	}
+}
+
+/**
+ * Draw a square symbolizing a producer of cargo.
+ * @param x X coordinate of the middle of the vertex.
+ * @param y Y coordinate of the middle of the vertex.
+ * @param size Y and y extend of the vertex.
+ * @param colour Colour with which the vertex will be filled.
+ * @param border_colour Colour for the border of the vertex.
+ */
+/* static */ void LinkGraphOverlay::DrawVertex(int x, int y, int size, int colour, int border_colour)
+{
+	size--;
+	int w1 = size / 2;
+	int w2 = size / 2 + size % 2;
+
+	GfxFillRect(x - w1, y - w1, x + w2, y + w2, colour);
+
+	w1++;
+	w2++;
+	GfxDrawLine(x - w1, y - w1, x + w2, y - w1, border_colour);
+	GfxDrawLine(x - w1, y + w2, x + w2, y + w2, border_colour);
+	GfxDrawLine(x - w1, y - w1, x - w1, y + w2, border_colour);
+	GfxDrawLine(x + w2, y - w1, x + w2, y + w2, border_colour);
+}
+
+/**
+ * Determine the middle of a station in the current window.
+ * @param st The station we're looking for.
+ * @return Middle point of the station in the current window.
+ */
+Point LinkGraphOverlay::GetStationMiddle(const Station *st) const {
+	if (this->window->viewport != NULL) {
+		return GetViewportStationMiddle(this->window->viewport, st);
+	} else {
+		/* assume this is a smallmap */
+		return static_cast<const SmallMapWindow *>(this->window)->GetStationMiddle(st);
+	}
+}
+
+/**
+ * Set a new cargo mask and rebuild the cache.
+ * @param cargo_mask New cargo mask.
+ */
+void LinkGraphOverlay::SetCargoMask(uint32 cargo_mask)
+{
+	this->cargo_mask = cargo_mask;
+	this->RebuildCache();
+	this->window->GetWidget<NWidgetBase>(this->widget_id)->SetDirty(this->window);
+}
+
+/**
+ * Set a new company mask and rebuild the cache.
+ * @param company_mask New company mask.
+ */
+void LinkGraphOverlay::SetCompanyMask(uint32 company_mask)
+{
+	this->company_mask = company_mask;
+	this->RebuildCache();
+	this->window->GetWidget<NWidgetBase>(this->widget_id)->SetDirty(this->window);
+}
+
+enum LinkGraphLegendWindowWidgets {
+	LGL_CAPTION,           ///< Caption widget.
+	LGL_SATURATION,        ///< Saturation legend.
+	LGL_SATURATION_FIRST,
+	LGL_SATURATION_LAST = LGL_SATURATION_FIRST + lengthof(LinkGraphOverlay::LINK_COLOURS) - 1,
+	LGL_COMPANIES,         ///< Company selection widget.
+	LGL_COMPANY_FIRST,
+	LGL_COMPANY_LAST = LGL_COMPANY_FIRST + MAX_COMPANIES - 1,
+	LGL_COMPANIES_ALL,
+	LGL_COMPANIES_NONE,
+	LGL_CARGOES,            ///< Cargo selection widget.
+	LGL_CARGO_FIRST,
+	LGL_CARGO_LAST = LGL_CARGO_FIRST + NUM_CARGO - 1,
+	LGL_CARGOES_ALL,
+	LGL_CARGOES_NONE,s
+};
+
+/** Make a number of rows with buttons for each company for the linkgraph legend window. */
+NWidgetBase *MakeCompanyButtonRowsLinkGraphGUI(int *biggest_index)
+{
+	return MakeCompanyButtonRows(biggest_index, LGL_COMPANY_FIRST, LGL_COMPANY_LAST, 3, STR_LINKGRAPH_LEGEND_SELECT_COMPANIES);
+}
+
+NWidgetBase *MakeSaturationLegendLinkGraphGUI(int *biggest_index)
+{
+	NWidgetVertical *panel = new NWidgetVertical();
+	for (uint i = 0; i < lengthof(LinkGraphOverlay::LINK_COLOURS); ++i) {
+		NWidgetBackground * wid = new NWidgetBackground(WWT_PANEL, COLOUR_DARK_GREEN, i + LGL_SATURATION_FIRST);
+		wid->SetMinimalSize(50, FONT_HEIGHT_SMALL);
+		wid->SetFill(0, 1);
+		wid->SetResize(0, 1);
+		panel->Add(wid);
+	}
+	*biggest_index = LGL_SATURATION_LAST;
+	return panel;
+}
+
+NWidgetBase *MakeCargoesLegendLinkGraphGUI(int *biggest_index)
+{
+	static const uint ENTRIES_PER_ROW = CeilDiv(NUM_CARGO, 5);
+	NWidgetVertical *panel = new NWidgetVertical();
+	NWidgetHorizontal *row = NULL;
+	for (uint i = 0; i < NUM_CARGO; ++i) {
+		if (i % ENTRIES_PER_ROW == 0) {
+			if (row) panel->Add(row);
+			row = new NWidgetHorizontal();
+		}
+		NWidgetBackground * wid = new NWidgetBackground(WWT_PANEL, COLOUR_GREY, i + LGL_CARGO_FIRST);
+		wid->SetMinimalSize(25, FONT_HEIGHT_SMALL);
+		wid->SetFill(0, 1);
+		wid->SetResize(0, 1);
+		row->Add(wid);
+	}
+	panel->Add(row);
+	*biggest_index = LGL_CARGO_LAST;
+	return panel;
+}
+
+
+static const NWidgetPart _nested_linkgraph_legend_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_DARK_GREEN),
+		NWidget(WWT_CAPTION, COLOUR_DARK_GREEN, LGL_CAPTION), SetDataTip(STR_LINKGRAPH_LEGEND_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_DARK_GREEN),
+		NWidget(WWT_STICKYBOX, COLOUR_DARK_GREEN),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_DARK_GREEN),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_PANEL, COLOUR_DARK_GREEN, LGL_SATURATION),
+				SetPadding(WD_FRAMERECT_TOP, 0, WD_FRAMERECT_BOTTOM, WD_CAPTIONTEXT_LEFT),
+				SetMinimalSize(50, 100),
+				NWidgetFunction(MakeSaturationLegendLinkGraphGUI),
+			EndContainer(),
+			NWidget(WWT_PANEL, COLOUR_DARK_GREEN, LGL_COMPANIES),
+				SetPadding(WD_FRAMERECT_TOP, 0, WD_FRAMERECT_BOTTOM, WD_CAPTIONTEXT_LEFT),
+				NWidget(NWID_VERTICAL, NC_EQUALSIZE),
+					SetMinimalSize(100, 100),
+					NWidgetFunction(MakeCompanyButtonRowsLinkGraphGUI),
+					NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, LGL_COMPANIES_ALL), SetDataTip(STR_LINKGRAPH_LEGEND_ALL, STR_NULL),
+					NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, LGL_COMPANIES_NONE), SetDataTip(STR_LINKGRAPH_LEGEND_NONE, STR_NULL),
+				EndContainer(),
+			EndContainer(),
+			NWidget(WWT_PANEL, COLOUR_DARK_GREEN, LGL_CARGOES),
+				SetPadding(WD_FRAMERECT_TOP, WD_FRAMERECT_RIGHT, WD_FRAMERECT_BOTTOM, WD_CAPTIONTEXT_LEFT),
+				NWidget(NWID_VERTICAL, NC_EQUALSIZE),
+					SetMinimalSize(150, 100),
+					NWidgetFunction(MakeCargoesLegendLinkGraphGUI),
+					NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, LGL_CARGOES_ALL), SetDataTip(STR_LINKGRAPH_LEGEND_ALL, STR_NULL),
+					NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, LGL_CARGOES_NONE), SetDataTip(STR_LINKGRAPH_LEGEND_NONE, STR_NULL),
+				EndContainer(),
+			EndContainer(),
+		EndContainer(),
+	EndContainer()
+};
+
+static const WindowDesc _linkgraph_legend_desc(
+	WDP_MANUAL, 300, 314,
+	WC_LINKGRAPH_LEGEND, WC_NONE,
+	WDF_UNCLICK_BUTTONS,
+	_nested_linkgraph_legend_widgets, lengthof(_nested_linkgraph_legend_widgets)
+);
+
+/**
+ * Open a link graph legend window.
+*/
+void ShowLinkGraphLegend()
+{
+	AllocateWindowDescFront<LinkGraphLegendWindow>(&_linkgraph_legend_desc, 0);
+}
+
+LinkGraphLegendWindow::LinkGraphLegendWindow(const WindowDesc *desc, int window_number)
+{
+	this->InitNested(desc, window_number);
+	this->InvalidateData(0);
+	this->SetOverlay(FindWindowById(WC_MAIN_WINDOW, 0)->viewport->overlay);
+}
+
+/**
+ * Set the overlay belonging to this menu and import its company/cargo settings.
+ * @params overlay New overlay for this menu.
+ */
+void LinkGraphLegendWindow::SetOverlay(LinkGraphOverlay *overlay) {
+	this->overlay = overlay;
+	uint32 companies = this->overlay->GetCompanyMask();
+	for (uint c = 0; c < MAX_COMPANIES; c++) {
+		if (!this->IsWidgetDisabled(LGL_COMPANY_FIRST + c)) {
+			this->SetWidgetLoweredState(LGL_COMPANY_FIRST + c, HasBit(companies, c));
+		}
+	}
+	uint32 cargoes = this->overlay->GetCargoMask();
+	for (uint c = 0; c < NUM_CARGO; c++) {
+		if (!this->IsWidgetDisabled(LGL_CARGO_FIRST + c)) {
+			this->SetWidgetLoweredState(LGL_CARGO_FIRST + c, HasBit(cargoes, c));
+		}
+	}
+}
+
+void LinkGraphLegendWindow::DrawWidget(const Rect &r, int widget) const
+{
+	const NWidgetBase *wid = this->GetWidget<NWidgetBase>(widget);
+	if (IsInsideMM(widget, LGL_COMPANY_FIRST, LGL_COMPANY_LAST + 1)) {
+		if (this->IsWidgetDisabled(widget)) return;
+		CompanyID cid = (CompanyID)(widget - LGL_COMPANY_FIRST);
+		Dimension sprite_size = GetSpriteSize(SPR_COMPANY_ICON);
+		DrawCompanyIcon(cid, (r.left + r.right - sprite_size.width) / 2, (r.top + r.bottom - sprite_size.height) / 2);
+		return;
+	}
+	if (IsInsideMM(widget, LGL_SATURATION_FIRST, LGL_SATURATION_LAST + 1)) {
+		GfxFillRect(r.left + 1, r.top + 1, r.right - 1, r.bottom - 1, LinkGraphOverlay::LINK_COLOURS[widget - LGL_SATURATION_FIRST]);
+		if (widget == LGL_SATURATION_FIRST) {
+			DrawString(wid->pos_x, wid->current_x + wid->pos_x, wid->pos_y, STR_LINKGRAPH_LEGEND_UNUSED, TC_FROMSTRING, SA_HOR_CENTER);
+		} else if (widget == LGL_SATURATION_LAST) {
+			DrawString(wid->pos_x, wid->current_x + wid->pos_x, wid->pos_y, STR_LINKGRAPH_LEGEND_OVERLOADED, TC_FROMSTRING, SA_HOR_CENTER);
+		} else if (widget == (LGL_SATURATION_LAST + LGL_SATURATION_FIRST) / 2) {
+			DrawString(wid->pos_x, wid->current_x + wid->pos_x, wid->pos_y, STR_LINKGRAPH_LEGEND_SATURATED, TC_FROMSTRING, SA_HOR_CENTER);
+		}
+	}
+	if (IsInsideMM(widget, LGL_CARGO_FIRST, LGL_CARGO_LAST + 1)) {
+		if (this->IsWidgetDisabled(widget)) return;
+		CargoSpec *cargo = CargoSpec::Get(widget - LGL_CARGO_FIRST);
+		GfxFillRect(r.left + 2, r.top + 2, r.right - 2, r.bottom - 2, cargo->legend_colour);
+		DrawString(wid->pos_x, wid->current_x + wid->pos_x, wid->pos_y + 2, cargo->abbrev, TC_BLACK, SA_HOR_CENTER);
+	}
+}
+
+/**
+ * Update the overlay with the new company selection.
+ */
+void LinkGraphLegendWindow::UpdateOverlayCompanies()
+{
+	uint32 mask = 0;
+	for (uint c = 0; c < MAX_COMPANIES; c++) {
+		if (this->IsWidgetDisabled(c + LGL_COMPANY_FIRST)) continue;
+		if (!this->IsWidgetLowered(c + LGL_COMPANY_FIRST)) continue;
+		SetBit(mask, c);
+	}
+	this->overlay->SetCompanyMask(mask);
+}
+
+/**
+ * Update the overlay with the new cargo selection.
+ */
+void LinkGraphLegendWindow::UpdateOverlayCargoes()
+{
+	uint32 mask = 0;
+	for (uint c = 0; c < NUM_CARGO; c++) {
+		if (this->IsWidgetDisabled(c + LGL_CARGO_FIRST)) continue;
+		if (!this->IsWidgetLowered(c + LGL_CARGO_FIRST)) continue;
+		SetBit(mask, c);
+	}
+	this->overlay->SetCargoMask(mask);
+}
+
+void LinkGraphLegendWindow::OnClick(Point pt, int widget, int click_count)
+{
+	/* Check which button is clicked */
+	if (IsInsideMM(widget, LGL_COMPANY_FIRST, LGL_COMPANY_LAST + 1)) {
+		/* Is it no on disable? */
+		if (!this->IsWidgetDisabled(widget)) {
+			this->ToggleWidgetLoweredState(widget);
+			this->UpdateOverlayCompanies();
+		}
+	} else if (widget == LGL_COMPANIES_ALL || widget == LGL_COMPANIES_NONE) {
+		for (uint c = 0; c < MAX_COMPANIES; c++) {
+			if (this->IsWidgetDisabled(c + LGL_COMPANY_FIRST)) continue;
+			this->SetWidgetLoweredState(LGL_COMPANY_FIRST + c, widget == LGL_COMPANIES_ALL);
+		}
+		this->UpdateOverlayCompanies();
+		this->SetDirty();
+	} else if (IsInsideMM(widget, LGL_CARGO_FIRST, LGL_CARGO_LAST + 1)) {
+		/* Is it no on disable? */
+		if (!this->IsWidgetDisabled(widget)) {
+			this->ToggleWidgetLoweredState(widget);
+			this->UpdateOverlayCargoes();
+
+		}
+	} else if (widget == LGL_CARGOES_ALL || widget == LGL_CARGOES_NONE) {
+		for (uint c = 0; c < NUM_CARGO; c++) {
+			if (this->IsWidgetDisabled(c + LGL_CARGO_FIRST)) continue;
+			this->SetWidgetLoweredState(LGL_CARGO_FIRST + c, widget == LGL_CARGOES_ALL);
+		}
+		this->UpdateOverlayCargoes();
+	}
+	this->SetDirty();
+}
+
+/**
+ * Invalidate the data of this window if the cargoes or companies have changed.
+ * @param data ignored
+ * @param gui_scope ignored
+ */
+void LinkGraphLegendWindow::OnInvalidateData(int data, bool gui_scope)
+{
+	/* Disable the companies who are not active */
+	for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+		this->SetWidgetDisabledState(i + LGL_COMPANY_FIRST, !Company::IsValidID(i));
+	}
+	for (CargoID i = 0; i < NUM_CARGO; i++) {
+		this->SetWidgetDisabledState(i + LGL_CARGO_FIRST, !CargoSpec::Get(i)->IsValid());
+	}
+}
diff --git a/src/linkgraph_gui.h b/src/linkgraph_gui.h
new file mode 100644
index 0000000..de62441
--- /dev/null
+++ b/src/linkgraph_gui.h
@@ -0,0 +1,116 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_gui.h Declaration of linkgraph overlay GUI. */
+
+#ifndef LINKGRAPH_GUI_H_
+#define LINKGRAPH_GUI_H_
+
+#include "company_func.h"
+#include "station_base.h"
+#include "widget_type.h"
+
+#include "table/strings.h"
+
+#include <map>
+#include <list>
+
+/**
+ * Properties of a link between two stations.
+ */
+struct LinkProperties {
+	LinkProperties() : capacity(0), usage(0), planned(0) {}
+
+	uint capacity; ///< Capacity of the link.
+	uint usage;    ///< Actual usage of the link.
+	uint planned;  ///< Planned usage of the link.
+};
+
+/**
+ * Handles drawing of links into some window.
+ * The window must either be a smallmap or have a valid viewport.
+ */
+class LinkGraphOverlay {
+public:
+	typedef std::map<StationID, LinkProperties> StationLinkMap;
+	typedef std::map<StationID, StationLinkMap> LinkMap;
+	typedef std::list<std::pair<StationID, uint> > StationSupplyList;
+
+	static const uint8 LINK_COLOURS[];
+
+	/**
+	 * Create a link graph overlay for the specified window.
+	 * @param w Window to be drawn into.
+	 * @param wid ID of the widget to draw into.
+	 * @param cargo_mask Bitmask of cargoes to be shown.
+	 * @param company_mask Bitmask of companies to be shown.
+	 * @param scale Desired thickness of lines and size of station dots.
+	 */
+	LinkGraphOverlay(const Window *w, uint wid, uint32 cargo_mask = 0xFFFF,
+			uint32 company_mask = 1 << _local_company, uint scale = 1) :
+			window(w), widget_id(wid), cargo_mask(cargo_mask), company_mask(company_mask), scale(scale)
+	{}
+
+	void RebuildCache();
+	void Draw(const DrawPixelInfo *dpi) const;
+	void SetCargoMask(uint32 cargo_mask);
+	void SetCompanyMask(uint32 company_mask);
+
+	/** Get a bitmask of the currently shown cargoes. */
+	uint32 GetCargoMask() {return this->cargo_mask;}
+
+	/** Get a bitmask of the currently shown companies. */
+	uint32 GetCompanyMask() {return this->company_mask;}
+
+protected:
+	const Window *window;              ///< Window to be drawn into.
+	const uint widget_id;              ///< ID of Widget in Window to be drawn to.
+	uint32 cargo_mask;                 ///< Bitmask of cargos to be displayed.
+	uint32 company_mask;               ///< Bitmask of companies to be displayed.
+	LinkMap cached_links;              ///< Cache for links to reduce recalculation.
+	StationSupplyList cached_stations; ///< Cache for stations to be drawn.
+	uint scale;                        ///< Number of parallel lines to be drawn for each link.
+
+	Point GetStationMiddle(const Station *st) const;
+
+	void DrawForwBackLinks(Point pta, StationID sta, Point ptb, StationID stb) const;
+	void AddLinks(const Station *sta, const Station *stb);
+	void DrawLinks(const DrawPixelInfo *dpi) const;
+	void DrawStationDots(const DrawPixelInfo *dpi) const;
+	void DrawContent(Point pta, Point ptb, const LinkProperties &cargo) const;
+	bool IsLinkVisible(Point pta, Point ptb, const DrawPixelInfo *dpi, int padding = 0) const;
+	bool IsPointVisible(Point pt, const DrawPixelInfo *dpi, int padding = 0) const;
+	void GetWidgetDpi(DrawPixelInfo *dpi) const;
+
+	static void AddStats(const LinkStat &orig_link, const FlowStat &orig_flow, LinkProperties &cargo);
+	static void DrawVertex(int x, int y, int size, int colour, int border_colour);
+};
+
+void ShowLinkGraphLegend();
+
+/**
+ * Menu window to select cargoes and companies to show in a link graph overlay.
+ */
+struct LinkGraphLegendWindow : Window {
+public:
+	LinkGraphLegendWindow(const WindowDesc *desc, int window_number);
+	void SetOverlay(LinkGraphOverlay *overlay);
+
+	virtual void DrawWidget(const Rect &r, int widget) const;
+	virtual void OnClick(Point pt, int widget, int click_count);
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true);
+
+private:
+	LinkGraphOverlay *overlay;
+
+	void UpdateOverlayCompanies();
+	void UpdateOverlayCargoes();
+};
+
+#endif /* LINKGRAPH_GUI_H_ */
diff --git a/src/main_gui.cpp b/src/main_gui.cpp
index 45f2d7e..175aea4 100644
--- a/src/main_gui.cpp
+++ b/src/main_gui.cpp
@@ -29,6 +29,7 @@
 #include "company_func.h"
 #include "toolbar_gui.h"
 #include "statusbar_gui.h"
+#include "linkgraph_gui.h"
 #include "tilehighlight_func.h"
 #include "hotkeys.h"
 
@@ -241,6 +242,11 @@ enum {
 
 struct MainWindow : Window
 {
+	uint refresh;
+
+	static const uint LINKGRAPH_REFRESH_PERIOD = 0xff;
+	static const uint LINKGRAPH_DELAY = 0xf;
+
 	MainWindow() : Window()
 	{
 		this->InitNested(&_main_window_desc, 0);
@@ -248,6 +254,18 @@ struct MainWindow : Window
 
 		NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(MW_VIEWPORT);
 		nvp->InitializeViewport(this, TileXY(32, 32), ZOOM_LVL_VIEWPORT);
+
+		this->viewport->overlay = new LinkGraphOverlay(this, MW_VIEWPORT, 0, 0, 3);
+		this->refresh = LINKGRAPH_DELAY;
+	}
+
+	virtual void OnTick()
+	{
+		if (--refresh == 0) {
+			this->viewport->overlay->RebuildCache();
+			this->GetWidget<NWidgetBase>(MW_VIEWPORT)->SetDirty(this);
+			this->refresh = LINKGRAPH_REFRESH_PERIOD;
+		}
 	}
 
 	virtual void OnPaint()
@@ -415,6 +433,7 @@ struct MainWindow : Window
 		this->viewport->scrollpos_y += ScaleByZoom(delta.y, this->viewport->zoom);
 		this->viewport->dest_scrollpos_x = this->viewport->scrollpos_x;
 		this->viewport->dest_scrollpos_y = this->viewport->scrollpos_y;
+		this->refresh = LINKGRAPH_DELAY;
 	}
 
 	virtual void OnMouseWheel(int wheel)
@@ -429,6 +448,7 @@ struct MainWindow : Window
 		if (this->viewport != NULL) {
 			NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(MW_VIEWPORT);
 			nvp->UpdateViewportCoordinates(this);
+			this->refresh = LINKGRAPH_DELAY;
 		}
 	}
 
diff --git a/src/misc.cpp b/src/misc.cpp
index 09ace07..d6c9b8f 100644
--- a/src/misc.cpp
+++ b/src/misc.cpp
@@ -47,6 +47,7 @@ void InitializeCompanies();
 void InitializeCheats();
 void InitializeNPF();
 void InitializeOldNames();
+void InitializeLinkGraphs();
 
 void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settings)
 {
@@ -101,6 +102,7 @@ void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settin
 #endif /* ENABLE_NETWORK */
 	InitializeAnimatedTiles();
 
+	InitializeLinkGraphs();
 	InitializeEconomy();
 
 	ResetObjectToPlace();
diff --git a/src/misc_gui.cpp b/src/misc_gui.cpp
index 137d533..f9ea6ad 100644
--- a/src/misc_gui.cpp
+++ b/src/misc_gui.cpp
@@ -803,17 +803,28 @@ void ShowCostOrIncomeAnimation(int x, int y, int z, Money cost)
 
 /**
  * Display animated feeder income.
- * @param x    World X position of the animation location.
- * @param y    World Y position of the animation location.
- * @param z    World Z position of the animation location.
- * @param cost Estimated feeder income.
+ * @param x        World X position of the animation location.
+ * @param y        World Y position of the animation location.
+ * @param z        World Z position of the animation location.
+ * @param transfer Estimated feeder income.
+ * @param income   Real income from goods being delivered to their final destination.
  */
-void ShowFeederIncomeAnimation(int x, int y, int z, Money cost)
+void ShowFeederIncomeAnimation(int x, int y, int z, Money transfer, Money income)
 {
 	Point pt = RemapCoords(x, y, z);
 
-	SetDParam(0, cost);
-	AddTextEffect(STR_FEEDER, pt.x, pt.y, DAY_TICKS, TE_RISING);
+	SetDParam(0, transfer);
+	if (income == 0) {
+		AddTextEffect(STR_FEEDER, pt.x, pt.y, DAY_TICKS, TE_RISING);
+	} else {
+		StringID msg = STR_FEEDER_COST;
+		if (income < 0) {
+			income = -income;
+			msg = STR_FEEDER_INCOME;
+		}
+		SetDParam(1, income);
+		AddTextEffect(msg, pt.x, pt.y, DAY_TICKS, TE_RISING);
+	}
 }
 
 /**
diff --git a/src/moving_average.cpp b/src/moving_average.cpp
new file mode 100644
index 0000000..9b840e6
--- /dev/null
+++ b/src/moving_average.cpp
@@ -0,0 +1,32 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.cpp Implementation of moving average functions. */
+
+#include "stdafx.h"
+#include "moving_average.h"
+#include "date_func.h"
+#include "station_base.h"
+
+/**
+ * Run moving average decrease function on all items from a pool which are due
+ * this tick. This function expects to be run every tick. It calls a method
+ * "RunAverages()" on all items for which id % DAY_TICKS == _tick_counter % DAY_TICKS.
+ * So each item is called once a day.
+ */
+template <class Titem> void RunAverages()
+{
+	for (uint id = _tick_counter % DAY_TICKS; id < Titem::GetPoolSize(); id += DAY_TICKS) {
+		Titem *item = Titem::GetIfValid(id);
+		if (item != NULL) item->RunAverages();
+	}
+}
+
+template class MovingAverage<uint>;
+template void RunAverages<Station>();
diff --git a/src/moving_average.h b/src/moving_average.h
new file mode 100644
index 0000000..3a4d2eb
--- /dev/null
+++ b/src/moving_average.h
@@ -0,0 +1,78 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.h Utility class for moving averages. */
+
+#ifndef MOVING_AVERAGE_H_
+#define MOVING_AVERAGE_H_
+
+#include "settings_type.h"
+#include "core/math_func.hpp"
+
+/**
+ * Class implementing moving average functionality. An instance of this class
+ * can be used to get a meaningful (Monthly()) value from a moving average and
+ * it can be used to do the decrease operation.
+ * @tparam Tvalue Type supporting operator*(uint), operator/(uint),
+ * operator*=(uint) and operator/=(uint) with the usual semantics.
+ */
+template<class Tvalue>
+class MovingAverage {
+protected:
+	uint length;
+
+public:
+	/**
+	 * Create a moving average.
+	 * @param length Length to be used.
+	 */
+	FORCEINLINE MovingAverage(uint length) : length(length)
+	{
+		assert(this->length > 0);
+	}
+
+	/**
+	 * Get the length of this moving average.
+	 * @return Length.
+	 */
+	FORCEINLINE uint Length() const
+	{
+		return this->length;
+	}
+
+	/**
+	 * Get the current average for 30 "length units" from the given value.
+	 * Mind that no one forces you to decrease the average daily. If you
+	 * don't this is not a real "monthly" value. In any case it's not really
+	 * "monthly" as we don't account for months with different numbers of
+	 * days than 30. It doesn't matter, though. The point is to get an
+	 * average over a defined past timeframe.
+	 * @param value Raw moving average.
+	 * @return 30 "length unit" average.
+	 */
+	FORCEINLINE Tvalue Monthly(const Tvalue &value) const
+	{
+		return (value * 30) / (this->length);
+	}
+
+	/**
+	 * Decrease the given value using this moving average.
+	 * @param value Moving average value to be decreased.
+	 * @return Decreased value.
+	 */
+	FORCEINLINE Tvalue &Decrease(Tvalue &value) const
+	{
+		return value = (value * this->length) / (this->length + 1);
+	}
+};
+
+template<class Titem> void RunAverages();
+
+#endif /* MOVING_AVERAGE_H_ */
+
diff --git a/src/newgrf.cpp b/src/newgrf.cpp
index b686bc9..0ce5546 100644
--- a/src/newgrf.cpp
+++ b/src/newgrf.cpp
@@ -8165,6 +8165,9 @@ static void AfterLoadGRFs()
 	/* Create dynamic list of industry legends for smallmap_gui.cpp */
 	BuildIndustriesLegend();
 
+	/* build the routemap legend, based on the available cargos */
+	BuildLinkStatsLegend();
+
 	/* Add all new airports to the airports array. */
 	FinaliseAirportsArray();
 	BindAirportSpecs();
diff --git a/src/openttd.cpp b/src/openttd.cpp
index 816180b..0ae8004 100644
--- a/src/openttd.cpp
+++ b/src/openttd.cpp
@@ -65,6 +65,8 @@
 #include "town.h"
 #include "industry.h"
 
+#include "linkgraph/linkgraph.h"
+
 #include <stdarg.h>
 
 #include "table/strings.h"
@@ -266,6 +268,12 @@ static void ShutdownGame()
 	/* Uninitialize variables that are allocated dynamically */
 	GamelogReset();
 
+	/* Reinitialize the link graphs to forcibly stop the threads.
+	 * If a link graph thread is running while the link graph handlers are
+	 * deleted we get a crash.
+	 */
+	InitializeLinkGraphs();
+
 #ifdef ENABLE_NETWORK
 	free(_config_file);
 #endif
diff --git a/src/order_base.h b/src/order_base.h
index 44ce7a3..a9869db 100644
--- a/src/order_base.h
+++ b/src/order_base.h
@@ -159,6 +159,9 @@ public:
 	inline void SetConditionValue(uint16 value) { SB(this->dest, 0, 11, value); }
 
 	bool ShouldStopAtStation(const Vehicle *v, StationID station) const;
+	bool CanLoadOrUnload() const;
+	bool CanLeaveWithCargo(bool has_cargo) const;
+
 	TileIndex GetLocation(const Vehicle *v) const;
 
 	/** Checks if this order has travel_time and if needed wait_time set. */
@@ -189,6 +192,16 @@ private:
 	friend void AfterLoadVehicles(bool part_of_load); ///< For instantiating the shared vehicle chain
 	friend const struct SaveLoad *GetOrderListDescription(); ///< Saving and loading of order lists.
 
+	/**
+	 * Get the order after the given one or the first one, if the given one is the
+	 * last one.
+	 * @param curr Order to find the next one for.
+	 * @return Next order.
+	 */
+	inline const Order *GetNext(const Order *curr) const { return (curr->next == NULL) ? this->GetFirstOrder() : curr->next; }
+
+	StationID GetNextStoppingStation(const Order *next, StationID curr_station, StationIDVector *stations, uint hops) const;
+
 	Order *first;                     ///< First order of the order list.
 	VehicleOrderID num_orders;        ///< NOSAVE: How many orders there are in the list.
 	VehicleOrderID num_manual_orders; ///< NOSAVE: How many manually added orders are there in the list.
@@ -229,6 +242,8 @@ public:
 	 */
 	inline Order *GetLastOrder() const { return this->GetOrderAt(this->num_orders - 1); }
 
+	StationID GetNextStoppingStation(VehicleOrderID curr_order, StationID curr_station, StationIDVector *stations = NULL) const;
+
 	/**
 	 * Get number of orders in the order list.
 	 * @return number of orders in the chain.
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
index 4441a78..1b18a84 100644
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -341,6 +341,66 @@ Order *OrderList::GetOrderAt(int index) const
 }
 
 /**
+ * Recursively determine the next deterministic station to stop at.
+ * @param next First order to check.
+ * @param curr_station Station the vehicle is just visiting or INVALID_STATION.
+ * @param hops Number of orders we have already checked.
+ * @return Next stoppping station or INVALID_STATION.
+ */
+StationID OrderList::GetNextStoppingStation(const Order *next, StationID curr_station, StationIDVector *stations, uint hops) const
+{
+	if (next == NULL || hops > this->GetNumOrders()) {
+		return INVALID_STATION;
+	}
+
+	if (next->IsType(OT_CONDITIONAL)) {
+		StationID skip_to = this->GetNextStoppingStation(
+				this->GetOrderAt(next->GetConditionSkipToOrder()),
+				curr_station, stations, hops + 1);
+		StationID advance = this->GetNextStoppingStation(
+				this->GetNext(next), curr_station, stations, hops + 1);
+		return skip_to == advance ? skip_to : INVALID_STATION;
+	}
+
+	if (!next->CanLoadOrUnload() ||	(next->GetDestination() == curr_station &&
+			(next->GetUnloadType() & (OUFB_TRANSFER | OUFB_UNLOAD)) == 0)) {
+		return this->GetNextStoppingStation(this->GetNext(next), curr_station, stations, hops + 1);
+	}
+
+	StationID st = next->GetDestination();
+	if (stations != NULL) stations->Include(st);
+	return st;
+}
+
+/**
+ * Get the next station the vehicle will stop at, if that is deterministic.
+ * @param curr_order ID of the current order.
+ * @param curr_station Station the vehicle is just visiting or INVALID_STATION.
+ * @param stations list to record all possible next stations in when nondeterministic.
+ * @return ID of the next station the vehicle will stop at or INVALID_STATION.
+ */
+StationID OrderList::GetNextStoppingStation(VehicleOrderID curr_order, StationID curr_station, StationIDVector *stations) const
+{
+	const Order *curr = this->GetOrderAt(curr_order);
+	if (curr == NULL) {
+		curr = this->GetFirstOrder();
+		if (curr == NULL) return INVALID_STATION;
+	}
+
+	/* If we're not at a station or the current order doesn't yield the station
+	 * we're at, we have to check the current order; otherwise we have to check
+	 * the next one.
+	 */
+	if (curr_station == INVALID_STATION ||
+			!(curr->IsType(OT_GOTO_STATION) || curr->IsType(OT_AUTOMATIC)) ||
+			curr_station != curr->GetDestination()) {
+		return this->GetNextStoppingStation(curr, curr_station, stations, 0);
+	} else {
+		return this->GetNextStoppingStation(this->GetNext(curr), curr_station, stations, 1);
+	}
+}
+
+/**
  * Insert a new order into the order chain.
  * @param new_order is the order to insert into the chain.
  * @param index is the position where the order is supposed to be inserted.
@@ -871,6 +931,7 @@ static CommandCost DecloneOrder(Vehicle *dst, DoCommandFlag flags)
 	if (flags & DC_EXEC) {
 		DeleteVehicleOrders(dst);
 		InvalidateVehicleOrder(dst, -1);
+
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(dst->type), 0);
 	}
 	return CommandCost();
@@ -1003,11 +1064,11 @@ CommandCost CmdSkipToOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 	if (ret.Failed()) return ret;
 
 	if (flags & DC_EXEC) {
+		if (v->current_order.IsType(OT_LOADING)) v->LeaveStation();
+
 		v->cur_auto_order_index = v->cur_real_order_index = sel_ord;
 		v->UpdateRealOrderIndex();
 
-		if (v->current_order.IsType(OT_LOADING)) v->LeaveStation();
-
 		InvalidateVehicleOrder(v, -2);
 	}
 
@@ -2011,3 +2072,23 @@ bool Order::ShouldStopAtStation(const Vehicle *v, StationID station) const
 			/* Finally do stop when there is no non-stop flag set for this type of station. */
 			!(this->GetNonStopType() & (is_dest_station ? ONSF_NO_STOP_AT_DESTINATION_STATION : ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS));
 }
+
+bool Order::CanLoadOrUnload() const
+{
+	return (this->IsType(OT_GOTO_STATION) || this->IsType(OT_AUTOMATIC)) &&
+			(this->GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION) == 0 &&
+			((this->GetLoadType() & OLFB_NO_LOAD) == 0 ||
+			(this->GetUnloadType() & OUFB_NO_UNLOAD) == 0);
+}
+
+/**
+ * A vehicle can leave the current station with cargo if:
+ * 1. it can load cargo here OR
+ * 2a. it could leave the last station with cargo AND
+ * 2b. it doesn't have to unload all cargo here.
+ */
+bool Order::CanLeaveWithCargo(bool has_cargo) const
+{
+	return (this->GetLoadType() & OLFB_NO_LOAD) == 0 || (has_cargo &&
+			(this->GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) == 0);
+}
diff --git a/src/order_type.h b/src/order_type.h
index 6d9b0f0..6b9f98b 100644
--- a/src/order_type.h
+++ b/src/order_type.h
@@ -13,12 +13,16 @@
 #define ORDER_TYPE_H
 
 #include "core/enum_type.hpp"
+#include "core/smallvec_type.hpp"
+#include "station_type.h"
 
 typedef byte VehicleOrderID;  ///< The index of an order within its current vehicle (not pool related)
 typedef uint16 OrderID;
 typedef uint16 OrderListID;
 typedef uint16 DestinationID;
 
+typedef SmallVector<StationID, 1> StationIDVector;
+
 /** Invalid vehicle order index (sentinel) */
 static const VehicleOrderID INVALID_VEH_ORDER_ID = 0xFF;
 /** Last valid VehicleOrderID. */
diff --git a/src/roadveh_cmd.cpp b/src/roadveh_cmd.cpp
index 69c1a55..05c70a2 100644
--- a/src/roadveh_cmd.cpp
+++ b/src/roadveh_cmd.cpp
@@ -243,6 +243,7 @@ CommandCost CmdBuildRoadVehicle(TileIndex tile, DoCommandFlag flags, const Engin
 		v->cargo_cap = rvi->capacity;
 
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 		v->engine_type = e->index;
 		v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
 
diff --git a/src/saveload/afterload.cpp b/src/saveload/afterload.cpp
index 4acd05b..64a888e 100644
--- a/src/saveload/afterload.cpp
+++ b/src/saveload/afterload.cpp
@@ -2604,6 +2604,8 @@ bool AfterLoadGame()
 	InitializeWindowsAndCaches();
 	/* Restore the signals */
 	ResetSignalHandlers();
+
+	AfterLoadLinkGraphs();
 	return true;
 }
 
diff --git a/src/saveload/cargopacket_sl.cpp b/src/saveload/cargopacket_sl.cpp
index eafe534..da920cc 100644
--- a/src/saveload/cargopacket_sl.cpp
+++ b/src/saveload/cargopacket_sl.cpp
@@ -26,7 +26,7 @@
 		 * to the current tile of the vehicle to prevent excessive profits
 		 */
 		FOR_ALL_VEHICLES(v) {
-			const VehicleCargoList::List *packets = v->cargo.Packets();
+			const CargoPacketList *packets = v->cargo.Packets();
 			for (VehicleCargoList::ConstIterator it(packets->begin()); it != packets->end(); it++) {
 				CargoPacket *cp = *it;
 				cp->source_xy = Station::IsValidID(cp->source) ? Station::Get(cp->source)->xy : v->tile;
@@ -44,7 +44,7 @@
 			for (CargoID c = 0; c < NUM_CARGO; c++) {
 				GoodsEntry *ge = &st->goods[c];
 
-				const StationCargoList::List *packets = ge->cargo.Packets();
+				const StationCargoPacketMap *packets = ge->cargo.Packets();
 				for (StationCargoList::ConstIterator it(packets->begin()); it != packets->end(); it++) {
 					CargoPacket *cp = *it;
 					cp->source_xy = Station::IsValidID(cp->source) ? Station::Get(cp->source)->xy : st->xy;
diff --git a/src/saveload/economy_sl.cpp b/src/saveload/economy_sl.cpp
index 9bdad61..ccfc202 100644
--- a/src/saveload/economy_sl.cpp
+++ b/src/saveload/economy_sl.cpp
@@ -63,11 +63,11 @@ static void Load_ECMY()
 }
 
 static const SaveLoad _cargopayment_desc[] = {
-	SLE_REF(CargoPayment, front,         REF_VEHICLE),
-	SLE_VAR(CargoPayment, route_profit,  SLE_INT64),
-	SLE_VAR(CargoPayment, visual_profit, SLE_INT64),
-
-	SLE_END()
+	    SLE_REF(CargoPayment, front,           REF_VEHICLE),
+	    SLE_VAR(CargoPayment, route_profit,    SLE_INT64),
+	    SLE_VAR(CargoPayment, visual_profit,   SLE_INT64),
+	SLE_CONDVAR(CargoPayment, visual_transfer, SLE_INT64, SL_CARGOMAP, SL_MAX_VERSION),
+	    SLE_END()
 };
 
 static void Save_CAPY()
diff --git a/src/saveload/linkgraph_sl.cpp b/src/saveload/linkgraph_sl.cpp
new file mode 100644
index 0000000..97702b0
--- /dev/null
+++ b/src/saveload/linkgraph_sl.cpp
@@ -0,0 +1,159 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_sl.cpp Code handling saving and loading of link graphs */
+
+#include "../stdafx.h"
+#include "../linkgraph/linkgraph.h"
+#include "../linkgraph/demands.h"
+#include "../settings_internal.h"
+#include "saveload.h"
+#include <vector>
+
+const SettingDesc *GetSettingDescription(uint index);
+
+/**
+ * Get a SaveLoad array for a link graph. The settings struct is derived from
+ * the global settings saveload array. The exact entries are calculated when the function
+ * is called the first time.
+ * It's necessary to keep a copy of the settings for each link graph so that you can
+ * change the settings while in-game and still not mess with current link graph runs.
+ * Of course the settings have to be saved and loaded, too, to avoid desyncs.
+ * @return Array of SaveLoad structs.
+ */
+const SaveLoad *GetLinkGraphDesc()
+{
+	static std::vector<SaveLoad> saveloads;
+	static const char *prefix = "linkgraph.";
+
+	/* Build the SaveLoad array on first call and don't touch it later on */
+	if (saveloads.empty()) {
+		size_t offset_gamesettings = cpp_offsetof(GameSettings, linkgraph);
+		size_t offset_component = cpp_offsetof(LinkGraph, settings);
+
+		size_t prefixlen = strlen(prefix);
+
+		int setting = 0;
+		const SettingDesc *desc = GetSettingDescription(setting);
+		while (desc->save.cmd != SL_END) {
+			if (desc->desc.name != NULL && strncmp(desc->desc.name, prefix, prefixlen) == 0) {
+				SaveLoad sl = desc->save;
+				char *&address = reinterpret_cast<char *&>(sl.address);
+				address -= offset_gamesettings;
+				address += offset_component;
+				saveloads.push_back(sl);
+			}
+			desc = GetSettingDescription(++setting);
+		}
+
+		const SaveLoad component_desc[] = {
+			SLE_CONDVAR(LinkGraph, num_nodes,          SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, index,              SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, current_station_id, SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, cargo,              SLE_UINT8,  SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_END()
+		};
+
+		int i = 0;
+		do {
+			saveloads.push_back(component_desc[i++]);
+		} while (saveloads.back().cmd != SL_END);
+	}
+
+	return &saveloads[0];
+}
+
+/* Edges and nodes are saved in the correct order, so we don't need to save their ids. */
+
+/**
+ * SaveLoad desc for a link graph node.
+ */
+static const SaveLoad _node_desc[] = {
+	 SLE_CONDVAR(Node, supply,    SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Node, demand,    SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Node, station,   SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_END()
+};
+
+/**
+ * SaveLoad desc for a link graph edge.
+ */
+static const SaveLoad _edge_desc[] = {
+	 SLE_CONDVAR(Edge, distance,  SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Edge, capacity,  SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Edge, next_edge, SLE_UINT32,        SL_MCF, SL_MAX_VERSION),
+	 SLE_END()
+};
+
+/**
+ * Save/load a component of a link graph
+ * @param comp the component to be saved or loaded
+ */
+static void SaveLoad_LinkGraphComponent(LinkGraphComponent &comp)
+{
+	uint size = comp.GetSize();
+	for (NodeID from = 0; from < size; ++from) {
+		Node *node = &comp.GetNode(from);
+		SlObject(node, _node_desc);
+		for (NodeID to = 0; to < size; ++to) {
+			SlObject(&comp.GetEdge(from, to), _edge_desc);
+		}
+	}
+}
+
+/**
+ * Save all link graphs.
+ */
+static void DoSave_LGRP(void *)
+{
+	for (CargoID cargo = 0; cargo < NUM_CARGO; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		SlObject(&graph, GetLinkGraphDesc());
+		SaveLoad_LinkGraphComponent(graph);
+	}
+}
+
+/**
+ * Load all link graphs.
+ */
+static void Load_LGRP()
+{
+	for (CargoID cargo = 0; cargo < NUM_CARGO; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		assert(graph.GetSize() == 0);
+		SlObject(&graph, GetLinkGraphDesc());
+		graph.SetSize();
+		SaveLoad_LinkGraphComponent(graph);
+		for (uint i = 0; i < graph.GetSize(); ++i) {
+			Node &node = graph.GetNode(i);
+			node.undelivered_supply = node.supply;
+		}
+	}
+}
+
+/**
+ * Spawn the threads for running link graph calculations.
+ * Has to be done after loading as the cargo classes might have changed.
+ */
+void AfterLoadLinkGraphs()
+{
+	for (CargoID cargo = 0; cargo < NUM_CARGO; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		if (graph.GetSize() > 0) graph.SpawnThread();
+	}
+}
+
+static void Save_LGRP()
+{
+	SlAutolength((AutolengthProc*)DoSave_LGRP, NULL);
+}
+
+extern const ChunkHandler _linkgraph_chunk_handlers[] = {
+	{ 'LGRP', Save_LGRP, Load_LGRP, NULL, NULL, CH_LAST},
+};
diff --git a/src/saveload/oldloader_sl.cpp b/src/saveload/oldloader_sl.cpp
index 362df6b..2649bc5 100644
--- a/src/saveload/oldloader_sl.cpp
+++ b/src/saveload/oldloader_sl.cpp
@@ -711,7 +711,7 @@ static bool LoadOldGood(LoadgameState *ls, int num)
 	SB(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE, 1, HasBit(_waiting_acceptance, 15));
 	SB(ge->acceptance_pickup, GoodsEntry::PICKUP, 1, _cargo_source != 0xFF);
 	if (GB(_waiting_acceptance, 0, 12) != 0 && CargoPacket::CanAllocateItem()) {
-		ge->cargo.Append(new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, (_cargo_source == 0xFF) ? INVALID_STATION : _cargo_source, 0, 0));
+		ge->cargo.Append(INVALID_STATION, new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, (_cargo_source == 0xFF) ? INVALID_STATION : _cargo_source, 0, 0));
 	}
 
 	return true;
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
index 3c7700e..1e54c17 100644
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -226,7 +226,7 @@
  *  159   21962
  *  160   21974
  */
-extern const uint16 SAVEGAME_VERSION = 160; ///< Current savegame version of OpenTTD.
+extern const uint16 SAVEGAME_VERSION = SL_EXT_RATING; ///< Current savegame version of OpenTTD.
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
@@ -402,6 +402,7 @@ extern const ChunkHandler _group_chunk_handlers[];
 extern const ChunkHandler _cargopacket_chunk_handlers[];
 extern const ChunkHandler _autoreplace_chunk_handlers[];
 extern const ChunkHandler _labelmaps_chunk_handlers[];
+extern const ChunkHandler _linkgraph_chunk_handlers[];
 extern const ChunkHandler _airport_chunk_handlers[];
 extern const ChunkHandler _object_chunk_handlers[];
 
@@ -432,6 +433,7 @@ static const ChunkHandler * const _chunk_handlers[] = {
 	_cargopacket_chunk_handlers,
 	_autoreplace_chunk_handlers,
 	_labelmaps_chunk_handlers,
+	_linkgraph_chunk_handlers,
 	_airport_chunk_handlers,
 	_object_chunk_handlers,
 	NULL,
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
index b5fb001..42ccc9f 100644
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -90,9 +90,6 @@ enum SLRefType {
 	REF_ORDERLIST     = 8, ///< Load/save a reference to an orderlist.
 };
 
-/** Highest possible savegame version. */
-#define SL_MAX_VERSION 255
-
 /** Flags of a chunk. */
 enum ChunkType {
 	CH_RIFF         =  0,
@@ -549,4 +546,23 @@ bool SaveloadCrashWithMissingNewGRFs();
 extern char _savegame_format[8];
 extern bool _do_autosave;
 
+/**
+ * Save/load versions used for the various branches.
+ * SL_TRUNK is always the current trunk version.
+ */
+enum SaveLoadVersions {
+	SL_TRUNK = 160,
+	SL_RESERVATION = SL_TRUNK + 10,
+	SL_CAPACITIES = SL_TRUNK + 20,
+	SL_COMPONENTS,
+	SL_DEMANDS = SL_COMPONENTS + 20,
+	SL_MCF,
+	SL_FLOWMAP,
+	SL_CARGOMAP,
+	SL_EXT_RATING,
+
+	/** Highest possible savegame version. */
+	SL_MAX_VERSION = 255
+};
+
 #endif /* SAVELOAD_H */
diff --git a/src/saveload/saveload_internal.h b/src/saveload/saveload_internal.h
index b400861..4bf5646 100644
--- a/src/saveload/saveload_internal.h
+++ b/src/saveload/saveload_internal.h
@@ -30,6 +30,7 @@ void AfterLoadVehicles(bool part_of_load);
 void AfterLoadStations();
 void AfterLoadRoadStops();
 void AfterLoadLabelMaps();
+void AfterLoadLinkGraphs();
 void UpdateHousesAndTowns();
 
 void UpdateOldAircraft();
diff --git a/src/saveload/station_sl.cpp b/src/saveload/station_sl.cpp
index f32e476..7eb63a8 100644
--- a/src/saveload/station_sl.cpp
+++ b/src/saveload/station_sl.cpp
@@ -224,9 +224,11 @@ static const SaveLoad _old_station_desc[] = {
 };
 
 static uint16 _waiting_acceptance;
+static uint16 _num_links;
+static uint32 _num_flows;
 static uint16 _cargo_source;
 static uint32 _cargo_source_xy;
-static uint16 _cargo_days;
+static uint8  _cargo_days;
 static Money  _cargo_feeder_share;
 
 static const SaveLoad _station_speclist_desc[] = {
@@ -236,6 +238,49 @@ static const SaveLoad _station_speclist_desc[] = {
 	SLE_END()
 };
 
+static StationID _station_id;
+
+/**
+ * Wrapper function to get the LinkStat's internal structure while
+ * some of the variables are private.
+ * @return Saveload description for LinkStat.
+ */
+const SaveLoad *GetLinkStatDesc()
+{
+	static const SaveLoad linkstat_desc[] = {
+		SLEG_VAR(             _station_id,         SLE_UINT16),
+		 SLE_VAR(LinkStat,    length,              SLE_UINT32),
+		 SLE_VAR(LinkStat,    capacity,            SLE_UINT32),
+		 SLE_VAR(LinkStat,    timeout,             SLE_UINT32),
+		 SLE_VAR(LinkStat,    usage,               SLE_UINT32),
+		 SLE_END()
+	};
+
+	return linkstat_desc;
+}
+
+/**
+ * Wrapper function to get the FlowStats's internal structure while
+ * some of the variables are private.
+ * @return the saveload description for FlowStat.
+ */
+const SaveLoad *GetFlowStatDesc()
+{
+	static const SaveLoad _flowstat_desc[] = {
+		SLEG_CONDVAR(             _station_id,         SLE_UINT16,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    via,                 SLE_UINT16,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    length,              SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    planned,             SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    sent,                SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_END()
+	};
+
+	return _flowstat_desc;
+}
+
+std::list<CargoPacket *> _packets;
+uint32 _num_dests;
+
 /**
  * Wrapper function to get the GoodsEntry's internal structure while
  * some of the variables itself are private.
@@ -258,14 +303,49 @@ const SaveLoad *GetGoodsDesc()
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_FILE_U32 | SLE_VAR_I64, 14, 64),
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_INT64,                  65, 67),
 		 SLE_CONDVAR(GoodsEntry, amount_fract,        SLE_UINT8,                 150, SL_MAX_VERSION),
-		 SLE_CONDLST(GoodsEntry, cargo.packets,       REF_CARGO_PACKET,           68, SL_MAX_VERSION),
-
+		SLEG_CONDLST(            _packets,            REF_CARGO_PACKET,           68, SL_CARGOMAP - 1),
+		SLEG_CONDVAR(            _num_dests,          SLE_UINT32,        SL_CARGOMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, supply,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, supply_new,          SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_flows,          SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, last_component,      SLE_UINT16,      SL_COMPONENTS, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, max_waiting_cargo,   SLE_UINT32,      SL_EXT_RATING, SL_MAX_VERSION),
 		SLE_END()
 	};
 
 	return goods_desc;
 }
 
+typedef std::pair<const StationID, std::list<CargoPacket *> > StationCargoPair;
+
+static const SaveLoad _cargo_list_desc[] = {
+	SLE_VAR(StationCargoPair, first,  SLE_UINT16),
+	SLE_LST(StationCargoPair, second, REF_CARGO_PACKET),
+	SLE_END()
+};
+
+/**
+ * swap the temporary packets with the packets without specific destination in
+ * the given goods entry. Assert that at least one of those is empty.
+ * @param ge the goods entry to swap with
+ */
+static void SwapPackets(GoodsEntry *ge)
+{
+	StationCargoPacketMap &ge_packets = const_cast<StationCargoPacketMap &>(*ge->cargo.Packets());
+
+	if (_packets.empty()) {
+		std::map<StationID, std::list<CargoPacket *> >::iterator it(ge_packets.find(INVALID_STATION));
+		if (it == ge_packets.end()) {
+			return;
+		} else {
+			it->second.swap(_packets);
+		}
+	} else {
+		assert(ge_packets[INVALID_STATION].empty());
+		ge_packets[INVALID_STATION].swap(_packets);
+	}
+}
 
 static void Load_STNS()
 {
@@ -281,6 +361,7 @@ static void Load_STNS()
 		for (CargoID i = 0; i < num_cargo; i++) {
 			GoodsEntry *ge = &st->goods[i];
 			SlObject(ge, GetGoodsDesc());
+			SwapPackets(ge);
 			if (IsSavegameVersionBefore(68)) {
 				SB(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE, 1, HasBit(_waiting_acceptance, 15));
 				if (GB(_waiting_acceptance, 0, 12) != 0) {
@@ -292,7 +373,10 @@ static void Load_STNS()
 					 * savegame versions. As the CargoPacketPool has more than
 					 * 16 million entries; it fits by an order of magnitude. */
 					assert(CargoPacket::CanAllocateItem());
-					ge->cargo.Append(new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, source, _cargo_source_xy, _cargo_source_xy, _cargo_feeder_share));
+
+					/* Don't construct the packet with station here, because that'll fail with old savegames */
+					CargoPacket *cp = new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, source, _cargo_source_xy, _cargo_source_xy, _cargo_feeder_share);
+					ge->cargo.Append(INVALID_STATION, cp);
 					SB(ge->acceptance_pickup, GoodsEntry::PICKUP, 1, 1);
 				}
 			}
@@ -318,7 +402,9 @@ static void Ptrs_STNS()
 		if (!IsSavegameVersionBefore(68)) {
 			for (CargoID i = 0; i < NUM_CARGO; i++) {
 				GoodsEntry *ge = &st->goods[i];
+				SwapPackets(ge);
 				SlObject(ge, GetGoodsDesc());
+				SwapPackets(ge);
 			}
 		}
 		SlObject(st, _old_station_desc);
@@ -405,8 +491,29 @@ static void RealSave_STNN(BaseStation *bst)
 
 	if (!waypoint) {
 		Station *st = Station::From(bst);
-		for (CargoID i = 0; i < NUM_CARGO; i++) {
-			SlObject(&st->goods[i], GetGoodsDesc());
+		for (CargoID c = 0; c < NUM_CARGO; c++) {
+			_num_dests = (uint32)st->goods[c].cargo.Packets()->MapSize();
+			_num_links = (uint16)st->goods[c].link_stats.size();
+			_num_flows = 0;
+			for (FlowStatMap::const_iterator it(st->goods[c].flows.begin()); it != st->goods[c].flows.end(); ++it) {
+				_num_flows += (uint32)it->second.size();
+			}
+			SlObject(&st->goods[c], GetGoodsDesc());
+			for (LinkStatMap::const_iterator it(st->goods[c].link_stats.begin()); it != st->goods[c].link_stats.end(); ++it) {
+				_station_id = it->first;
+				LinkStat ls(it->second); // make a copy to avoid constness problems
+				SlObject(&ls, GetLinkStatDesc());
+			}
+			for (FlowStatMap::const_iterator outer_it(st->goods[c].flows.begin()); outer_it != st->goods[c].flows.end(); ++outer_it) {
+				_station_id = outer_it->first;
+				for (FlowStatSet::const_iterator inner_it(outer_it->second.begin()); inner_it != outer_it->second.end(); ++inner_it) {
+					FlowStat fs(*inner_it); // make a copy to avoid constness problems
+					SlObject(&fs, GetFlowStatDesc());
+				}
+			}
+			for (StationCargoPacketMap::ConstMapIterator it(st->goods[c].cargo.Packets()->begin()); it != st->goods[c].cargo.Packets()->end(); ++it) {
+				SlObject(const_cast<StationCargoPacketMap::value_type *>(&(*it)), _cargo_list_desc);
+			}
 		}
 	}
 
@@ -437,8 +544,29 @@ static void Load_STNN()
 
 		if (!waypoint) {
 			Station *st = Station::From(bst);
-			for (CargoID i = 0; i < NUM_CARGO; i++) {
-				SlObject(&st->goods[i], GetGoodsDesc());
+			for (CargoID c = 0; c < NUM_CARGO; c++) {
+				SlObject(&st->goods[c], GetGoodsDesc());
+				LinkStat ls;
+				for (uint16 i = 0; i < _num_links; ++i) {
+					SlObject(&ls, GetLinkStatDesc());
+					assert(ls.IsValid());
+					st->goods[c].link_stats[_station_id] = ls;
+				}
+				FlowStat fs;
+				for (uint32 i = 0; i < _num_flows; ++i) {
+					SlObject(&fs, GetFlowStatDesc());
+					st->goods[c].flows[_station_id].insert(fs);
+				}
+				if (IsSavegameVersionBefore(SL_CARGOMAP -1)) {
+					SwapPackets(&st->goods[c]);
+				} else {
+					StationCargoPair pair;
+					for (uint i = 0; i < _num_dests; ++i) {
+						SlObject(&pair, _cargo_list_desc);
+						const_cast<StationCargoPacketMap &>(*(st->goods[c].cargo.Packets()))[pair.first].swap(pair.second);
+						assert(pair.second.empty());
+					}
+				}
 			}
 		}
 
@@ -461,7 +589,16 @@ static void Ptrs_STNN()
 	FOR_ALL_STATIONS(st) {
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
 			GoodsEntry *ge = &st->goods[i];
-			SlObject(ge, GetGoodsDesc());
+			if (IsSavegameVersionBefore(SL_CARGOMAP)) {
+				SwapPackets(ge);
+				SlObject(ge, GetGoodsDesc());
+				SwapPackets(ge);
+			} else {
+				SlObject(ge, GetGoodsDesc());
+				for (StationCargoPacketMap::ConstMapIterator it = ge->cargo.Packets()->begin(); it != ge->cargo.Packets()->end(); ++it) {
+					SlObject(const_cast<StationCargoPair *>(&(*it)), _cargo_list_desc);
+				}
+			}
 		}
 		SlObject(st, _station_desc);
 	}
diff --git a/src/saveload/vehicle_sl.cpp b/src/saveload/vehicle_sl.cpp
index f3af881..508917c 100644
--- a/src/saveload/vehicle_sl.cpp
+++ b/src/saveload/vehicle_sl.cpp
@@ -489,6 +489,7 @@ const SaveLoad *GetVehicleDescription(VehicleType vt)
 		     SLE_VAR(Vehicle, vehstatus,             SLE_UINT8),
 		 SLE_CONDVAR(Vehicle, last_station_visited,  SLE_FILE_U8  | SLE_VAR_U16,   0,   4),
 		 SLE_CONDVAR(Vehicle, last_station_visited,  SLE_UINT16,                   5, SL_MAX_VERSION),
+		 SLE_CONDVAR(Vehicle, last_loading_station,  SLE_UINT16,       SL_CAPACITIES, SL_MAX_VERSION),
 
 		     SLE_VAR(Vehicle, cargo_type,            SLE_UINT8),
 		 SLE_CONDVAR(Vehicle, cargo_subtype,         SLE_UINT8,                   35, SL_MAX_VERSION),
@@ -499,6 +500,7 @@ const SaveLoad *GetVehicleDescription(VehicleType vt)
 		     SLE_VAR(Vehicle, cargo_cap,             SLE_UINT16),
 		SLEG_CONDVAR(         _cargo_count,          SLE_UINT16,                   0,  67),
 		 SLE_CONDLST(Vehicle, cargo.packets,         REF_CARGO_PACKET,            68, SL_MAX_VERSION),
+		 SLE_CONDLST(Vehicle, cargo.reserved,        REF_CARGO_PACKET,SL_RESERVATION, SL_MAX_VERSION),
 
 		     SLE_VAR(Vehicle, day_counter,           SLE_UINT8),
 		     SLE_VAR(Vehicle, tick_counter,          SLE_UINT8),
@@ -780,6 +782,8 @@ void Load_VEHS()
 			v->last_station_visited = INVALID_STATION;
 		}
 
+		if (IsSavegameVersionBefore(SL_CAPACITIES)) v->last_loading_station = INVALID_STATION;
+
 		if (IsSavegameVersionBefore(5)) {
 			/* Convert the current_order.type (which is a mix of type and flags, because
 			 *  in those versions, they both were 4 bits big) to type and flags */
diff --git a/src/settings.cpp b/src/settings.cpp
index 38101e7..a6e432f 100644
--- a/src/settings.cpp
+++ b/src/settings.cpp
@@ -1618,7 +1618,7 @@ void DeleteGRFPresetFromConfig(const char *config_name)
 	delete ini;
 }
 
-static const SettingDesc *GetSettingDescription(uint index)
+const SettingDesc *GetSettingDescription(uint index)
 {
 	if (index >= lengthof(_settings)) return NULL;
 	return &_settings[index];
diff --git a/src/settings_gui.cpp b/src/settings_gui.cpp
index 0203b75..1e93d9b 100644
--- a/src/settings_gui.cpp
+++ b/src/settings_gui.cpp
@@ -1413,6 +1413,20 @@ static SettingEntry _settings_economy[] = {
 /** Economy sub-page */
 static SettingsPage _settings_economy_page = {_settings_economy, lengthof(_settings_economy)};
 
+static SettingEntry _settings_linkgraph[] = {
+	SettingEntry("linkgraph.recalc_interval"),
+	SettingEntry("linkgraph.distribution_pax"),
+	SettingEntry("linkgraph.distribution_mail"),
+	SettingEntry("linkgraph.distribution_armoured"),
+	SettingEntry("linkgraph.distribution_default"),
+	SettingEntry("linkgraph.accuracy"),
+	SettingEntry("linkgraph.demand_distance"),
+	SettingEntry("linkgraph.demand_size"),
+	SettingEntry("linkgraph.short_path_saturation"),
+};
+/** Linkgraph sub-page */
+static SettingsPage _settings_linkgraph_page = {_settings_linkgraph, lengthof(_settings_linkgraph)};
+
 static SettingEntry _settings_ai_npc[] = {
 	SettingEntry("ai.ai_in_multiplayer"),
 	SettingEntry("ai.ai_disable_veh_train"),
@@ -1505,6 +1519,7 @@ static SettingEntry _settings_main[] = {
 	SettingEntry(&_settings_vehicles_page,     STR_CONFIG_SETTING_VEHICLES),
 	SettingEntry(&_settings_stations_page,     STR_CONFIG_SETTING_STATIONS),
 	SettingEntry(&_settings_economy_page,      STR_CONFIG_SETTING_ECONOMY),
+	SettingEntry(&_settings_linkgraph_page,    STR_CONFIG_SETTING_LINKGRAPH),
 	SettingEntry(&_settings_ai_page,           STR_CONFIG_SETTING_AI),
 };
 
diff --git a/src/settings_type.h b/src/settings_type.h
index 3b8b324..bbc679b 100644
--- a/src/settings_type.h
+++ b/src/settings_type.h
@@ -17,6 +17,8 @@
 #include "transport_type.h"
 #include "network/core/config.h"
 #include "company_type.h"
+#include "cargotype.h"
+#include "linkgraph/linkgraph_type.h"
 #include "openttd.h"
 
 /** Available industry map generation densities. */
@@ -113,6 +115,10 @@ struct GUISettings {
 
 	uint16 console_backlog_timeout;          ///< the minimum amount of time items should be in the console backlog before they will be removed in ~3 seconds granularity.
 	uint16 console_backlog_length;           ///< the minimum amount of items in the console backlog before items will be removed.
+
+	uint8  station_gui_group_order;          ///< the order of grouping cargo entries in the station gui
+	uint8  station_gui_sort_by;              ///< sort cargo entries in the station gui by station name or amount
+	uint8  station_gui_sort_order;           ///< the sort order of entries in the station gui - ascending or descending
 #ifdef ENABLE_NETWORK
 	uint16 network_chat_box_width;           ///< width of the chat box in pixels
 	uint8  network_chat_box_height;          ///< height of the chat box in lines
@@ -405,6 +411,30 @@ struct EconomySettings {
 	bool   allow_town_level_crossings;       ///< towns are allowed to build level crossings
 };
 
+struct LinkGraphSettings {
+	uint16 recalc_interval;                     ///< minimum interval (in days) between subsequent calculations of components in the same link graph
+	DistributionTypeByte distribution_pax;      ///< distribution type for passengers
+	DistributionTypeByte distribution_mail;     ///< distribution type for mail
+	DistributionTypeByte distribution_armoured; ///< distribution type for armoured cargo class
+	DistributionTypeByte distribution_default;  ///< distribution type for all other goods
+	uint8 accuracy;                             ///< accuracy when calculating things on the link graph. low accuracy => low running time
+	uint8 demand_size;                          ///< influence of supply ("station size") on the demand function
+	uint8 demand_distance;                      ///< influence of distance between stations on the demand function
+	uint8 short_path_saturation;                ///< percentage up to which short paths are saturated before saturating most capacious paths
+
+	FORCEINLINE DistributionType GetDistributionType(CargoID cargo) const {
+		if (IsCargoInClass(cargo, CC_PASSENGERS)) {
+			return this->distribution_pax;
+		} else if (IsCargoInClass(cargo, CC_MAIL)) {
+			return this->distribution_mail;
+		} else if (IsCargoInClass(cargo, CC_ARMOURED)) {
+			return this->distribution_armoured;
+		} else {
+			return this->distribution_default;
+		}
+	}
+};
+
 /** Settings related to stations. */
 struct StationSettings {
 	bool   modified_catchment;               ///< different-size catchment areas
@@ -443,6 +473,7 @@ struct GameSettings {
 	OrderSettings        order;              ///< settings related to orders
 	VehicleSettings      vehicle;            ///< options for vehicles
 	EconomySettings      economy;            ///< settings to change the economy
+	LinkGraphSettings    linkgraph;          ///< settings for link graph calculations
 	StationSettings      station;            ///< settings related to station management
 	LocaleSettings       locale;             ///< settings related to used currency/unit system in the current game
 };
diff --git a/src/ship_cmd.cpp b/src/ship_cmd.cpp
index 6eb03eb..55785f3 100644
--- a/src/ship_cmd.cpp
+++ b/src/ship_cmd.cpp
@@ -609,6 +609,7 @@ CommandCost CmdBuildShip(TileIndex tile, DoCommandFlag flags, const Engine *e, u
 		v->cargo_cap = svi->capacity;
 
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 		v->engine_type = e->index;
 
 		v->reliability = e->reliability;
diff --git a/src/smallmap_gui.cpp b/src/smallmap_gui.cpp
index 2fd8662..e575abf 100644
--- a/src/smallmap_gui.cpp
+++ b/src/smallmap_gui.cpp
@@ -14,45 +14,25 @@
 #include "industry.h"
 #include "station_map.h"
 #include "landscape.h"
-#include "window_gui.h"
 #include "tree_map.h"
 #include "viewport_func.h"
 #include "town.h"
-#include "blitter/factory.hpp"
 #include "tunnelbridge_map.h"
-#include "strings_func.h"
 #include "core/endian_func.hpp"
 #include "vehicle_base.h"
 #include "sound_func.h"
 #include "window_func.h"
 #include "company_base.h"
+#include "smallmap_gui.h"
 
 #include "table/strings.h"
 
-/** Widget numbers of the small map window. */
-enum SmallMapWindowWidgets {
-	SM_WIDGET_CAPTION,           ///< Caption widget.
-	SM_WIDGET_MAP_BORDER,        ///< Border around the smallmap.
-	SM_WIDGET_MAP,               ///< Panel containing the smallmap.
-	SM_WIDGET_LEGEND,            ///< Bottom panel to display smallmap legends.
-	SM_WIDGET_ZOOM_IN,           ///< Button to zoom in one step.
-	SM_WIDGET_ZOOM_OUT,          ///< Button to zoom out one step.
-	SM_WIDGET_CONTOUR,           ///< Button to select the contour view (height map).
-	SM_WIDGET_VEHICLES,          ///< Button to select the vehicles view.
-	SM_WIDGET_INDUSTRIES,        ///< Button to select the industries view.
-	SM_WIDGET_ROUTES,            ///< Button to select the routes view.
-	SM_WIDGET_VEGETATION,        ///< Button to select the vegetation view.
-	SM_WIDGET_OWNERS,            ///< Button to select the owners view.
-	SM_WIDGET_CENTERMAP,         ///< Button to move smallmap center to main window center.
-	SM_WIDGET_TOGGLETOWNNAME,    ///< Toggle button to display town names.
-	SM_WIDGET_SELECT_BUTTONS,    ///< Selection widget for the buttons present in some smallmap modes.
-	SM_WIDGET_ENABLE_ALL,        ///< Button to enable display of all legend entries.
-	SM_WIDGET_DISABLE_ALL,       ///< Button to disable display of all legend entries.
-	SM_WIDGET_SHOW_HEIGHT,       ///< Show heightmap toggle button.
-};
-
 static int _smallmap_industry_count; ///< Number of used industries
 static int _smallmap_company_count;  ///< Number of entries in the owner legend.
+static int _smallmap_cargo_count;    ///< number of cargos in the link stats legend
+
+/** Link stat colours shown in legenda. */
+static uint8 _linkstat_colours_in_legenda[] = {0, 1, 3, 5, 7, 9, 11};
 
 static const int NUM_NO_COMPANY_ENTRIES = 4; ///< Number of entries in the owner legend that are not companies.
 
@@ -77,18 +57,6 @@ static const int NUM_NO_COMPANY_ENTRIES = 4; ///< Number of entries in the owner
  */
 #define MS(a, b) {a, b, INVALID_INDUSTRYTYPE, 0, INVALID_COMPANY, true, false, true}
 
-/** Structure for holding relevant data for legends in small map */
-struct LegendAndColour {
-	uint8 colour;              ///< Colour of the item on the map.
-	StringID legend;           ///< String corresponding to the coloured item.
-	IndustryType type;         ///< Type of industry. Only valid for industry entries.
-	uint8 height;              ///< Height in tiles. Only valid for height legend entries.
-	CompanyID company;         ///< Company to display. Only valid for company entries of the owner legend.
-	bool show_on_map;          ///< For filtering industries, if \c true, industry is shown on the map in colour.
-	bool end;                  ///< This is the end of the list.
-	bool col_break;            ///< Perform a column break and go further at the next column.
-};
-
 /** Legend text giving the colours to look for on the minimap */
 static LegendAndColour _legend_land_contours[] = {
 	/* The colours for the following values are set at BuildLandLegend() based on each colour scheme. */
@@ -162,6 +130,8 @@ static LegendAndColour _legend_land_owners[NUM_NO_COMPANY_ENTRIES + MAX_COMPANIE
 #undef MOEND
 #undef MKEND
 
+/** Legend entries for the link stats view. */
+static LegendAndColour _legend_linkstats[NUM_CARGO + lengthof(_linkstat_colours_in_legenda) + 1];
 /**
  * Allow room for all industries, plus a terminator entry
  * This is required in order to have the indutry slots all filled up
@@ -205,10 +175,44 @@ void BuildIndustriesLegend()
 	_smallmap_industry_count = j;
 }
 
+/**
+ * Populate legend table for the link stat view.
+ */
+void BuildLinkStatsLegend()
+{
+	/* Clear the legend */
+	memset(_legend_linkstats, 0, sizeof(_legend_linkstats));
+
+	uint i = 0;
+	for (; i < _sorted_cargo_specs_size; ++i) {
+		const CargoSpec *cs = _sorted_cargo_specs[i];
+
+		_legend_linkstats[i].legend = cs->name;
+		_legend_linkstats[i].colour = cs->legend_colour;
+		_legend_linkstats[i].type = cs->Index();
+		_legend_linkstats[i].show_on_map = true;
+	}
+
+	_legend_linkstats[i].col_break = true;
+	_smallmap_cargo_count = i;
+
+	for (; i < _smallmap_cargo_count + lengthof(_linkstat_colours_in_legenda); ++i) {
+		_legend_linkstats[i].legend = STR_EMPTY;
+		_legend_linkstats[i].colour = LinkGraphOverlay::LINK_COLOURS[_linkstat_colours_in_legenda[i - _smallmap_cargo_count]];
+		_legend_linkstats[i].show_on_map = true;
+	}
+
+	_legend_linkstats[_smallmap_cargo_count].legend = STR_LINKGRAPH_LEGEND_UNUSED;
+	_legend_linkstats[i - 1].legend = STR_LINKGRAPH_LEGEND_OVERLOADED;
+	_legend_linkstats[(_smallmap_cargo_count + i - 1) / 2].legend = STR_LINKGRAPH_LEGEND_SATURATED;
+	_legend_linkstats[i].end = true;
+}
+
 static const LegendAndColour * const _legend_table[] = {
 	_legend_land_contours,
 	_legend_vehicles,
 	_legend_from_industries,
+	_legend_linkstats,
 	_legend_routes,
 	_legend_vegetation,
 	_legend_land_owners,
@@ -482,6 +486,17 @@ static inline uint32 GetSmallMapRoutesPixels(TileIndex tile, TileType t)
 	return ApplyMask(cs->default_colour, &_smallmap_contours_andor[t]);
 }
 
+/**
+ * Return the colour a tile would be displayed with in the small map in mode "link stats".
+ *
+ * @param tile The tile of which we would like to get the colour.
+ * @param t    Effective tile type of the tile (see #GetEffectiveTileType).
+ * @return The colour of tile in the small map in mode "link stats"
+ */
+static inline uint32 GetSmallMapLinkStatsPixels(TileIndex tile, TileType t)
+{
+	return _smallmap_show_heightmap ? GetSmallMapContoursPixels(tile, t) : GetSmallMapRoutesPixels(tile, t);
+}
 
 static const uint32 _vegetation_clear_bits[] = {
 	MKCOLOUR(0x54545454), ///< full grass
@@ -558,991 +573,981 @@ static const byte _vehicle_type_colours[6] = {
 	184, 191, 152, 15, 215, 184
 };
 
+/**
+ * Remap tile to location on this smallmap.
+ * @param tile_x X coordinate of the tile.
+ * @param tile_y Y coordinate of the tile.
+ * @return Position to draw on.
+ */
+FORCEINLINE Point SmallMapWindow::RemapTile(int tile_x, int tile_y) const
+{
+	int x_offset = tile_x - this->scroll_x / (int)TILE_SIZE;
+	int y_offset = tile_y - this->scroll_y / (int)TILE_SIZE;
 
-/** Class managing the smallmap window. */
-class SmallMapWindow : public Window {
-	/** Types of legends in the #SM_WIDGET_LEGEND widget. */
-	enum SmallMapType {
-		SMT_CONTOUR,
-		SMT_VEHICLES,
-		SMT_INDUSTRY,
-		SMT_ROUTES,
-		SMT_VEGETATION,
-		SMT_OWNER,
-	};
-
-	/** Available kinds of zoomlevel changes. */
-	enum ZoomLevelChange {
-		ZLC_INITIALIZE, ///< Initialize zoom level.
-		ZLC_ZOOM_OUT,   ///< Zoom out.
-		ZLC_ZOOM_IN,    ///< Zoom in.
-	};
-
-	static SmallMapType map_type; ///< Currently displayed legends.
-	static bool show_towns;       ///< Display town names in the smallmap.
-
-	static const uint LEGEND_BLOB_WIDTH = 8;              ///< Width of the coloured blob in front of a line text in the #SM_WIDGET_LEGEND widget.
-	static const uint INDUSTRY_MIN_NUMBER_OF_COLUMNS = 2; ///< Minimal number of columns in the #SM_WIDGET_LEGEND widget for the #SMT_INDUSTRY legend.
-	uint min_number_of_fixed_rows; ///< Minimal number of rows in the legends for the fixed layouts only (all except #SMT_INDUSTRY).
-	uint column_width;             ///< Width of a column in the #SM_WIDGET_LEGEND widget.
-
-	int32 scroll_x;  ///< Horizontal world coordinate of the base tile left of the top-left corner of the smallmap display.
-	int32 scroll_y;  ///< Vertical world coordinate of the base tile left of the top-left corner of the smallmap display.
-	int32 subscroll; ///< Number of pixels (0..3) between the right end of the base tile and the pixel at the top-left corner of the smallmap display.
-	int zoom;        ///< Zoom level. Bigger number means more zoom-out (further away).
-
-	static const uint8 FORCE_REFRESH_PERIOD = 0x1F; ///< map is redrawn after that many ticks
-	uint8 refresh; ///< refresh counter, zeroed every FORCE_REFRESH_PERIOD ticks
-
-	/**
-	 * Remap tile to location on this smallmap.
-	 * @param tile_x X coordinate of the tile.
-	 * @param tile_y Y coordinate of the tile.
-	 * @return Position to draw on.
-	 */
-	FORCEINLINE Point RemapTile(int tile_x, int tile_y) const
-	{
-		int x_offset = tile_x - this->scroll_x / (int)TILE_SIZE;
-		int y_offset = tile_y - this->scroll_y / (int)TILE_SIZE;
-
-		if (this->zoom == 1) return RemapCoords(x_offset, y_offset, 0);
+	if (this->zoom == 1) return RemapCoords(x_offset, y_offset, 0);
 
-		/* For negative offsets, round towards -inf. */
-		if (x_offset < 0) x_offset -= this->zoom - 1;
-		if (y_offset < 0) y_offset -= this->zoom - 1;
+	/* For negative offsets, round towards -inf. */
+	if (x_offset < 0) x_offset -= this->zoom - 1;
+	if (y_offset < 0) y_offset -= this->zoom - 1;
 
-		return RemapCoords(x_offset / this->zoom, y_offset / this->zoom, 0);
-	}
+	return RemapCoords(x_offset / this->zoom, y_offset / this->zoom, 0);
+}
 
-	/**
-	 * Determine the tile relative to the base tile of the smallmap, and the pixel position at
-	 * that tile for a point in the smallmap.
-	 * @param px       Horizontal coordinate of the pixel.
-	 * @param py       Vertical coordinate of the pixel.
-	 * @param sub[out] Pixel position at the tile (0..3).
-	 * @param add_sub  Add current #subscroll to the position.
-	 * @return Tile being displayed at the given position relative to #scroll_x and #scroll_y.
-	 * @note The #subscroll offset is already accounted for.
-	 */
-	FORCEINLINE Point PixelToTile(int px, int py, int *sub, bool add_sub = true) const
-	{
-		if (add_sub) px += this->subscroll;  // Total horizontal offset.
+/**
+ * Determine the tile relative to the base tile of the smallmap, and the pixel position at
+ * that tile for a point in the smallmap.
+ * @param px       Horizontal coordinate of the pixel.
+ * @param py       Vertical coordinate of the pixel.
+ * @param sub[out] Pixel position at the tile (0..3).
+ * @param add_sub  Add current #subscroll to the position.
+ * @return Tile being displayed at the given position relative to #scroll_x and #scroll_y.
+ * @note The #subscroll offset is already accounted for.
+ */
+FORCEINLINE Point SmallMapWindow::PixelToTile(int px, int py, int *sub, bool add_sub) const
+{
+	if (add_sub) px += this->subscroll;  // Total horizontal offset.
 
-		/* For each two rows down, add a x and a y tile, and
-		 * For each four pixels to the right, move a tile to the right. */
-		Point pt = {((py >> 1) - (px >> 2)) * this->zoom, ((py >> 1) + (px >> 2)) * this->zoom};
-		px &= 3;
+	/* For each two rows down, add a x and a y tile, and
+	 * For each four pixels to the right, move a tile to the right. */
+	Point pt = {((py >> 1) - (px >> 2)) * this->zoom, ((py >> 1) + (px >> 2)) * this->zoom};
+	px &= 3;
 
-		if (py & 1) { // Odd number of rows, handle the 2 pixel shift.
-			if (px < 2) {
-				pt.x += this->zoom;
-				px += 2;
-			} else {
-				pt.y += this->zoom;
-				px -= 2;
-			}
+	if (py & 1) { // Odd number of rows, handle the 2 pixel shift.
+		if (px < 2) {
+			pt.x += this->zoom;
+			px += 2;
+		} else {
+			pt.y += this->zoom;
+			px -= 2;
 		}
-
-		*sub = px;
-		return pt;
 	}
 
-	/**
-	 * Compute base parameters of the smallmap such that tile (\a tx, \a ty) starts at pixel (\a x, \a y).
-	 * @param tx        Tile x coordinate.
-	 * @param ty        Tile y coordinate.
-	 * @param x         Non-negative horizontal position in the display where the tile starts.
-	 * @param y         Non-negative vertical position in the display where the tile starts.
-	 * @param sub [out] Value of #subscroll needed.
-	 * @return #scroll_x, #scroll_y values.
-	 */
-	Point ComputeScroll(int tx, int ty, int x, int y, int *sub)
-	{
-		assert(x >= 0 && y >= 0);
-
-		int new_sub;
-		Point tile_xy = PixelToTile(x, y, &new_sub, false);
-		tx -= tile_xy.x;
-		ty -= tile_xy.y;
-
-		Point scroll;
-		if (new_sub == 0) {
-			*sub = 0;
-			scroll.x = (tx + this->zoom) * TILE_SIZE;
-			scroll.y = (ty - this->zoom) * TILE_SIZE;
-		} else {
-			*sub = 4 - new_sub;
-			scroll.x = (tx + 2 * this->zoom) * TILE_SIZE;
-			scroll.y = (ty - 2 * this->zoom) * TILE_SIZE;
-		}
-		return scroll;
+	*sub = px;
+	return pt;
+}
+
+/**
+ * Compute base parameters of the smallmap such that tile (\a tx, \a ty) starts at pixel (\a x, \a y).
+ * @param tx        Tile x coordinate.
+ * @param ty        Tile y coordinate.
+ * @param x         Non-negative horizontal position in the display where the tile starts.
+ * @param y         Non-negative vertical position in the display where the tile starts.
+ * @param sub [out] Value of #subscroll needed.
+ * @return #scroll_x, #scroll_y values.
+ */
+Point SmallMapWindow::ComputeScroll(int tx, int ty, int x, int y, int *sub)
+{
+	assert(x >= 0 && y >= 0);
+
+	int new_sub;
+	Point tile_xy = PixelToTile(x, y, &new_sub, false);
+	tx -= tile_xy.x;
+	ty -= tile_xy.y;
+
+	Point scroll;
+	if (new_sub == 0) {
+		*sub = 0;
+		scroll.x = (tx + this->zoom) * TILE_SIZE;
+		scroll.y = (ty - this->zoom) * TILE_SIZE;
+	} else {
+		*sub = 4 - new_sub;
+		scroll.x = (tx + 2 * this->zoom) * TILE_SIZE;
+		scroll.y = (ty - 2 * this->zoom) * TILE_SIZE;
 	}
+	return scroll;
+}
 
-	/**
-	 * Initialize or change the zoom level.
-	 * @param change  Way to change the zoom level.
-	 * @param zoom_pt Position to keep fixed while zooming.
-	 * @pre \c *zoom_pt should contain a point in the smallmap display when zooming in or out.
-	 */
-	void SetZoomLevel(ZoomLevelChange change, const Point *zoom_pt)
-	{
-		static const int zoomlevels[] = {1, 2, 4, 6, 8}; // Available zoom levels. Bigger number means more zoom-out (further away).
-		static const int MIN_ZOOM_INDEX = 0;
-		static const int MAX_ZOOM_INDEX = lengthof(zoomlevels) - 1;
-
-		int new_index, cur_index, sub;
-		Point tile;
-		switch (change) {
-			case ZLC_INITIALIZE:
-				cur_index = - 1; // Definitely different from new_index.
-				new_index = MIN_ZOOM_INDEX;
-				break;
+/**
+ * Initialize or change the zoom level.
+ * @param change  Way to change the zoom level.
+ * @param zoom_pt Position to keep fixed while zooming.
+ * @pre \c *zoom_pt should contain a point in the smallmap display when zooming in or out.
+ */
+void SmallMapWindow::SetZoomLevel(ZoomLevelChange change, const Point *zoom_pt)
+{
+	static const int zoomlevels[] = {1, 2, 4, 6, 8}; // Available zoom levels. Bigger number means more zoom-out (further away).
+	static const int MIN_ZOOM_INDEX = 0;
+	static const int MAX_ZOOM_INDEX = lengthof(zoomlevels) - 1;
+
+	int new_index, cur_index, sub;
+	Point tile;
+	switch (change) {
+		case ZLC_INITIALIZE:
+			cur_index = - 1; // Definitely different from new_index.
+			new_index = MIN_ZOOM_INDEX;
+			break;
+
+		case ZLC_ZOOM_IN:
+		case ZLC_ZOOM_OUT:
+			for (cur_index = MIN_ZOOM_INDEX; cur_index <= MAX_ZOOM_INDEX; cur_index++) {
+				if (this->zoom == zoomlevels[cur_index]) break;
+			}
+			assert(cur_index <= MAX_ZOOM_INDEX);
 
-			case ZLC_ZOOM_IN:
-			case ZLC_ZOOM_OUT:
-				for (cur_index = MIN_ZOOM_INDEX; cur_index <= MAX_ZOOM_INDEX; cur_index++) {
-					if (this->zoom == zoomlevels[cur_index]) break;
-				}
-				assert(cur_index <= MAX_ZOOM_INDEX);
+			tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
+			new_index = Clamp(cur_index + ((change == ZLC_ZOOM_IN) ? -1 : 1), MIN_ZOOM_INDEX, MAX_ZOOM_INDEX);
+			break;
 
-				tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
-				new_index = Clamp(cur_index + ((change == ZLC_ZOOM_IN) ? -1 : 1), MIN_ZOOM_INDEX, MAX_ZOOM_INDEX);
-				break;
+		default: NOT_REACHED();
+	}
 
-			default: NOT_REACHED();
+	if (new_index != cur_index) {
+		this->zoom = zoomlevels[new_index];
+		if (cur_index >= 0) {
+			Point new_tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
+			this->SetNewScroll(this->scroll_x + (tile.x - new_tile.x) * TILE_SIZE,
+					this->scroll_y + (tile.y - new_tile.y) * TILE_SIZE, sub);
+		} else if (this->map_type == SMT_LINKSTATS) {
+			this->overlay.RebuildCache();
 		}
+		this->SetWidgetDisabledState(SM_WIDGET_ZOOM_IN,  this->zoom == zoomlevels[MIN_ZOOM_INDEX]);
+		this->SetWidgetDisabledState(SM_WIDGET_ZOOM_OUT, this->zoom == zoomlevels[MAX_ZOOM_INDEX]);
+		this->SetDirty();
+	}
+}
 
-		if (new_index != cur_index) {
-			this->zoom = zoomlevels[new_index];
-			if (cur_index >= 0) {
-				Point new_tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
-				this->SetNewScroll(this->scroll_x + (tile.x - new_tile.x) * TILE_SIZE,
-						this->scroll_y + (tile.y - new_tile.y) * TILE_SIZE, sub);
-			}
-			this->SetWidgetDisabledState(SM_WIDGET_ZOOM_IN,  this->zoom == zoomlevels[MIN_ZOOM_INDEX]);
-			this->SetWidgetDisabledState(SM_WIDGET_ZOOM_OUT, this->zoom == zoomlevels[MAX_ZOOM_INDEX]);
-			this->SetDirty();
+/**
+ * Decide which colours to show to the user for a group of tiles.
+ * @param ta Tile area to investigate.
+ * @return Colours to display.
+ */
+inline uint32 SmallMapWindow::GetTileColours(const TileArea &ta) const
+{
+	int importance = 0;
+	TileIndex tile = INVALID_TILE; // Position of the most important tile.
+	TileType et = MP_VOID;         // Effective tile type at that position.
+
+	TILE_AREA_LOOP(ti, ta) {
+		TileType ttype = GetEffectiveTileType(ti);
+		if (_tiletype_importance[ttype] > importance) {
+			importance = _tiletype_importance[ttype];
+			tile = ti;
+			et = ttype;
 		}
 	}
 
-	/**
-	 * Decide which colours to show to the user for a group of tiles.
-	 * @param ta Tile area to investigate.
-	 * @return Colours to display.
-	 */
-	inline uint32 GetTileColours(const TileArea &ta) const
-	{
-		int importance = 0;
-		TileIndex tile = INVALID_TILE; // Position of the most important tile.
-		TileType et = MP_VOID;         // Effective tile type at that position.
-
-		TILE_AREA_LOOP(ti, ta) {
-			TileType ttype = GetEffectiveTileType(ti);
-			if (_tiletype_importance[ttype] > importance) {
-				importance = _tiletype_importance[ttype];
-				tile = ti;
-				et = ttype;
-			}
-		}
+	switch (this->map_type) {
+		case SMT_CONTOUR:
+			return GetSmallMapContoursPixels(tile, et);
 
-		switch (this->map_type) {
-			case SMT_CONTOUR:
-				return GetSmallMapContoursPixels(tile, et);
+		case SMT_VEHICLES:
+			return GetSmallMapVehiclesPixels(tile, et);
 
-			case SMT_VEHICLES:
-				return GetSmallMapVehiclesPixels(tile, et);
+		case SMT_INDUSTRY:
+			return GetSmallMapIndustriesPixels(tile, et);
 
-			case SMT_INDUSTRY:
-				return GetSmallMapIndustriesPixels(tile, et);
+		case SMT_LINKSTATS:
+			return GetSmallMapLinkStatsPixels(tile, et);
 
-			case SMT_ROUTES:
-				return GetSmallMapRoutesPixels(tile, et);
+		case SMT_ROUTES:
+			return GetSmallMapRoutesPixels(tile, et);
 
-			case SMT_VEGETATION:
-				return GetSmallMapVegetationPixels(tile, et);
+		case SMT_VEGETATION:
+			return GetSmallMapVegetationPixels(tile, et);
 
-			case SMT_OWNER:
-				return GetSmallMapOwnerPixels(tile, et);
+		case SMT_OWNER:
+			return GetSmallMapOwnerPixels(tile, et);
 
-			default: NOT_REACHED();
-		}
+		default: NOT_REACHED();
 	}
+}
 
-	/**
-	 * Draws one column of tiles of the small map in a certain mode onto the screen buffer, skipping the shifted rows in between.
-	 *
-	 * @param dst Pointer to a part of the screen buffer to write to.
-	 * @param xc The X coordinate of the first tile in the column.
-	 * @param yc The Y coordinate of the first tile in the column
-	 * @param pitch Number of pixels to advance in the screen buffer each time a pixel is written.
-	 * @param reps Number of lines to draw
-	 * @param start_pos Position of first pixel to draw.
-	 * @param end_pos Position of last pixel to draw (exclusive).
-	 * @param blitter current blitter
-	 * @note If pixel position is below \c 0, skip drawing.
-	 * @see GetSmallMapPixels(TileIndex)
-	 */
-	void DrawSmallMapColumn(void *dst, uint xc, uint yc, int pitch, int reps, int start_pos, int end_pos, Blitter *blitter) const
-	{
-		void *dst_ptr_abs_end = blitter->MoveTo(_screen.dst_ptr, 0, _screen.height);
-		uint min_xy = _settings_game.construction.freeform_edges ? 1 : 0;
-
-		do {
-			/* Check if the tile (xc,yc) is within the map range */
-			if (xc >= MapMaxX() || yc >= MapMaxY()) continue;
-
-			/* Check if the dst pointer points to a pixel inside the screen buffer */
-			if (dst < _screen.dst_ptr) continue;
-			if (dst >= dst_ptr_abs_end) continue;
-
-			/* Construct tilearea covered by (xc, yc, xc + this->zoom, yc + this->zoom) such that it is within min_xy limits. */
-			TileArea ta;
-			if (min_xy == 1 && (xc == 0 || yc == 0)) {
-				if (this->zoom == 1) continue; // The tile area is empty, don't draw anything.
+/**
+ * Draws one column of tiles of the small map in a certain mode onto the screen buffer, skipping the shifted rows in between.
+ *
+ * @param dst Pointer to a part of the screen buffer to write to.
+ * @param xc The X coordinate of the first tile in the column.
+ * @param yc The Y coordinate of the first tile in the column
+ * @param pitch Number of pixels to advance in the screen buffer each time a pixel is written.
+ * @param reps Number of lines to draw
+ * @param start_pos Position of first pixel to draw.
+ * @param end_pos Position of last pixel to draw (exclusive).
+ * @param blitter current blitter
+ * @note If pixel position is below \c 0, skip drawing.
+ * @see GetSmallMapPixels(TileIndex)
+ */
+void SmallMapWindow::DrawSmallMapColumn(void *dst, uint xc, uint yc, int pitch, int reps, int start_pos, int end_pos, Blitter *blitter) const
+{
+	void *dst_ptr_abs_end = blitter->MoveTo(_screen.dst_ptr, 0, _screen.height);
+	uint min_xy = _settings_game.construction.freeform_edges ? 1 : 0;
 
-				ta = TileArea(TileXY(max(min_xy, xc), max(min_xy, yc)), this->zoom - (xc == 0), this->zoom - (yc == 0));
-			} else {
-				ta = TileArea(TileXY(xc, yc), this->zoom, this->zoom);
-			}
-			ta.ClampToMap(); // Clamp to map boundaries (may contain MP_VOID tiles!).
-
-			uint32 val = this->GetTileColours(ta);
-			uint8 *val8 = (uint8 *)&val;
-			int idx = max(0, -start_pos);
-			for (int pos = max(0, start_pos); pos < end_pos; pos++) {
-				blitter->SetPixel(dst, idx, 0, val8[idx]);
-				idx++;
-			}
-		/* Switch to next tile in the column */
-		} while (xc += this->zoom, yc += this->zoom, dst = blitter->MoveTo(dst, pitch, 0), --reps != 0);
-	}
+	do {
+		/* Check if the tile (xc,yc) is within the map range */
+		if (xc >= MapMaxX() || yc >= MapMaxY()) continue;
 
-	/**
-	 * Adds vehicles to the smallmap.
-	 * @param dpi the part of the smallmap to be drawn into
-	 * @param blitter current blitter
-	 */
-	void DrawVehicles(const DrawPixelInfo *dpi, Blitter *blitter) const
-	{
-		const Vehicle *v;
-		FOR_ALL_VEHICLES(v) {
-			if (v->type == VEH_EFFECT) continue;
-			if (v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) continue;
-
-			/* Remap into flat coordinates. */
-			Point pt = this->RemapTile(v->x_pos / TILE_SIZE, v->y_pos / TILE_SIZE);
-
-			int y = pt.y - dpi->top;
-			if (!IsInsideMM(y, 0, dpi->height)) continue; // y is out of bounds.
-
-			bool skip = false; // Default is to draw both pixels.
-			int x = pt.x - this->subscroll - 3 - dpi->left; // Offset X coordinate.
-			if (x < 0) {
-				/* if x+1 is 0, that means we're on the very left edge,
-				 * and should thus only draw a single pixel */
-				if (++x != 0) continue;
-				skip = true;
-			} else if (x >= dpi->width - 1) {
-				/* Check if we're at the very right edge, and if so draw only a single pixel */
-				if (x != dpi->width - 1) continue;
-				skip = true;
-			}
+		/* Check if the dst pointer points to a pixel inside the screen buffer */
+		if (dst < _screen.dst_ptr) continue;
+		if (dst >= dst_ptr_abs_end) continue;
 
-			/* Calculate pointer to pixel and the colour */
-			byte colour = (this->map_type == SMT_VEHICLES) ? _vehicle_type_colours[v->type] : 0xF;
+		/* Construct tilearea covered by (xc, yc, xc + this->zoom, yc + this->zoom) such that it is within min_xy limits. */
+		TileArea ta;
+		if (min_xy == 1 && (xc == 0 || yc == 0)) {
+			if (this->zoom == 1) continue; // The tile area is empty, don't draw anything.
 
-			/* And draw either one or two pixels depending on clipping */
-			blitter->SetPixel(dpi->dst_ptr, x, y, colour);
-			if (!skip) blitter->SetPixel(dpi->dst_ptr, x + 1, y, colour);
+			ta = TileArea(TileXY(max(min_xy, xc), max(min_xy, yc)), this->zoom - (xc == 0), this->zoom - (yc == 0));
+		} else {
+			ta = TileArea(TileXY(xc, yc), this->zoom, this->zoom);
 		}
-	}
+		ta.ClampToMap(); // Clamp to map boundaries (may contain MP_VOID tiles!).
+
+		uint32 val = this->GetTileColours(ta);
+		uint8 *val8 = (uint8 *)&val;
+		int idx = max(0, -start_pos);
+		for (int pos = max(0, start_pos); pos < end_pos; pos++) {
+			blitter->SetPixel(dst, idx, 0, val8[idx]);
+			idx++;
+		}
+	/* Switch to next tile in the column */
+	} while (xc += this->zoom, yc += this->zoom, dst = blitter->MoveTo(dst, pitch, 0), --reps != 0);
+}
 
-	/**
-	 * Adds town names to the smallmap.
-	 * @param dpi the part of the smallmap to be drawn into
-	 */
-	void DrawTowns(const DrawPixelInfo *dpi) const
-	{
-		const Town *t;
-		FOR_ALL_TOWNS(t) {
-			/* Remap the town coordinate */
-			Point pt = this->RemapTile(TileX(t->xy), TileY(t->xy));
-			int x = pt.x - this->subscroll - (t->sign.width_small >> 1);
-			int y = pt.y;
-
-			/* Check if the town sign is within bounds */
-			if (x + t->sign.width_small > dpi->left &&
-					x < dpi->left + dpi->width &&
-					y + FONT_HEIGHT_SMALL > dpi->top &&
-					y < dpi->top + dpi->height) {
-				/* And draw it. */
-				SetDParam(0, t->index);
-				DrawString(x, x + t->sign.width_small, y, STR_SMALLMAP_TOWN);
-			}
+/**
+ * Adds vehicles to the smallmap.
+ * @param dpi the part of the smallmap to be drawn into
+ * @param blitter current blitter
+ */
+void SmallMapWindow::DrawVehicles(const DrawPixelInfo *dpi, Blitter *blitter) const
+{
+	const Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		if (v->type == VEH_EFFECT) continue;
+		if (v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) continue;
+
+		/* Remap into flat coordinates. */
+		Point pt = this->RemapTile(v->x_pos / TILE_SIZE, v->y_pos / TILE_SIZE);
+
+		int y = pt.y - dpi->top;
+		if (!IsInsideMM(y, 0, dpi->height)) continue; // y is out of bounds.
+
+		bool skip = false; // Default is to draw both pixels.
+		int x = pt.x - this->subscroll - 3 - dpi->left; // Offset X coordinate.
+		if (x < 0) {
+			/* if x+1 is 0, that means we're on the very left edge,
+			 * and should thus only draw a single pixel */
+			if (++x != 0) continue;
+			skip = true;
+		} else if (x >= dpi->width - 1) {
+			/* Check if we're at the very right edge, and if so draw only a single pixel */
+			if (x != dpi->width - 1) continue;
+			skip = true;
 		}
-	}
 
-	/**
-	 * Draws vertical part of map indicator
-	 * @param x X coord of left/right border of main viewport
-	 * @param y Y coord of top border of main viewport
-	 * @param y2 Y coord of bottom border of main viewport
-	 */
-	static inline void DrawVertMapIndicator(int x, int y, int y2)
-	{
-		GfxFillRect(x, y,      x, y + 3, 69);
-		GfxFillRect(x, y2 - 3, x, y2,    69);
-	}
+		/* Calculate pointer to pixel and the colour */
+		byte colour = (this->map_type == SMT_VEHICLES) ? _vehicle_type_colours[v->type] : 0xF;
 
-	/**
-	 * Draws horizontal part of map indicator
-	 * @param x X coord of left border of main viewport
-	 * @param x2 X coord of right border of main viewport
-	 * @param y Y coord of top/bottom border of main viewport
-	 */
-	static inline void DrawHorizMapIndicator(int x, int x2, int y)
-	{
-		GfxFillRect(x,      y, x + 3, y, 69);
-		GfxFillRect(x2 - 3, y, x2,    y, 69);
+		/* And draw either one or two pixels depending on clipping */
+		blitter->SetPixel(dpi->dst_ptr, x, y, colour);
+		if (!skip) blitter->SetPixel(dpi->dst_ptr, x + 1, y, colour);
 	}
+}
 
-	/**
-	 * Adds map indicators to the smallmap.
-	 */
-	void DrawMapIndicators() const
-	{
-		/* Find main viewport. */
-		const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
+/**
+ * Adds town names to the smallmap.
+ * @param dpi the part of the smallmap to be drawn into
+ */
+void SmallMapWindow::DrawTowns(const DrawPixelInfo *dpi) const
+{
+	const Town *t;
+	FOR_ALL_TOWNS(t) {
+		/* Remap the town coordinate */
+		Point pt = this->RemapTile(TileX(t->xy), TileY(t->xy));
+		int x = pt.x - this->subscroll - (t->sign.width_small >> 1);
+		int y = pt.y;
+
+		/* Check if the town sign is within bounds */
+		if (x + t->sign.width_small > dpi->left &&
+				x < dpi->left + dpi->width &&
+				y + FONT_HEIGHT_SMALL > dpi->top &&
+				y < dpi->top + dpi->height) {
+			/* And draw it. */
+			SetDParam(0, t->index);
+			DrawString(x, x + t->sign.width_small, y, STR_SMALLMAP_TOWN);
+		}
+	}
+}
 
-		Point tile = InverseRemapCoords(vp->virtual_left, vp->virtual_top);
-		Point tl = this->RemapTile(tile.x >> 4, tile.y >> 4);
-		tl.x -= this->subscroll;
+/**
+ * Adds map indicators to the smallmap.
+ */
+void SmallMapWindow::DrawMapIndicators() const
+{
+	/* Find main viewport. */
+	const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
 
-		tile = InverseRemapCoords(vp->virtual_left + vp->virtual_width, vp->virtual_top + vp->virtual_height);
-		Point br = this->RemapTile(tile.x >> 4, tile.y >> 4);
-		br.x -= this->subscroll;
+	Point tile = InverseRemapCoords(vp->virtual_left, vp->virtual_top);
+	Point tl = this->RemapTile(tile.x >> 4, tile.y >> 4);
+	tl.x -= this->subscroll;
 
-		SmallMapWindow::DrawVertMapIndicator(tl.x, tl.y, br.y);
-		SmallMapWindow::DrawVertMapIndicator(br.x, tl.y, br.y);
+	tile = InverseRemapCoords(vp->virtual_left + vp->virtual_width, vp->virtual_top + vp->virtual_height);
+	Point br = this->RemapTile(tile.x >> 4, tile.y >> 4);
+	br.x -= this->subscroll;
 
-		SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, tl.y);
-		SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, br.y);
-	}
+	SmallMapWindow::DrawVertMapIndicator(tl.x, tl.y, br.y);
+	SmallMapWindow::DrawVertMapIndicator(br.x, tl.y, br.y);
 
-	/**
-	 * Draws the small map.
-	 *
-	 * Basically, the small map is draw column of pixels by column of pixels. The pixels
-	 * are drawn directly into the screen buffer. The final map is drawn in multiple passes.
-	 * The passes are:
-	 * <ol><li>The colours of tiles in the different modes.</li>
-	 * <li>Town names (optional)</li></ol>
-	 *
-	 * @param dpi pointer to pixel to write onto
-	 */
-	void DrawSmallMap(DrawPixelInfo *dpi) const
-	{
-		Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
-		DrawPixelInfo *old_dpi;
-
-		old_dpi = _cur_dpi;
-		_cur_dpi = dpi;
-
-		/* Clear it */
-		GfxFillRect(dpi->left, dpi->top, dpi->left + dpi->width - 1, dpi->top + dpi->height - 1, 0);
-
-		/* Which tile is displayed at (dpi->left, dpi->top)? */
-		int dx;
-		Point tile = this->PixelToTile(dpi->left, dpi->top, &dx);
-		int tile_x = this->scroll_x / (int)TILE_SIZE + tile.x;
-		int tile_y = this->scroll_y / (int)TILE_SIZE + tile.y;
-
-		void *ptr = blitter->MoveTo(dpi->dst_ptr, -dx - 4, 0);
-		int x = - dx - 4;
-		int y = 0;
-
-		for (;;) {
-			/* Distance from left edge */
-			if (x >= -3) {
-				if (x >= dpi->width) break; // Exit the loop.
-
-				int end_pos = min(dpi->width, x + 4);
-				int reps = (dpi->height - y + 1) / 2; // Number of lines.
-				if (reps > 0) {
-					this->DrawSmallMapColumn(ptr, tile_x, tile_y, dpi->pitch * 2, reps, x, end_pos, blitter);
-				}
-			}
+	SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, tl.y);
+	SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, br.y);
+}
 
-			if (y == 0) {
-				tile_y += this->zoom;
-				y++;
-				ptr = blitter->MoveTo(ptr, 0, 1);
-			} else {
-				tile_x -= this->zoom;
-				y--;
-				ptr = blitter->MoveTo(ptr, 0, -1);
+/**
+ * Draws the small map.
+ *
+ * Basically, the small map is draw column of pixels by column of pixels. The pixels
+ * are drawn directly into the screen buffer. The final map is drawn in multiple passes.
+ * The passes are:
+ * <ol><li>The colours of tiles in the different modes.</li>
+ * <li>Town names (optional)</li></ol>
+ *
+ * @param dpi pointer to pixel to write onto
+ */
+void SmallMapWindow::DrawSmallMap(DrawPixelInfo *dpi) const
+{
+	Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
+	DrawPixelInfo *old_dpi;
+
+	old_dpi = _cur_dpi;
+	_cur_dpi = dpi;
+
+	/* Clear it */
+	GfxFillRect(dpi->left, dpi->top, dpi->left + dpi->width - 1, dpi->top + dpi->height - 1, 0);
+
+	/* Which tile is displayed at (dpi->left, dpi->top)? */
+	int dx;
+	Point tile = this->PixelToTile(dpi->left, dpi->top, &dx);
+	int tile_x = this->scroll_x / (int)TILE_SIZE + tile.x;
+	int tile_y = this->scroll_y / (int)TILE_SIZE + tile.y;
+
+	void *ptr = blitter->MoveTo(dpi->dst_ptr, -dx - 4, 0);
+	int x = - dx - 4;
+	int y = 0;
+
+	for (;;) {
+		/* Distance from left edge */
+		if (x >= -3) {
+			if (x >= dpi->width) break; // Exit the loop.
+
+			int end_pos = min(dpi->width, x + 4);
+			int reps = (dpi->height - y + 1) / 2; // Number of lines.
+			if (reps > 0) {
+				this->DrawSmallMapColumn(ptr, tile_x, tile_y, dpi->pitch * 2, reps, x, end_pos, blitter);
 			}
-			ptr = blitter->MoveTo(ptr, 2, 0);
-			x += 2;
 		}
 
-		/* Draw vehicles */
-		if (this->map_type == SMT_CONTOUR || this->map_type == SMT_VEHICLES) this->DrawVehicles(dpi, blitter);
-
-		/* Draw town names */
-		if (this->show_towns) this->DrawTowns(dpi);
-
-		/* Draw map indicators */
-		this->DrawMapIndicators();
-
-		_cur_dpi = old_dpi;
+		if (y == 0) {
+			tile_y += this->zoom;
+			y++;
+			ptr = blitter->MoveTo(ptr, 0, 1);
+		} else {
+			tile_x -= this->zoom;
+			y--;
+			ptr = blitter->MoveTo(ptr, 0, -1);
+		}
+		ptr = blitter->MoveTo(ptr, 2, 0);
+		x += 2;
 	}
 
-	/**
-	 * Function to set up widgets depending on the information being shown on the smallmap.
-	 */
-	void SetupWidgetData()
-	{
-		StringID legend_tooltip;
-		StringID enable_all_tooltip;
-		StringID disable_all_tooltip;
-		int plane;
-		switch (this->map_type) {
-			case SMT_INDUSTRY:
-				legend_tooltip = STR_SMALLMAP_TOOLTIP_INDUSTRY_SELECTION;
-				enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_INDUSTRIES;
-				disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_INDUSTRIES;
-				plane = 0;
-				break;
+	/* Draw vehicles */
+	if (this->map_type == SMT_CONTOUR || this->map_type == SMT_VEHICLES) this->DrawVehicles(dpi, blitter);
 
-			case SMT_OWNER:
-				legend_tooltip = STR_SMALLMAP_TOOLTIP_COMPANY_SELECTION;
-				enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_COMPANIES;
-				disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_COMPANIES;
-				plane = 0;
-				break;
+	/* Draw link stat overlay */
+	if (this->map_type == SMT_LINKSTATS) this->overlay.Draw(dpi);
 
-			default:
-				legend_tooltip = STR_NULL;
-				enable_all_tooltip = STR_NULL;
-				disable_all_tooltip = STR_NULL;
-				plane = 1;
-				break;
-		}
+	/* Draw town names */
+	if (this->show_towns) this->DrawTowns(dpi);
 
-		this->GetWidget<NWidgetCore>(SM_WIDGET_LEGEND)->SetDataTip(STR_NULL, legend_tooltip);
-		this->GetWidget<NWidgetCore>(SM_WIDGET_ENABLE_ALL)->SetDataTip(STR_SMALLMAP_ENABLE_ALL, enable_all_tooltip);
-		this->GetWidget<NWidgetCore>(SM_WIDGET_DISABLE_ALL)->SetDataTip(STR_SMALLMAP_DISABLE_ALL, disable_all_tooltip);
-		this->GetWidget<NWidgetStacked>(SM_WIDGET_SELECT_BUTTONS)->SetDisplayedPlane(plane);
-	}
+	/* Draw map indicators */
+	this->DrawMapIndicators();
 
-public:
-	uint min_number_of_columns;    ///< Minimal number of columns in legends.
+	_cur_dpi = old_dpi;
+}
 
-	SmallMapWindow(const WindowDesc *desc, int window_number) : Window(), refresh(FORCE_REFRESH_PERIOD)
-	{
-		this->InitNested(desc, window_number);
-		this->LowerWidget(this->map_type + SM_WIDGET_CONTOUR);
+/**
+ * Function to set up widgets depending on the information being shown on the smallmap.
+ */
+void SmallMapWindow::SetupWidgetData()
+{
+	StringID legend_tooltip;
+	StringID enable_all_tooltip;
+	StringID disable_all_tooltip;
+	int plane;
+	switch (this->map_type) {
+		case SMT_INDUSTRY:
+			legend_tooltip = STR_SMALLMAP_TOOLTIP_INDUSTRY_SELECTION;
+			enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_INDUSTRIES;
+			disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_INDUSTRIES;
+			plane = 0;
+			break;
+
+		case SMT_OWNER:
+			legend_tooltip = STR_SMALLMAP_TOOLTIP_COMPANY_SELECTION;
+			enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_COMPANIES;
+			disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_COMPANIES;
+			plane = 0;
+			break;
+
+		case SMT_LINKSTATS:
+			legend_tooltip = STR_SMALLMAP_TOOLTIP_CARGO_SELECTION;
+			enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_CARGOS;
+			disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_CARGOS;
+			plane = 0;
+			break;
 
-		BuildLandLegend();
-		this->SetWidgetLoweredState(SM_WIDGET_SHOW_HEIGHT, _smallmap_show_heightmap);
+		default:
+			legend_tooltip = STR_NULL;
+			enable_all_tooltip = STR_NULL;
+			disable_all_tooltip = STR_NULL;
+			plane = 1;
+			break;
+	}
 
-		this->SetWidgetLoweredState(SM_WIDGET_TOGGLETOWNNAME, this->show_towns);
+	this->GetWidget<NWidgetCore>(SM_WIDGET_LEGEND)->SetDataTip(STR_NULL, legend_tooltip);
+	this->GetWidget<NWidgetCore>(SM_WIDGET_ENABLE_ALL)->SetDataTip(STR_SMALLMAP_ENABLE_ALL, enable_all_tooltip);
+	this->GetWidget<NWidgetCore>(SM_WIDGET_DISABLE_ALL)->SetDataTip(STR_SMALLMAP_DISABLE_ALL, disable_all_tooltip);
+	this->GetWidget<NWidgetStacked>(SM_WIDGET_SELECT_BUTTONS)->SetDisplayedPlane(plane);
+}
 
-		this->SetupWidgetData();
+SmallMapWindow::SmallMapWindow(const WindowDesc *desc, int window_number) :
+		Window(),
+		refresh(FORCE_REFRESH_PERIOD),
+		overlay(this, SM_WIDGET_MAP)
+{
+	this->InitNested(desc, window_number);
+	this->LowerWidget(this->map_type + SM_WIDGET_CONTOUR);
 
-		this->SetZoomLevel(ZLC_INITIALIZE, NULL);
-		this->SmallMapCenterOnCurrentPos();
-	}
+	BuildLandLegend();
+	this->SetWidgetLoweredState(SM_WIDGET_SHOW_HEIGHT, _smallmap_show_heightmap);
 
-	/**
-	 * Compute minimal required width of the legends.
-	 * @return Minimally needed width for displaying the smallmap legends in pixels.
-	 */
-	inline uint GetMinLegendWidth() const
-	{
-		return WD_FRAMERECT_LEFT + this->min_number_of_columns * this->column_width;
-	}
+	this->SetWidgetLoweredState(SM_WIDGET_TOGGLETOWNNAME, this->show_towns);
 
-	/**
-	 * Return number of columns that can be displayed in \a width pixels.
-	 * @return Number of columns to display.
-	 */
-	inline uint GetNumberColumnsLegend(uint width) const
-	{
-		return width / this->column_width;
-	}
+	this->SetupWidgetData();
 
-	/**
-	 * Compute height given a number of columns.
-	 * @param Number of columns.
-	 * @return Needed height for displaying the smallmap legends in pixels.
-	 */
-	uint GetLegendHeight(uint num_columns) const
-	{
-		uint num_rows = max(this->min_number_of_fixed_rows, CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), num_columns));
-		return WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM + num_rows * FONT_HEIGHT_SMALL;
-	}
+	this->SetZoomLevel(ZLC_INITIALIZE, NULL);
+	this->SmallMapCenterOnCurrentPos();
+}
 
-	virtual void SetStringParameters(int widget) const
-	{
-		switch (widget) {
-			case SM_WIDGET_CAPTION:
-				SetDParam(0, STR_SMALLMAP_TYPE_CONTOURS + this->map_type);
-				break;
-		}
+/**
+ * Compute height given a number of columns.
+ * @param Number of columns.
+ * @return Needed height for displaying the smallmap legends in pixels.
+ */
+void SmallMapWindow::SetStringParameters(int widget) const
+{
+	switch (widget) {
+		case SM_WIDGET_CAPTION:
+			SetDParam(0, STR_SMALLMAP_TYPE_CONTOURS + this->map_type);
+			break;
 	}
+}
 
-	virtual void OnInit()
-	{
-		uint min_width = 0;
-		this->min_number_of_columns = INDUSTRY_MIN_NUMBER_OF_COLUMNS;
-		this->min_number_of_fixed_rows = 0;
-		for (uint i = 0; i < lengthof(_legend_table); i++) {
-			uint height = 0;
-			uint num_columns = 1;
-			for (const LegendAndColour *tbl = _legend_table[i]; !tbl->end; ++tbl) {
-				StringID str;
-				if (i == SMT_INDUSTRY) {
-					SetDParam(0, tbl->legend);
-					SetDParam(1, IndustryPool::MAX_SIZE);
-					str = STR_SMALLMAP_INDUSTRY;
-				} else if (i == SMT_OWNER) {
-					if (tbl->company != INVALID_COMPANY) {
-						if (!Company::IsValidID(tbl->company)) {
-							/* Rebuild the owner legend. */
-							BuildOwnerLegend();
-							this->OnInit();
-							return;
-						}
-						/* Non-fixed legend entries for the owner view. */
-						SetDParam(0, tbl->company);
-						str = STR_SMALLMAP_COMPANY;
-					} else {
-						str = tbl->legend;
+void SmallMapWindow::OnInit()
+{
+	uint min_width = 0;
+	this->min_number_of_columns = INDUSTRY_MIN_NUMBER_OF_COLUMNS;
+	this->min_number_of_fixed_rows = lengthof(_linkstat_colours_in_legenda);
+	for (uint i = 0; i < lengthof(_legend_table); i++) {
+		uint height = 0;
+		uint num_columns = 1;
+		for (const LegendAndColour *tbl = _legend_table[i]; !tbl->end; ++tbl) {
+			StringID str;
+			if (i == SMT_INDUSTRY) {
+				SetDParam(0, tbl->legend);
+				SetDParam(1, IndustryPool::MAX_SIZE);
+				str = STR_SMALLMAP_INDUSTRY;
+			} else if (i == SMT_LINKSTATS) {
+				SetDParam(0, tbl->legend);
+				str = STR_SMALLMAP_LINKSTATS;
+			} else if (i == SMT_OWNER) {
+				if (tbl->company != INVALID_COMPANY) {
+					if (!Company::IsValidID(tbl->company)) {
+						/* Rebuild the owner legend. */
+						BuildOwnerLegend();
+						this->OnInit();
+						return;
 					}
+					/* Non-fixed legend entries for the owner view. */
+					SetDParam(0, tbl->company);
+					str = STR_SMALLMAP_COMPANY;
 				} else {
-					if (tbl->col_break) {
-						this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
-						height = 0;
-						num_columns++;
-					}
-					height++;
 					str = tbl->legend;
 				}
-				min_width = max(GetStringBoundingBox(str).width, min_width);
+			} else {
+				if (tbl->col_break) {
+					this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
+					height = 0;
+					num_columns++;
+				}
+				height++;
+				str = tbl->legend;
 			}
-			this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
-			this->min_number_of_columns = max(this->min_number_of_columns, num_columns);
+			min_width = max(GetStringBoundingBox(str).width, min_width);
 		}
-
-		/* The width of a column is the minimum width of all texts + the size of the blob + some spacing */
-		this->column_width = min_width + LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+		this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
+		this->min_number_of_columns = max(this->min_number_of_columns, num_columns);
 	}
 
-	virtual void OnPaint()
-	{
-		if (this->map_type == SMT_OWNER) {
-			for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
-				if (tbl->company != INVALID_COMPANY && !Company::IsValidID(tbl->company)) {
-					/* Rebuild the owner legend. */
-					BuildOwnerLegend();
-					this->InvalidateData(1);
-					break;
-				}
+	/* The width of a column is the minimum width of all texts + the size of the blob + some spacing */
+	this->column_width = min_width + LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+}
+
+void SmallMapWindow::OnPaint()
+{
+	if (this->map_type == SMT_OWNER) {
+		for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
+			if (tbl->company != INVALID_COMPANY && !Company::IsValidID(tbl->company)) {
+				/* Rebuild the owner legend. */
+				BuildOwnerLegend();
+				this->InvalidateData(1);
+				break;
 			}
 		}
-
-		this->DrawWidgets();
 	}
 
-	virtual void DrawWidget(const Rect &r, int widget) const
-	{
-		switch (widget) {
-			case SM_WIDGET_MAP: {
-				DrawPixelInfo new_dpi;
-				if (!FillDrawPixelInfo(&new_dpi, r.left + 1, r.top + 1, r.right - r.left - 1, r.bottom - r.top - 1)) return;
-				this->DrawSmallMap(&new_dpi);
-				break;
+	this->DrawWidgets();
+}
+
+void SmallMapWindow::DrawWidget(const Rect &r, int widget) const
+{
+	switch (widget) {
+		case SM_WIDGET_MAP: {
+			DrawPixelInfo new_dpi;
+			if (!FillDrawPixelInfo(&new_dpi, r.left + 1, r.top + 1, r.right - r.left - 1, r.bottom - r.top - 1)) return;
+			this->DrawSmallMap(&new_dpi);
+			break;
+		}
+
+		case SM_WIDGET_LEGEND: {
+			uint columns = this->GetNumberColumnsLegend(r.right - r.left + 1);
+			uint number_of_rows = this->GetNumberRowsLegend(columns);
+			bool rtl = _current_text_dir == TD_RTL;
+			uint y_org = r.top + WD_FRAMERECT_TOP;
+			uint x = rtl ? r.right - this->column_width - WD_FRAMERECT_RIGHT : r.left + WD_FRAMERECT_LEFT;
+			uint y = y_org;
+			uint i = 0; // Row counter for industry legend.
+			uint row_height = FONT_HEIGHT_SMALL;
+
+			uint text_left  = rtl ? 0 : LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT;
+			uint text_right = this->column_width - 1 - (rtl ? LEGEND_BLOB_WIDTH + WD_FRAMERECT_RIGHT : 0);
+			uint blob_left  = rtl ? this->column_width - 1 - LEGEND_BLOB_WIDTH : 0;
+			uint blob_right = rtl ? this->column_width - 1 : LEGEND_BLOB_WIDTH;
+
+			StringID string = STR_NULL;
+			switch (this->map_type) {
+				case SMT_INDUSTRY:
+					string = STR_SMALLMAP_INDUSTRY;
+					break;
+				case SMT_LINKSTATS:
+					string = STR_SMALLMAP_LINKSTATS;
+					break;
+				case SMT_OWNER:
+					string = STR_SMALLMAP_COMPANY;
+					break;
+				default:
+					break;
 			}
 
-			case SM_WIDGET_LEGEND: {
-				uint columns = this->GetNumberColumnsLegend(r.right - r.left + 1);
-				uint number_of_rows = max((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) ? CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), columns) : 0, this->min_number_of_fixed_rows);
-				bool rtl = _current_text_dir == TD_RTL;
-				uint y_org = r.top + WD_FRAMERECT_TOP;
-				uint x = rtl ? r.right - this->column_width - WD_FRAMERECT_RIGHT : r.left + WD_FRAMERECT_LEFT;
-				uint y = y_org;
-				uint i = 0; // Row counter for industry legend.
-				uint row_height = FONT_HEIGHT_SMALL;
-
-				uint text_left  = rtl ? 0 : LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT;
-				uint text_right = this->column_width - 1 - (rtl ? LEGEND_BLOB_WIDTH + WD_FRAMERECT_RIGHT : 0);
-				uint blob_left  = rtl ? this->column_width - 1 - LEGEND_BLOB_WIDTH : 0;
-				uint blob_right = rtl ? this->column_width - 1 : LEGEND_BLOB_WIDTH;
-
-				for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
-					if (tbl->col_break || ((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) && i++ >= number_of_rows)) {
-						/* Column break needed, continue at top, COLUMN_WIDTH pixels
-						 * (one "row") to the right. */
-						x += rtl ? -(int)this->column_width : this->column_width;
-						y = y_org;
-						i = 1;
-					}
+			for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
+				if (tbl->col_break || ((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER || this->map_type == SMT_LINKSTATS) && i++ >= number_of_rows)) {
+					/* Column break needed, continue at top, COLUMN_WIDTH pixels
+					 * (one "row") to the right. */
+					x += rtl ? -(int)this->column_width : this->column_width;
+					y = y_org;
+					i = 1;
+				}
 
-					if (this->map_type == SMT_INDUSTRY) {
+				switch (this->map_type) {
+					case SMT_INDUSTRY:
 						/* Industry name must be formatted, since it's not in tiny font in the specs.
 						 * So, draw with a parameter and use the STR_SMALLMAP_INDUSTRY string, which is tiny font */
 						SetDParam(0, tbl->legend);
 						SetDParam(1, Industry::GetIndustryTypeCount(tbl->type));
-						if (!tbl->show_on_map) {
-							/* Simply draw the string, not the black border of the legend colour.
-							 * This will enforce the idea of the disabled item */
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_INDUSTRY, TC_GREY);
-						} else {
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_INDUSTRY, TC_BLACK);
-							GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, 0); // Outer border of the legend colour
-						}
-					} else if (this->map_type == SMT_OWNER && tbl->company != INVALID_COMPANY) {
-						SetDParam(0, tbl->company);
-						if (!tbl->show_on_map) {
-							/* Simply draw the string, not the black border of the legend colour.
-							 * This will enforce the idea of the disabled item */
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_COMPANY, TC_GREY);
-						} else {
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_COMPANY, TC_BLACK);
-							GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, 0); // Outer border of the legend colour
+						/* FALL THROUGH */
+					case SMT_LINKSTATS:
+						SetDParam(0, tbl->legend);
+						/* FALL_THROUGH */
+					case SMT_OWNER:
+						if (this->map_type != SMT_OWNER || tbl->company != INVALID_COMPANY) {
+							if (this->map_type == SMT_OWNER) SetDParam(0, tbl->company);
+							if (!tbl->show_on_map) {
+								/* Simply draw the string, not the black border of the legend colour.
+								 * This will enforce the idea of the disabled item */
+								DrawString(x + text_left, x + text_right, y, string, TC_GREY);
+							} else {
+								DrawString(x + text_left, x + text_right, y, string, TC_BLACK);
+								GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, 0); // Outer border of the legend colour
+							}
+							break;
 						}
-					} else {
+						/* FALL_THROUGH */
+					default:
 						if (this->map_type == SMT_CONTOUR) SetDParam(0, tbl->height * TILE_HEIGHT_STEP);
-
 						/* Anything that is not an industry or a company is using normal process */
 						GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, 0);
 						DrawString(x + text_left, x + text_right, y, tbl->legend);
-					}
-					GfxFillRect(x + blob_left + 1, y + 2, x + blob_right - 1, y + row_height - 2, tbl->colour); // Legend colour
-
-					y += row_height;
+						break;
 				}
+
+				GfxFillRect(x + blob_left + 1, y + 2, x + blob_right - 1, y + row_height - 2, tbl->colour); // Legend colour
+
+				y += row_height;
 			}
 		}
 	}
+}
 
-	/**
-	 * Select a new map type.
-	 * @param map_type New map type.
-	 */
-	void SwitchMapType(SmallMapType map_type)
-	{
-		this->RaiseWidget(this->map_type + SM_WIDGET_CONTOUR);
-		this->map_type = map_type;
-		this->LowerWidget(this->map_type + SM_WIDGET_CONTOUR);
+/**
+ * Get the number of rows in the legend from the number of columns. Those
+ * are at least min_number_of_fixed_rows and possibly more if there are so
+ * many cargoes, industry types or companies that they won't fit in the
+ * available space.
+ * @param columns Number of columns in the legend.
+ * @return Number of rows needed for everything to fit in.
+ */
+FORCEINLINE uint SmallMapWindow::GetNumberRowsLegend(uint columns) const
+{
+	/* reserve one column for link colours */
+	uint num_rows_linkstats = CeilDiv(_smallmap_cargo_count, columns - 1);
+	uint num_rows_others = CeilDiv(max(_smallmap_industry_count,_smallmap_company_count), columns);
+	return max(this->min_number_of_fixed_rows, max(num_rows_linkstats, num_rows_others));
+}
 
-		this->SetupWidgetData();
+/**
+ * Select and toggle a legend item. When CTRL is pressed, disable all other
+ * items in the group defined by begin_legend_item and end_legend_item and
+ * keep the clicked one enabled even if it was already enabled before. If
+ * the other items in the group are all disabled already and CTRL is pressed
+ * enable them instead.
+ * @param click_pos the index of the item being selected
+ * @param legend the legend from which we select
+ * @param end_legend_item index one past the last item in the group to be inverted
+ * @param begin_legend_item index of the first item in the group to be inverted
+ */
+void SmallMapWindow::SelectLegendItem(int click_pos, LegendAndColour *legend, int end_legend_item, int begin_legend_item)
+{
+	if (_ctrl_pressed) {
+		/* Disable all, except the clicked one */
+		bool changes = false;
+		for (int i = begin_legend_item; i != end_legend_item; i++) {
+			bool new_state = (i == click_pos);
+			if (legend[i].show_on_map != new_state) {
+				changes = true;
+				legend[i].show_on_map = new_state;
+			}
+		}
+		if (!changes) {
+			/* Nothing changed? Then show all (again). */
+			for (int i = begin_legend_item; i != end_legend_item; i++) {
+				legend[i].show_on_map = true;
+			}
+		}
+	} else {
+		legend[click_pos].show_on_map = !legend[click_pos].show_on_map;
+	}
+	this->SetOverlayCargoMask();
+}
 
-		this->SetDirty();
+/**
+ * Set the link graph overlay cargo mask from the legend.
+ */
+void SmallMapWindow::SetOverlayCargoMask()
+{
+	if (this->map_type == SMT_LINKSTATS) {
+		uint32 cargo_mask = 0;
+		for (int i = 0; i != _smallmap_cargo_count; ++i) {
+			if (_legend_linkstats[i].show_on_map) SetBit(cargo_mask, _legend_linkstats[i].type);
+		}
+		this->overlay.SetCargoMask(cargo_mask);
+		this->overlay.RebuildCache();
 	}
+}
 
-	virtual void OnClick(Point pt, int widget, int click_count)
-	{
-		/* User clicked something, notify the industry chain window to stop sending newly selected industries. */
-		InvalidateWindowClassesData(WC_INDUSTRY_CARGOES, NUM_INDUSTRYTYPES);
-
-		switch (widget) {
-			case SM_WIDGET_MAP: { // Map window
-				/*
-				 * XXX: scrolling with the left mouse button is done by subsequently
-				 * clicking with the left mouse button; clicking once centers the
-				 * large map at the selected point. So by unclicking the left mouse
-				 * button here, it gets reclicked during the next inputloop, which
-				 * would make it look like the mouse is being dragged, while it is
-				 * actually being (virtually) clicked every inputloop.
-				 */
-				_left_button_clicked = false;
-
-				const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
-				Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
-				int sub;
-				pt = this->PixelToTile(pt.x - wid->pos_x, pt.y - wid->pos_y, &sub);
-				pt = RemapCoords(this->scroll_x + pt.x * TILE_SIZE + this->zoom * (TILE_SIZE - sub * TILE_SIZE / 4),
-						this->scroll_y + pt.y * TILE_SIZE + sub * this->zoom * TILE_SIZE / 4, 0);
-
-				w->viewport->follow_vehicle = INVALID_VEHICLE;
-				w->viewport->dest_scrollpos_x = pt.x - (w->viewport->virtual_width  >> 1);
-				w->viewport->dest_scrollpos_y = pt.y - (w->viewport->virtual_height >> 1);
+/**
+ * Select a new map type.
+ * @param map_type New map type.
+ */
+void SmallMapWindow::SwitchMapType(SmallMapType map_type)
+{
+	this->RaiseWidget(this->map_type + SM_WIDGET_CONTOUR);
+	this->map_type = map_type;
+	this->LowerWidget(this->map_type + SM_WIDGET_CONTOUR);
 
-				this->SetDirty();
-				break;
-			}
+	this->SetupWidgetData();
 
-			case SM_WIDGET_ZOOM_IN:
-			case SM_WIDGET_ZOOM_OUT: {
-				const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
-				Point pt = {wid->current_x / 2, wid->current_y / 2};
-				this->SetZoomLevel((widget == SM_WIDGET_ZOOM_IN) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
-				SndPlayFx(SND_15_BEEP);
-				break;
-			}
+	if (map_type == SMT_LINKSTATS) this->overlay.RebuildCache();
+	this->SetDirty();
+}
 
-			case SM_WIDGET_CONTOUR:    // Show land contours
-			case SM_WIDGET_VEHICLES:   // Show vehicles
-			case SM_WIDGET_INDUSTRIES: // Show industries
-			case SM_WIDGET_ROUTES:     // Show transport routes
-			case SM_WIDGET_VEGETATION: // Show vegetation
-			case SM_WIDGET_OWNERS:     // Show land owners
-				this->SwitchMapType((SmallMapType)(widget - SM_WIDGET_CONTOUR));
-				SndPlayFx(SND_15_BEEP);
-				break;
+void SmallMapWindow::OnClick(Point pt, int widget, int click_count)
+{
+	/* User clicked something, notify the industry chain window to stop sending newly selected industries. */
+	InvalidateWindowClassesData(WC_INDUSTRY_CARGOES, NUM_INDUSTRYTYPES);
+
+	switch (widget) {
+		case SM_WIDGET_MAP: { // Map window
+			/*
+			 * XXX: scrolling with the left mouse button is done by subsequently
+			 * clicking with the left mouse button; clicking once centers the
+			 * large map at the selected point. So by unclicking the left mouse
+			 * button here, it gets reclicked during the next inputloop, which
+			 * would make it look like the mouse is being dragged, while it is
+			 * actually being (virtually) clicked every inputloop.
+			 */
+			_left_button_clicked = false;
 
-			case SM_WIDGET_CENTERMAP: // Center the smallmap again
-				this->SmallMapCenterOnCurrentPos();
-				this->HandleButtonClick(SM_WIDGET_CENTERMAP);
-				SndPlayFx(SND_15_BEEP);
-				break;
+			const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+			Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
+			int sub;
+			pt = this->PixelToTile(pt.x - wid->pos_x, pt.y - wid->pos_y, &sub);
+			pt = RemapCoords(this->scroll_x + pt.x * TILE_SIZE + this->zoom * (TILE_SIZE - sub * TILE_SIZE / 4),
+					this->scroll_y + pt.y * TILE_SIZE + sub * this->zoom * TILE_SIZE / 4, 0);
 
-			case SM_WIDGET_TOGGLETOWNNAME: // Toggle town names
-				this->show_towns = !this->show_towns;
-				this->SetWidgetLoweredState(SM_WIDGET_TOGGLETOWNNAME, this->show_towns);
+			w->viewport->follow_vehicle = INVALID_VEHICLE;
+			w->viewport->dest_scrollpos_x = pt.x - (w->viewport->virtual_width  >> 1);
+			w->viewport->dest_scrollpos_y = pt.y - (w->viewport->virtual_height >> 1);
 
-				this->SetDirty();
-				SndPlayFx(SND_15_BEEP);
-				break;
+			this->SetDirty();
+			break;
+		}
 
-			case SM_WIDGET_LEGEND: // Legend
-				/* If industry type small map*/
-				if (this->map_type == SMT_INDUSTRY) {
-					/* If click on industries label, find right industry type and enable/disable it */
-					const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_LEGEND); // Label panel
-					uint line = (pt.y - wi->pos_y - WD_FRAMERECT_TOP) / FONT_HEIGHT_SMALL;
-					uint columns = this->GetNumberColumnsLegend(wi->current_x);
-					uint number_of_rows = max(CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), columns), this->min_number_of_fixed_rows);
-					if (line >= number_of_rows) break;
-
-					bool rtl = _current_text_dir == TD_RTL;
-					int x = pt.x - wi->pos_x;
-					if (rtl) x = wi->current_x - x;
-					uint column = (x - WD_FRAMERECT_LEFT) / this->column_width;
-
-					/* Check if click is on industry label*/
-					int industry_pos = (column * number_of_rows) + line;
-					if (industry_pos < _smallmap_industry_count) {
-						if (_ctrl_pressed) {
-							/* Disable all, except the clicked one */
-							bool changes = false;
-							for (int i = 0; i != _smallmap_industry_count; i++) {
-								bool new_state = i == industry_pos;
-								if (_legend_from_industries[i].show_on_map != new_state) {
-									changes = true;
-									_legend_from_industries[i].show_on_map = new_state;
-								}
-							}
-							if (!changes) {
-								/* Nothing changed? Then show all (again). */
-								for (int i = 0; i != _smallmap_industry_count; i++) {
-									_legend_from_industries[i].show_on_map = true;
-								}
-							}
-						} else {
-							_legend_from_industries[industry_pos].show_on_map = !_legend_from_industries[industry_pos].show_on_map;
-						}
-					}
-					this->SetDirty();
-				} else if (this->map_type == SMT_OWNER) {
-					/* If click on companies label, find right company and enable/disable it. */
-					const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_LEGEND);
-					uint line = (pt.y - wi->pos_y - WD_FRAMERECT_TOP) / FONT_HEIGHT_SMALL;
-					uint columns = this->GetNumberColumnsLegend(wi->current_x);
-					uint number_of_rows = max(CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), columns), this->min_number_of_fixed_rows);
-					if (line >= number_of_rows) break;
-
-					bool rtl = _current_text_dir == TD_RTL;
-					int x = pt.x - wi->pos_x;
-					if (rtl) x = wi->current_x - x;
-					uint column = (x - WD_FRAMERECT_LEFT) / this->column_width;
-
-					/* Check if click is on company label. */
-					int company_pos = (column * number_of_rows) + line;
-					if (company_pos < NUM_NO_COMPANY_ENTRIES) break;
-					if (company_pos < _smallmap_company_count) {
-						if (_ctrl_pressed) {
-							/* Disable all, except the clicked one */
-							bool changes = false;
-							for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-								bool new_state = i == company_pos;
-								if (_legend_land_owners[i].show_on_map != new_state) {
-									changes = true;
-									_legend_land_owners[i].show_on_map = new_state;
-								}
-							}
-							if (!changes) {
-								/* Nothing changed? Then show all (again). */
-								for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-									_legend_land_owners[i].show_on_map = true;
-								}
-							}
-						} else {
-							_legend_land_owners[company_pos].show_on_map = !_legend_land_owners[company_pos].show_on_map;
-						}
-					}
-					this->SetDirty();
-				}
-				break;
+		case SM_WIDGET_ZOOM_IN:
+		case SM_WIDGET_ZOOM_OUT: {
+			const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+			Point pt = {wid->current_x / 2, wid->current_y / 2};
+			this->SetZoomLevel((widget == SM_WIDGET_ZOOM_IN) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
+			SndPlayFx(SND_15_BEEP);
+			break;
+		}
 
-			case SM_WIDGET_ENABLE_ALL:
-				if (this->map_type == SMT_INDUSTRY) {
-					for (int i = 0; i != _smallmap_industry_count; i++) {
-						_legend_from_industries[i].show_on_map = true;
-					}
-				} else if (this->map_type == SMT_OWNER) {
-					for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-						_legend_land_owners[i].show_on_map = true;
-					}
-				}
-				this->SetDirty();
-				break;
+		case SM_WIDGET_CONTOUR:    // Show land contours
+		case SM_WIDGET_VEHICLES:   // Show vehicles
+		case SM_WIDGET_INDUSTRIES: // Show industries
+		case SM_WIDGET_LINKSTATS:  // Show route map
+		case SM_WIDGET_ROUTES:     // Show transport routes
+		case SM_WIDGET_VEGETATION: // Show vegetation
+		case SM_WIDGET_OWNERS:     // Show land owners
+			this->SwitchMapType((SmallMapType)(widget - SM_WIDGET_CONTOUR));
+			SndPlayFx(SND_15_BEEP);
+			break;
+
+		case SM_WIDGET_CENTERMAP: // Center the smallmap again
+			this->SmallMapCenterOnCurrentPos();
+			this->HandleButtonClick(SM_WIDGET_CENTERMAP);
+			SndPlayFx(SND_15_BEEP);
+			break;
+
+		case SM_WIDGET_TOGGLETOWNNAME: // Toggle town names
+			this->show_towns = !this->show_towns;
+			this->SetWidgetLoweredState(SM_WIDGET_TOGGLETOWNNAME, this->show_towns);
+
+			this->SetDirty();
+			SndPlayFx(SND_15_BEEP);
+			break;
+
+		case SM_WIDGET_LEGEND: // Legend
+			if (this->map_type == SMT_INDUSTRY || this->map_type == SMT_LINKSTATS || this->map_type == SMT_OWNER) {
+				/* If click on label, find right type and enable/disable it */
+				const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_LEGEND); // Label panel
+				uint line = (pt.y - wi->pos_y - WD_FRAMERECT_TOP) / FONT_HEIGHT_SMALL;
+				uint columns = this->GetNumberColumnsLegend(wi->current_x);
+				uint number_of_rows = this->GetNumberRowsLegend(columns);
+				if (line >= number_of_rows) break;
+
+				bool rtl = _current_text_dir == TD_RTL;
+				int x = pt.x - wi->pos_x;
+				if (rtl) x = wi->current_x - x;
+				uint column = (x - WD_FRAMERECT_LEFT) / this->column_width;
 
-			case SM_WIDGET_DISABLE_ALL:
+				/* Check if click is on label*/
+				int click_pos = (column * number_of_rows) + line;
 				if (this->map_type == SMT_INDUSTRY) {
-					for (int i = 0; i != _smallmap_industry_count; i++) {
-						_legend_from_industries[i].show_on_map = false;
+					if (click_pos < _smallmap_industry_count) {
+						this->SelectLegendItem(click_pos, _legend_from_industries, _smallmap_industry_count);
 					}
-				} else {
-					for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-						_legend_land_owners[i].show_on_map = false;
+				} else if (this->map_type == SMT_LINKSTATS) {
+					if (click_pos < _smallmap_cargo_count) {
+						this->SelectLegendItem(click_pos, _legend_linkstats, _smallmap_cargo_count);
+					}
+				} else if (this->map_type == SMT_OWNER) {
+					if (click_pos < _smallmap_company_count) {
+						this->SelectLegendItem(click_pos, _legend_land_owners, _smallmap_company_count, NUM_NO_COMPANY_ENTRIES);
 					}
 				}
 				this->SetDirty();
-				break;
-
-			case SM_WIDGET_SHOW_HEIGHT: // Enable/disable showing of heightmap.
-				_smallmap_show_heightmap = !_smallmap_show_heightmap;
-				this->SetWidgetLoweredState(SM_WIDGET_SHOW_HEIGHT, _smallmap_show_heightmap);
-				this->SetDirty();
-				break;
+			}
+			break;
+
+		case SM_WIDGET_ENABLE_ALL:
+			/* FALL THROUGH */
+		case SM_WIDGET_DISABLE_ALL: {
+			LegendAndColour *tbl = NULL;
+			switch (this->map_type) {
+				case SMT_INDUSTRY:
+					tbl = _legend_from_industries;
+					break;
+				case SMT_OWNER:
+					tbl = &(_legend_land_owners[NUM_NO_COMPANY_ENTRIES]);
+					break;
+				case SMT_LINKSTATS:
+					tbl = _legend_linkstats;
+					break;
+				default:
+					NOT_REACHED();
+			}
+			for (;!tbl->end && tbl->legend != STR_LINKGRAPH_LEGEND_UNUSED; ++tbl) {
+				tbl->show_on_map = (widget == SM_WIDGET_ENABLE_ALL);
+			}
+			this->SetOverlayCargoMask();
+			this->SetDirty();
+			break;
 		}
-	}
 
-	/**
-	 * Some data on this window has become invalid.
-	 * @param data Information about the changed data.
-	 * - data = 0: Displayed industries at the industry chain window have changed.
-	 * - data = 1: Companies have changed.
-	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
-	 */
-	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
-	{
-		if (!gui_scope) return;
-		switch (data) {
-			case 1:
-				/* The owner legend has already been rebuilt. */
-				this->ReInit();
-				break;
-
-			case 0: {
-				extern uint64 _displayed_industries;
-				if (this->map_type != SMT_INDUSTRY) this->SwitchMapType(SMT_INDUSTRY);
+		case SM_WIDGET_SHOW_HEIGHT: // Enable/disable showing of heightmap.
+			_smallmap_show_heightmap = !_smallmap_show_heightmap;
+			this->SetWidgetLoweredState(SM_WIDGET_SHOW_HEIGHT, _smallmap_show_heightmap);
+			this->SetDirty();
+			break;
+	}
+}
 
-				for (int i = 0; i != _smallmap_industry_count; i++) {
-					_legend_from_industries[i].show_on_map = HasBit(_displayed_industries, _legend_from_industries[i].type);
-				}
-				break;
+/**
+ * Some data on this window has become invalid.
+ * @param data Information about the changed data.
+ * - data = 0: Displayed industries at the industry chain window have changed.
+ * - data = 1: Companies have changed.
+ * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+ */
+void SmallMapWindow::OnInvalidateData(int data, bool gui_scope)
+{
+	if (!gui_scope) return;
+	switch (data) {
+		case 1:
+			/* The owner legend has already been rebuilt. */
+			this->ReInit();
+			break;
+
+		case 0: {
+			extern uint64 _displayed_industries;
+			if (this->map_type != SMT_INDUSTRY) this->SwitchMapType(SMT_INDUSTRY);
+
+			for (int i = 0; i != _smallmap_industry_count; i++) {
+				_legend_from_industries[i].show_on_map = HasBit(_displayed_industries, _legend_from_industries[i].type);
 			}
-
-			default: NOT_REACHED();
+			break;
 		}
-		this->SetDirty();
+
+		default: NOT_REACHED();
 	}
+	this->SetDirty();
+}
 
-	virtual bool OnRightClick(Point pt, int widget)
-	{
-		if (widget != SM_WIDGET_MAP || _scrolling_viewport) return false;
+bool SmallMapWindow::OnRightClick(Point pt, int widget)
+{
+	if (widget != SM_WIDGET_MAP || _scrolling_viewport) return false;
 
-		_scrolling_viewport = true;
-		return true;
-	}
+	_scrolling_viewport = true;
+	return true;
+}
 
-	virtual void OnMouseWheel(int wheel)
-	{
-		if (_settings_client.gui.scrollwheel_scrolling == 0) {
-			const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
-			int cursor_x = _cursor.pos.x - this->left - wid->pos_x;
-			int cursor_y = _cursor.pos.y - this->top  - wid->pos_y;
-			if (IsInsideMM(cursor_x, 0, wid->current_x) && IsInsideMM(cursor_y, 0, wid->current_y)) {
-				Point pt = {cursor_x, cursor_y};
-				this->SetZoomLevel((wheel < 0) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
-			}
+void SmallMapWindow::OnMouseWheel(int wheel)
+{
+	if (_settings_client.gui.scrollwheel_scrolling == 0) {
+		const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+		int cursor_x = _cursor.pos.x - this->left - wid->pos_x;
+		int cursor_y = _cursor.pos.y - this->top  - wid->pos_y;
+		if (IsInsideMM(cursor_x, 0, wid->current_x) && IsInsideMM(cursor_y, 0, wid->current_y)) {
+			Point pt = {cursor_x, cursor_y};
+			this->SetZoomLevel((wheel < 0) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
 		}
 	}
+}
 
-	virtual void OnTick()
-	{
-		/* Update the window every now and then */
-		if (--this->refresh != 0) return;
+void SmallMapWindow::OnTick()
+{
+	/* Update the window every now and then */
+	if (--this->refresh != 0) return;
 
-		this->refresh = FORCE_REFRESH_PERIOD;
-		this->SetDirty();
+	if (this->map_type == SMT_LINKSTATS) this->overlay.RebuildCache();
+	this->refresh = FORCE_REFRESH_PERIOD;
+	this->SetDirty();
+}
+
+/**
+ * Set new #scroll_x, #scroll_y, and #subscroll values after limiting them such that the center
+ * of the smallmap always contains a part of the map.
+ * @param sx  Proposed new #scroll_x
+ * @param sy  Proposed new #scroll_y
+ * @param sub Proposed new #subscroll
+ */
+void SmallMapWindow::SetNewScroll(int sx, int sy, int sub)
+{
+	const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+	Point hv = InverseRemapCoords(wi->current_x * TILE_SIZE / 2, wi->current_y * TILE_SIZE / 2);
+	hv.x *= this->zoom;
+	hv.y *= this->zoom;
+
+	if (sx < -hv.x) {
+		sx = -hv.x;
+		sub = 0;
+	}
+	if (sx > (int)(MapMaxX() * TILE_SIZE) - hv.x) {
+		sx = MapMaxX() * TILE_SIZE - hv.x;
+		sub = 0;
+	}
+	if (sy < -hv.y) {
+		sy = -hv.y;
+		sub = 0;
+	}
+	if (sy > (int)(MapMaxY() * TILE_SIZE) - hv.y) {
+		sy = MapMaxY() * TILE_SIZE - hv.y;
+		sub = 0;
 	}
 
-	/**
-	 * Set new #scroll_x, #scroll_y, and #subscroll values after limiting them such that the center
-	 * of the smallmap always contains a part of the map.
-	 * @param sx  Proposed new #scroll_x
-	 * @param sy  Proposed new #scroll_y
-	 * @param sub Proposed new #subscroll
-	 */
-	void SetNewScroll(int sx, int sy, int sub)
-	{
-		const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
-		Point hv = InverseRemapCoords(wi->current_x * TILE_SIZE / 2, wi->current_y * TILE_SIZE / 2);
-		hv.x *= this->zoom;
-		hv.y *= this->zoom;
-
-		if (sx < -hv.x) {
-			sx = -hv.x;
-			sub = 0;
-		}
-		if (sx > (int)(MapMaxX() * TILE_SIZE) - hv.x) {
-			sx = MapMaxX() * TILE_SIZE - hv.x;
-			sub = 0;
-		}
-		if (sy < -hv.y) {
-			sy = -hv.y;
-			sub = 0;
-		}
-		if (sy > (int)(MapMaxY() * TILE_SIZE) - hv.y) {
-			sy = MapMaxY() * TILE_SIZE - hv.y;
-			sub = 0;
-		}
+	this->scroll_x = sx;
+	this->scroll_y = sy;
+	this->subscroll = sub;
+	if (this->map_type == SMT_LINKSTATS) this->overlay.RebuildCache();
+}
 
-		this->scroll_x = sx;
-		this->scroll_y = sy;
-		this->subscroll = sub;
-	}
+void SmallMapWindow::OnScroll(Point delta)
+{
+	_cursor.fix_at = true;
 
-	virtual void OnScroll(Point delta)
-	{
-		_cursor.fix_at = true;
+	/* While tile is at (delta.x, delta.y)? */
+	int sub;
+	Point pt = this->PixelToTile(delta.x, delta.y, &sub);
+	this->SetNewScroll(this->scroll_x + pt.x * TILE_SIZE, this->scroll_y + pt.y * TILE_SIZE, sub);
 
-		/* While tile is at (delta.x, delta.y)? */
-		int sub;
-		Point pt = this->PixelToTile(delta.x, delta.y, &sub);
-		this->SetNewScroll(this->scroll_x + pt.x * TILE_SIZE, this->scroll_y + pt.y * TILE_SIZE, sub);
+	this->SetDirty();
+}
 
-		this->SetDirty();
-	}
+void SmallMapWindow::SmallMapCenterOnCurrentPos()
+{
+	const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
+	Point pt = InverseRemapCoords(vp->virtual_left + vp->virtual_width  / 2, vp->virtual_top  + vp->virtual_height / 2);
+
+	int sub;
+	const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+	Point sxy = this->ComputeScroll(pt.x / TILE_SIZE, pt.y / TILE_SIZE, max(0, (int)wid->current_x / 2 - 2), wid->current_y / 2, &sub);
+	this->SetNewScroll(sxy.x, sxy.y, sub);
+	this->SetDirty();
+}
 
-	void SmallMapCenterOnCurrentPos()
-	{
-		const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
-		Point pt = InverseRemapCoords(vp->virtual_left + vp->virtual_width  / 2, vp->virtual_top  + vp->virtual_height / 2);
+/**
+ * Get the center of the given station as point on the screen in the smallmap window.
+ * @param st Station to find in the smallmap.
+ * @return Point with coordinates of the station.
+ */
+Point SmallMapWindow::GetStationMiddle(const Station *st) const
+{
+	int x = (st->rect.right + st->rect.left + 1) / 2;
+	int y = (st->rect.bottom + st->rect.top + 1) / 2;
+	Point ret = this->RemapTile(x, y);
 
-		int sub;
-		const NWidgetBase *wid = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
-		Point sxy = this->ComputeScroll(pt.x / TILE_SIZE, pt.y / TILE_SIZE, max(0, (int)wid->current_x / 2 - 2), wid->current_y / 2, &sub);
-		this->SetNewScroll(sxy.x, sxy.y, sub);
-		this->SetDirty();
-	}
-};
+	/* Same magic 3 as in DrawVehicles; that's where I got it from.
+	 * No idea what it is, but without it the result looks bad.
+	 */
+	ret.x -= 3 + this->subscroll;
+	return ret;
+}
 
 SmallMapWindow::SmallMapType SmallMapWindow::map_type = SMT_CONTOUR;
 bool SmallMapWindow::show_towns = true;
@@ -1639,6 +1644,8 @@ static const NWidgetPart _nested_smallmap_bar[] = {
 							SetDataTip(SPR_IMG_ZOOMIN, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_IN), SetFill(1, 1),
 					NWidget(WWT_PUSHIMGBTN, COLOUR_BROWN, SM_WIDGET_CENTERMAP),
 							SetDataTip(SPR_IMG_SMALLMAP, STR_SMALLMAP_CENTER), SetFill(1, 1),
+					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_BLANK),
+							SetDataTip(SPR_DOT_SMALL, STR_NULL), SetFill(1, 1),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_CONTOUR),
 							SetDataTip(SPR_IMG_SHOW_COUNTOURS, STR_SMALLMAP_TOOLTIP_SHOW_LAND_CONTOURS_ON_MAP), SetFill(1, 1),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_VEHICLES),
@@ -1652,6 +1659,8 @@ static const NWidgetPart _nested_smallmap_bar[] = {
 							SetDataTip(SPR_IMG_ZOOMOUT, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_OUT), SetFill(1, 1),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_TOGGLETOWNNAME),
 							SetDataTip(SPR_IMG_TOWN, STR_SMALLMAP_TOOLTIP_TOGGLE_TOWN_NAMES_ON_OFF), SetFill(1, 1),
+					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_LINKSTATS),
+							SetDataTip(SPR_IMG_GRAPHS, STR_SMALLMAP_TOOLTIP_SHOW_LINK_STATS_ON_MAP), SetFill(1, 1),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_ROUTES),
 							SetDataTip(SPR_IMG_SHOW_ROUTES, STR_SMALLMAP_TOOLTIP_SHOW_TRANSPORT_ROUTES_ON), SetFill(1, 1),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_VEGETATION),
@@ -1703,7 +1712,7 @@ static const NWidgetPart _nested_smallmap_widgets[] = {
 };
 
 static const WindowDesc _smallmap_desc(
-	WDP_AUTO, 446, 314,
+	WDP_AUTO, 484, 314,
 	WC_SMALLMAP, WC_NONE,
 	WDF_UNCLICK_BUTTONS,
 	_nested_smallmap_widgets, lengthof(_nested_smallmap_widgets)
diff --git a/src/smallmap_gui.h b/src/smallmap_gui.h
index 572a175..efd1977 100644
--- a/src/smallmap_gui.h
+++ b/src/smallmap_gui.h
@@ -12,9 +12,184 @@
 #ifndef SMALLMAP_GUI_H
 #define SMALLMAP_GUI_H
 
+#include "industry_type.h"
+#include "window_gui.h"
+#include "strings_func.h"
+#include "blitter/factory.hpp"
+#include "linkgraph_gui.h"
+
+/* set up the cargos to be displayed in the smallmap's route legend */
+void BuildLinkStatsLegend();
+
 void BuildIndustriesLegend();
 void ShowSmallMap();
 void BuildLandLegend();
 void BuildOwnerLegend();
 
+/** Structure for holding relevant data for legends in small map */
+struct LegendAndColour {
+	uint8 colour;              ///< Colour of the item on the map.
+	StringID legend;           ///< String corresponding to the coloured item.
+	IndustryType type;         ///< Type of industry. Only valid for industry entries.
+	uint8 height;              ///< Height in tiles. Only valid for height legend entries.
+	CompanyID company;         ///< Company to display. Only valid for company entries of the owner legend.
+	bool show_on_map;          ///< For filtering industries, if \c true, industry is shown on the map in colour.
+	bool end;                  ///< This is the end of the list.
+	bool col_break;            ///< Perform a column break and go further at the next column.
+};
+
+/** Widget numbers of the small map window. */
+enum SmallMapWindowWidgets {
+	SM_WIDGET_CAPTION,           ///< Caption widget.
+	SM_WIDGET_MAP_BORDER,        ///< Border around the smallmap.
+	SM_WIDGET_MAP,               ///< Panel containing the smallmap.
+	SM_WIDGET_LEGEND,            ///< Bottom panel to display smallmap legends.
+	SM_WIDGET_BLANK,             ///< Empty button as placeholder.
+	SM_WIDGET_ZOOM_IN,           ///< Button to zoom in one step.
+	SM_WIDGET_ZOOM_OUT,          ///< Button to zoom out one step.
+	SM_WIDGET_CONTOUR,           ///< Button to select the contour view (height map).
+	SM_WIDGET_VEHICLES,          ///< Button to select the vehicles view.
+	SM_WIDGET_INDUSTRIES,        ///< Button to select the industries view.
+	SM_WIDGET_LINKSTATS,         ///< Button to select the link stats view.
+	SM_WIDGET_ROUTES,            ///< Button to select the routes view.
+	SM_WIDGET_VEGETATION,        ///< Button to select the vegetation view.
+	SM_WIDGET_OWNERS,            ///< Button to select the owners view.
+	SM_WIDGET_CENTERMAP,         ///< Button to move smallmap center to main window center.
+	SM_WIDGET_TOGGLETOWNNAME,    ///< Toggle button to display town names.
+	SM_WIDGET_SELECT_BUTTONS,    ///< Selection widget for the buttons present in some smallmap modes.
+	SM_WIDGET_ENABLE_ALL,        ///< Button to enable display of all legend entries.
+	SM_WIDGET_DISABLE_ALL,       ///< Button to disable display of all legend entries.
+	SM_WIDGET_SHOW_HEIGHT,       ///< Show heightmap toggle button.
+};
+
+/** Class managing the smallmap window. */
+class SmallMapWindow : public Window {
+protected:
+	/** Types of legends in the #SM_WIDGET_LEGEND widget. */
+	enum SmallMapType {
+		SMT_CONTOUR,
+		SMT_VEHICLES,
+		SMT_INDUSTRY,
+		SMT_LINKSTATS,
+		SMT_ROUTES,
+		SMT_VEGETATION,
+		SMT_OWNER,
+	};
+
+	/** Available kinds of zoomlevel changes. */
+	enum ZoomLevelChange {
+		ZLC_INITIALIZE, ///< Initialize zoom level.
+		ZLC_ZOOM_OUT,   ///< Zoom out.
+		ZLC_ZOOM_IN,    ///< Zoom in.
+	};
+
+	static SmallMapType map_type; ///< Currently displayed legends.
+	static bool show_towns;       ///< Display town names in the smallmap.
+
+	static const uint LEGEND_BLOB_WIDTH = 8;              ///< Width of the coloured blob in front of a line text in the #SM_WIDGET_LEGEND widget.
+	static const uint INDUSTRY_MIN_NUMBER_OF_COLUMNS = 2; ///< Minimal number of columns in the #SM_WIDGET_LEGEND widget for the #SMT_INDUSTRY legend.
+	static const uint8 FORCE_REFRESH_PERIOD = 0x1F; ///< map is redrawn after that many ticks
+
+	uint min_number_of_fixed_rows; ///< Minimal number of rows in the legends for the fixed layouts only (all except #SMT_INDUSTRY).
+	uint column_width;             ///< Width of a column in the #SM_WIDGET_LEGEND widget.
+
+	int32 scroll_x;  ///< Horizontal world coordinate of the base tile left of the top-left corner of the smallmap display.
+	int32 scroll_y;  ///< Vertical world coordinate of the base tile left of the top-left corner of the smallmap display.
+	int32 subscroll; ///< Number of pixels (0..3) between the right end of the base tile and the pixel at the top-left corner of the smallmap display.
+	int zoom;        ///< Zoom level. Bigger number means more zoom-out (further away).
+
+	uint8 refresh;   ///< Refresh counter, zeroed every FORCE_REFRESH_PERIOD ticks.
+	LinkGraphOverlay overlay;
+
+	/**
+	 * Draws vertical part of map indicator
+	 * @param x X coord of left/right border of main viewport
+	 * @param y Y coord of top border of main viewport
+	 * @param y2 Y coord of bottom border of main viewport
+	 */
+	static inline void DrawVertMapIndicator(int x, int y, int y2)
+	{
+		GfxFillRect(x, y,      x, y + 3, 69);
+		GfxFillRect(x, y2 - 3, x, y2,    69);
+	}
+
+	/**
+	 * Draws horizontal part of map indicator
+	 * @param x X coord of left border of main viewport
+	 * @param x2 X coord of right border of main viewport
+	 * @param y Y coord of top/bottom border of main viewport
+	 */
+	static inline void DrawHorizMapIndicator(int x, int x2, int y)
+	{
+		GfxFillRect(x,      y, x + 3, y, 69);
+		GfxFillRect(x2 - 3, y, x2,    y, 69);
+	}
+
+	void DrawMapIndicators() const;
+	void DrawSmallMapColumn(void *dst, uint xc, uint yc, int pitch, int reps, int start_pos, int end_pos, Blitter *blitter) const;
+	void DrawVehicles(const DrawPixelInfo *dpi, Blitter *blitter) const;
+	void DrawTowns(const DrawPixelInfo *dpi) const;
+	void DrawSmallMap(DrawPixelInfo *dpi) const;
+
+	Point RemapTile(int tile_x, int tile_y) const;
+	Point PixelToTile(int px, int py, int *sub, bool add_sub = true) const;
+	Point ComputeScroll(int tx, int ty, int x, int y, int *sub);
+	void SetZoomLevel(ZoomLevelChange change, const Point *zoom_pt);
+	void SetOverlayCargoMask();
+	void SetupWidgetData();
+	uint32 GetTileColours(const TileArea &ta) const;
+
+public:
+	uint min_number_of_columns;    ///< Minimal number of columns in legends.
+
+	SmallMapWindow(const WindowDesc *desc, int window_number);
+
+	/**
+	 * Compute minimal required width of the legends.
+	 * @return Minimally needed width for displaying the smallmap legends in pixels.
+	 */
+	inline uint GetMinLegendWidth() const
+	{
+		return WD_FRAMERECT_LEFT + this->min_number_of_columns * this->column_width;
+	}
+
+	/**
+	 * Return number of columns that can be displayed in \a width pixels.
+	 * @return Number of columns to display.
+	 */
+	inline uint GetNumberColumnsLegend(uint width) const
+	{
+		return width / this->column_width;
+	}
+
+	/**
+	 * Compute height given a number of columns.
+	 * @param Number of columns.
+	 * @return Needed height for displaying the smallmap legends in pixels.
+	 */
+	inline uint GetLegendHeight(uint num_columns) const
+	{
+		return WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM +
+				this->GetNumberRowsLegend(num_columns) * FONT_HEIGHT_SMALL;
+	}
+
+	uint GetNumberRowsLegend(uint columns) const;
+	Point GetStationMiddle(const Station *st) const;
+	void SwitchMapType(SmallMapType map_type);
+	void SetNewScroll(int sx, int sy, int sub);
+	void SelectLegendItem(int click_pos, LegendAndColour *legend, int end_legend_item, int begin_legend_item = 0);
+	void SmallMapCenterOnCurrentPos();
+
+	virtual void SetStringParameters(int widget) const;
+	virtual void OnInit();
+	virtual void OnPaint();
+	virtual void DrawWidget(const Rect &r, int widget) const;
+	virtual void OnClick(Point pt, int widget, int click_count);
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true);
+	virtual bool OnRightClick(Point pt, int widget);
+	virtual void OnMouseWheel(int wheel);
+	virtual void OnTick();
+	virtual void OnScroll(Point delta);
+};
+
 #endif /* SMALLMAP_GUI_H */
diff --git a/src/station.cpp b/src/station.cpp
index 0cfcf02..1ff4235 100644
--- a/src/station.cpp
+++ b/src/station.cpp
@@ -60,10 +60,16 @@ Station::Station(TileIndex tile) :
 	last_vehicle_type(VEH_INVALID)
 {
 	/* this->random_bits is set in Station::AddFacility() */
+
+	/* has to be done like this as we can't give arguments when constructing an array */
+	for (CargoID i = 0; i < NUM_CARGO; ++i) {
+		this->goods[i].cargo.AssignTo(this, i);
+	}
 }
 
 /**
- * Clean up a station by clearing vehicle orders and invalidating windows.
+ * Clean up a station by clearing vehicle orders, invalidating windows and
+ * removing link stats.
  * Aircraft-Hangar orders need special treatment here, as the hangars are
  * actually part of a station (tiletype is STATION), but the order type
  * is OT_GOTO_DEPOT.
@@ -87,12 +93,25 @@ Station::~Station()
 		if (a->targetairport == this->index) a->targetairport = INVALID_STATION;
 	}
 
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID c = 0; c < NUM_CARGO; ++c) {
+			GoodsEntry &ge = st->goods[c];
+			ge.link_stats.erase(this->index);
+			DeleteStaleFlows(st->index, c, this->index);
+			ge.cargo.RerouteStalePackets(this->index);
+		}
+	}
+
 	Vehicle *v;
 	FOR_ALL_VEHICLES(v) {
 		/* Forget about this station if this station is removed */
 		if (v->last_station_visited == this->index) {
 			v->last_station_visited = INVALID_STATION;
 		}
+		if (v->last_loading_station == this->index) {
+			v->last_loading_station = INVALID_STATION;
+		}
 	}
 
 	InvalidateWindowData(WC_STATION_LIST, this->owner, 0);
diff --git a/src/station_base.h b/src/station_base.h
index 7d64664..7d23e02 100644
--- a/src/station_base.h
+++ b/src/station_base.h
@@ -16,13 +16,272 @@
 #include "newgrf_airport.h"
 #include "cargopacket.h"
 #include "industry_type.h"
+#include "linkgraph/linkgraph_type.h"
 #include "newgrf_storage.h"
+#include "moving_average.h"
+#include <map>
+#include <set>
 
 typedef Pool<BaseStation, StationID, 32, 64000> StationPool;
 extern StationPool _station_pool;
 
 static const byte INITIAL_STATION_RATING = 175;
 
+/**
+ * Link statistics. They include figures for capacity and usage of a link. Both
+ * are moving averages which are increased for every vehicle arriving at the
+ * destination station and decreased in regular intervals. Additionally while a
+ * vehicle is loading at the source station part of the capacity is frozen and
+ * prevented from being decreased. This is done so that the link won't break
+ * down all the time when the typical "full load" order is used.
+ */
+class LinkStat : private MovingAverage<uint> {
+private:
+	/**
+	 * Capacity of the link.
+	 * This is a moving average. Use MovingAverage::Monthly() to get a meaningful value.
+	 */
+	uint capacity;
+
+	/**
+	 * Time until the link is removed. Decreases exponentially.
+	 */
+	uint timeout;
+
+	/**
+	 * Usage of the link.
+	 * This is a moving average. Use MovingAverage::Monthly() to get a meaningful value.
+	 */
+	uint usage;
+
+public:
+	/**
+	 * Minimum length of moving averages for capacity and usage.
+	 */
+	static const uint MIN_AVERAGE_LENGTH = 32;
+
+	friend const SaveLoad *GetLinkStatDesc();
+
+	/**
+	 * We don't allow creating a link stat without a timeout/length.
+         */
+	LinkStat() : MovingAverage<uint>(0) {NOT_REACHED();}
+
+	/**
+	 * Create a link stat with at least a distance.
+         * @param distance Length for the moving average and link timeout.
+         * @param capacity Initial capacity of the link.
+         * @param usage Initial usage of the link.
+         */
+	FORCEINLINE LinkStat(uint distance, uint capacity = 1, uint usage = 0) :
+		MovingAverage<uint>(distance), capacity(capacity), timeout(distance), usage(usage) {}
+
+	/**
+	 * Reset everything to 0.
+	 */
+	FORCEINLINE void Clear()
+	{
+		this->capacity = 1;
+		this->usage = 0;
+		this->timeout = this->length;
+	}
+
+	/**
+	 * Apply the moving averages to usage and capacity.
+	 */
+	FORCEINLINE void Decrease()
+	{
+		this->MovingAverage<uint>::Decrease(this->usage);
+		this->timeout = this->timeout * MIN_AVERAGE_LENGTH / (MIN_AVERAGE_LENGTH + 1);
+		this->capacity = max(this->MovingAverage<uint>::Decrease(this->capacity), (uint)1);
+	}
+
+	/**
+	 * Get an estimate of the current the capacity by calculating the moving average.
+	 * @return Capacity.
+	 */
+	FORCEINLINE uint Capacity() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->capacity);
+	}
+
+	/**
+	 * Get an estimage of the current usage by calculating the moving average.
+	 * @return Usage.
+	 */
+	FORCEINLINE uint Usage() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->usage);
+	}
+
+	/**
+	 * Add some capacity and usage.
+	 * @param capacity Additional capacity.
+	 * @param usage Additional usage.
+	 */
+	FORCEINLINE void Increase(uint capacity, uint usage)
+	{
+		this->timeout = this->length;
+		this->capacity += capacity;
+		this->usage += usage;
+	}
+
+	/**
+	 * Reset the timeout and make sure there is at least a minimum capacity.
+         */
+	FORCEINLINE void Refresh(uint min_capacity)
+	{
+		this->capacity = max(this->capacity, min_capacity);
+		this->timeout = this->length;
+	}
+
+	/**
+	 * Check if the timeout has hit.
+	 * @return If timeout is > 0.
+	 */
+	FORCEINLINE bool IsValid() const
+	{
+		return this->timeout > 0;
+	}
+};
+
+/**
+ * Flow statistics telling how much flow should be and was sent along a link.
+ */
+class FlowStat : private MovingAverage<uint> {
+private:
+	uint planned;  ///< Cargo planned to be sent along a link each "month" (30 units of time, determined by moving average).
+	uint sent;     ///< Moving average of cargo being sent.
+	StationID via; ///< Other end of the link. Can be this station, then it means "deliver here".
+
+public:
+	friend const SaveLoad *GetFlowStatDesc();
+
+	/**
+	 * Create a flow stat.
+	 * @param distance Distance to be used as length of moving average.
+	 * @param st Remote station.
+	 * @param planned Cargo planned to be sent along this link.
+	 * @param sent Cargo already sent along this link.
+	 */
+	FORCEINLINE FlowStat(uint distance = 1, StationID st = INVALID_STATION, uint planned = 0, uint sent = 0) :
+		MovingAverage<uint>(distance), planned(planned), sent(sent), via(st) {}
+
+	/**
+	 * Clone an existing flow stat, changing the plan.
+	 * @param prev Flow stat to be cloned.
+	 * @param new_plan New value for planned.
+	 */
+	FORCEINLINE FlowStat(const FlowStat &prev, uint new_plan) :
+		MovingAverage<uint>(prev.length), planned(new_plan), sent(prev.sent), via(prev.via) {}
+
+	/**
+	 * Prevents one copy operation when moving a flowstat from one set to another and decreasing it at the same time.
+	 */
+	FORCEINLINE FlowStat GetDecreasedCopy() const
+	{
+		FlowStat ret(this->length, this->via, this->planned, this->sent);
+		this->MovingAverage<uint>::Decrease(ret.sent);
+		return ret;
+	}
+
+	/**
+	 * Increase the sent value.
+	 * @param sent Amount to be added to sent.
+	 */
+	FORCEINLINE void Increase(uint sent)
+	{
+		this->sent += sent;
+	}
+
+	/**
+	 * Get an estimate of cargo sent along this link during the last 30 time units.
+	 * @return Cargo sent along this link.
+	 */
+	FORCEINLINE uint Sent() const
+	{
+		return this->MovingAverage<uint>::Monthly(sent);
+	}
+
+	/**
+	 * Get the amount of cargo planned to be sent along this link in 30 time units.
+	 * @return Cargo planned to be sent.
+	 */
+	FORCEINLINE uint Planned() const
+	{
+		return this->planned;
+	}
+
+	/**
+	 * Get the station this link is connected to.
+	 * @return Remote station.
+	 */
+	FORCEINLINE StationID Via() const
+	{
+		return this->via;
+	}
+
+	/**
+	 * Comparator for two flow stats for ordering them in a way that makes
+	 * the next flow stat to sent cargo for show up as first element.
+	 */
+	struct Comparator {
+		/**
+		 * Comparator function. Decides by planned - sent or via, if those
+		 * are equal.
+		 * @param x First flow stat.
+		 * @param y Second flow stat.
+		 * @return True if x.planned - x.sent is greater than y.planned - y.sent.
+		 */
+		bool operator()(const FlowStat &x, const FlowStat &y) const
+		{
+			int diff_x = (int)x.Planned() - (int)x.Sent();
+			int diff_y = (int)y.Planned() - (int)y.Sent();
+			if (diff_x != diff_y) {
+				return diff_x > diff_y;
+			} else {
+				return x.Via() > y.Via();
+			}
+		}
+	};
+
+	/**
+	 * Add up two flow stats' planned and sent figures and assign via from the other one to this one.
+	 * @param other Flow stat to add to this one.
+	 * @return This flow stat.
+	 */
+	FORCEINLINE FlowStat &operator+=(const FlowStat &other)
+	{
+		assert(this->via == INVALID_STATION || other.via == INVALID_STATION || this->via == other.via);
+		if (other.via != INVALID_STATION) this->via = other.via;
+		this->planned += other.planned;
+		uint sent = this->sent + other.sent;
+		if (sent > 0) {
+			this->length = (this->length * this->sent + other.length * other.sent) / sent;
+			assert(this->length > 0);
+		}
+		this->sent = sent;
+		return *this;
+	}
+
+	/**
+	 * Clear this flow stat.
+	 */
+	FORCEINLINE void Clear()
+	{
+		this->planned = 0;
+		this->sent = 0;
+		this->via = INVALID_STATION;
+	}
+};
+
+typedef std::set<FlowStat, FlowStat::Comparator> FlowStatSet; ///< Percentage of flow to be sent via specified station (or consumed locally).
+
+typedef std::map<StationID, LinkStat> LinkStatMap;
+typedef std::map<StationID, FlowStatSet> FlowStatMap; ///< Flow descriptions by origin stations.
+
+uint GetMovingAverageLength(const Station *from, const Station *to);
+
 struct GoodsEntry {
 	enum AcceptancePickup {
 		ACCEPTANCE,
@@ -34,7 +293,11 @@ struct GoodsEntry {
 		days_since_pickup(255),
 		rating(INITIAL_STATION_RATING),
 		last_speed(0),
-		last_age(255)
+		last_age(255),
+		supply(0),
+		supply_new(0),
+		last_component(INVALID_LINKGRAPH_COMPONENT),
+		max_waiting_cargo(0)
 	{}
 
 	byte acceptance_pickup;
@@ -42,8 +305,21 @@ struct GoodsEntry {
 	byte rating;
 	byte last_speed;
 	byte last_age;
-	byte amount_fract;      ///< Fractional part of the amount in the cargo list
-	StationCargoList cargo; ///< The cargo packets of cargo waiting in this station
+	byte amount_fract;                   ///< Fractional part of the amount in the cargo list.
+	StationCargoList cargo;              ///< The cargo packets of cargo waiting in this station.
+	uint supply;                         ///< Cargo supplied last month.
+	uint supply_new;                     ///< Cargo supplied so far this month.
+	FlowStatMap flows;                   ///< Planned flows through this station.
+	LinkStatMap link_stats;              ///< Capacities and usage statistics for outgoing links.
+	LinkGraphComponentID last_component; ///< Component this station was last part of in this cargo's link graph.
+	uint max_waiting_cargo;              ///< Max cargo from this station waiting at any station.
+	FlowStat GetSumFlowVia(StationID via) const;
+
+	void UpdateFlowStats(StationID source, uint count, StationID next);
+	void UpdateFlowStats(FlowStatSet &flow_stats, uint count, StationID next);
+	void UpdateFlowStats(FlowStatSet &flow_stats, FlowStatSet::iterator flow_it, uint count);
+
+	StationID UpdateFlowStatsTransfer(StationID source, uint count, StationID curr);
 };
 
 /** All airport-related information. Only valid if tile != INVALID_TILE. */
@@ -224,6 +500,8 @@ public:
 	/* virtual */ uint32 GetNewGRFVariable(const ResolverObject *object, byte variable, byte parameter, bool *available) const;
 
 	/* virtual */ void GetTileArea(TileArea *ta, StationType type) const;
+
+	void RunAverages();
 };
 
 #define FOR_ALL_STATIONS(var) FOR_ALL_BASE_STATIONS_OF_TYPE(Station, var)
diff --git a/src/station_cmd.cpp b/src/station_cmd.cpp
index 8597533..3ff3482 100644
--- a/src/station_cmd.cpp
+++ b/src/station_cmd.cpp
@@ -45,6 +45,7 @@
 #include "debug.h"
 #include "core/random_func.hpp"
 #include "company_base.h"
+#include "moving_average.h"
 #include "table/airporttile_ids.h"
 #include "newgrf_airporttiles.h"
 #include "order_backup.h"
@@ -3006,6 +3007,19 @@ static void UpdateStationRating(Station *st)
 			int rating = 0;
 			uint waiting = ge->cargo.Count();
 
+			/* num_dests is at least 1 if there is any cargo as
+			 * INVALID_STATION is also a destination.
+			 */
+			uint num_dests = (uint)ge->cargo.Packets()->MapSize();
+
+			/* Average amount of cargo per next hop, but prefer solitary stations
+			 * with only one or two next hops. They are allowed to have more
+			 * cargo waiting per next hop.
+			 * With manual cargo distribution waiting_avg = waiting / 2 as then
+			 * INVALID_STATION is the only destination.
+			 */
+			uint waiting_avg = waiting / (num_dests + 1);
+
 			if (HasBit(cs->callback_mask, CBM_CARGO_STATION_RATING_CALC)) {
 				/* Perform custom station rating. If it succeeds the speed, days in transit and
 				 * waiting cargo ratings must not be executed. */
@@ -3014,7 +3028,7 @@ static void UpdateStationRating(Station *st)
 				uint last_speed = ge->last_speed;
 				if (last_speed == 0) last_speed = 0xFF;
 
-				uint32 var18 = min(ge->days_since_pickup, 0xFF) | (min(waiting, 0xFFFF) << 8) | (min(last_speed, 0xFF) << 24);
+				uint32 var18 = min(ge->days_since_pickup, 0xFF) | (min(ge->max_waiting_cargo, 0xFFFF) << 8) | (min(last_speed, 0xFF) << 24);
 				/* Convert to the 'old' vehicle types */
 				uint32 var10 = (st->last_vehicle_type == VEH_INVALID) ? 0x0 : (st->last_vehicle_type + 0x10);
 				uint16 callback = GetCargoCallback(CBID_CARGO_STATION_RATING_CALC, var10, var18, cs);
@@ -3039,11 +3053,11 @@ static void UpdateStationRating(Station *st)
 				(rating += 45, days > 3) ||
 				(rating += 35, true);
 
-				(rating -= 90, waiting > 1500) ||
-				(rating += 55, waiting > 1000) ||
-				(rating += 35, waiting > 600) ||
-				(rating += 10, waiting > 300) ||
-				(rating += 20, waiting > 100) ||
+				(rating -= 90, ge->max_waiting_cargo > 1500) ||
+				(rating += 55, ge->max_waiting_cargo > 1000) ||
+				(rating += 35, ge->max_waiting_cargo > 600) ||
+				(rating += 10, ge->max_waiting_cargo > 300) ||
+				(rating += 20, ge->max_waiting_cargo > 100) ||
 				(rating += 10, true);
 			}
 
@@ -3061,12 +3075,12 @@ static void UpdateStationRating(Station *st)
 				/* only modify rating in steps of -2, -1, 0, 1 or 2 */
 				ge->rating = rating = or_ + Clamp(Clamp(rating, 0, 255) - or_, -2, 2);
 
-				/* if rating is <= 64 and more than 200 items waiting,
+				/* if rating is <= 64 and more than 100 items waiting on average per destination,
 				 * remove some random amount of goods from the station */
-				if (rating <= 64 && waiting >= 200) {
+				if (rating <= 64 && waiting_avg >= 100) {
 					int dec = Random() & 0x1F;
-					if (waiting < 400) dec &= 7;
-					waiting -= dec + 1;
+					if (waiting_avg < 200) dec &= 7;
+					waiting -= (dec + 1) * num_dests;
 					waiting_changed = true;
 				}
 
@@ -3075,7 +3089,7 @@ static void UpdateStationRating(Station *st)
 					uint32 r = Random();
 					if (rating <= (int)GB(r, 0, 7)) {
 						/* Need to have int, otherwise it will just overflow etc. */
-						waiting = max((int)waiting - (int)GB(r, 8, 2) - 1, 0);
+						waiting = max((int)waiting - (int)((GB(r, 8, 2) - 1) * num_dests), 0);
 						waiting_changed = true;
 					}
 				}
@@ -3095,7 +3109,28 @@ static void UpdateStationRating(Station *st)
 					waiting_changed = true;
 				}
 
-				if (waiting_changed) ge->cargo.Truncate(waiting);
+				if (waiting_changed) {
+					/* feed back the exact own waiting cargo at this station for the
+					 * next rating calculation.
+					 */
+					ge->max_waiting_cargo = 0;
+
+					/* If truncating also punish the source stations' ratings to
+					 * decrease the flow of incoming cargo. */
+
+					StationCargoAmountMap waiting_per_source;
+					ge->cargo.CountAndTruncate(waiting, waiting_per_source);
+					for (StationCargoAmountMap::iterator i(waiting_per_source.begin()); i != waiting_per_source.end(); ++i) {
+						Station *source_station = Station::GetIfValid(i->first);
+						if (source_station == NULL) continue;
+
+						GoodsEntry &source_ge = source_station->goods[cs->Index()];
+						source_ge.max_waiting_cargo = max(source_ge.max_waiting_cargo, i->second);
+					}
+				} else {
+					/* if the average number per next hop is low, be more forgiving. */
+					ge->max_waiting_cargo = waiting_avg;
+				}
 			}
 		}
 	}
@@ -3108,6 +3143,138 @@ static void UpdateStationRating(Station *st)
 	}
 }
 
+/**
+ * Delete all flows at a station for specific cargo and destination.
+ * @param at Station to delete flows from.
+ * @param c_id Cargo for which flows shall be deleted.
+ * @param to Remote station of flows to be deleted.
+ */
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to)
+{
+	FlowStatMap &flows = Station::Get(at)->goods[c_id].flows;
+	for (FlowStatMap::iterator f_it = flows.begin(); f_it != flows.end();) {
+		FlowStatSet &s_flows = f_it->second;
+		for (FlowStatSet::iterator s_it = s_flows.begin(); s_it != s_flows.end();) {
+			if (s_it->Via() == to) {
+				s_flows.erase(s_it++);
+				break; // There can only be one flow stat for this remote station in each set.
+			} else {
+				++s_it;
+			}
+		}
+		if (s_flows.empty()) {
+			flows.erase(f_it++);
+		} else {
+			++f_it;
+		}
+	}
+}
+
+/**
+ * Get the length of a moving average for a link between two stations.
+ * @param from Source station.
+ * @param to Destination station.
+ * @return Moving average length.
+ */
+uint GetMovingAverageLength(const Station *from, const Station *to)
+{
+	return LinkStat::MIN_AVERAGE_LENGTH + (DistanceManhattan(from->xy, to->xy) >> 2);
+}
+
+/**
+ * Run the moving average decrease function for all link stats.
+ */
+void Station::RunAverages()
+{
+	FlowStatSet new_flows;
+	for (int goods_index = 0; goods_index < NUM_CARGO; ++goods_index) {
+		LinkStatMap &links = this->goods[goods_index].link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end();) {
+			StationID id = i->first;
+			Station *other = Station::GetIfValid(id);
+			if (other == NULL) {
+				this->goods[goods_index].cargo.RerouteStalePackets(id);
+				links.erase(i++);
+			} else {
+				LinkStat &ls = i->second;
+				ls.Decrease();
+				if (ls.IsValid()) {
+					++i;
+				} else {
+					DeleteStaleFlows(this->index, goods_index, id);
+					this->goods[goods_index].cargo.RerouteStalePackets(id);
+					links.erase(i++);
+				}
+			}
+		}
+
+		if (_settings_game.linkgraph.GetDistributionType(goods_index) == DT_MANUAL) {
+			this->goods[goods_index].flows.clear();
+			continue;
+		}
+
+		FlowStatMap &flows = this->goods[goods_index].flows;
+		for (FlowStatMap::iterator i = flows.begin(); i != flows.end();) {
+			if (!Station::IsValidID(i->first)) {
+				flows.erase(i++);
+			} else {
+				FlowStatSet &flow_set = i->second;
+				for (FlowStatSet::iterator j = flow_set.begin(); j != flow_set.end(); ++j) {
+					if (Station::IsValidID(j->Via())) {
+						new_flows.insert(j->GetDecreasedCopy());
+					}
+				}
+				flow_set.swap(new_flows);
+				new_flows.clear();
+				++i;
+			}
+		}
+	}
+}
+
+/**
+ * Increase capacity for a link stat given by station cargo and next hop.
+ * @param st Station to get the link stats from.
+ * @param cargo Cargo to increase stat for.
+ * @param next_station_id Station the consist will be travelling to next.
+ * @param capacity Capacity to add to link stat.
+ * @param usage Usage to add to link stat. If UINT_MAX refresh the link instead of increasing.
+ */
+void IncreaseStats(Station *st, CargoID cargo, StationID next_station_id, uint capacity, uint usage)
+{
+	LinkStatMap &stats = st->goods[cargo].link_stats;
+	LinkStatMap::iterator i = stats.find(next_station_id);
+	if (i == stats.end()) {
+		Station *next = Station::Get(next_station_id);
+		assert(st->index != next_station_id && next != NULL);
+		stats.insert(std::make_pair(next_station_id, LinkStat(
+				GetMovingAverageLength(st, next), capacity, usage)));
+	} else {
+		LinkStat &link_stat = i->second;
+		if (usage == UINT_MAX) {
+			link_stat.Refresh(capacity);
+		} else {
+			link_stat.Increase(capacity, usage);
+		}
+		assert(link_stat.IsValid());
+	}
+}
+
+/**
+ * Increase capacity for all link stats associated with vehicles in the given consist.
+ * @param st Station to get the link stats from.
+ * @param front First vehicle in the consist.
+ * @param next_station_id Station the consist will be travelling to next.
+ */
+void IncreaseStats(Station *st, const Vehicle *front, StationID next_station_id)
+{
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			IncreaseStats(st, v->cargo_type, next_station_id, v->cargo_cap, v->cargo.Count());
+		}
+	}
+}
+
 /* called for every station each tick */
 static void StationHandleSmallTick(BaseStation *st)
 {
@@ -3124,6 +3291,8 @@ void OnTick_Station()
 {
 	if (_game_mode == GM_EDITOR) return;
 
+	RunAverages<Station>();
+
 	BaseStation *st;
 	FOR_ALL_BASE_STATIONS(st) {
 		StationHandleSmallTick(st);
@@ -3142,7 +3311,13 @@ void OnTick_Station()
 
 void StationMonthlyLoop()
 {
-	/* not used */
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for(int goods_index = 0; goods_index < NUM_CARGO; ++goods_index) {
+			st->goods[goods_index].supply = st->goods[goods_index].supply_new;
+			st->goods[goods_index].supply_new = 0;
+		}
+	}
 }
 
 
@@ -3178,7 +3353,17 @@ static uint UpdateStationWaiting(Station *st, CargoID type, uint amount, SourceT
 	/* No new "real" cargo item yet. */
 	if (amount == 0) return 0;
 
-	ge.cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id));
+	StationID id = st->index;
+	StationID next = INVALID_STATION;
+	FlowStatSet &flow_stats = ge.flows[id];
+	FlowStatSet::iterator i = flow_stats.begin();
+	if (i != flow_stats.end()) {
+		next = i->Via();
+		ge.UpdateFlowStats(flow_stats, i, amount);
+	}
+
+	ge.cargo.Append(next, new CargoPacket(st->index, st->xy, amount, source_type, source_id));
+	ge.supply_new += amount;
 
 	if (!HasBit(ge.acceptance_pickup, GoodsEntry::PICKUP)) {
 		InvalidateWindowData(WC_STATION_LIST, st->index);
@@ -3546,6 +3731,96 @@ static CommandCost TerraformTile_Station(TileIndex tile, DoCommandFlag flags, ui
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 }
 
+/**
+ * Update the flow stats for a specific entry.
+ * @param flow_stats Flow stats to update.
+ * @param flow_it Iterator pointing to an entry in flow_stats.
+ * @param count Amount by which the flow should be increased.
+ */
+void GoodsEntry::UpdateFlowStats(FlowStatSet &flow_stats, FlowStatSet::iterator flow_it, uint count)
+{
+	FlowStat fs = *flow_it;
+	fs.Increase(count);
+	flow_stats.erase(flow_it);
+	flow_stats.insert(fs);
+}
+
+/**
+ * Update the flow stats for a specific next station.
+ * @param flow_stats Flow stats to update.
+ * @param count Amount by which the flow should be increased.
+ * @param next Next hop for which the flow stats should be updated.
+ */
+void GoodsEntry::UpdateFlowStats(FlowStatSet &flow_stats, uint count, StationID next)
+{
+	FlowStatSet::iterator flow_it = flow_stats.begin();
+	while (flow_it != flow_stats.end()) {
+		StationID via = flow_it->Via();
+		if (via == next) { //usually the first one is the correct one
+			this->UpdateFlowStats(flow_stats, flow_it, count);
+			return;
+		} else {
+			++flow_it;
+		}
+	}
+}
+
+/**
+ * Update the flow stats for "count" cargo from "source" sent to "next".
+ * @param source ID of station the cargo is from.
+ * @param count Amount of cargo.
+ * @param next ID of the station the cargo is travelling to.
+ */
+void GoodsEntry::UpdateFlowStats(StationID source, uint count, StationID next)
+{
+	if (source == INVALID_STATION || next == INVALID_STATION || this->flows.empty()) return;
+	FlowStatSet &flow_stats = this->flows[source];
+	this->UpdateFlowStats(flow_stats, count, next);
+}
+
+/**
+ * Update the flow stats for "count" cargo that cannot be delivered here.
+ * @param source ID of station where the cargo is from.
+ * @param count Amount of cargo.
+ * @param curr ID of station where it is stored for now.
+ * @return ID of the station where the cargo is sent next.
+ */
+StationID GoodsEntry::UpdateFlowStatsTransfer(StationID source, uint count, StationID curr)
+{
+	if (source == INVALID_STATION || this->flows.empty()) return INVALID_STATION;
+	FlowStatSet &flow_stats = this->flows[source];
+	FlowStatSet::iterator flow_it = flow_stats.begin();
+	while (flow_it != flow_stats.end()) {
+		StationID via = flow_it->Via();
+		if (via != curr) {
+			this->UpdateFlowStats(flow_stats, flow_it, count);
+			return via;
+		} else {
+			++flow_it;
+		}
+	}
+	return INVALID_STATION;
+}
+
+/**
+ * Get the sum of flows via a specific station from this GoodsEntry.
+ * @param via Remote station to look for.
+ * @return a FlowStat with all flows for 'via' added up.
+ */
+FlowStat GoodsEntry::GetSumFlowVia(StationID via) const
+{
+	FlowStat ret(1, via);
+	for (FlowStatMap::const_iterator i = this->flows.begin(); i != this->flows.end(); ++i) {
+		const FlowStatSet &flow_set = i->second;
+		for (FlowStatSet::const_iterator j = flow_set.begin(); j != flow_set.end(); ++j) {
+			const FlowStat &flow = *j;
+			if (flow.Via() == via) {
+				ret += flow;
+			}
+		}
+	}
+	return ret;
+}
 
 extern const TileTypeProcs _tile_type_station_procs = {
 	DrawTile_Station,           // draw_tile_proc
diff --git a/src/station_func.h b/src/station_func.h
index 0fe5b2f..4eaf727 100644
--- a/src/station_func.h
+++ b/src/station_func.h
@@ -18,6 +18,7 @@
 #include "road_type.h"
 #include "cargo_type.h"
 #include "company_type.h"
+#include "vehicle_type.h"
 
 void ModifyStationRatingAround(TileIndex tile, Owner owner, int amount, uint radius);
 
@@ -46,4 +47,10 @@ bool IsStationTileElectrifiable(TileIndex tile);
 
 void UpdateAirportsNoise();
 
+void IncreaseStats(Station *st, const Vehicle *v, StationID next_station_id);
+
+void IncreaseStats(Station *st, CargoID cargo, StationID next_station_id, uint capacity, uint usage);
+
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to);
+
 #endif /* STATION_FUNC_H */
diff --git a/src/station_gui.cpp b/src/station_gui.cpp
index e55c032..56bdded 100644
--- a/src/station_gui.cpp
+++ b/src/station_gui.cpp
@@ -32,6 +32,8 @@
 
 #include "table/strings.h"
 
+#include <vector>
+
 /**
  * Draw a (multi)line of cargos seperated by commas, and prefixed with a string.
  * @param cargo_mask Mask of cargos to include in the list.
@@ -820,10 +822,18 @@ static const NWidgetPart _nested_station_view_widgets[] = {
 		NWidget(WWT_STICKYBOX, COLOUR_GREY),
 	EndContainer(),
 	NWidget(NWID_HORIZONTAL),
-		NWidget(WWT_PANEL, COLOUR_GREY, SVW_WAITING), SetMinimalSize(237, 52), SetResize(1, 10), SetScrollbar(SVW_SCROLLBAR), EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, SVW_SORT_ORDER), SetMinimalSize(81, 12), SetFill(1, 1), SetDataTip(STR_BUTTON_SORT_BY, STR_TOOLTIP_SORT_ORDER),
+		NWidget(WWT_DROPDOWN, COLOUR_GREY, SVW_SORT_BY), SetMinimalSize(168, 12), SetResize(1, 0), SetFill(0, 1), SetDataTip(0x0, STR_TOOLTIP_SORT_CRITERIA),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, SVW_GROUP), SetMinimalSize(81, 12), SetFill(1, 1), SetDataTip(STR_STATION_VIEW_GROUP, 0x0),
+		NWidget(WWT_DROPDOWN, COLOUR_GREY, SVW_GROUP_BY), SetMinimalSize(168, 12), SetResize(1, 0), SetFill(0, 1), SetDataTip(0x0, STR_TOOLTIP_GROUP_ORDER),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY, SVW_WAITING), SetMinimalSize(237, 44), SetResize(1, 10), SetScrollbar(SVW_SCROLLBAR), EndContainer(),
 		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, SVW_SCROLLBAR),
 	EndContainer(),
-	NWidget(WWT_PANEL, COLOUR_GREY, SVW_ACCEPTLIST), SetMinimalSize(249, 32), SetResize(1, 0), EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY, SVW_ACCEPTLIST), SetMinimalSize(249, 23), SetResize(1, 0), EndContainer(),
 	NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, SVW_LOCATION), SetMinimalSize(60, 12), SetResize(1, 0), SetFill(1, 1),
 				SetDataTip(STR_BUTTON_LOCATION, STR_STATION_VIEW_CENTER_TOOLTIP),
@@ -856,33 +866,270 @@ static void DrawCargoIcons(CargoID i, uint waiting, int left, int right, int y)
 
 	SpriteID sprite = CargoSpec::Get(i)->GetCargoIcon();
 
-	int x = _current_text_dir == TD_RTL ? right - num * 10 : left;
+	int x = _current_text_dir == TD_RTL ? left : right - num * 10;
 	do {
 		DrawSprite(sprite, PAL_NONE, x, y);
 		x += 10;
 	} while (--num);
 }
 
-struct CargoData {
-	CargoID cargo;
-	StationID source;
-	uint count;
+CargoDataEntry::CargoDataEntry() :
+	parent(NULL),
+	station(INVALID_STATION),
+	num_children(0),
+	count(0),
+	children(new CargoDataSet(CargoSorter(ST_CARGO_ID)))
+{}
+
+CargoDataEntry::CargoDataEntry(CargoID cargo, uint count, CargoDataEntry *parent) :
+	parent(parent),
+	cargo(cargo),
+	num_children(0),
+	count(count),
+	children(new CargoDataSet)
+{}
+
+CargoDataEntry::CargoDataEntry(StationID station, uint count, CargoDataEntry *parent) :
+	parent(parent),
+	station(station),
+	num_children(0),
+	count(count),
+	children(new CargoDataSet)
+{}
+
+CargoDataEntry::CargoDataEntry(StationID station) :
+	parent(NULL),
+	station(station),
+	num_children(0),
+	count(0),
+	children(NULL)
+{}
+
+CargoDataEntry::CargoDataEntry(CargoID cargo) :
+	parent(NULL),
+	cargo(cargo),
+	num_children(0),
+	count(0),
+	children(NULL)
+{}
+
+CargoDataEntry::~CargoDataEntry()
+{
+	this->Clear();
+	delete this->children;
+}
 
-	CargoData(CargoID cargo, StationID source, uint count) :
-		cargo(cargo),
-		source(source),
-		count(count)
-	{ }
-};
+/**
+ * Delete all subentries, reset count and num_children and adapt parent's count.
+ */
+void CargoDataEntry::Clear()
+{
+	if (this->children != NULL) {
+		for (CargoDataSet::iterator i = this->children->begin(); i != this->children->end(); ++i) {
+			assert(*i != this);
+			delete *i;
+		}
+		this->children->clear();
+	}
+	if (this->parent != NULL) this->parent->count -= this->count;
+	this->count = 0;
+	this->num_children = 0;
+}
+
+/**
+ * Remove a subentry from this one and delete it.
+ * @param child the entry to be removed. This may also be a synthetic entry
+ * which only contains the ID of the entry to be removed. In this case child is
+ * not deleted.
+ */
+void CargoDataEntry::Remove(CargoDataEntry *child)
+{
+	CargoDataSet::iterator i = this->children->find(child);
+	if (i != this->children->end()) {
+		delete *i;
+		this->children->erase(i);
+	}
+}
+
+/**
+ * Retrieve a subentry or insert it if it doesn't exist, yet.
+ * @tparam ID type of ID: either StationID or CargoID
+ * @param child_id ID of the child to be inserted or retrieved.
+ * @return the new or retrieved subentry
+ */
+template<class ID>
+CargoDataEntry *CargoDataEntry::InsertOrRetrieve(ID child_id)
+{
+	CargoDataEntry tmp(child_id);
+	CargoDataSet::iterator i = this->children->find(&tmp);
+	if (i == this->children->end()) {
+		IncrementSize();
+		return *(this->children->insert(new CargoDataEntry(child_id, 0, this)).first);
+	} else {
+		CargoDataEntry *ret = *i;
+		assert(this->children->value_comp().GetSortType() != ST_COUNT);
+		return ret;
+	}
+}
+
+/**
+ * Update the count for this entry and propagate the change to the parent entry
+ * if there is one.
+ * @param count the amount to be added to this entry
+ */
+void CargoDataEntry::Update(uint count)
+{
+	this->count += count;
+	if (this->parent != NULL) this->parent->Update(count);
+}
+
+/**
+ * Increment
+ */
+void CargoDataEntry::IncrementSize()
+{
+	 ++this->num_children;
+	 if (this->parent != NULL) this->parent->IncrementSize();
+}
+
+void CargoDataEntry::Resort(CargoSortType type, SortOrder order)
+{
+	CargoDataSet *new_subs = new CargoDataSet(this->children->begin(), this->children->end(), CargoSorter(type, order));
+	delete this->children;
+	this->children = new_subs;
+}
+
+CargoDataEntry *CargoDataEntry::Retrieve(CargoDataSet::iterator i) const
+{
+	if (i == this->children->end()) {
+		return NULL;
+	} else {
+		assert(this->children->value_comp().GetSortType() != ST_COUNT);
+		return *i;
+	}
+}
+
+bool CargoSorter::operator()(const CargoDataEntry *cd1, const CargoDataEntry *cd2) const
+{
+	switch (this->type) {
+		case ST_STATION_ID:
+			return this->SortId<StationID>(cd1->GetStation(), cd2->GetStation());
+			break;
+		case ST_CARGO_ID:
+			return this->SortId<CargoID>(cd1->GetCargo(), cd2->GetCargo());
+			break;
+		case ST_COUNT:
+			return this->SortCount(cd1, cd2);
+			break;
+		case ST_STATION_STRING:
+			return this->SortStation(cd1->GetStation(), cd2->GetStation());
+			break;
+		default:
+			NOT_REACHED();
+	}
+}
+
+template<class ID>
+bool CargoSorter::SortId(ID st1, ID st2) const
+{
+	return (this->order == SO_ASCENDING) ? st1 < st2 : st2 < st1;
+}
 
-typedef std::list<CargoData> CargoDataList;
+bool CargoSorter::SortCount(const CargoDataEntry *cd1, const CargoDataEntry *cd2) const
+{
+	uint c1 = cd1->GetCount();
+	uint c2 = cd2->GetCount();
+	if (c1 == c2) {
+		return this->SortStation(cd1->GetStation(), cd2->GetStation());
+	} else if (this->order == SO_ASCENDING) {
+		return c1 < c2;
+	} else {
+		return c2 < c1;
+	}
+}
+
+bool CargoSorter::SortStation(StationID st1, StationID st2) const
+{
+	static char buf1[MAX_LENGTH_STATION_NAME_CHARS];
+	static char buf2[MAX_LENGTH_STATION_NAME_CHARS];
+
+	if (!Station::IsValidID(st1)) {
+		return Station::IsValidID(st2) ? this->order == SO_ASCENDING : this->SortId(st1, st2);
+	} else if (!Station::IsValidID(st2)) {
+		return order == SO_DESCENDING;
+	}
+
+	SetDParam(0, st1);
+	GetString(buf1, STR_STATION_NAME, lastof(buf1));
+	SetDParam(0, st2);
+	GetString(buf2, STR_STATION_NAME, lastof(buf2));
+
+	int res = strcmp(buf1, buf2);
+	if (res == 0) {
+		return this->SortId(st1, st2);
+	} else {
+		return (this->order == SO_ASCENDING) ? res < 0 : res > 0;
+	}
+}
 
 /**
  * The StationView window
  */
 struct StationViewWindow : public Window {
-	uint32 cargo;                 ///< Bitmask of cargo types to expand
-	uint16 cargo_rows[NUM_CARGO]; ///< Header row for each cargo type
+	/**
+	 * A row being displayed in the cargo view (as opposed to being "hidden" behind a plus sign).
+	 */
+	struct RowDisplay {
+		RowDisplay(CargoDataEntry *f, StationID n) : filter(f), next_station(n) {}
+		RowDisplay(CargoDataEntry *f, CargoID n) : filter(f), next_cargo(n) {}
+
+		/**
+		 * Parent of the cargo entry belonging to the row.
+		 */
+		CargoDataEntry *filter;
+		union {
+			/**
+			 * ID of the station belonging to the entry actually displayed if it's to/from/via.
+			 */
+			StationID next_station;
+
+			/**
+			 * ID of the cargo belonging to the entry actually displayed if it's cargo.
+			 */
+			CargoID next_cargo;
+		};
+	};
+
+	typedef std::vector<RowDisplay> CargoDataVector;
+
+	static const int NUM_COLUMNS = 4; ///< Number of "columns" in the cargo view: cargo, from, via, to
+
+	/**
+	 * Type of data invalidation.
+	 */
+	enum Invalidation {
+		INV_FLOWS = 0x100, ///< The planned flows have been recalculated and everything has to be updated.
+		INV_CARGO = 0x200  ///< Some cargo has been added or removed.
+	};
+
+	/**
+	 * Type of grouping used in each of the "columns".
+	 */
+	enum Grouping {
+		GR_SOURCE,      ///< Group by source of cargo ("from").
+		GR_NEXT,        ///< Group by next station ("via").
+		GR_DESTINATION, ///< Group by estimated final destination ("to").
+		GR_CARGO,       ///< Group by cargo type.
+	};
+
+	/**
+	 * Display mode of the cargo view.
+	 */
+	enum Mode {
+		MODE_WAITING, ///< Show cargo waiting at the station.
+		MODE_PLANNED  ///< Show cargo planned to pass through the station.
+	};
+
 	uint expand_shrink_width;     ///< The width allocated to the expand/shrink 'button'
 	int rating_lines;             ///< Number of lines in the cargo ratings view.
 	int accepts_lines;            ///< Number of lines in the accepted cargo view.
@@ -894,7 +1141,31 @@ struct StationViewWindow : public Window {
 		ALH_ACCEPTS = 3,  ///< Height of the accepted cargo view.
 	};
 
-	StationViewWindow(const WindowDesc *desc, WindowNumber window_number) : Window()
+	static const StringID _sort_names[];  ///< Names of the sorting options in the dropdown.
+	static const StringID _group_names[]; ///< Names of the grouping options in the dropdown.
+
+	/**
+	 * Sort types of the different 'columns'.
+	 * In fact only ST_COUNT and ST_AS_GROUPING are active and you can only
+	 * sort all the columns in the same way. The other options haven't been
+	 * included in the GUI due to lack of space.
+	 */
+	CargoSortType sortings[NUM_COLUMNS];
+
+	/** Sort order (ascending/descending) for the 'columns'. */
+	SortOrder sort_orders[NUM_COLUMNS];
+
+	int scroll_to_row;                  ///< If set, scroll the main viewport to the station pointed to by this row.
+	int grouping_index;                 ///< Currently selected entry in the grouping drop down.
+	Mode current_mode;                  ///< Currently selected display mode of cargo view.
+	Grouping groupings[NUM_COLUMNS];    ///< Grouping modes for the different columns.
+
+	CargoDataEntry expanded_rows;       ///< Parent entry of currently expanded rows.
+	CargoDataEntry cached_destinations; ///< Cache for the flows passing through this station.
+	CargoDataVector displayed_rows;     ///< Parent entry of currently displayed rows (including collapsed ones).
+
+	StationViewWindow(const WindowDesc *desc, WindowNumber window_number) : Window(),
+		scroll_to_row(INT_MAX), grouping_index(0)
 	{
 		this->rating_lines  = ALH_RATING;
 		this->accepts_lines = ALH_ACCEPTS;
@@ -904,6 +1175,12 @@ struct StationViewWindow : public Window {
 		/* Nested widget tree creation is done in two steps to ensure that this->GetWidget<NWidgetCore>(SVW_ACCEPTS) exists in UpdateWidgetSize(). */
 		this->FinishInitNested(desc, window_number);
 
+		this->groupings[0] = GR_CARGO;
+		this->sortings[0] = ST_AS_GROUPING;
+		this->SelectGroupBy(_settings_client.gui.station_gui_group_order);
+		this->SelectSortBy(_settings_client.gui.station_gui_sort_by);
+		this->sort_orders[0] = SO_ASCENDING;
+		this->SelectSortOrder((SortOrder)_settings_client.gui.station_gui_sort_order);
 		Owner owner = Station::Get(window_number)->owner;
 		if (owner != OWNER_NONE) this->owner = owner;
 	}
@@ -919,12 +1196,50 @@ struct StationViewWindow : public Window {
 		DeleteWindowById(WC_AIRCRAFT_LIST, VehicleListIdentifier(VL_STATION_LIST, VEH_AIRCRAFT, owner, this->window_number).Pack(), false);
 	}
 
+	/**
+	 * Show a certain cargo entry characterized by source/next/dest station, cargo ID and amount of cargo at the
+	 * right place in the cargo view. I.e. update as many rows as are expanded following that characterization.
+	 * @param data Root entry of the tree.
+	 * @param cargo Cargo ID of the entry to be shown.
+	 * @param source Source station of the entry to be shown.
+	 * @param next Next station the cargo to be shown will visit.
+	 * @param dest Final destination of the cargo to be shown.
+	 * @param count Amount of cargo to be shown.
+	 */
+	void ShowCargo(CargoDataEntry *data, CargoID cargo, StationID source, StationID next, StationID dest, uint count)
+	{
+		if (count == 0) return;
+		const CargoDataEntry *expand = &this->expanded_rows;
+		for (int i = 0; i < NUM_COLUMNS && expand != NULL; ++i) {
+			switch (groupings[i]) {
+				case GR_CARGO:
+					assert(i == 0);
+					data = data->InsertOrRetrieve(cargo);
+					expand = expand->Retrieve(cargo);
+					break;
+				case GR_SOURCE:
+					data = data->InsertOrRetrieve(source);
+					expand = expand->Retrieve(source);
+					break;
+				case GR_NEXT:
+					data = data->InsertOrRetrieve(next);
+					expand = expand->Retrieve(next);
+					break;
+				case GR_DESTINATION:
+					data = data->InsertOrRetrieve(dest);
+					expand = expand->Retrieve(dest);
+					break;
+			}
+		}
+		data->Update(count);
+	}
+
 	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
 	{
 		switch (widget) {
 			case SVW_WAITING:
 				resize->height = FONT_HEIGHT_NORMAL;
-				size->height = WD_FRAMERECT_TOP + 5 * resize->height + WD_FRAMERECT_BOTTOM;
+				size->height = WD_FRAMERECT_TOP + 4 * resize->height + WD_FRAMERECT_BOTTOM;
 				this->expand_shrink_width = max(GetStringBoundingBox("-").width, GetStringBoundingBox("+").width) + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
 				break;
 
@@ -936,20 +1251,21 @@ struct StationViewWindow : public Window {
 
 	virtual void OnPaint()
 	{
-		CargoDataList cargolist;
-		uint32 transfers = 0;
-		this->OrderWaitingCargo(&cargolist, &transfers);
+		const Station *st = Station::Get(this->window_number);
+		CargoDataEntry cargo;
+		BuildCargoList(&cargo, st);
 
-		this->vscroll->SetCount((int)cargolist.size() + 1); // update scrollbar
+		this->vscroll->SetCount(cargo.GetNumChildren()); // update scrollbar
 
 		/* disable some buttons */
-		const Station *st = Station::Get(this->window_number);
 		this->SetWidgetDisabledState(SVW_RENAME,   st->owner != _local_company);
 		this->SetWidgetDisabledState(SVW_TRAINS,   !(st->facilities & FACIL_TRAIN));
 		this->SetWidgetDisabledState(SVW_ROADVEHS, !(st->facilities & FACIL_TRUCK_STOP) && !(st->facilities & FACIL_BUS_STOP));
 		this->SetWidgetDisabledState(SVW_SHIPS,    !(st->facilities & FACIL_DOCK));
 		this->SetWidgetDisabledState(SVW_PLANES,   !(st->facilities & FACIL_AIRPORT));
 
+		SetDParam(0, st->index);
+		SetDParam(1, st->facilities);
 		this->DrawWidgets();
 
 		if (!this->IsShaded()) {
@@ -972,10 +1288,20 @@ struct StationViewWindow : public Window {
 				}
 			}
 
+			/* draw arrow pointing up/down for ascending/descending sorting */
+			this->DrawSortButtonState(SVW_SORT_ORDER, sort_orders[1] == SO_ASCENDING ? SBS_UP : SBS_DOWN);
+
+			int pos = this->vscroll->GetPosition();
+
+			int maxrows = this->vscroll->GetCapacity();
+
+			displayed_rows.clear();
+
 			/* Draw waiting cargo. */
 			NWidgetBase *nwi = this->GetWidget<NWidgetBase>(SVW_WAITING);
 			Rect waiting_rect = {nwi->pos_x, nwi->pos_y, nwi->pos_x + nwi->current_x - 1, nwi->pos_y + nwi->current_y - 1};
-			this->DrawWaitingCargo(waiting_rect, cargolist, transfers);
+			this->DrawEntries(&cargo, waiting_rect, pos, maxrows, 0);
+			scroll_to_row = INT_MAX;
 		}
 	}
 
@@ -989,116 +1315,332 @@ struct StationViewWindow : public Window {
 	}
 
 	/**
-	 * Order waiting cargo by type and destination.
-	 * @param cargolist [out] Ordered cargo.
-	 * @param transfers [out] Bitmask for cargoes being transfered.
-	 * @pre \c *cargolist must be empty.
+	 * Rebuild the cache for estimated destinations which is used to quickly show the "destination" entries
+	 * even if we actually don't know the destination of a certain packet from just looking at it.
+	 * @param i Cargo to recalculate the cache for.
 	 */
-	void OrderWaitingCargo(CargoDataList *cargolist, uint32 *transfers)
+	void RecalcDestinations(CargoID i)
 	{
-		assert(cargolist->size() == 0);
-		*transfers = 0;
+		const Station *st = Station::Get(this->window_number);
+		CargoDataEntry *cargo_entry = cached_destinations.InsertOrRetrieve(i);
+		cargo_entry->Clear();
+
+		const FlowStatMap &flows = st->goods[i].flows;
+		for (FlowStatMap::const_iterator it = flows.begin(); it != flows.end(); ++it) {
+			StationID from = it->first;
+			CargoDataEntry *source_entry = cargo_entry->InsertOrRetrieve(from);
+			const FlowStatSet &flow_set = it->second;
+			for (FlowStatSet::const_iterator flow_it = flow_set.begin(); flow_it != flow_set.end(); ++flow_it) {
+				const FlowStat &stat = *flow_it;
+				StationID via = stat.Via();
+				CargoDataEntry *via_entry = source_entry->InsertOrRetrieve(via);
+				if (via == this->window_number) {
+					via_entry->InsertOrRetrieve(via)->Update(stat.Planned());
+				} else {
+					EstimateDestinations(i, from, via, stat.Planned(), via_entry);
+				}
+			}
+		}
+	}
 
-		StationID station_id = this->window_number;
-		const Station *st = Station::Get(station_id);
+	/**
+	 * Estimate the amounts of cargo per final destination for a given cargo, source station and next hop and
+	 * save the result as children of the given CargoDataEntry.
+	 * @param cargo ID of the cargo to estimate destinations for.
+	 * @param source Source station of the given batch of cargo.
+	 * @param next Intermediate hop to start the calculation at ("next hop").
+	 * @param count Size of the batch of cargo.
+	 * @param dest CargoDataEntry to save the results in.
+	 */
+	void EstimateDestinations(CargoID cargo, StationID source, StationID next, uint count, CargoDataEntry *dest)
+	{
+		if (Station::IsValidID(next) && Station::IsValidID(source)) {
+			CargoDataEntry tmp;
+			const FlowStatMap &flowmap = Station::Get(next)->goods[cargo].flows;
+			FlowStatMap::const_iterator map_it = flowmap.find(source);
+			if (map_it != flowmap.end()) {
+				const FlowStatSet &flows = map_it->second;
+				for (FlowStatSet::const_iterator i = flows.begin(); i != flows.end(); ++i) {
+					tmp.InsertOrRetrieve(i->Via())->Update(i->Planned());
+				}
+			}
 
-		/* count types of cargos waiting in station */
-		for (CargoID i = 0; i < NUM_CARGO; i++) {
-			if (st->goods[i].cargo.Empty()) {
-				this->cargo_rows[i] = 0;
+			if (tmp.GetCount() == 0) {
+				dest->InsertOrRetrieve(INVALID_STATION)->Update(count);
 			} else {
-				/* Add an entry for total amount of cargo of this type waiting. */
-				cargolist->push_back(CargoData(i, INVALID_STATION, st->goods[i].cargo.Count()));
-
-				/* Set the row for this cargo entry for the expand/hide button */
-				this->cargo_rows[i] = (uint16)cargolist->size();
-
-				/* Add an entry for each distinct cargo source. */
-				const StationCargoList::List *packets = st->goods[i].cargo.Packets();
-				for (StationCargoList::ConstIterator it(packets->begin()); it != packets->end(); it++) {
-					const CargoPacket *cp = *it;
-					if (cp->SourceStation() != station_id) {
-						bool added = false;
-
-						/* Enable the expand/hide button for this cargo type */
-						SetBit(*transfers, i);
-
-						/* Don't add cargo lines if not expanded */
-						if (!HasBit(this->cargo, i)) break;
-
-						/* Check if we already have this source in the list */
-						for (CargoDataList::iterator jt(cargolist->begin()); jt != cargolist->end(); jt++) {
-							CargoData *cd = &(*jt);
-							if (cd->cargo == i && cd->source == cp->SourceStation()) {
-								cd->count += cp->Count();
-								added = true;
-								break;
-							}
+				uint sum_estimated = 0;
+				while (sum_estimated < count) {
+					for (CargoDataSet::iterator i = tmp.Begin(); i != tmp.End() && sum_estimated < count; ++i) {
+						CargoDataEntry *child = *i;
+						uint estimate = DivideApprox(child->GetCount() * count, tmp.GetCount());
+						if (estimate == 0) estimate = 1;
+
+						sum_estimated += estimate;
+						if (sum_estimated > count) {
+							estimate -= sum_estimated - count;
+							sum_estimated = count;
 						}
 
-						if (!added) cargolist->push_back(CargoData(i, cp->SourceStation(), cp->Count()));
+						if (estimate > 0) {
+							if (child->GetStation() == next) {
+								dest->InsertOrRetrieve(next)->Update(estimate);
+							} else {
+								EstimateDestinations(cargo, source, child->GetStation(), estimate, dest);
+							}
+						}
 					}
+
 				}
 			}
+		} else {
+			dest->InsertOrRetrieve(INVALID_STATION)->Update(count);
 		}
 	}
 
 	/**
-	 * Draw waiting cargo.
-	 * @param r Rectangle of the widget.
-	 * @param cargolist Cargo, ordered by type and destination.
-	 * @param transfers Bitmask for cargoes that are transfered.
+	 * Build up the cargo view for PLANNED mode and a specific cargo.
+	 * @param i Cargo to show.
+	 * @param flows The current station's flows for that cargo.
+	 * @param cargo The CargoDataEntry to save the results in.
 	 */
-	void DrawWaitingCargo(const Rect &r, const CargoDataList &cargolist, uint32 transfers) const
+	void BuildFlowList(CargoID i, const FlowStatMap &flows, CargoDataEntry *cargo)
 	{
-		int y = r.top + WD_FRAMERECT_TOP;
-		int pos = this->vscroll->GetPosition();
+		const CargoDataEntry *source_dest = this->cached_destinations.Retrieve(i);
+		for (FlowStatMap::const_iterator it = flows.begin(); it != flows.end(); ++it) {
+			StationID from = it->first;
+			const CargoDataEntry *source_entry = source_dest->Retrieve(from);
+			const FlowStatSet &flow_set = it->second;
+			for (FlowStatSet::const_iterator flow_it = flow_set.begin(); flow_it != flow_set.end(); ++flow_it) {
+				const FlowStat &stat = *flow_it;
+				const CargoDataEntry *via_entry = source_entry->Retrieve(stat.Via());
+				for (CargoDataSet::iterator dest_it = via_entry->Begin(); dest_it != via_entry->End(); ++dest_it) {
+					CargoDataEntry *dest_entry = *dest_it;
+					ShowCargo(cargo, i, from, stat.Via(), dest_entry->GetStation(), dest_entry->GetCount());
+				}
+			}
+		}
+	}
 
-		const Station *st = Station::Get(this->window_number);
-		if (--pos < 0) {
-			StringID str = STR_JUST_NOTHING;
-			for (CargoID i = 0; i < NUM_CARGO; i++) {
-				if (!st->goods[i].cargo.Empty()) str = STR_EMPTY;
+	/**
+	 * Build up the cargo view for WAITING mode and a specific cargo.
+	 * @param i Cargo to show.
+	 * @param packets The current station's cargo list for that cargo.
+	 * @param cargo The CargoDataEntry to save the result in.
+	 */
+	void BuildCargoList(CargoID i, const StationCargoList &packets, CargoDataEntry *cargo)
+	{
+		const CargoDataEntry *source_dest = this->cached_destinations.Retrieve(i);
+		for (StationCargoList::ConstIterator it = packets.Packets()->begin(); it != packets.Packets()->end(); it++) {
+			const CargoPacket *cp = *it;
+			StationID next = it.GetKey();
+
+			const CargoDataEntry *source_entry = source_dest->Retrieve(cp->SourceStation());
+			if (source_entry == NULL) {
+				ShowCargo(cargo, i, cp->SourceStation(), next, INVALID_STATION, cp->Count());
+				continue;
+			}
+
+			const CargoDataEntry *via_entry = source_entry->Retrieve(next);
+			if (via_entry == NULL) {
+				ShowCargo(cargo, i, cp->SourceStation(), next, INVALID_STATION, cp->Count());
+				continue;
+			}
+
+			for (CargoDataSet::iterator dest_it = via_entry->Begin(); dest_it != via_entry->End(); ++dest_it) {
+				CargoDataEntry *dest_entry = *dest_it;
+				uint val = DivideApprox(cp->Count() * dest_entry->GetCount(), via_entry->GetCount());
+				ShowCargo(cargo, i, cp->SourceStation(), next, dest_entry->GetStation(), val);
 			}
-			SetDParam(0, str);
-			DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_STATION_VIEW_WAITING_TITLE);
-			y += FONT_HEIGHT_NORMAL;
 		}
+	}
 
-		bool rtl = _current_text_dir == TD_RTL;
-		int text_left    = rtl ? r.left + this->expand_shrink_width : r.left + WD_FRAMERECT_LEFT;
-		int text_right   = rtl ? r.right - WD_FRAMERECT_LEFT : r.right - this->expand_shrink_width;
-		int shrink_left  = rtl ? r.left + WD_FRAMERECT_LEFT : r.right - this->expand_shrink_width + WD_FRAMERECT_LEFT;
-		int shrink_right = rtl ? r.left + this->expand_shrink_width - WD_FRAMERECT_RIGHT : r.right - WD_FRAMERECT_RIGHT;
-
-
-		int maxrows = this->vscroll->GetCapacity();
-		for (CargoDataList::const_iterator it = cargolist.begin(); it != cargolist.end() && pos > -maxrows; ++it) {
-			if (--pos < 0) {
-				const CargoData *cd = &(*it);
-				if (cd->source == INVALID_STATION) {
-					/* Heading */
-					DrawCargoIcons(cd->cargo, cd->count, r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y);
-					SetDParam(0, cd->cargo);
-					SetDParam(1, cd->count);
-					if (HasBit(transfers, cd->cargo)) {
-						/* This cargo has transfers waiting so show the expand or shrink 'button' */
-						const char *sym = HasBit(this->cargo, cd->cargo) ? "-" : "+";
-						DrawString(text_left, text_right, y, STR_STATION_VIEW_WAITING_CARGO, TC_FROMSTRING, SA_RIGHT);
-						DrawString(shrink_left, shrink_right, y, sym, TC_YELLOW, SA_RIGHT);
-					} else {
-						DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_STATION_VIEW_WAITING_CARGO, TC_FROMSTRING, SA_RIGHT);
-					}
+	/**
+	 * Build up the cargo view for all cargoes.
+	 * @param cargo The root cargo entry to save all results in.
+	 * @param st The station to calculate the cargo view from.
+	 */
+	void BuildCargoList(CargoDataEntry *cargo, const Station *st)
+	{
+		for (CargoID i = 0; i < NUM_CARGO; i++) {
+
+			if (this->cached_destinations.Retrieve(i) == NULL) {
+				this->RecalcDestinations(i);
+			}
+
+			if (this->current_mode == MODE_WAITING) {
+				BuildCargoList(i, st->goods[i].cargo, cargo);
+			} else {
+				BuildFlowList(i, st->goods[i].flows, cargo);
+			}
+		}
+	}
+
+	/**
+	 * Mark a specific row, characterized by its CargoDataEntry, as expanded.
+	 * @param data The row to be marked as expanded.
+	 */
+	void SetDisplayedRow(const CargoDataEntry *data)
+	{
+		std::list<StationID> stations;
+		const CargoDataEntry *parent = data->GetParent();
+		if (parent->GetParent() == NULL) {
+			this->displayed_rows.push_back(RowDisplay(&this->expanded_rows, data->GetCargo()));
+			return;
+		}
+
+		StationID next = data->GetStation();
+		while (parent->GetParent()->GetParent() != NULL) {
+			stations.push_back(parent->GetStation());
+			parent = parent->GetParent();
+		}
+
+		CargoID cargo = parent->GetCargo();
+		CargoDataEntry *filter = this->expanded_rows.Retrieve(cargo);
+		while (!stations.empty()) {
+			filter = filter->Retrieve(stations.back());
+			stations.pop_back();
+		}
+
+		this->displayed_rows.push_back(RowDisplay(filter, next));
+	}
+
+	/**
+	 * Select the correct string for an entry referring to the specified station.
+	 * @param station Station the entry is showing cargo for.
+	 * @param here String to be shown if the entry refers to the same station as this station GUI belongs to.
+	 * @param other_station String to be shown if the entry refers to a specific other station.
+	 * @param any String to be shown if the entry refers to "any station".
+	 * @return One of the three given strings, depending on what station the entry refers to.
+	 */
+	StringID GetEntryString(StationID station, StringID here, StringID other_station, StringID any)
+	{
+		if (station == this->window_number) {
+			return here;
+		} else if (station != INVALID_STATION) {
+			SetDParam(2, station);
+			return other_station;
+		} else {
+			return any;
+		}
+	}
+
+	/**
+	 * Determine if we need to show the special "non-stop" string.
+	 * @param cd Entry we are going to show.
+	 * @param station Station the entry refers to.
+	 * @param column The "column" the entry will be shown in.
+	 * @return either STR_STATION_VIEW_VIA or STR_STATION_VIEW_NONSTOP.
+	 */
+	StringID SearchNonStop(CargoDataEntry *cd, StationID station, int column)
+	{
+		CargoDataEntry *parent = cd->GetParent();
+		for (int i = column - 1; i > 0; --i) {
+			if (this->groupings[i] == GR_DESTINATION) {
+				if (parent->GetStation() == station) {
+					return STR_STATION_VIEW_NONSTOP;
+				} else {
+					return STR_STATION_VIEW_VIA;
+				}
+			}
+			parent = parent->GetParent();
+		}
+
+		if (this->groupings[column + 1] == GR_DESTINATION) {
+			CargoDataSet::iterator begin = cd->Begin();
+			CargoDataSet::iterator end = cd->End();
+			if (begin != end && ++(cd->Begin()) == end && (*(begin))->GetStation() == station) {
+				return STR_STATION_VIEW_NONSTOP;
+			} else {
+				return STR_STATION_VIEW_VIA;
+			}
+		}
+
+		return STR_STATION_VIEW_VIA;
+	}
+
+	/**
+	 * Draw the given cargo entries in the station GUI.
+	 * @param entry Root entry for all cargo to be drawn.
+	 * @param r Screen rectangle to draw into.
+	 * @param pos Current row to be drawn to (counted down from 0 to -maxrows, same as vscroll->GetPosition()).
+	 * @param maxrows Maximum row to be drawn.
+	 * @param column Current "column" being drawn.
+	 * @param cargo Current cargo being drawn (if cargo column has been passed).
+	 * @return row (in "pos" counting) after the one we have last drawn to.
+	 */
+	int DrawEntries(CargoDataEntry *entry, Rect &r, int pos, int maxrows, int column, CargoID cargo = CT_INVALID)
+	{
+		if (this->sortings[column] == ST_AS_GROUPING) {
+			if (this->groupings[column] != GR_CARGO) {
+				entry->Resort(ST_STATION_STRING, this->sort_orders[column]);
+			}
+		} else {
+			entry->Resort(ST_COUNT, this->sort_orders[column]);
+		}
+		for (CargoDataSet::iterator i = entry->Begin(); i != entry->End(); ++i) {
+			CargoDataEntry *cd = *i;
+
+			if (this->groupings[column] == GR_CARGO) cargo = cd->GetCargo();
+
+			if (pos > -maxrows && pos <= 0) {
+				StringID str = STR_EMPTY;
+				int y = r.top + WD_FRAMERECT_TOP - pos * FONT_HEIGHT_NORMAL;
+				SetDParam(0, cargo);
+				SetDParam(1, cd->GetCount());
+
+				if (this->groupings[column] == GR_CARGO) {
+					str = STR_STATION_VIEW_WAITING_CARGO;
+					DrawCargoIcons(cd->GetCargo(), cd->GetCount(), r.left + WD_FRAMERECT_LEFT + this->expand_shrink_width, r.right - WD_FRAMERECT_RIGHT - this->expand_shrink_width, y);
 				} else {
-					SetDParam(0, cd->cargo);
-					SetDParam(1, cd->count);
-					SetDParam(2, cd->source);
-					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_STATION_VIEW_EN_ROUTE_FROM, TC_FROMSTRING, SA_RIGHT);
+					StationID station = cd->GetStation();
+
+					switch (this->groupings[column]) {
+						case GR_SOURCE:
+							str = this->GetEntryString(station, STR_STATION_VIEW_FROM_HERE, STR_STATION_VIEW_FROM, STR_STATION_VIEW_FROM_ANY);
+							break;
+						case GR_NEXT:
+							str = this->GetEntryString(station, STR_STATION_VIEW_VIA_HERE, STR_STATION_VIEW_VIA, STR_STATION_VIEW_VIA_ANY);
+							if (str == STR_STATION_VIEW_VIA) str = SearchNonStop(cd, station, column);
+							break;
+						case GR_DESTINATION:
+							str = this->GetEntryString(station, STR_STATION_VIEW_TO_HERE, STR_STATION_VIEW_TO, STR_STATION_VIEW_TO_ANY);
+							break;
+						default:
+							NOT_REACHED();
+					}
+					if (pos == -this->scroll_to_row && Station::IsValidID(station)) {
+						ScrollMainWindowToTile(Station::Get(station)->xy);
+					}
 				}
 
-				y += FONT_HEIGHT_NORMAL;
+				bool rtl = _current_text_dir == TD_RTL;
+				int text_left    = rtl ? r.left + this->expand_shrink_width : r.left + WD_FRAMERECT_LEFT + column * this->expand_shrink_width;
+				int text_right   = rtl ? r.right - WD_FRAMERECT_LEFT - column * this->expand_shrink_width : r.right - this->expand_shrink_width;
+				int shrink_left  = rtl ? r.left + WD_FRAMERECT_LEFT : r.right - this->expand_shrink_width + WD_FRAMERECT_LEFT;
+				int shrink_right = rtl ? r.left + this->expand_shrink_width - WD_FRAMERECT_RIGHT : r.right - WD_FRAMERECT_RIGHT;
+
+				DrawString(text_left, text_right, y, str);
+
+				if (column < NUM_COLUMNS - 1) {
+					const char *sym = cd->GetNumChildren() > 0 ? "-" : "+";
+					DrawString(shrink_left, shrink_right, y, sym, TC_YELLOW);
+				}
+				SetDisplayedRow(cd);
 			}
+			pos = DrawEntries(cd, r, --pos, maxrows, column + 1, cargo);
 		}
+		return pos;
+	}
+
+	/**
+	 * Invalidate the cache for the given cargo.
+	 * @param cargo ID of the cargo.
+	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+	 */
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		if (!gui_scope) return;
+		this->cached_destinations.Remove((CargoID)data);
 	}
 
 	/**
@@ -1138,32 +1680,55 @@ struct StationViewWindow : public Window {
 			if (!HasBit(ge->acceptance_pickup, GoodsEntry::PICKUP)) continue;
 
 			SetDParam(0, cs->name);
-			SetDParam(2, ToPercent8(ge->rating));
-			SetDParam(1, STR_CARGO_RATING_APPALLING + (ge->rating >> 5));
-			DrawString(r.left + WD_FRAMERECT_LEFT + 6, r.right - WD_FRAMERECT_RIGHT - 6, y, STR_STATION_VIEW_CARGO_RATING);
+			SetDParam(1, ge->supply);
+			SetDParam(3, ToPercent8(ge->rating));
+			SetDParam(2, STR_CARGO_RATING_APPALLING + (ge->rating >> 5));
+			DrawString(r.left + WD_FRAMERECT_LEFT + 6, r.right - WD_FRAMERECT_RIGHT - 6, y, STR_STATION_VIEW_CARGO_SUPPLY_RATING);
 			y += FONT_HEIGHT_NORMAL;
 		}
 		return CeilDiv(y - r.top - WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL);
 	}
 
-	void HandleCargoWaitingClick(int row)
+	/**
+	 * Expand or collapse a specific row.
+	 * @param filter Parent of the row.
+	 * @param next ID pointing to the row.
+	 */
+	template<class ID>
+	void HandleCargoWaitingClick(CargoDataEntry *filter, ID next)
 	{
-		if (row == 0) return;
+		if (filter->Retrieve(next) != NULL) {
+			filter->Remove(next);
+		} else {
+			filter->InsertOrRetrieve(next);
+		}
+	}
 
-		for (CargoID c = 0; c < NUM_CARGO; c++) {
-			if (this->cargo_rows[c] == row) {
-				ToggleBit(this->cargo, c);
-				this->SetWidgetDirty(SVW_WAITING);
-				break;
+	/**
+	 * Handle a click on a specific row in the cargo view.
+	 * @param row Row being clicked.
+	 */
+	void HandleCargoWaitingClick(int row)
+	{
+		if (row < 0 || (uint)row >= this->displayed_rows.size()) return;
+		if (_ctrl_pressed) {
+			this->scroll_to_row = row;
+		} else {
+			RowDisplay &display = this->displayed_rows[row];
+			if (display.filter == &this->expanded_rows) {
+				this->HandleCargoWaitingClick<CargoID>(display.filter, display.next_cargo);
+			} else {
+				this->HandleCargoWaitingClick<StationID>(display.filter, display.next_station);
 			}
 		}
+		this->SetWidgetDirty(SVW_WAITING);
 	}
 
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
 		switch (widget) {
 			case SVW_WAITING:
-				this->HandleCargoWaitingClick(this->vscroll->GetScrolledRowFromWidget(pt.y, this, SVW_WAITING, WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL));
+				this->HandleCargoWaitingClick(this->vscroll->GetScrolledRowFromWidget(pt.y, this, SVW_WAITING, WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL) - this->vscroll->GetPosition());
 				break;
 
 			case SVW_LOCATION:
@@ -1201,6 +1766,119 @@ struct StationViewWindow : public Window {
 			case SVW_PLANES:   // Show list of scheduled aircraft to this station
 				ShowVehicleListWindow(this->owner, (VehicleType)(widget - SVW_TRAINS), (StationID)this->window_number);
 				break;
+
+			case SVW_SORT_BY: {
+				ShowDropDownMenu(this, _sort_names, this->current_mode, SVW_SORT_BY, 0, 0);
+				break;
+			}
+
+			case SVW_GROUP_BY: {
+				ShowDropDownMenu(this, _group_names, this->grouping_index, SVW_GROUP_BY, 0, 0);
+				break;
+			}
+
+			case SVW_SORT_ORDER: { // flip sorting method asc/desc
+				this->SelectSortOrder(this->sort_orders[1] == SO_ASCENDING ? SO_DESCENDING : SO_ASCENDING);
+				this->flags4 |= WF_TIMEOUT_BEGIN;
+				this->LowerWidget(SVW_SORT_ORDER);
+				break;
+			}
+		}
+	}
+
+	/**
+	 * Select a new sort order for the cargo view.
+	 * @param order New sort order.
+	 */
+	void SelectSortOrder(SortOrder order)
+	{
+		this->sort_orders[1] = this->sort_orders[2] = this->sort_orders[3] = order;
+		_settings_client.gui.station_gui_sort_order = this->sort_orders[1];
+		this->SetDirty();
+	}
+
+	/**
+	 * Select a new sort criterium for the cargo view.
+	 * @param index Row being selected in the sort criteria drop down.
+	 */
+	void SelectSortBy(int index)
+	{
+		_settings_client.gui.station_gui_sort_by = index;
+		switch (_sort_names[index]) {
+			case STR_STATION_VIEW_WAITING_STATION:
+				this->current_mode = MODE_WAITING;
+				this->sortings[1] = this->sortings[2] = this->sortings[3] = ST_AS_GROUPING;
+				break;
+			case STR_STATION_VIEW_WAITING_AMOUNT:
+				this->current_mode = MODE_WAITING;
+				this->sortings[1] = this->sortings[2] = this->sortings[3] = ST_COUNT;
+				break;
+			case STR_STATION_VIEW_PLANNED_STATION:
+				this->current_mode = MODE_PLANNED;
+				this->sortings[1] = this->sortings[2] = this->sortings[3] = ST_AS_GROUPING;
+				break;
+			case STR_STATION_VIEW_PLANNED_AMOUNT:
+				this->current_mode = MODE_PLANNED;
+				this->sortings[1] = this->sortings[2] = this->sortings[3] = ST_COUNT;
+				break;
+			default:
+				NOT_REACHED();
+		}
+		/* Display the current sort variant */
+		this->GetWidget<NWidgetCore>(SVW_SORT_BY)->widget_data = _sort_names[index];
+		this->SetDirty();
+	}
+
+	/**
+	 * Select a new grouping mode for the cargo view.
+	 * @param index Row being selected in the grouping drop down.
+	 */
+	void SelectGroupBy(int index)
+	{
+		this->grouping_index = index;
+		_settings_client.gui.station_gui_group_order = index;
+		this->GetWidget<NWidgetCore>(SVW_GROUP_BY)->widget_data = _group_names[index];
+		switch (_group_names[index]) {
+			case STR_STATION_VIEW_GROUP_S_V_D:
+				this->groupings[1] = GR_SOURCE;
+				this->groupings[2] = GR_NEXT;
+				this->groupings[3] = GR_DESTINATION;
+				break;
+			case STR_STATION_VIEW_GROUP_S_D_V:
+				this->groupings[1] = GR_SOURCE;
+				this->groupings[2] = GR_DESTINATION;
+				this->groupings[3] = GR_NEXT;
+				break;
+			case STR_STATION_VIEW_GROUP_V_S_D:
+				this->groupings[1] = GR_NEXT;
+				this->groupings[2] = GR_SOURCE;
+				this->groupings[3] = GR_DESTINATION;
+				break;
+			case STR_STATION_VIEW_GROUP_V_D_S:
+				this->groupings[1] = GR_NEXT;
+				this->groupings[2] = GR_DESTINATION;
+				this->groupings[3] = GR_SOURCE;
+				break;
+			case STR_STATION_VIEW_GROUP_D_S_V:
+				this->groupings[1] = GR_DESTINATION;
+				this->groupings[2] = GR_SOURCE;
+				this->groupings[3] = GR_NEXT;
+				break;
+			case STR_STATION_VIEW_GROUP_D_V_S:
+				this->groupings[1] = GR_DESTINATION;
+				this->groupings[2] = GR_NEXT;
+				this->groupings[3] = GR_SOURCE;
+				break;
+		}
+		this->SetDirty();
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		if (widget == SVW_SORT_BY) {
+			this->SelectSortBy(index);
+		} else {
+			this->SelectGroupBy(index);
 		}
 	}
 
@@ -1217,9 +1895,26 @@ struct StationViewWindow : public Window {
 	}
 };
 
+const StringID StationViewWindow::_sort_names[] = {
+	STR_STATION_VIEW_WAITING_STATION,
+	STR_STATION_VIEW_WAITING_AMOUNT,
+	STR_STATION_VIEW_PLANNED_STATION,
+	STR_STATION_VIEW_PLANNED_AMOUNT,
+	INVALID_STRING_ID
+};
+
+const StringID StationViewWindow::_group_names[] = {
+	STR_STATION_VIEW_GROUP_S_V_D,
+	STR_STATION_VIEW_GROUP_S_D_V,
+	STR_STATION_VIEW_GROUP_V_S_D,
+	STR_STATION_VIEW_GROUP_V_D_S,
+	STR_STATION_VIEW_GROUP_D_S_V,
+	STR_STATION_VIEW_GROUP_D_V_S,
+	INVALID_STRING_ID
+};
 
 static const WindowDesc _station_view_desc(
-	WDP_AUTO, 249, 110,
+	WDP_AUTO, 249, 117,
 	WC_STATION_VIEW, WC_NONE,
 	WDF_UNCLICK_BUTTONS,
 	_nested_station_view_widgets, lengthof(_nested_station_view_widgets)
diff --git a/src/station_gui.h b/src/station_gui.h
index dd442dc..5485b87 100644
--- a/src/station_gui.h
+++ b/src/station_gui.h
@@ -13,21 +13,28 @@
 #define STATION_GUI_H
 
 #include "command_type.h"
+#include "station_type.h"
 #include "tilearea_type.h"
 #include "window_type.h"
+#include "cargo_type.h"
+#include <set>
 
 /** Enum for StationView, referring to _station_view_widgets and _station_view_expanded_widgets */
 enum StationViewWidgets {
 	SVW_CAPTION    =  0, ///< Caption of the window
-	SVW_WAITING    =  1, ///< List of waiting cargo
-	SVW_SCROLLBAR  =  2, ///< Scrollbar
-	SVW_ACCEPTLIST =  3, ///< List of accepted cargos
-	SVW_RATINGLIST =  3, ///< Ratings of cargos
-	SVW_LOCATION   =  4, ///< 'Location' button
-	SVW_RATINGS    =  5, ///< 'Ratings' button
-	SVW_ACCEPTS    =  5, ///< 'Accepts' button
-	SVW_RENAME     =  6, ///< 'Rename' button
-	SVW_TRAINS     =  7, ///< List of scheduled trains button
+	SVW_SORT_ORDER =  1, ///< 'Sort order' button
+	SVW_SORT_BY    =  2, ///< 'Sort by' button
+	SVW_GROUP      =  3, ///< label for "group by"
+	SVW_GROUP_BY   =  4, ///< 'Group by' button
+	SVW_WAITING    =  5, ///< List of waiting cargo
+	SVW_SCROLLBAR  =  6, ///< Scrollbar
+	SVW_ACCEPTLIST =  7, ///< List of accepted cargos
+	SVW_RATINGLIST =  7, ///< Ratings of cargos
+	SVW_LOCATION   =  8, ///< 'Location' button
+	SVW_RATINGS    =  9, ///< 'Ratings' button
+	SVW_ACCEPTS    =  9, ///< 'Accepts' button
+	SVW_RENAME     = 10, ///< 'Rename' button
+	SVW_TRAINS     = 11, ///< List of scheduled trains button
 	SVW_ROADVEHS,        ///< List of scheduled road vehs button
 	SVW_SHIPS,           ///< List of scheduled ships button
 	SVW_PLANES,          ///< List of scheduled planes button
@@ -46,4 +53,152 @@ void CheckRedrawStationCoverage(const Window *w);
 void ShowSelectStationIfNeeded(CommandContainer cmd, TileArea ta);
 void ShowSelectWaypointIfNeeded(CommandContainer cmd, TileArea ta);
 
+enum SortOrder {
+	SO_DESCENDING,
+	SO_ASCENDING
+};
+
+class CargoDataEntry;
+
+enum CargoSortType {
+	ST_AS_GROUPING,    ///< by the same principle the entries are being grouped
+	ST_COUNT,          ///< by amount of cargo
+	ST_STATION_STRING, ///< by station name
+	ST_STATION_ID,     ///< by station id
+	ST_CARGO_ID,       ///< by cargo id
+};
+
+class CargoSorter {
+public:
+	CargoSorter(CargoSortType t = ST_STATION_ID, SortOrder o = SO_ASCENDING) : type(t), order(o) {}
+	CargoSortType GetSortType() {return this->type;}
+	bool operator()(const CargoDataEntry *cd1, const CargoDataEntry *cd2) const;
+
+private:
+	CargoSortType type;
+	SortOrder order;
+
+	template<class ID>
+	bool SortId(ID st1, ID st2) const;
+	bool SortCount(const CargoDataEntry *cd1, const CargoDataEntry *cd2) const;
+	bool SortStation (StationID st1, StationID st2) const;
+};
+
+typedef std::set<CargoDataEntry *, CargoSorter> CargoDataSet;
+
+/**
+ * A cargo data entry representing one possible row in the station view window's
+ * top part. Cargo data entries form a tree where each entry can have several
+ * children. Parents keep track of the sums of their childrens' cargo counts.
+ */
+class CargoDataEntry {
+public:
+	CargoDataEntry();
+	~CargoDataEntry();
+
+	/**
+	 * Insert a new child or retrieve an existing child using a station ID as ID.
+	 * @param station ID of the station for which an entry shall be created or retrieved
+	 * @return a child entry associated with the given station.
+	 */
+	CargoDataEntry *InsertOrRetrieve(StationID station) {return this->InsertOrRetrieve<StationID>(station);}
+
+	/**
+	 * Insert a new child or retrieve an existing child using a cargo ID as ID.
+	 * @param cargo ID of the cargo for which an entry shall be created or retrieved
+	 * @return a child entry associated with the given cargo.
+	 */
+	CargoDataEntry *InsertOrRetrieve(CargoID cargo) {return this->InsertOrRetrieve<CargoID>(cargo);}
+
+	void Update(uint count);
+
+	/**
+	 * Remove a child associated with the given station.
+	 * @param station ID of the station for which the child should be removed.
+	 */
+	void Remove(StationID station) {CargoDataEntry t(station); this->Remove(&t);}
+
+	/**
+	 * Remove a child associated with the given cargo.
+	 * @param cargo ID of the cargo for which the child should be removed.
+	 */
+	void Remove(CargoID cargo) {CargoDataEntry t(cargo); this->Remove(&t);}
+
+	/**
+	 * Retrieve a child for the given station. Return NULL if it doesn't exist.
+	 * @param station ID of the station the child we're looking for is associated with.
+	 * @return a child entry for the given station or NULL.
+	 */
+	CargoDataEntry *Retrieve(StationID station) const {CargoDataEntry t(station); return this->Retrieve(this->children->find(&t));}
+
+	/**
+	 * Retrieve a child for the given cargo. Return NULL if it doesn't exist.
+	 * @param cargo ID of the cargo the child we're looking for is associated with.
+	 * @return a child entry for the given cargo or NULL.
+	 */
+	CargoDataEntry *Retrieve(CargoID cargo) const {CargoDataEntry t(cargo);return this->Retrieve(this->children->find(&t));}
+
+	void Resort(CargoSortType type, SortOrder order);
+
+	/**
+	 * Get the station ID for this entry.
+	 */
+	StationID GetStation() const {return this->station;}
+
+	/**
+	 * Get the cargo ID for this entry.
+	 */
+	CargoID GetCargo() const {return this->cargo;}
+
+	/**
+	 * Get the cargo count for this entry.
+	 */
+	uint GetCount() const {return this->count;}
+
+	/**
+	 * Get the parent entry for this entry.
+	 */
+	CargoDataEntry *GetParent() const {return this->parent;}
+
+	/**
+	 * Get the number of children for this entry.
+	 */
+	uint GetNumChildren() const {return this->num_children;}
+
+	/**
+	 * Get an iterator pointing to the begin of the set of children.
+	 */
+	CargoDataSet::iterator Begin() const {return this->children->begin();}
+
+	/**
+	 * Get an iterator pointing to the end of the set of children.
+	 */
+	CargoDataSet::iterator End() const {return this->children->end();}
+
+	void Clear();
+private:
+
+	CargoDataEntry(StationID st, uint c, CargoDataEntry *p);
+	CargoDataEntry(CargoID car, uint c, CargoDataEntry *p);
+	CargoDataEntry(StationID st);
+	CargoDataEntry(CargoID car);
+
+	CargoDataEntry *Retrieve(CargoDataSet::iterator i) const;
+
+	template<class ID>
+	CargoDataEntry *InsertOrRetrieve(ID s);
+
+	void Remove(CargoDataEntry *comp);
+	void IncrementSize();
+
+	CargoDataEntry *parent;   ///< the parent of this entry
+	const union {
+		StationID station;    ///< ID of the station this entry is associated with
+		CargoID cargo;        ///< ID of the cargo this entry is associated with
+	};
+	uint num_children;        ///< the number of subentries belonging to this entry
+	uint count;               ///< sum of counts of all children or amount of cargo for this entry
+	CargoDataSet *children;   ///< the children of this entry
+};
+
 #endif /* STATION_GUI_H */
diff --git a/src/station_type.h b/src/station_type.h
index d6084d7..3223082 100644
--- a/src/station_type.h
+++ b/src/station_type.h
@@ -14,6 +14,7 @@
 
 #include "core/smallvec_type.hpp"
 #include "tilearea_type.h"
+#include <list>
 
 typedef uint16 StationID;
 typedef uint16 RoadStopID;
@@ -88,6 +89,9 @@ enum CatchmentArea {
 static const uint MAX_LENGTH_STATION_NAME_CHARS  =  32; ///< The maximum length of a station name in characters including '\0'
 static const uint MAX_LENGTH_STATION_NAME_PIXELS = 180; ///< The maximum length of a station name in pixels
 
+/** List of station IDs */
+typedef std::list<StationID> StationIDList;
+
 /** List of stations */
 typedef SmallVector<Station *, 2> StationList;
 
diff --git a/src/table/settings.ini b/src/table/settings.ini
index 36db523..15762b8 100644
--- a/src/table/settings.ini
+++ b/src/table/settings.ini
@@ -514,6 +514,115 @@ guiflags = SGF_NO_NETWORK
 def      = true
 str      = STR_CONFIG_SETTING_ALLOW_TOWN_LEVEL_CROSSINGS
 
+; link graph
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.recalc_interval
+type     = SLE_UINT16
+from     = SL_COMPONENTS
+def      = 16
+min      = 1
+max      = 4096
+interval = 1
+str      = STR_CONFIG_SETTING_LINKGRAPH_INTERVAL
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_pax
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_PAX
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_mail
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_MAIL
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_armoured
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_default
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_ASYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.accuracy
+type     = SLE_UINT8
+from     = SL_DEMANDS
+def      = 16
+min      = 2
+max      = 64
+interval = 1
+str      = STR_CONFIG_SETTING_LINKGRAPH_ACCURACY
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.demand_distance
+type     = SLE_UINT8
+from     = SL_DEMANDS
+def      = 100
+min      = 0
+max      = 255
+interval = 5
+str      = STR_CONFIG_SETTING_DEMAND_DISTANCE
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.demand_size
+type     = SLE_UINT8
+from     = SL_DEMANDS
+def      = 100
+min      = 0
+max      = 100
+interval = 5
+str      = STR_CONFIG_SETTING_DEMAND_SIZE
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.short_path_saturation
+type     = SLE_UINT8
+from     = SL_MCF
+def      = 80
+min      = 0
+max      = 250
+interval = 5
+str      = STR_CONFIG_SETTING_SHORT_PATH_SATURATION
+
 ; Vehicles
 
 [SDT_VAR]
@@ -2351,6 +2460,32 @@ def      = false
 str      = STR_CONFIG_SETTING_EXPENSES_LAYOUT
 proc     = RedrawScreen
 
+[SDTC_VAR]
+var      = gui.station_gui_group_order
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = 0
+min      = 0
+max      = 5
+interval = 1
+
+[SDTC_VAR]
+var      = gui.station_gui_sort_by
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = 0
+min      = 0
+max      = 3
+interval = 1
+
+[SDTC_VAR]
+var      = gui.station_gui_sort_order
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = 0
+min      = 0
+max      = 1
+interval = 1
 
 ; For the dedicated build we'll enable dates in logs by default.
 [SDTC_BOOL]
diff --git a/src/texteff.cpp b/src/texteff.cpp
index 0feb522..644b281 100644
--- a/src/texteff.cpp
+++ b/src/texteff.cpp
@@ -20,6 +20,7 @@
 /** Container for all information about a text effect */
 struct TextEffect : public ViewportSign {
 	uint64 params_1;     ///< DParam parameter
+	uint64 params_2;     ///< second DParam parameter
 	StringID string_id;  ///< String to draw for the text effect, if INVALID_STRING_ID then it's not valid
 	uint8 duration;      ///< How long the text effect should stay, in ticks (applies only when mode == TE_RISING)
 	TextEffectMode mode; ///< Type of text effect
@@ -52,6 +53,7 @@ TextEffectID AddTextEffect(StringID msg, int center, int y, uint8 duration, Text
 	te->string_id = msg;
 	te->duration = duration;
 	te->params_1 = GetDParam(0);
+	te->params_2 = GetDParam(1);
 	te->mode = mode;
 
 	/* Make sure we only dirty the new area */
@@ -67,6 +69,7 @@ void UpdateTextEffect(TextEffectID te_id, StringID msg)
 	TextEffect *te = _text_effects.Get(te_id);
 	te->string_id = msg;
 	te->params_1 = GetDParam(0);
+	te->params_2 = GetDParam(1);
 
 	te->UpdatePosition(te->center, te->top, msg);
 }
@@ -108,7 +111,7 @@ void DrawTextEffects(DrawPixelInfo *dpi)
 	for (TextEffect *te = _text_effects.Begin(); te != end; te++) {
 		if (te->string_id == INVALID_STRING_ID) continue;
 		if (te->mode == TE_RISING || (_settings_client.gui.loading_indicators && !IsTransparencySet(TO_LOADING))) {
-			ViewportAddString(dpi, ZOOM_LVL_OUT_2X, te, te->string_id, te->string_id - 1, 0, te->params_1);
+			ViewportAddString(dpi, ZOOM_LVL_OUT_2X, te, te->string_id, te->string_id - 1, 0, te->params_1, te->params_2);
 		}
 	}
 }
diff --git a/src/texteff.hpp b/src/texteff.hpp
index b9762c3..9ef74c1 100644
--- a/src/texteff.hpp
+++ b/src/texteff.hpp
@@ -41,6 +41,6 @@ void UpdateFillingPercent(TextEffectID te_id, uint8 percent, StringID colour);
 void HideFillingPercent(TextEffectID *te_id);
 
 void ShowCostOrIncomeAnimation(int x, int y, int z, Money cost);
-void ShowFeederIncomeAnimation(int x, int y, int z, Money cost);
+void ShowFeederIncomeAnimation(int x, int y, int z, Money transfer, Money income);
 
 #endif /* TEXTEFF_HPP */
diff --git a/src/toolbar_gui.cpp b/src/toolbar_gui.cpp
index 711b738..3008af2 100644
--- a/src/toolbar_gui.cpp
+++ b/src/toolbar_gui.cpp
@@ -39,6 +39,7 @@
 #include "smallmap_gui.h"
 #include "graph_gui.h"
 #include "textbuf_gui.h"
+#include "linkgraph_gui.h"
 #include "newgrf_debug.h"
 #include "hotkeys.h"
 #include "engine_base.h"
@@ -407,10 +408,11 @@ static CallBackFunction MenuClickSaveLoad(int index = 0)
 enum MapMenuEntries {
 	MME_SHOW_SMALLMAP        = 0,
 	MME_SHOW_EXTRAVIEWPORTS,
+	MME_SHOW_LINKGRAPH,
 	MME_SHOW_SIGNLISTS,
 	MME_SHOW_TOWNDIRECTORY,    ///< This entry is only used in Editor mode
-	MME_MENUCOUNT_NORMAL     = 3,
-	MME_MENUCOUNT_EDITOR     = 4,
+	MME_MENUCOUNT_NORMAL     = 4,
+	MME_MENUCOUNT_EDITOR     = 5,
 };
 
 static CallBackFunction ToolbarMapClick(Window *w)
@@ -430,6 +432,7 @@ static CallBackFunction MenuClickMap(int index)
 	switch (index) {
 		case MME_SHOW_SMALLMAP:       ShowSmallMap();            break;
 		case MME_SHOW_EXTRAVIEWPORTS: ShowExtraViewPortWindow(); break;
+		case MME_SHOW_LINKGRAPH:      ShowLinkGraphLegend();     break;
 		case MME_SHOW_SIGNLISTS:      ShowSignList();            break;
 		case MME_SHOW_TOWNDIRECTORY:  if (_game_mode == GM_EDITOR) ShowTownDirectory(); break;
 	}
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
index 100b467..5c4330b 100644
--- a/src/train_cmd.cpp
+++ b/src/train_cmd.cpp
@@ -704,6 +704,7 @@ CommandCost CmdBuildRailVehicle(TileIndex tile, DoCommandFlag flags, const Engin
 		v->cargo_type = e->GetDefaultCargoType();
 		v->cargo_cap = rvi->capacity;
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 
 		v->engine_type = e->index;
 		v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index e3ffbbc..44b5365 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -670,10 +670,11 @@ void Vehicle::PreDestructor()
 	if (CleaningPool()) return;
 
 	if (Station::IsValidID(this->last_station_visited)) {
-		Station::Get(this->last_station_visited)->loading_vehicles.remove(this);
+		Station *st = Station::Get(this->last_station_visited);
+		st->loading_vehicles.remove(this);
 
 		HideFillingPercent(&this->fill_percent_te_id);
-
+		this->CancelReservation(INVALID_STATION, st);
 		delete this->cargo_payment;
 	}
 
@@ -1176,7 +1177,7 @@ uint8 CalcPercentVehicleFilled(const Vehicle *v, StringID *colour)
 
 	/* Count up max and used */
 	for (; v != NULL; v = v->Next()) {
-		count += v->cargo.Count();
+		count += v->cargo.OnboardCount();
 		max += v->cargo_cap;
 		if (v->cargo_cap != 0 && colour != NULL) {
 			unloading += HasBit(v->vehicle_flags, VF_CARGO_UNLOADING) ? 1 : 0;
@@ -1859,9 +1860,14 @@ void Vehicle::BeginLoading()
 		this->current_order.MakeLoading(false);
 	}
 
-	Station::Get(this->last_station_visited)->loading_vehicles.push_back(this);
+	Station *curr_station = Station::Get(this->last_station_visited);
+	curr_station->loading_vehicles.push_back(this);
+
+	if (this->last_loading_station != INVALID_STATION && this->last_loading_station != this->last_station_visited) {
+		IncreaseStats(Station::Get(this->last_loading_station), this, this->last_station_visited);
+	}
 
-	PrepareUnload(this);
+	PrepareUnload(curr_station, this);
 
 	SetWindowDirty(GetWindowClassForVehicleType(this->type), this->owner);
 	SetWindowWidgetDirty(WC_VEHICLE_VIEW, this->index, VVW_WIDGET_START_STOP_VEH);
@@ -1874,6 +1880,23 @@ void Vehicle::BeginLoading()
 }
 
 /**
+ * Return all reserved cargo packets to the station.
+ * @param st the station where the reserved packets should go.
+ */
+void Vehicle::CancelReservation(StationID next, Station *st)
+{
+	for (Vehicle *v = this; v != NULL; v = v->next) {
+		VehicleCargoList &cargo = v->cargo;
+		if (cargo.ReservedCount() > 0) {
+			DEBUG(misc, 1, "cancelling cargo reservation");
+			GoodsEntry &ge = st->goods[v->cargo_type];
+			cargo.Unreserve(next, &ge.cargo);
+			SetBit(ge.acceptance_pickup, GoodsEntry::PICKUP);
+		}
+	}
+}
+
+/**
  * Perform all actions when leaving a station.
  * @pre this->current_order.IsType(OT_LOADING)
  */
@@ -1890,6 +1913,21 @@ void Vehicle::LeaveStation()
 	Station *st = Station::Get(this->last_station_visited);
 	st->loading_vehicles.remove(this);
 
+	this->CancelReservation(INVALID_STATION, st);
+
+	if ((this->current_order.GetLoadType() & OLFB_NO_LOAD) == 0 ||
+			(this->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
+		if (this->current_order.CanLeaveWithCargo(this->last_loading_station != INVALID_STATION)) {
+			/* if the vehicle could load here or could stop with cargo loaded set the last loading station */
+			this->last_loading_station = this->last_station_visited;
+		} else {
+			/* if the vehicle couldn't load and had to unload or transfer everything
+			 * set the last loading station to invalid as it will leave empty.
+			 */
+			this->last_loading_station = INVALID_STATION;
+		}
+	}
+
 	HideFillingPercent(&this->fill_percent_te_id);
 
 	if (this->type == VEH_TRAIN && !(this->vehstatus & VS_CRASHED)) {
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index baf99d3..a3df2c9 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -126,6 +126,7 @@ private:
 
 	Vehicle *next_shared;               ///< pointer to the next vehicle that shares the order
 	Vehicle *previous_shared;           ///< NOSAVE: pointer to the previous vehicle in the shared order chain
+
 public:
 	friend const SaveLoad *GetVehicleDescription(VehicleType vt); ///< So we can use private/protected variables in the saveload code
 	friend void FixOldVehicles();
@@ -208,6 +209,7 @@ public:
 	byte waiting_triggers;              ///< Triggers to be yet matched before rerandomizing the random bits.
 
 	StationID last_station_visited;     ///< The last station we stopped at.
+	StationID last_loading_station;     ///< Last station the vehicle has stopped at and could possibly leave from with any cargo loaded.
 
 	CargoID cargo_type;                 ///< type of cargo this vehicle is carrying
 	byte cargo_subtype;                 ///< Used for livery refits (NewGRF variations)
@@ -244,6 +246,7 @@ public:
 	virtual ~Vehicle();
 
 	void BeginLoading();
+	void CancelReservation(StationID next, Station *st);
 	void LeaveStation();
 
 	GroundVehicleCache *GetGroundVehicleCache();
diff --git a/src/viewport.cpp b/src/viewport.cpp
index 1360064..09adf6c 100644
--- a/src/viewport.cpp
+++ b/src/viewport.cpp
@@ -45,6 +45,7 @@
 #include "window_func.h"
 #include "tilehighlight_func.h"
 #include "window_gui.h"
+#include "linkgraph_gui.h"
 
 #include "table/strings.h"
 
@@ -213,6 +214,8 @@ void InitializeWindowViewport(Window *w, int x, int y,
 	vp->dest_scrollpos_x = pt.x;
 	vp->dest_scrollpos_y = pt.y;
 
+	vp->overlay = NULL;
+
 	w->viewport = vp;
 	vp->virtual_left = 0;//pt.x;
 	vp->virtual_top = 0;//pt.y;
@@ -1353,22 +1356,8 @@ static void ViewportDrawBoundingBoxes(const ParentSpriteToSortVector *psd)
 	}
 }
 
-static void ViewportDrawStrings(DrawPixelInfo *dpi, const StringSpriteToDrawVector *sstdv)
+static void ViewportDrawStrings(ZoomLevel zoom, const StringSpriteToDrawVector *sstdv)
 {
-	DrawPixelInfo dp;
-	ZoomLevel zoom;
-
-	_cur_dpi = &dp;
-	dp = *dpi;
-
-	zoom = dp.zoom;
-	dp.zoom = ZOOM_LVL_NORMAL;
-
-	dp.left   = UnScaleByZoom(dp.left,   zoom);
-	dp.top    = UnScaleByZoom(dp.top,    zoom);
-	dp.width  = UnScaleByZoom(dp.width,  zoom);
-	dp.height = UnScaleByZoom(dp.height, zoom);
-
 	const StringSpriteToDraw *ssend = sstdv->End();
 	for (const StringSpriteToDraw *ss = sstdv->Begin(); ss != ssend; ++ss) {
 		TextColour colour = TC_BLACK;
@@ -1450,7 +1439,24 @@ void ViewportDoDraw(const ViewPort *vp, int left, int top, int right, int bottom
 
 	if (_draw_bounding_boxes) ViewportDrawBoundingBoxes(&_vd.parent_sprites_to_sort);
 
-	if (_vd.string_sprites_to_draw.Length() != 0) ViewportDrawStrings(&_vd.dpi, &_vd.string_sprites_to_draw);
+	DrawPixelInfo dp = _vd.dpi;
+	ZoomLevel zoom = _vd.dpi.zoom;
+	dp.zoom = ZOOM_LVL_NORMAL;
+	dp.width = UnScaleByZoom(dp.width, zoom);
+	dp.height = UnScaleByZoom(dp.height, zoom);
+	_cur_dpi = &dp;
+
+	/* translate to window coordinates */
+	dp.left = x;
+	dp.top = y;
+
+	if (vp->overlay != NULL) vp->overlay->Draw(&dp);
+
+	/* translate back to world coordinates */
+	dp.left = UnScaleByZoom(_vd.dpi.left, zoom);
+	dp.top = UnScaleByZoom(_vd.dpi.top, zoom);
+
+	if (_vd.string_sprites_to_draw.Length() != 0) ViewportDrawStrings(zoom, &_vd.string_sprites_to_draw);
 
 	_cur_dpi = old_dpi;
 
@@ -1566,6 +1572,7 @@ void UpdateViewportPosition(Window *w)
 		int delta_x = w->viewport->dest_scrollpos_x - w->viewport->scrollpos_x;
 		int delta_y = w->viewport->dest_scrollpos_y - w->viewport->scrollpos_y;
 
+		bool update_overlay = false;
 		if (delta_x != 0 || delta_y != 0) {
 			if (_settings_client.gui.smooth_scroll) {
 				int max_scroll = ScaleByMapSize1D(512);
@@ -1576,11 +1583,14 @@ void UpdateViewportPosition(Window *w)
 				w->viewport->scrollpos_x = w->viewport->dest_scrollpos_x;
 				w->viewport->scrollpos_y = w->viewport->dest_scrollpos_y;
 			}
+			update_overlay = (w->viewport->scrollpos_x == w->viewport->dest_scrollpos_x &&
+								w->viewport->scrollpos_y == w->viewport->dest_scrollpos_y);
 		}
 
 		ClampViewportToMap(vp, w->viewport->scrollpos_x, w->viewport->scrollpos_y);
 
 		SetViewportPosition(w, w->viewport->scrollpos_x, w->viewport->scrollpos_y);
+		if (update_overlay) RebuildViewportOverlay(w);
 	}
 }
 
@@ -1914,6 +1924,15 @@ bool HandleViewportClicked(const ViewPort *vp, int x, int y)
 	return result;
 }
 
+void RebuildViewportOverlay(Window *w)
+{
+	if (w->viewport->overlay != NULL &&
+			w->viewport->overlay->GetCompanyMask() != 0 &&
+			w->viewport->overlay->GetCargoMask() != 0) {
+		w->viewport->overlay->RebuildCache();
+		w->SetDirty();
+	}
+}
 
 /**
  * Scrolls the viewport in a window to a given location.
@@ -1937,6 +1956,7 @@ bool ScrollWindowTo(int x, int y, int z, Window *w, bool instant)
 	if (instant) {
 		w->viewport->scrollpos_x = pt.x;
 		w->viewport->scrollpos_y = pt.y;
+		RebuildViewportOverlay(w);
 	}
 
 	w->viewport->dest_scrollpos_x = pt.x;
@@ -2890,3 +2910,15 @@ void ResetObjectToPlace()
 {
 	SetObjectToPlace(SPR_CURSOR_MOUSE, PAL_NONE, HT_NONE, WC_MAIN_WINDOW, 0);
 }
+
+Point GetViewportStationMiddle(const ViewPort *vp, const Station *st)
+{
+	int x = TileX(st->xy) * TILE_SIZE;
+	int y = TileY(st->xy) * TILE_SIZE;
+	int z = GetSlopeZ(Clamp(x, 0, MapSizeX() * TILE_SIZE - 1), Clamp(y, 0, MapSizeY() * TILE_SIZE - 1));
+
+	Point p = RemapCoords(x, y, z);
+	p.x = UnScaleByZoom(p.x - vp->virtual_left, vp->zoom) + vp->left;
+	p.y = UnScaleByZoom(p.y - vp->virtual_top, vp->zoom) + vp->top;
+	return p;
+}
diff --git a/src/viewport_func.h b/src/viewport_func.h
index 7faa173..213138d 100644
--- a/src/viewport_func.h
+++ b/src/viewport_func.h
@@ -16,6 +16,7 @@
 #include "viewport_type.h"
 #include "window_type.h"
 #include "tile_type.h"
+#include "station_type.h"
 
 static const int TILE_HEIGHT_STEP = 50; ///< One Z unit tile height difference is displayed as 50m.
 
@@ -67,6 +68,8 @@ void ViewportDoDraw(const ViewPort *vp, int left, int top, int right, int bottom
 bool ScrollWindowToTile(TileIndex tile, Window *w, bool instant = false);
 bool ScrollWindowTo(int x, int y, int z, Window *w, bool instant = false);
 
+void RebuildViewportOverlay(Window *w);
+
 bool ScrollMainWindowToTile(TileIndex tile, bool instant = false);
 bool ScrollMainWindowTo(int x, int y, int z = -1, bool instant = false);
 
@@ -76,4 +79,6 @@ extern Point _tile_fract_coords;
 
 void MarkTileDirtyByTile(TileIndex tile);
 
+Point GetViewportStationMiddle(const ViewPort *vp, const Station *st);
+
 #endif /* VIEWPORT_FUNC_H */
diff --git a/src/viewport_type.h b/src/viewport_type.h
index 9fbd927..6974fce 100644
--- a/src/viewport_type.h
+++ b/src/viewport_type.h
@@ -15,6 +15,8 @@
 #include "zoom_type.h"
 #include "strings_type.h"
 
+class LinkGraphOverlay;
+
 /**
  * Data structure for viewport, display of a part of the world
  */
@@ -30,6 +32,7 @@ struct ViewPort {
 	int virtual_height;  ///< height << zoom
 
 	ZoomLevel zoom;
+	LinkGraphOverlay *overlay;
 };
 
 /** Margings for the viewport sign */
diff --git a/src/window_type.h b/src/window_type.h
index 458ba70..2102bf7 100644
--- a/src/window_type.h
+++ b/src/window_type.h
@@ -111,6 +111,7 @@ enum WindowClass {
 	WC_INDUSTRY_CARGOES,
 	WC_GRF_PARAMETERS,
 	WC_BUILD_OBJECT,
+	WC_LINKGRAPH_LEGEND,
 
 	WC_INVALID = 0xFFFF
 };
