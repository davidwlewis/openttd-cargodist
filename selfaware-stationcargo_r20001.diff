diff --git a/src/cargopacket.cpp b/src/cargopacket.cpp
index 418eb8e..2541312 100644
--- a/src/cargopacket.cpp
+++ b/src/cargopacket.cpp
@@ -282,6 +282,20 @@ void VehicleCargoList::InvalidateCache()
 	this->Parent::InvalidateCache();
 }
 
+/**
+ * Assign the cargo list to a goods entry.
+ * @param station the station the cargo list is assigned to
+ * @param cargo the cargo the list is assigned to
+ */
+void StationCargoList::AssignTo(Station *station, CargoID cargo)
+{
+	assert(this->station == NULL);
+	assert(station != NULL && cargo != INVALID_CARGO);
+	this->station = station;
+	this->cargo = cargo;
+}
+
+
 /*
  * We have to instantiate everything we want to be usable.
  */
diff --git a/src/cargopacket.h b/src/cargopacket.h
index dfd5e72..9d1e29e 100644
--- a/src/cargopacket.h
+++ b/src/cargopacket.h
@@ -16,6 +16,7 @@
 #include "economy_type.h"
 #include "station_type.h"
 #include "cargo_type.h"
+#include "cargotype.h"
 #include "vehicle_type.h"
 #include <list>
 
@@ -395,6 +396,8 @@ public:
 	/** The stations, via GoodsEntry, have a CargoList. */
 	friend const struct SaveLoad *GetGoodsDesc();
 
+	StationCargoList() : station(NULL), cargo(INVALID_CARGO) {}
+
 	/**
 	 * Are two the two CargoPackets mergeable in the context of
 	 * a list of CargoPackets for a Vehicle?
@@ -409,6 +412,12 @@ public:
 				cp1->source_type     == cp2->source_type &&
 				cp1->source_id       == cp2->source_id;
 	}
+
+	void AssignTo(Station *station, CargoID cargo);
+
+private:
+	Station *station;
+	CargoID cargo;
 };
 
 #endif /* CARGOPACKET_H */
diff --git a/src/station.cpp b/src/station.cpp
index 26305cd..e5322ca 100644
--- a/src/station.cpp
+++ b/src/station.cpp
@@ -60,6 +60,11 @@ Station::Station(TileIndex tile) :
 	last_vehicle_type(VEH_INVALID)
 {
 	/* this->random_bits is set in Station::AddFacility() */
+
+	/* has to be done like this as we can't give arguments when constructing an array */
+	for (CargoID i = 0; i < NUM_CARGO; ++i) {
+		this->goods[i].cargo.AssignTo(this, i);
+	}
 }
 
 /**
