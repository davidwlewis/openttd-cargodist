diff --git a/src/order_base.h b/src/order_base.h
index fccc802..c13cf59 100644
--- a/src/order_base.h
+++ b/src/order_base.h
@@ -124,6 +124,12 @@ public:
 	void MakeConditional(VehicleOrderID order);
 
 	/**
+	 * Makes this order an automatic order.
+	 * @param destination the station to go to.
+	 */
+	void MakeAutomatic(StationID destination);
+
+	/**
 	 * Gets the destination of this order.
 	 * @pre IsType(OT_GOTO_WAYPOINT) || IsType(OT_GOTO_DEPOT) || IsType(OT_GOTO_STATION).
 	 * @return the destination of the order.
@@ -270,6 +276,13 @@ private:
 
 	Ticks timetable_duration;       ///< NOSAVE: Total duration of the order list
 
+	/**
+	 * Update the counters and delete the order. Doesn't update order->next or this->first
+	 * @param order the order to be deleted.
+	 * @param index index of the order to be deleted, used to update conditional orders
+	 */
+	void DeleteOrder(Order *order, int index);
+
 public:
 	/** Default constructor producing an invalid order list. */
 	OrderList(VehicleOrderID num_orders = INVALID_VEH_ORDER_ID)
@@ -332,6 +345,13 @@ public:
 	void DeleteOrderAt(int index);
 
 	/**
+	 * Delete all automatic orders between start_index and the next non-automatic one
+	 * @param start_index the first index to look at
+	 * @return the number of orders deleted
+	 */
+	int DeleteAutoOrders(int start_index);
+
+	/**
 	 * Move an order to another position within the order list.
 	 * @param from is the zero-based position of the order to move.
 	 * @param to is the zero-based position where the order is moved to.
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
index ba8d51f..1e4568a 100644
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -99,6 +99,12 @@ void Order::MakeConditional(VehicleOrderID order)
 	this->dest = 0;
 }
 
+void Order::MakeAutomatic(StationID destination)
+{
+	this->type = OT_AUTOMATIC;
+	this->dest = destination;
+}
+
 void Order::SetRefit(CargoID cargo, byte subtype)
 {
 	this->refit_cargo = cargo;
@@ -272,6 +278,26 @@ void OrderList::InsertOrderAt(Order *new_order, int index)
 	}
 	++this->num_orders;
 	this->timetable_duration += new_order->wait_time + new_order->travel_time;
+
+	int next_non_auto = index;
+	while(new_order->IsType(OT_AUTOMATIC) && new_order->next != NULL) {
+		++next_non_auto;
+		new_order = new_order->next;
+	}
+	/* As we insert an order, the order to skip to will be 'wrong'. */
+	VehicleOrderID cur_order_id = 0;
+	for(Order *order = this->first; order != NULL; order = order->next) {
+		if (order->IsType(OT_CONDITIONAL)) {
+			VehicleOrderID order_id = order->GetConditionSkipToOrder();
+			if (order_id >= next_non_auto) {
+				order->SetConditionSkipToOrder(order_id + 1);
+			}
+			if (order_id == cur_order_id) {
+				order->SetConditionSkipToOrder((order_id + 1) % this->num_orders);
+			}
+		}
+		cur_order_id++;
+	}
 }
 
 
@@ -289,9 +315,55 @@ void OrderList::DeleteOrderAt(int index)
 		to_remove = prev->next;
 		prev->next = to_remove->next;
 	}
+	this->DeleteOrder(to_remove, index);
+}
+
+void OrderList::DeleteOrder(Order *order, int index)
+{
+	this->timetable_duration -= (order->wait_time + order->travel_time);
 	--this->num_orders;
-	this->timetable_duration -= (to_remove->wait_time + to_remove->travel_time);
-	delete to_remove;
+	delete order;
+
+	/* As we delete an order, the order to skip to will be 'wrong'. */
+	VehicleOrderID cur_order_id = 0;
+	for(Order *order = this->first; order != NULL; order = order->next) {
+		if (order->IsType(OT_CONDITIONAL)) {
+			VehicleOrderID order_id = order->GetConditionSkipToOrder();
+			if (order_id > index || (order_id == index && !order->IsType(OT_AUTOMATIC)) || order_id == this->num_orders) {
+				order->SetConditionSkipToOrder(max(order_id - 1, 0));
+			}
+			if (order_id == cur_order_id) {
+				order->SetConditionSkipToOrder((order_id + 1) % this->num_orders);
+			}
+		}
+		cur_order_id++;
+	}
+}
+
+int OrderList::DeleteAutoOrders(int start_index)
+{
+	if (start_index >= this->num_orders) return 0;
+
+	int deleted = 0;
+	Order *to_remove;
+
+	if (start_index == 0) {
+		while(this->first != NULL && this->first->IsType(OT_AUTOMATIC)) {
+			to_remove = this->first;
+			this->first = to_remove->next;
+			this->DeleteOrder(to_remove, 0);
+			++deleted;
+		}
+	} else {
+		Order *prev = GetOrderAt(start_index - 1);
+		while(prev->next != NULL && prev->next->IsType(OT_AUTOMATIC)) {
+			to_remove = prev->next;
+			prev->next = to_remove->next;
+			this->DeleteOrder(to_remove, start_index);
+			++deleted;
+		}
+	}
+	return deleted;
 }
 
 void OrderList::MoveOrder(int from, int to)
@@ -319,6 +391,21 @@ void OrderList::MoveOrder(int from, int to)
 		moving_one->next = one_before->next;
 		one_before->next = moving_one;
 	}
+
+	/* As we move an order, the order to skip to will be 'wrong'. */
+	for(Order *order = this->first; order != NULL; order = order->next) {
+		if (order->IsType(OT_CONDITIONAL)) {
+			VehicleOrderID order_id = order->GetConditionSkipToOrder();
+			if (order_id == from) {
+				order_id = to;
+			} else if (order_id > from && order_id <= to) {
+				order_id--;
+			} else if (order_id < from && order_id >= to) {
+				order_id++;
+			}
+			order->SetConditionSkipToOrder(order_id);
+		}
+	}
 }
 
 void OrderList::RemoveVehicle(Vehicle *v)
@@ -689,22 +776,6 @@ CommandCost CmdInsertOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 			InvalidateVehicleOrder(u, INVALID_VEH_ORDER_ID | (sel_ord << 8));
 		}
 
-		/* As we insert an order, the order to skip to will be 'wrong'. */
-		VehicleOrderID cur_order_id = 0;
-		Order *order;
-		FOR_VEHICLE_ORDERS(v, order) {
-			if (order->IsType(OT_CONDITIONAL)) {
-				VehicleOrderID order_id = order->GetConditionSkipToOrder();
-				if (order_id >= sel_ord) {
-					order->SetConditionSkipToOrder(order_id + 1);
-				}
-				if (order_id == cur_order_id) {
-					order->SetConditionSkipToOrder((order_id + 1) % v->GetNumOrders());
-				}
-			}
-			cur_order_id++;
-		}
-
 		/* Make sure to rebuild the whole list */
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
 	}
@@ -778,21 +849,6 @@ CommandCost CmdDeleteOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 			InvalidateVehicleOrder(u, sel_ord | (INVALID_VEH_ORDER_ID << 8));
 		}
 
-		/* As we delete an order, the order to skip to will be 'wrong'. */
-		VehicleOrderID cur_order_id = 0;
-		FOR_VEHICLE_ORDERS(v, order) {
-			if (order->IsType(OT_CONDITIONAL)) {
-				VehicleOrderID order_id = order->GetConditionSkipToOrder();
-				if (order_id >= sel_ord) {
-					order->SetConditionSkipToOrder(max(order_id - 1, 0));
-				}
-				if (order_id == cur_order_id) {
-					order->SetConditionSkipToOrder((order_id + 1) % v->GetNumOrders());
-				}
-			}
-			cur_order_id++;
-		}
-
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
 	}
 
@@ -891,22 +947,6 @@ CommandCost CmdMoveOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 			InvalidateVehicleOrder(u, moving_order | (target_order << 8));
 		}
 
-		/* As we move an order, the order to skip to will be 'wrong'. */
-		Order *order;
-		FOR_VEHICLE_ORDERS(v, order) {
-			if (order->IsType(OT_CONDITIONAL)) {
-				VehicleOrderID order_id = order->GetConditionSkipToOrder();
-				if (order_id == moving_order) {
-					order_id = target_order;
-				} else if (order_id > moving_order && order_id <= target_order) {
-					order_id--;
-				} else if (order_id < moving_order && order_id >= target_order) {
-					order_id++;
-				}
-				order->SetConditionSkipToOrder(order_id);
-			}
-		}
-
 		/* Make sure to rebuild the whole list */
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
 	}
@@ -1637,7 +1677,15 @@ bool UpdateOrderDest(Vehicle *v, const Order *order, int conditional_depth)
 	assert(v->cur_order_index < v->GetNumOrders());
 
 	/* Get the current order */
-	order = v->GetOrder(v->cur_order_index);
+	order = v->GetNextManualOrder(v->cur_order_index);
+	if (order == NULL) {
+		order = v->GetNextManualOrder(0);
+		if (order == NULL) {
+			v->current_order.Free();
+			v->dest_tile = 0;
+			return false;
+		}
+	}
 	v->current_order = *order;
 	return UpdateOrderDest(v, order, conditional_depth + 1);
 }
@@ -1692,7 +1740,7 @@ bool ProcessOrders(Vehicle *v)
 	/* Get the current order */
 	if (v->cur_order_index >= v->GetNumOrders()) v->cur_order_index = 0;
 
-	const Order *order = v->GetOrder(v->cur_order_index);
+	const Order *order = v->GetNextManualOrder(v->cur_order_index);
 
 	/* If no order, do nothing. */
 	if (order == NULL || (v->type == VEH_AIRCRAFT && !CheckForValidOrders(v))) {
diff --git a/src/order_gui.cpp b/src/order_gui.cpp
index a3ed0ce..c6b1101 100644
--- a/src/order_gui.cpp
+++ b/src/order_gui.cpp
@@ -200,8 +200,15 @@ void DrawOrderString(const Vehicle *v, const Order *order, int order_index, int
 		DrawSprite(sprite, PAL_NONE, rtl ? right - sprite_size.width : left, y + ((int)FONT_HEIGHT_NORMAL - (int)sprite_size.height) / 2);
 	}
 
+	TextColour colour = TC_BLACK;
+	if (order->IsType(OT_AUTOMATIC)) {
+		colour =  selected ? TC_SILVER : TC_GREY;
+	} else if (selected) {
+		colour = TC_WHITE;
+	}
+
 	SetDParam(0, order_index + 1);
-	DrawString(left, rtl ? right - sprite_size.width - 3 : middle, y, STR_ORDER_INDEX, selected ? TC_WHITE : TC_BLACK, SA_RIGHT | SA_FORCE);
+	DrawString(left, rtl ? right - sprite_size.width - 3 : middle, y, STR_ORDER_INDEX, colour, SA_RIGHT | SA_FORCE);
 
 	SetDParam(5, STR_EMPTY);
 
@@ -211,6 +218,13 @@ void DrawOrderString(const Vehicle *v, const Order *order, int order_index, int
 			SetDParam(1, order->GetDestination());
 			break;
 
+		case OT_AUTOMATIC:
+			SetDParam(0, STR_ORDER_GO_TO_STATION);
+			SetDParam(1, STR_ORDER_GO_TO);
+			SetDParam(2, order->GetDestination());
+			SetDParam(3, STR_EMPTY);
+			break;
+
 		case OT_GOTO_STATION: {
 			OrderLoadFlags load = order->GetLoadType();
 			OrderUnloadFlags unload = order->GetUnloadType();
@@ -298,7 +312,7 @@ void DrawOrderString(const Vehicle *v, const Order *order, int order_index, int
 		default: NOT_REACHED();
 	}
 
-	DrawString(rtl ? left : middle, rtl ? middle : right, y, STR_ORDER_TEXT, selected ? TC_WHITE : TC_BLACK);
+	DrawString(rtl ? left : middle, rtl ? middle : right, y, STR_ORDER_TEXT, colour);
 }
 
 
@@ -1352,8 +1366,8 @@ public:
 			this->goto_type = OPOS_GOTO;
 			NWidgetBase *nwid = this->GetWidget<NWidgetBase>(ORDER_WIDGET_ORDER_LIST);
 			if (IsInsideBS(_cursor.pos.x, this->left + nwid->pos_x, nwid->current_x) && IsInsideBS(_cursor.pos.y, this->top + nwid->pos_y, nwid->current_y)) {
-				int order_id = this->GetOrderFromPt(_cursor.pos.y - this->top);
-				if (order_id != INVALID_ORDER) {
+				VehicleOrderID order_id = this->GetOrderFromPt(_cursor.pos.y - this->top);
+				if (order_id != INVALID_VEH_ORDER_ID) {
 					Order order;
 					order.next = NULL;
 					order.index = 0;
diff --git a/src/order_type.h b/src/order_type.h
index 7b252ad..6d9b0f0 100644
--- a/src/order_type.h
+++ b/src/order_type.h
@@ -38,6 +38,7 @@ enum OrderType {
 	OT_DUMMY         = 5,
 	OT_GOTO_WAYPOINT = 6,
 	OT_CONDITIONAL   = 7,
+	OT_AUTOMATIC     = 8,
 	OT_END
 };
 
diff --git a/src/timetable_cmd.cpp b/src/timetable_cmd.cpp
index 0f8fc39..12d68de 100644
--- a/src/timetable_cmd.cpp
+++ b/src/timetable_cmd.cpp
@@ -242,7 +242,7 @@ void UpdateVehicleTimetable(Vehicle *v, bool travelling)
 	bool just_started = false;
 
 	/* This vehicle is arriving at the first destination in the timetable. */
-	if (v->cur_order_index == 0 && travelling) {
+	if (!v->current_order.IsType(OT_AUTOMATIC) && v->cur_order_index == 0 && travelling) {
 		/* If the start date hasn't been set, or it was set automatically when
 		 * the vehicle last arrived at the first destination, update it to the
 		 * current time. Otherwise set the late counter appropriately to when
@@ -270,7 +270,7 @@ void UpdateVehicleTimetable(Vehicle *v, bool travelling)
 
 		/* Modify station waiting time only if our new value is larger (this is
 		 * always the case when we cleared the timetable). */
-		if (!v->current_order.IsType(OT_CONDITIONAL) && (travelling || time_taken > v->current_order.wait_time)) {
+		if (!v->current_order.IsType(OT_AUTOMATIC) && !v->current_order.IsType(OT_CONDITIONAL) && (travelling || time_taken > v->current_order.wait_time)) {
 			/* Round the time taken up to the nearest day, as this will avoid
 			 * confusion for people who are timetabling in days, and can be
 			 * adjusted later by people who aren't. */
@@ -279,7 +279,7 @@ void UpdateVehicleTimetable(Vehicle *v, bool travelling)
 			ChangeTimetable(v, v->cur_order_index, time_taken, travelling);
 		}
 
-		if (v->cur_order_index == 0 && travelling) {
+		if (!v->current_order.IsType(OT_AUTOMATIC) && v->cur_order_index == 0 && travelling) {
 			/* If we just started we would have returned earlier and have not reached
 			 * this code. So obviously, we have completed our round: So turn autofill
 			 * off again. */
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index cb915a6..1a0d1fd 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -1231,7 +1231,7 @@ void VehicleEnterDepot(Vehicle *v)
 	if (v->current_order.IsType(OT_GOTO_DEPOT)) {
 		SetWindowDirty(WC_VEHICLE_VIEW, v->index);
 
-		const Order *real_order = v->GetOrder(v->cur_order_index);
+		const Order *real_order = v->GetNextManualOrder(v->cur_order_index);
 		Order t = v->current_order;
 		v->current_order.MakeDummy();
 
@@ -1742,6 +1742,8 @@ void Vehicle::BeginLoading()
 {
 	assert(IsTileType(tile, MP_STATION) || type == VEH_SHIP);
 
+	int from = 0;
+	int to = 0;
 	if (this->current_order.IsType(OT_GOTO_STATION) &&
 			this->current_order.GetDestination() == this->last_station_visited) {
 		current_order.MakeLoading(true);
@@ -1753,11 +1755,33 @@ void Vehicle::BeginLoading()
 		 * whether the train is lost or not; not marking a train lost
 		 * that arrives at random stations is bad. */
 		this->current_order.SetNonStopType(ONSF_NO_STOP_AT_ANY_STATION);
-
+		if (this->orders.list->DeleteAutoOrders(this->cur_order_index) > 0) {
+			from = this->cur_order_index;
+			to = INVALID_VEH_ORDER_ID;
+		}
 	} else {
+		Order *in_list = this->GetOrder(this->cur_order_index);
+		if (in_list && in_list->IsType(OT_AUTOMATIC)) {
+			if (in_list->GetDestination() != this->last_station_visited) {
+				in_list->MakeAutomatic(this->last_station_visited);
+				from = -2;
+			}
+		} else {
+			Order *auto_order = new Order();
+			auto_order->MakeAutomatic(this->last_station_visited);
+			this->orders.list->InsertOrderAt(auto_order, this->cur_order_index);
+			from = INVALID_VEH_ORDER_ID;
+			to = this->cur_order_index;
+		}
 		current_order.MakeLoading(false);
 	}
 
+	if (from != 0 || to != 0) {
+		for (Vehicle *u = this->FirstShared(); u != NULL; u = u->NextShared()) {
+			InvalidateVehicleOrder(this, from | (to << 8));
+		}
+	}
+
 	Station::Get(this->last_station_visited)->loading_vehicles.push_back(this);
 
 	PrepareUnload(this);
@@ -1812,7 +1836,7 @@ void Vehicle::HandleLoading(bool mode)
 			this->LeaveStation();
 
 			/* If this was not the final order, don't remove it from the list. */
-			if (!at_destination_station) return;
+			if (!at_destination_station) break;
 			break;
 		}
 
@@ -2138,6 +2162,20 @@ void Vehicle::RemoveFromShared()
 	this->previous_shared = NULL;
 }
 
+/**
+ * Get the next manual (not OT_AUTOMATIC) order after the one at the given index.
+ * @param index the index to start searching at
+ * @return the next manual order at or after index or NULL if there is none.
+ */
+Order *Vehicle::GetNextManualOrder(int index) const
+{
+	Order *order = this->GetOrder(index);
+	while(order != NULL && order->IsType(OT_AUTOMATIC)) {
+		order = order->next;
+	}
+	return order;
+}
+
 void StopAllVehicles()
 {
 	Vehicle *v;
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index 381a5e3..2d59c37 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -662,6 +662,8 @@ public:
 		return (this->orders.list == NULL) ? NULL : this->orders.list->GetOrderAt(index);
 	}
 
+	Order *GetNextManualOrder(int index) const;
+
 	/**
 	 * Returns the last order of a vehicle, or NULL if it doesn't exists
 	 * @return last order of a vehicle, if available
