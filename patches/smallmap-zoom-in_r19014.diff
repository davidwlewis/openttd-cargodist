diff --git a/src/blitter/32bpp_anim.cpp b/src/blitter/32bpp_anim.cpp
index 29c0a95..d5de254 100644
--- a/src/blitter/32bpp_anim.cpp
+++ b/src/blitter/32bpp_anim.cpp
@@ -23,8 +23,8 @@ inline void Blitter_32bppAnim::Draw(const Blitter::BlitterParams *bp, ZoomLevel
 {
 	const SpriteData *src = (const SpriteData *)bp->sprite;
 
-	const Colour *src_px = (const Colour *)(src->data + src->offset[zoom][0]);
-	const uint8  *src_n  = (const uint8  *)(src->data + src->offset[zoom][1]);
+	const Colour *src_px = (const Colour *)(src->data + src->offset[zoom - ZOOM_LVL_BLITTER_MIN][0]);
+	const uint8  *src_n  = (const uint8  *)(src->data + src->offset[zoom - ZOOM_LVL_BLITTER_MIN][1]);
 
 	for (uint i = bp->skip_top; i != 0; i--) {
 		src_px = (const Colour *)((const byte *)src_px + *(const uint32 *)src_px);
diff --git a/src/blitter/32bpp_optimized.cpp b/src/blitter/32bpp_optimized.cpp
index 492e4b6..2fa69e2 100644
--- a/src/blitter/32bpp_optimized.cpp
+++ b/src/blitter/32bpp_optimized.cpp
@@ -30,11 +30,11 @@ inline void Blitter_32bppOptimized::Draw(const Blitter::BlitterParams *bp, ZoomL
 
 	/* src_px : each line begins with uint32 n = 'number of bytes in this line',
 	 *          then n times is the Colour struct for this line */
-	const Colour *src_px = (const Colour *)(src->data + src->offset[zoom][0]);
+	const Colour *src_px = (const Colour *)(src->data + src->offset[zoom - ZOOM_LVL_BLITTER_MIN][0]);
 	/* src_n  : each line begins with uint32 n = 'number of bytes in this line',
 	 *          then interleaved stream of 'm' and 'n' channels. 'm' is remap,
 	 *          'n' is number of bytes with the same alpha channel class */
-	const uint8  *src_n  = (const uint8  *)(src->data + src->offset[zoom][1]);
+	const uint8  *src_n  = (const uint8  *)(src->data + src->offset[zoom - ZOOM_LVL_BLITTER_MIN][1]);
 
 	/* skip upper lines in src_px and src_n */
 	for (uint i = bp->skip_top; i != 0; i--) {
@@ -260,7 +260,7 @@ Sprite *Blitter_32bppOptimized::Encode(SpriteLoader::Sprite *sprite, Blitter::Al
 	/* streams of pixels (a, r, g, b channels)
 	 *
 	 * stored in separated stream so data are always aligned on 4B boundary */
-	Colour *dst_px_orig[ZOOM_LVL_COUNT];
+	Colour *dst_px_orig[ZOOM_LVL_BLITTER_COUNT];
 
 	/* interleaved stream of 'm' channel and 'n' channel
 	 * 'n' is number if following pixels with the same alpha channel class
@@ -268,21 +268,22 @@ Sprite *Blitter_32bppOptimized::Encode(SpriteLoader::Sprite *sprite, Blitter::Al
 	 *
 	 * it has to be stored in one stream so fewer registers are used -
 	 * x86 has problems with register allocation even with this solution */
-	uint8  *dst_n_orig[ZOOM_LVL_COUNT];
+	uint8  *dst_n_orig[ZOOM_LVL_BLITTER_COUNT];
 
 	/* lengths of streams */
-	uint32 lengths[ZOOM_LVL_COUNT][2];
+	uint32 lengths[ZOOM_LVL_BLITTER_COUNT][2];
 
-	for (ZoomLevel z = ZOOM_LVL_BEGIN; z < ZOOM_LVL_END; z++) {
-		const SpriteLoader::Sprite *src_orig = ResizeSprite(sprite, z);
+	ZoomLevel zoom_value = ZOOM_LVL_BLITTER_MIN;
+	for (int zoom_index = 0; zoom_index < ZOOM_LVL_BLITTER_COUNT; zoom_index++, zoom_value++) {
+		const SpriteLoader::Sprite *src_orig = ResizeSprite(sprite, zoom_value);
 
 		uint size = src_orig->height * src_orig->width;
 
-		dst_px_orig[z] = CallocT<Colour>(size + src_orig->height * 2);
-		dst_n_orig[z]  = CallocT<uint8>(size * 2 + src_orig->height * 4 * 2);
+		dst_px_orig[zoom_index] = CallocT<Colour>(size + src_orig->height * 2);
+		dst_n_orig[zoom_index]  = CallocT<uint8>(size * 2 + src_orig->height * 4 * 2);
 
-		uint32 *dst_px_ln = (uint32 *)dst_px_orig[z];
-		uint32 *dst_n_ln  = (uint32 *)dst_n_orig[z];
+		uint32 *dst_px_ln = (uint32 *)dst_px_orig[zoom_index];
+		uint32 *dst_n_ln  = (uint32 *)dst_n_orig[zoom_index];
 
 		const SpriteLoader::CommonPixel *src = (const SpriteLoader::CommonPixel *)src_orig->data;
 
@@ -349,15 +350,15 @@ Sprite *Blitter_32bppOptimized::Encode(SpriteLoader::Sprite *sprite, Blitter::Al
 			dst_n_ln =  (uint32 *)dst_n;
 		}
 
-		lengths[z][0] = (byte *)dst_px_ln - (byte *)dst_px_orig[z]; // all are aligned to 4B boundary
-		lengths[z][1] = (byte *)dst_n_ln  - (byte *)dst_n_orig[z];
+		lengths[zoom_index][0] = (byte *)dst_px_ln - (byte *)dst_px_orig[zoom_index]; // all are aligned to 4B boundary
+		lengths[zoom_index][1] = (byte *)dst_n_ln  - (byte *)dst_n_orig[zoom_index];
 
 		free(src_orig->data);
 		free((void *)src_orig);
 	}
 
 	uint len = 0; // total length of data
-	for (ZoomLevel z = ZOOM_LVL_BEGIN; z < ZOOM_LVL_END; z++) {
+	for (int z = 0; z < ZOOM_LVL_BLITTER_COUNT; z++) {
 		len += lengths[z][0] + lengths[z][1];
 	}
 
@@ -370,8 +371,8 @@ Sprite *Blitter_32bppOptimized::Encode(SpriteLoader::Sprite *sprite, Blitter::Al
 
 	SpriteData *dst = (SpriteData *)dest_sprite->data;
 
-	for (ZoomLevel z = ZOOM_LVL_BEGIN; z < ZOOM_LVL_END; z++) {
-		dst->offset[z][0] = z == ZOOM_LVL_BEGIN ? 0 : lengths[z - 1][1] + dst->offset[z - 1][1];
+	for (int z = 0; z < ZOOM_LVL_BLITTER_COUNT; z++) {
+		dst->offset[z][0] = z == 0 ? 0 : lengths[z - 1][1] + dst->offset[z - 1][1];
 		dst->offset[z][1] = lengths[z][0] + dst->offset[z][0];
 
 		memcpy(dst->data + dst->offset[z][0], dst_px_orig[z], lengths[z][0]);
diff --git a/src/blitter/32bpp_optimized.hpp b/src/blitter/32bpp_optimized.hpp
index e516865..29231c5 100644
--- a/src/blitter/32bpp_optimized.hpp
+++ b/src/blitter/32bpp_optimized.hpp
@@ -18,7 +18,7 @@
 class Blitter_32bppOptimized : public Blitter_32bppSimple {
 public:
 	struct SpriteData {
-		uint32 offset[ZOOM_LVL_COUNT][2];
+		uint32 offset[ZOOM_LVL_BLITTER_COUNT][2];
 		byte data[];
 	};
 
diff --git a/src/blitter/8bpp_optimized.cpp b/src/blitter/8bpp_optimized.cpp
index 4cc8667..9d0efc1 100644
--- a/src/blitter/8bpp_optimized.cpp
+++ b/src/blitter/8bpp_optimized.cpp
@@ -20,7 +20,7 @@ void Blitter_8bppOptimized::Draw(Blitter::BlitterParams *bp, BlitterMode mode, Z
 {
 	/* Find the offset of this zoom-level */
 	const SpriteData *sprite_src = (const SpriteData *)bp->sprite;
-	uint offset = sprite_src->offset[zoom];
+	uint offset = sprite_src->offset[zoom - ZOOM_LVL_BLITTER_MIN];
 
 	/* Find where to start reading in the source sprite */
 	const uint8 *src = sprite_src->data + offset;
@@ -113,7 +113,7 @@ Sprite *Blitter_8bppOptimized::Encode(SpriteLoader::Sprite *sprite, Blitter::All
 	/* Make memory for all zoom-levels */
 	uint memory = sizeof(SpriteData);
 
-	for (ZoomLevel i = ZOOM_LVL_BEGIN; i < ZOOM_LVL_END; i++) {
+	for (ZoomLevel i = ZOOM_LVL_BLITTER_MIN; i <= ZOOM_LVL_BLITTER_MAX; i++) {
 		memory += UnScaleByZoom(sprite->height, i) * UnScaleByZoom(sprite->width, i);
 	}
 
@@ -128,15 +128,16 @@ Sprite *Blitter_8bppOptimized::Encode(SpriteLoader::Sprite *sprite, Blitter::All
 	byte *dst = temp_dst->data;
 
 	/* Make the sprites per zoom-level */
-	for (ZoomLevel i = ZOOM_LVL_BEGIN; i < ZOOM_LVL_END; i++) {
+	ZoomLevel zoom_value = ZOOM_LVL_BLITTER_MIN;
+	for (int zoom_index = 0; zoom_index < ZOOM_LVL_BLITTER_COUNT; zoom_index++, zoom_value++) {
 		/* Store the index table */
 		uint offset = dst - temp_dst->data;
-		temp_dst->offset[i] = offset;
+		temp_dst->offset[zoom_index] = offset;
 
 		/* cache values, because compiler can't cache it */
-		int scaled_height = UnScaleByZoom(sprite->height, i);
-		int scaled_width  = UnScaleByZoom(sprite->width,  i);
-		int scaled_1      =   ScaleByZoom(1,              i);
+		int scaled_height = UnScaleByZoom(sprite->height, zoom_value);
+		int scaled_width  = UnScaleByZoom(sprite->width,  zoom_value);
+		int scaled_1      =   ScaleByZoom(1,              zoom_value);
 
 		for (int y = 0; y < scaled_height; y++) {
 			uint trans = 0;
@@ -145,7 +146,7 @@ Sprite *Blitter_8bppOptimized::Encode(SpriteLoader::Sprite *sprite, Blitter::All
 			byte *count_dst = NULL;
 
 			/* Store the scaled image */
-			const SpriteLoader::CommonPixel *src = &sprite->data[ScaleByZoom(y, i) * sprite->width];
+			const SpriteLoader::CommonPixel *src = &sprite->data[ScaleByZoom(y, zoom_value) * sprite->width];
 			const SpriteLoader::CommonPixel *src_end = &src[sprite->width];
 
 			for (int x = 0; x < scaled_width; x++) {
diff --git a/src/blitter/8bpp_optimized.hpp b/src/blitter/8bpp_optimized.hpp
index fbc9457..f10b383 100644
--- a/src/blitter/8bpp_optimized.hpp
+++ b/src/blitter/8bpp_optimized.hpp
@@ -18,8 +18,8 @@
 class Blitter_8bppOptimized : public Blitter_8bppBase {
 public:
 	struct SpriteData {
-		uint32 offset[ZOOM_LVL_COUNT]; ///< offsets (from .data) to streams for different zoom levels
-		byte data[];                   ///< data, all zoomlevels
+		uint32 offset[ZOOM_LVL_BLITTER_COUNT]; ///< offsets (from .data) to streams for different zoom levels
+		byte data[];                           ///< data, all zoomlevels
 	};
 
 	/* virtual */ void Draw(Blitter::BlitterParams *bp, BlitterMode mode, ZoomLevel zoom);
diff --git a/src/main_gui.cpp b/src/main_gui.cpp
index ed05584..a1a4b8e 100644
--- a/src/main_gui.cpp
+++ b/src/main_gui.cpp
@@ -137,7 +137,7 @@ bool DoZoomInOutWindow(int how, Window *w)
 
 	switch (how) {
 		case ZOOM_IN:
-			if (vp->zoom == ZOOM_LVL_MIN) return false;
+			if (vp->zoom == ZOOM_LVL_BLITTER_MIN) return false;
 			vp->zoom = (ZoomLevel)((int)vp->zoom - 1);
 			vp->virtual_width >>= 1;
 			vp->virtual_height >>= 1;
@@ -148,7 +148,7 @@ bool DoZoomInOutWindow(int how, Window *w)
 			w->viewport->dest_scrollpos_y = w->viewport->scrollpos_y;
 			break;
 		case ZOOM_OUT:
-			if (vp->zoom == ZOOM_LVL_MAX) return false;
+			if (vp->zoom == ZOOM_LVL_BLITTER_MAX) return false;
 			vp->zoom = (ZoomLevel)((int)vp->zoom + 1);
 
 			w->viewport->scrollpos_x -= vp->virtual_width >> 1;
@@ -175,7 +175,7 @@ void ZoomInOrOutToCursorWindow(bool in, Window *w)
 
 	if (_game_mode != GM_MENU) {
 		ViewPort *vp = w->viewport;
-		if ((in && vp->zoom == ZOOM_LVL_MIN) || (!in && vp->zoom == ZOOM_LVL_MAX))
+		if ((in && vp->zoom == ZOOM_LVL_BLITTER_MIN) || (!in && vp->zoom == ZOOM_LVL_BLITTER_MAX))
 			return;
 
 		Point pt = GetTileZoomCenterWindow(in, w);
diff --git a/src/saveload/misc_sl.cpp b/src/saveload/misc_sl.cpp
index 67ca389..1c920ff 100644
--- a/src/saveload/misc_sl.cpp
+++ b/src/saveload/misc_sl.cpp
@@ -52,7 +52,7 @@ void ResetViewportAfterLoadGame()
 	w->viewport->dest_scrollpos_y = _saved_scrollpos_y;
 
 	ViewPort *vp = w->viewport;
-	vp->zoom = (ZoomLevel)min(_saved_scrollpos_zoom, ZOOM_LVL_MAX);
+	vp->zoom = (ZoomLevel)Clamp(_saved_scrollpos_zoom, ZOOM_LVL_BLITTER_MIN, ZOOM_LVL_BLITTER_MAX);
 	vp->virtual_width = ScaleByZoom(vp->width, vp->zoom);
 	vp->virtual_height = ScaleByZoom(vp->height, vp->zoom);
 
diff --git a/src/smallmap_gui.cpp b/src/smallmap_gui.cpp
index 2532b75..7936591 100644
--- a/src/smallmap_gui.cpp
+++ b/src/smallmap_gui.cpp
@@ -25,6 +25,7 @@
 #include "vehicle_base.h"
 #include "sound_func.h"
 #include "window_func.h"
+#include "zoom_func.h"
 #include "company_base.h"
 
 #include "table/strings.h"
@@ -36,6 +37,8 @@ enum SmallMapWindowWidgets {
 	SM_WIDGET_MAP_BORDER,        ///< Border around the smallmap.
 	SM_WIDGET_MAP,               ///< Panel containing the smallmap.
 	SM_WIDGET_LEGEND,            ///< Bottom panel to display smallmap legends.
+	SM_WIDGET_ZOOM_IN,
+	SM_WIDGET_ZOOM_OUT,
 	SM_WIDGET_CONTOUR,           ///< Button to select the contour view (height map).
 	SM_WIDGET_VEHICLES,          ///< Button to select the vehicles view.
 	SM_WIDGET_INDUSTRIES,        ///< Button to select the industries view.
@@ -440,6 +443,18 @@ class SmallMapWindow : public Window {
 		SMT_OWNER,
 	};
 
+	/**
+	 * save the Vehicle's old position here, so that we don't get glitches when redrawing
+	 */
+	struct VehicleAndPosition {
+		VehicleAndPosition(const Vehicle *v) : tile(v->tile), vehicle(v->index) {}
+		TileIndex tile;
+		VehicleID vehicle;
+	};
+
+	typedef std::list<VehicleAndPosition> VehicleList;
+	VehicleList vehicles_on_map;
+	
 	static SmallMapType map_type; ///< Currently displayed legends.
 	static bool show_towns;       ///< Display town names in the smallmap.
 
@@ -449,14 +464,66 @@ class SmallMapWindow : public Window {
 	uint min_number_of_fixed_rows; ///< Minimal number of rows in the legends for the fixed layouts only (all except #SMT_INDUSTRY).
 	uint column_width;             ///< Width of a column in the #SM_WIDGET_LEGEND widget.
 
+	/**
+	 * zoom level of the smallmap.
+	 * May be something between ZOOM_LVL_MIN and ZOOM_LVL_MAX.
+	 */
+	ZoomLevel zoom;
+
 	int32 scroll_x;  ///< Horizontal world coordinate of the base tile left of the top-left corner of the smallmap display.
 	int32 scroll_y;  ///< Vertical world coordinate of the base tile left of the top-left corner of the smallmap display.
 	int32 subscroll; ///< Number of pixels (0..3) between the right end of the base tile and the pixel at the top-left corner of the smallmap display.
 
 	static const uint8 FORCE_REFRESH_PERIOD = 0x1F; ///< map is redrawn after that many ticks
+	static const uint8 REFRESH_NEXT_TICK = 1;
 	uint8 refresh; ///< refresh counter, zeroed every FORCE_REFRESH_PERIOD ticks
 
 	/**
+	 * remap coordinates on the main map into coordinates on the smallmap
+	 * @param pos_x X position on the main map
+	 * @param pos_y Y position on the main map
+	 * @return Point in the smallmap
+	 */
+	inline Point RemapPlainCoords(int pos_x, int pos_y) const
+	{
+		return RemapCoords(
+				RemapX(pos_x),
+				RemapY(pos_y),
+				0
+				);
+	}
+
+	/**
+	 * scale a coordinate from the main map into the smallmap dimension
+	 * @param pos coordinate to be scaled
+	 * @return scaled coordinate
+	 */
+	inline int UnScalePlainCoord(int pos) const
+	{
+		return UnScaleByZoomLower(pos, this->zoom) / TILE_SIZE;
+	}
+
+	/**
+	 * Remap a map X coordinate to a location on this smallmap.
+	 * @param pos_x the tile's X coordinate.
+	 * @return the X coordinate to draw on.
+	 */
+	inline int RemapX(int pos_x) const
+	{
+		return UnScalePlainCoord(pos_x) - UnScalePlainCoord(this->scroll_x);
+	}
+
+	/**
+	 * Remap a map Y coordinate to a location on this smallmap.
+	 * @param pos_y the tile's Y coordinate.
+	 * @return the Y coordinate to draw on.
+	 */
+	inline int RemapY(int pos_y) const
+	{
+		return UnScalePlainCoord(pos_y) - UnScalePlainCoord(this->scroll_y);
+	}
+
+	/**
 	 * Remap tile to location on this smallmap.
 	 * @param tile_x X coordinate of the tile.
 	 * @param tile_y Y coordinate of the tile.
@@ -464,8 +531,7 @@ class SmallMapWindow : public Window {
 	 */
 	FORCEINLINE Point RemapTile(int tile_x, int tile_y) const
 	{
-		return RemapCoords(tile_x - this->scroll_x / TILE_SIZE,
-				tile_y - this->scroll_y / TILE_SIZE, 0);
+		return RemapPlainCoords(tile_x * TILE_SIZE, tile_y * TILE_SIZE);
 	}
 
 	/**
@@ -477,7 +543,7 @@ class SmallMapWindow : public Window {
 	 * @return Tile being displayed at the given position relative to #scroll_x and #scroll_y.
 	 * @note The #subscroll offset is already accounted for.
 	 */
-	FORCEINLINE Point PixelToTile(int dx, int dy, int *sub) const
+	FORCEINLINE Point PixelToWorld(int dx, int dy, int *sub) const
 	{
 		dx += this->subscroll;  // Total horizontal offset.
 
@@ -496,11 +562,37 @@ class SmallMapWindow : public Window {
 			}
 		}
 
+		pt.x = ScaleByZoomLower(pt.x * TILE_SIZE, this->zoom);
+		pt.y = ScaleByZoomLower(pt.y * TILE_SIZE, this->zoom);
+
 		*sub = dx;
 		return pt;
 	}
 
 	/**
+	 * choose a different tile from the tiles to be drawn in one pixel
+	 * each time. This decreases the chance that certain structures
+	 * (railway lines, roads) disappear completely when zooming out.
+	 * @param x the X coordinate of the upper right corner of the drawn area
+	 * @param y the Y coordinate of the upper right corner of the drawn area
+	 * @param xc the unscaled X coordinate x was calcluated from
+	 * @param yc the unscaled Y coordinate y was calcluated from
+	 */
+	void AntiAlias(uint &x, uint &y, uint xc, uint yc) const
+	{
+		int bits_needed = this->zoom - ZOOM_LVL_NORMAL;
+		if (bits_needed <= 0) return;
+		for(int i = 0; i < bits_needed; ++i) {
+			x += ((xc ^ yc) & 0x1) << i;
+			yc >>= 1;
+			y += ((xc ^ yc) & 0x1) << i;
+			xc >>= 1;
+		}
+		x = min(x, MapMaxX() - 1);
+		y = min(y, MapMaxY() - 1);
+	}
+
+	/**
 	 * Draws one column of the small map in a certain mode onto the screen buffer. This
 	 * function looks exactly the same for all types
 	 *
@@ -523,12 +615,18 @@ class SmallMapWindow : public Window {
 		do {
 			/* Check if the tile (xc,yc) is within the map range */
 			uint min_xy = _settings_game.construction.freeform_edges ? 1 : 0;
-			if (IsInsideMM(xc, min_xy, MapMaxX()) && IsInsideMM(yc, min_xy, MapMaxY())) {
+
+			/* divide by TILE_SIZE last to avoid loss of information which leads to glitches */
+			uint x = ScaleByZoomLower(xc, this->zoom) / TILE_SIZE;
+			uint y = ScaleByZoomLower(yc, this->zoom) / TILE_SIZE;
+
+			if (IsInsideMM(x, min_xy, MapMaxX()) && IsInsideMM(y, min_xy, MapMaxY())) {
 				/* Check if the dst pointer points to a pixel inside the screen buffer */
 				if (dst < _screen.dst_ptr) continue;
 				if (dst >= dst_ptr_abs_end) continue;
 
-				uint32 val = proc(TileXY(xc, yc));
+				AntiAlias(x, y, xc / TILE_SIZE, yc / TILE_SIZE);
+				uint32 val = proc(TileXY(x, y));
 				uint8 *val8 = (uint8 *)&val;
 				int idx = max(0, -start_pos);
 				for (int pos = max(0, start_pos); pos < end_pos; pos++) {
@@ -537,7 +635,7 @@ class SmallMapWindow : public Window {
 				}
 			}
 		/* Switch to next tile in the column */
-		} while (xc++, yc++, dst = blitter->MoveTo(dst, pitch, 0), --reps != 0);
+		} while (xc += TILE_SIZE, yc += TILE_SIZE, dst = blitter->MoveTo(dst, pitch, 0), --reps != 0);
 	}
 
 	/**
@@ -547,36 +645,73 @@ class SmallMapWindow : public Window {
 	 */
 	void DrawVehicles(const DrawPixelInfo *dpi, Blitter *blitter) const
 	{
-		const Vehicle *v;
-		FOR_ALL_VEHICLES(v) {
-			if (v->type == VEH_EFFECT) continue;
-			if (v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) continue;
+		for(VehicleList::const_iterator i = this->vehicles_on_map.begin(); i != this->vehicles_on_map.end(); ++i) {
+			const Vehicle *v = Vehicle::GetIfValid((*i).vehicle);
+			if (v == NULL) continue;
+
+			TileIndex tile = (*i).tile;
 
 			/* Remap into flat coordinates. */
-			Point pt = this->RemapTile(v->x_pos / TILE_SIZE, v->y_pos / TILE_SIZE);
+			Point pt = this->RemapTile(TileX(tile), TileY(tile));
 
 			int y = pt.y - dpi->top;
-			if (!IsInsideMM(y, 0, dpi->height)) continue; // y is out of bounds.
-
-			bool skip = false; // Default is to draw both pixels.
 			int x = pt.x - this->subscroll - 3 - dpi->left; // Offset X coordinate.
-			if (x < 0) {
-				/* if x+1 is 0, that means we're on the very left edge,
-				 * and should thus only draw a single pixel */
-				if (++x != 0) continue;
-				skip = true;
-			} else if (x >= dpi->width - 1) {
-				/* Check if we're at the very right edge, and if so draw only a single pixel */
-				if (x != dpi->width - 1) continue;
-				skip = true;
-			}
+
+			int scale = GetVehicleScale();
 
 			/* Calculate pointer to pixel and the colour */
 			byte colour = (this->map_type == SMT_VEHICLES) ? _vehicle_type_colours[v->type] : 0xF;
 
-			/* And draw either one or two pixels depending on clipping */
-			blitter->SetPixel(dpi->dst_ptr, x, y, colour);
-			if (!skip) blitter->SetPixel(dpi->dst_ptr, x + 1, y, colour);
+			/* Draw rhombus */
+			for (int dy = 0; dy < scale; dy++) {
+				for (int dx = 0; dx < scale; dx++) {
+					Point pt = RemapCoords(dx, dy, 0);
+					if (IsInsideMM(y + pt.y, 0, dpi->height)) {
+						if (IsInsideMM(x + pt.x, 0, dpi->width)) {
+							blitter->SetPixel(dpi->dst_ptr, x + pt.x, y + pt.y, colour);
+						}
+						if (IsInsideMM(x + pt.x + 1, 0, dpi->width)) {
+							blitter->SetPixel(dpi->dst_ptr, x + pt.x + 1, y + pt.y, colour);
+						}
+					}
+				}
+			}
+		}
+	}
+
+
+	FORCEINLINE int GetVehicleScale() const
+	{
+		int scale = 1;
+		if (this->zoom < ZOOM_LVL_NORMAL) {
+			scale = 1 << (ZOOM_LVL_NORMAL - this->zoom);
+		}
+		return scale;
+	}
+
+	void DrawIndustries(DrawPixelInfo *dpi) const {
+		/* Emphasize all industries if current view is zoomed out "Industreis" */
+		Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
+		if ((this->map_type == SMT_INDUSTRY) && (this->zoom > ZOOM_LVL_NORMAL)) {
+			const Industry *i;
+			FOR_ALL_INDUSTRIES(i) {
+				if (_legend_from_industries[_industry_to_list_pos[i->type]].show_on_map) {
+					TileIndex tile = i->location.tile;
+					Point pt = RemapTile(TileX(tile), TileY(tile));
+
+					int y = pt.y - dpi->top;
+					if (!IsInsideMM(y, 0, dpi->height)) continue;
+
+					int x = pt.x - dpi->left - 3; // mysterious -3 inherited from trunk (vehicle drawing)
+					byte colour = GetIndustrySpec(i->type)->map_colour;
+
+					for (int offset = 0; offset < 4; ++offset) {
+						if (IsInsideMM(x + offset, 0, dpi->width)) {
+							blitter->SetPixel(dpi->dst_ptr, x + offset, y, colour);
+						}
+					}
+				}
+			}
 		}
 	}
 
@@ -637,14 +772,13 @@ class SmallMapWindow : public Window {
 		/* Find main viewport. */
 		const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
 
-		Point pt = RemapCoords(this->scroll_x, this->scroll_y, 0);
+		/* UnScale everything separately to produce the same rounding errors as when drawing the background */
+		Point pt = RemapCoords(UnScalePlainCoord(this->scroll_x), UnScalePlainCoord(this->scroll_y), 0);
 
-		int x = vp->virtual_left - pt.x;
-		int y = vp->virtual_top - pt.y;
-		int x2 = (x + vp->virtual_width) / TILE_SIZE;
-		int y2 = (y + vp->virtual_height) / TILE_SIZE;
-		x /= TILE_SIZE;
-		y /= TILE_SIZE;
+		int x = UnScalePlainCoord(vp->virtual_left) - pt.x;
+		int y = UnScalePlainCoord(vp->virtual_top) - pt.y;
+		int x2 = x + UnScalePlainCoord(vp->virtual_width);
+		int y2 = y + UnScalePlainCoord(vp->virtual_height);
 
 		x -= this->subscroll;
 		x2 -= this->subscroll;
@@ -696,9 +830,9 @@ class SmallMapWindow : public Window {
 
 		/* Which tile is displayed at (dpi->left, dpi->top)? */
 		int dx;
-		Point tile = this->PixelToTile(dpi->left, dpi->top, &dx);
-		int tile_x = this->scroll_x / TILE_SIZE + tile.x;
-		int tile_y = this->scroll_y / TILE_SIZE + tile.y;
+		Point tile = this->PixelToWorld(dpi->left, dpi->top, &dx);
+		int tile_x = UnScaleByZoomLower(this->scroll_x + tile.x, this->zoom);
+		int tile_y = UnScaleByZoomLower(this->scroll_y + tile.y, this->zoom);
 
 		void *ptr = blitter->MoveTo(dpi->dst_ptr, -dx - 4, 0);
 		int x = - dx - 4;
@@ -717,11 +851,11 @@ class SmallMapWindow : public Window {
 			}
 
 			if (y == 0) {
-				tile_y++;
+				tile_y += TILE_SIZE;
 				y++;
 				ptr = blitter->MoveTo(ptr, 0, 1);
 			} else {
-				tile_x--;
+				tile_x -= TILE_SIZE;
 				y--;
 				ptr = blitter->MoveTo(ptr, 0, -1);
 			}
@@ -732,6 +866,8 @@ class SmallMapWindow : public Window {
 		/* Draw vehicles */
 		if (this->map_type == SMT_CONTOUR || this->map_type == SMT_VEHICLES) this->DrawVehicles(dpi, blitter);
 
+		this->DrawIndustries(dpi);
+
 		/* Draw town names */
 		if (this->show_towns) this->DrawTowns(dpi);
 
@@ -741,8 +877,62 @@ class SmallMapWindow : public Window {
 		_cur_dpi = old_dpi;
 	}
 
+	/**
+	 * Zoom in the map by one level.
+	 * @param cx horizontal coordinate of center point, relative to SM_WIDGET_MAP widget
+	 * @param cy vertical coordinate of center point, relative to SM_WIDGET_MAP widget
+	 */
+	void ZoomIn(int cx, int cy)
+	{
+		if (this->zoom > ZOOM_LVL_MIN) {
+			this->zoom--;
+			this->DoScroll(cx, cy);
+			this->SetWidgetDisabledState(SM_WIDGET_ZOOM_IN, this->zoom == ZOOM_LVL_MIN);
+			this->EnableWidget(SM_WIDGET_ZOOM_OUT);
+			this->SetDirty();
+		}
+	}
+
+	/**
+	 * Zoom out the map by one level.
+	 * @param cx horizontal coordinate of center point, relative to SM_WIDGET_MAP widget
+	 * @param cy vertical coordinate of center point, relative to SM_WIDGET_MAP widget
+	 */
+	void ZoomOut(int cx, int cy)
+	{
+		if (this->zoom < ZOOM_LVL_MAX) {
+			this->zoom++;
+			this->DoScroll(cx / -2, cy / -2);
+			this->EnableWidget(SM_WIDGET_ZOOM_IN);
+			this->SetWidgetDisabledState(SM_WIDGET_ZOOM_OUT, this->zoom == ZOOM_LVL_MAX);
+			this->SetDirty();
+		}
+	}
+
+	void RecalcVehiclePositions() {
+		this->vehicles_on_map.clear();
+		const Vehicle *v;
+		const NWidgetCore *wi = this->GetWidget<NWidgetCore>(SM_WIDGET_MAP);
+		int scale = GetVehicleScale();
+
+		FOR_ALL_VEHICLES(v) {
+			if (v->type == VEH_EFFECT) continue;
+			if (v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) continue;
+
+			/* Remap into flat coordinates. */
+			Point pos = RemapTile(TileX(v->tile), TileY(v->tile));
+
+			/* Check if rhombus is inside bounds */
+			if (IsInsideMM(pos.x, -2 * scale, wi->current_x + 2 * scale) &&
+				IsInsideMM(pos.y, -2 * scale, wi->current_y + 2 * scale)) {
+
+				this->vehicles_on_map.push_back(VehicleAndPosition(v));
+			}
+		}
+	}
+
 public:
-	SmallMapWindow(const WindowDesc *desc, int window_number) : Window(), refresh(FORCE_REFRESH_PERIOD)
+	SmallMapWindow(const WindowDesc *desc, int window_number) : Window(), zoom(ZOOM_LVL_NORMAL), refresh(FORCE_REFRESH_PERIOD)
 	{
 		this->InitNested(desc, window_number);
 		this->LowerWidget(this->map_type + SM_WIDGET_CONTOUR);
@@ -916,12 +1106,28 @@ public:
 				Point pt = RemapCoords(this->scroll_x, this->scroll_y, 0);
 				Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
 				w->viewport->follow_vehicle = INVALID_VEHICLE;
-				w->viewport->dest_scrollpos_x = pt.x + ((_cursor.pos.x - this->left + wid->pos_x) << 4) - (w->viewport->virtual_width  >> 1);
-				w->viewport->dest_scrollpos_y = pt.y + ((_cursor.pos.y - this->top  - wid->pos_y) << 4) - (w->viewport->virtual_height >> 1);
+				int scaled_x_off = ScaleByZoom((_cursor.pos.x - this->left + wid->pos_x) * TILE_SIZE, this->zoom);
+				int scaled_y_off = ScaleByZoom((_cursor.pos.y - this->top - wid->pos_y) * TILE_SIZE, this->zoom);
+				w->viewport->dest_scrollpos_x = pt.x + scaled_x_off - (w->viewport->virtual_width >> 1);
+				w->viewport->dest_scrollpos_y = pt.y + scaled_y_off - (w->viewport->virtual_height >> 1);
 
 				this->SetDirty();
 			} break;
 
+			case SM_WIDGET_ZOOM_OUT: {
+				const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+				this->ZoomOut(wi->current_x / 2, wi->current_y / 2);
+				this->HandleButtonClick(SM_WIDGET_ZOOM_OUT);
+				SndPlayFx(SND_15_BEEP);
+			} break;
+
+			case SM_WIDGET_ZOOM_IN: {
+				const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+				this->ZoomIn(wi->current_x / 2, wi->current_y / 2);
+				this->HandleButtonClick(SM_WIDGET_ZOOM_IN);
+				SndPlayFx(SND_15_BEEP);
+			} break;
+
 			case SM_WIDGET_CONTOUR:    // Show land contours
 			case SM_WIDGET_VEHICLES:   // Show vehicles
 			case SM_WIDGET_INDUSTRIES: // Show industries
@@ -1009,6 +1215,28 @@ public:
 		}
 	}
 
+	virtual void OnMouseWheel(int wheel)
+	{
+		/* Cursor position relative to window */
+		int cx = _cursor.pos.x - this->left;
+		int cy = _cursor.pos.y - this->top;
+
+		const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
+		/* Is cursor over the map ? */
+		if (IsInsideMM(cx, wi->pos_x, wi->pos_x + wi->current_x + 1) &&
+				IsInsideMM(cy, wi->pos_y, wi->pos_y + wi->current_y + 1)) {
+			/* Cursor position relative to map */
+			cx -= wi->pos_x;
+			cy -= wi->pos_y;
+
+			if (wheel < 0) {
+				this->ZoomIn(cx, cy);
+			} else {
+				this->ZoomOut(cx, cy);
+			}
+		}
+	}
+
 	virtual void OnRightClick(Point pt, int widget)
 	{
 		if (widget == SM_WIDGET_MAP) {
@@ -1022,6 +1250,8 @@ public:
 		/* Update the window every now and then */
 		if (--this->refresh != 0) return;
 
+		this->RecalcVehiclePositions();
+
 		this->refresh = FORCE_REFRESH_PERIOD;
 		this->SetDirty();
 	}
@@ -1029,18 +1259,29 @@ public:
 	virtual void OnScroll(Point delta)
 	{
 		_cursor.fix_at = true;
+		DoScroll(delta.x, delta.y);
+		this->SetDirty();
+	}
 
-		/* While tile is at (delta.x, delta.y)? */
+
+	/**
+	 * Do the actual scrolling, but don't fix the cursor or set the window dirty.
+	 * @param dx x offset to scroll in screen dimension
+	 * @param dy y offset to scroll in screen dimension
+	 */
+	void DoScroll(int dx, int dy)
+	{
+		/* While tile is at (dx, dy)? */
 		int sub;
-		Point pt = this->PixelToTile(delta.x, delta.y, &sub);
-		int x = this->scroll_x + pt.x * TILE_SIZE;
-		int y = this->scroll_y + pt.y * TILE_SIZE;
+		Point pt = this->PixelToWorld(dx, dy, &sub);
+		int x = this->scroll_x + pt.x;
+		int y = this->scroll_y + pt.y;
 
 		const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
 		int hx = wi->current_x / 2;
 		int hy = wi->current_y / 2;
-		int hvx = hx * -4 + hy * 8;
-		int hvy = hx *  4 + hy * 8;
+		int hvx = ScaleByZoomLower(hx * -4 + hy * 8, this->zoom);
+		int hvy = ScaleByZoomLower(hx *  4 + hy * 8, this->zoom);
 		if (x < -hvx) {
 			x = -hvx;
 			sub = 0;
@@ -1061,8 +1302,7 @@ public:
 		this->scroll_x = x;
 		this->scroll_y = y;
 		this->subscroll = sub;
-
-		this->SetDirty();
+		this->refresh = REFRESH_NEXT_TICK;
 	}
 
 	void SmallMapCenterOnCurrentPos()
@@ -1070,10 +1310,12 @@ public:
 		const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
 		const NWidgetBase *wi = this->GetWidget<NWidgetBase>(SM_WIDGET_MAP);
 
-		int x = ((vp->virtual_width  - (int)wi->current_x * TILE_SIZE) / 2 + vp->virtual_left) / 4;
-		int y = ((vp->virtual_height - (int)wi->current_y * TILE_SIZE) / 2 + vp->virtual_top ) / 2 - TILE_SIZE * 2;
-		this->scroll_x = (y - x) & ~0xF;
-		this->scroll_y = (x + y) & ~0xF;
+		int zoomed_width = ScaleByZoom(wi->current_x * TILE_SIZE, this->zoom);
+		int zoomed_height = ScaleByZoom(wi->current_y * TILE_SIZE, this->zoom);
+		int x  = ((vp->virtual_width - zoomed_width) / 2 + vp->virtual_left);
+		int y  = ((vp->virtual_height - zoomed_height) / 2 + vp->virtual_top);
+		this->scroll_x = (y * 2 - x) / 4;
+		this->scroll_y = (x + y * 2) / 4;
 		this->SetDirty();
 	}
 };
@@ -1169,6 +1411,7 @@ static const NWidgetPart _nested_smallmap_bar[] = {
 			NWidget(NWID_VERTICAL),
 				/* Top button row. */
 				NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+					NWidget(WWT_PUSHIMGBTN, COLOUR_BROWN, SM_WIDGET_ZOOM_IN), SetDataTip(SPR_IMG_ZOOMIN, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_IN),
 					NWidget(WWT_PUSHIMGBTN, COLOUR_BROWN, SM_WIDGET_CENTERMAP), SetDataTip(SPR_IMG_SMALLMAP, STR_SMALLMAP_CENTER),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_CONTOUR), SetDataTip(SPR_IMG_SHOW_COUNTOURS, STR_SMALLMAP_TOOLTIP_SHOW_LAND_CONTOURS_ON_MAP),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_VEHICLES), SetDataTip(SPR_IMG_SHOW_VEHICLES, STR_SMALLMAP_TOOLTIP_SHOW_VEHICLES_ON_MAP),
@@ -1176,6 +1419,7 @@ static const NWidgetPart _nested_smallmap_bar[] = {
 				EndContainer(),
 				/* Bottom button row. */
 				NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+					NWidget(WWT_PUSHIMGBTN, COLOUR_BROWN, SM_WIDGET_ZOOM_OUT), SetDataTip(SPR_IMG_ZOOMOUT, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_OUT),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_TOGGLETOWNNAME), SetDataTip(SPR_IMG_TOWN, STR_SMALLMAP_TOOLTIP_TOGGLE_TOWN_NAMES_ON_OFF),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_ROUTES), SetDataTip(SPR_IMG_SHOW_ROUTES, STR_SMALLMAP_TOOLTIP_SHOW_TRANSPORT_ROUTES_ON),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_VEGETATION), SetDataTip(SPR_IMG_PLANTTREES, STR_SMALLMAP_TOOLTIP_SHOW_VEGETATION_ON_MAP),
@@ -1225,7 +1469,7 @@ static const NWidgetPart _nested_smallmap_widgets[] = {
 };
 
 static const WindowDesc _smallmap_desc(
-	WDP_AUTO, 446, 314,
+	WDP_AUTO, 460, 314,
 	WC_SMALLMAP, WC_NONE,
 	WDF_UNCLICK_BUTTONS,
 	_nested_smallmap_widgets, lengthof(_nested_smallmap_widgets)
diff --git a/src/sound.cpp b/src/sound.cpp
index a0f3862..567ee90 100644
--- a/src/sound.cpp
+++ b/src/sound.cpp
@@ -179,7 +179,7 @@ static void StartSound(SoundID sound_id, int panning, uint volume)
 
 
 static const byte _vol_factor_by_zoom[] = {255, 190, 134, 87};
-assert_compile(lengthof(_vol_factor_by_zoom) == ZOOM_LVL_COUNT);
+assert_compile(lengthof(_vol_factor_by_zoom) == ZOOM_LVL_BLITTER_COUNT);
 
 static const byte _sound_base_vol[] = {
 	128,  90, 128, 128, 128, 128, 128, 128,
@@ -243,7 +243,7 @@ static void SndPlayScreenCoordFx(SoundID sound, int left, int right, int top, in
 			StartSound(
 				sound,
 				panning,
-				(msf.effect_vol * _vol_factor_by_zoom[vp->zoom - ZOOM_LVL_BEGIN]) / 256
+				(msf.effect_vol * _vol_factor_by_zoom[vp->zoom - ZOOM_LVL_BLITTER_MIN]) / 256
 			);
 			return;
 		}
diff --git a/src/viewport.cpp b/src/viewport.cpp
index c9b6746..ce9bfad 100644
--- a/src/viewport.cpp
+++ b/src/viewport.cpp
@@ -457,10 +457,10 @@ Point GetTileZoomCenterWindow(bool in, Window * w)
  * @param widget_zoom_out widget index for window with zoom-out button */
 void HandleZoomMessage(Window *w, const ViewPort *vp, byte widget_zoom_in, byte widget_zoom_out)
 {
-	w->SetWidgetDisabledState(widget_zoom_in, vp->zoom == ZOOM_LVL_MIN);
+	w->SetWidgetDisabledState(widget_zoom_in, vp->zoom == ZOOM_LVL_BLITTER_MIN);
 	w->SetWidgetDirty(widget_zoom_in);
 
-	w->SetWidgetDisabledState(widget_zoom_out, vp->zoom == ZOOM_LVL_MAX);
+	w->SetWidgetDisabledState(widget_zoom_out, vp->zoom == ZOOM_LVL_BLITTER_MAX);
 	w->SetWidgetDirty(widget_zoom_out);
 }
 
@@ -1201,15 +1201,15 @@ void ViewportSign::UpdatePosition(int center, int top, StringID str)
  */
 void ViewportSign::MarkDirty() const
 {
-	/* We use ZOOM_LVL_MAX here, as every viewport can have another zoom,
+	/* We use ZOOM_LVL_BLITTER_MAX here, as every viewport can have another zoom,
 	 *  and there is no way for us to know which is the biggest. So make the
 	 *  biggest area dirty, and we are safe for sure.
 	 * We also add 1 to make sure the whole thing is redrawn. */
 	MarkAllViewportsDirty(
-		this->center - ScaleByZoom(this->width_normal / 2 + 1, ZOOM_LVL_MAX),
-		this->top    - ScaleByZoom(1, ZOOM_LVL_MAX),
-		this->center + ScaleByZoom(this->width_normal / 2 + 1, ZOOM_LVL_MAX),
-		this->top    + ScaleByZoom(VPSM_TOP + FONT_HEIGHT_NORMAL + VPSM_BOTTOM + 1, ZOOM_LVL_MAX));
+		this->center - ScaleByZoom(this->width_normal / 2 + 1, ZOOM_LVL_BLITTER_MAX),
+		this->top    - ScaleByZoom(1, ZOOM_LVL_BLITTER_MAX),
+		this->center + ScaleByZoom(this->width_normal / 2 + 1, ZOOM_LVL_BLITTER_MAX),
+		this->top    + ScaleByZoom(VPSM_TOP + FONT_HEIGHT_NORMAL + VPSM_BOTTOM + 1, ZOOM_LVL_BLITTER_MAX));
 }
 
 static void ViewportDrawTileSprites(const TileSpriteToDrawVector *tstdv)
diff --git a/src/waypoint_gui.cpp b/src/waypoint_gui.cpp
index 0a6d10a..a381eec 100644
--- a/src/waypoint_gui.cpp
+++ b/src/waypoint_gui.cpp
@@ -55,7 +55,7 @@ public:
 
 		this->flags4 |= WF_DISABLE_VP_SCROLL;
 		NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(WAYPVW_VIEWPORT);
-		nvp->InitializeViewport(this, this->wp->xy, ZOOM_LVL_MIN);
+		nvp->InitializeViewport(this, this->wp->xy, ZOOM_LVL_BLITTER_MIN);
 
 		this->OnInvalidateData(0);
 	}
diff --git a/src/zoom_type.h b/src/zoom_type.h
index e2698ae..e2211a3 100644
--- a/src/zoom_type.h
+++ b/src/zoom_type.h
@@ -16,15 +16,13 @@
 
 enum ZoomLevel {
 	/* Our possible zoom-levels */
-	ZOOM_LVL_BEGIN  = 0,
-	ZOOM_LVL_NORMAL = 0,
+	ZOOM_LVL_IN_8X,
+	ZOOM_LVL_IN_4X,
+	ZOOM_LVL_IN_2X,
+	ZOOM_LVL_NORMAL,
 	ZOOM_LVL_OUT_2X,
 	ZOOM_LVL_OUT_4X,
 	ZOOM_LVL_OUT_8X,
-	ZOOM_LVL_END,
-
-	/* Number of zoom levels */
-	ZOOM_LVL_COUNT = ZOOM_LVL_END - ZOOM_LVL_BEGIN,
 
 	/* Here we define in which zoom viewports are */
 	ZOOM_LVL_VIEWPORT = ZOOM_LVL_NORMAL,
@@ -37,10 +35,22 @@ enum ZoomLevel {
 	ZOOM_LVL_ROADVEH  = ZOOM_LVL_NORMAL,
 	ZOOM_LVL_WORLD_SCREENSHOT = ZOOM_LVL_NORMAL,
 
-	ZOOM_LVL_DETAIL   = ZOOM_LVL_OUT_2X, ///< All zoomlevels below or equal to this, will result in details on the screen, like road-work, ...
+	ZOOM_LVL_DETAIL   = ZOOM_LVL_OUT_2X, ///< All zoomlevels with higher resolution or equal to this, will result in details on the screen, like road-work, ...
 
-	ZOOM_LVL_MIN      = ZOOM_LVL_NORMAL,
+	/* min/max for all zoom levels */
+	ZOOM_LVL_MIN      = ZOOM_LVL_IN_8X,
 	ZOOM_LVL_MAX      = ZOOM_LVL_OUT_8X,
+	ZOOM_LVL_COUNT    = ZOOM_LVL_MAX + 1 - ZOOM_LVL_MIN,
+
+	/* min/max for zoom levels the blitter can handle
+	 *
+	 * This distinction makes it possible to introduce more zoom levels for other windows.
+	 * For example the smallmap is drawn independently from the main viewport and thus
+	 * could support different zoom levels.
+	 */
+	ZOOM_LVL_BLITTER_MIN   = ZOOM_LVL_NORMAL,
+	ZOOM_LVL_BLITTER_MAX   = ZOOM_LVL_OUT_8X,
+	ZOOM_LVL_BLITTER_COUNT = ZOOM_LVL_BLITTER_MAX + 1 - ZOOM_LVL_BLITTER_MIN,
 };
 DECLARE_POSTFIX_INCREMENT(ZoomLevel)
 
