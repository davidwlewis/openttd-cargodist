diff --git a/projects/openttd_vs80.vcproj b/projects/openttd_vs80.vcproj
index d7a5ffc..dfe41f7 100644
--- a/projects/openttd_vs80.vcproj
+++ b/projects/openttd_vs80.vcproj
@@ -588,6 +588,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1084,6 +1092,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\demand_settings.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -1100,6 +1124,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -2124,6 +2156,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
diff --git a/projects/openttd_vs90.vcproj b/projects/openttd_vs90.vcproj
index 9021d62..4fea4ed 100644
--- a/projects/openttd_vs90.vcproj
+++ b/projects/openttd_vs90.vcproj
@@ -585,6 +585,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1081,6 +1089,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\demand_settings.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -1097,6 +1121,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -2121,6 +2153,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
diff --git a/source.list b/source.list
index adae228..ee2721a 100644
--- a/source.list
+++ b/source.list
@@ -32,6 +32,8 @@ heightmap.cpp
 highscore.cpp
 ini.cpp
 landscape.cpp
+linkgraph/demands.cpp
+linkgraph/linkgraph.cpp
 map.cpp
 misc.cpp
 mixer.cpp
@@ -180,10 +182,16 @@ industrytype.h
 ini_type.h
 landscape.h
 landscape_type.h
+linkgraph/demands.h
+linkgraph/demand_settings.h
+linkgraph/linkgraph.h
+linkgraph/linkgraph_type.h
 livery.h
 map_func.h
 map_type.h
 mixer.h
+moving_average.h
+moving_average.cpp
 network/network.h
 network/network_base.h
 network/network_client.h
@@ -460,6 +468,7 @@ saveload/gamelog_sl.cpp
 saveload/group_sl.cpp
 saveload/industry_sl.cpp
 saveload/labelmaps_sl.cpp
+saveload/linkgraph_sl.cpp
 saveload/map_sl.cpp
 saveload/misc_sl.cpp
 saveload/newgrf_sl.cpp
diff --git a/src/aircraft_cmd.cpp b/src/aircraft_cmd.cpp
index 395c6ed..4cdf361 100644
--- a/src/aircraft_cmd.cpp
+++ b/src/aircraft_cmd.cpp
@@ -1306,6 +1306,7 @@ static void AircraftEntersTerminal(Aircraft *v)
 	if (v->current_order.IsType(OT_GOTO_DEPOT)) return;
 
 	Station *st = Station::Get(v->targetairport);
+	StationID previous_station = v->last_station_visited;
 	v->last_station_visited = v->targetairport;
 
 	/* Check if station was ever visited before */
@@ -1322,7 +1323,7 @@ static void AircraftEntersTerminal(Aircraft *v)
 		AI::NewEvent(v->owner, new AIEventStationFirstVehicle(st->index, v->index));
 	}
 
-	v->BeginLoading();
+	v->BeginLoading(previous_station);
 }
 
 static void AircraftLandAirplane(Aircraft *v)
diff --git a/src/cargo_type.h b/src/cargo_type.h
index 8d9a1a8..2e0e355 100644
--- a/src/cargo_type.h
+++ b/src/cargo_type.h
@@ -23,6 +23,7 @@ typedef byte CargoID;
 
 /** Available types of cargo */
 enum CargoTypes {
+	CT_BEGIN        =  0,
 	/* Temperate */
 	CT_PASSENGERS   =  0,
 	CT_COAL         =  1,
@@ -64,6 +65,7 @@ enum CargoTypes {
 	CT_FIZZY_DRINKS = 11,
 
 	NUM_CARGO       = 32,   ///< Maximal number of cargo types in a game.
+	CT_END          = 32,
 
 	CT_NO_REFIT     = 0xFE, ///< Do not refit cargo of a vehicle (used in vehicle orders and auto-replace/auto-new).
 	CT_INVALID      = 0xFF, ///< Invalid cargo type.
diff --git a/src/core/math_func.cpp b/src/core/math_func.cpp
index 7f0630a..1a9f398 100644
--- a/src/core/math_func.cpp
+++ b/src/core/math_func.cpp
@@ -46,3 +46,21 @@ int GreatestCommonDivisor(int a, int b)
 	return a;
 
 }
+
+
+/**
+ * Deterministic approximate division.
+ * Cancels out division errors stemming from the integer nature of the division over multiple runs.
+ */
+int DivideApprox(int a, int b) {
+	int random_like = ((a + b) * (a - b)) % b;
+
+	int remainder = a % b;
+
+	int ret = a / b;
+	if (abs(random_like) < abs(remainder)) {
+		ret += ((a < 0) ^ (b < 0)) ? -1 : 1;
+	}
+
+	return ret;
+}
diff --git a/src/core/math_func.hpp b/src/core/math_func.hpp
index e0b9dbc..9d7319c 100644
--- a/src/core/math_func.hpp
+++ b/src/core/math_func.hpp
@@ -317,5 +317,6 @@ static FORCEINLINE uint ToPercent16(uint i)
 
 int LeastCommonMultiple(int a, int b);
 int GreatestCommonDivisor(int a, int b);
+int DivideApprox(int a, int b);
 
 #endif /* MATH_FUNC_HPP */
diff --git a/src/landscape.cpp b/src/landscape.cpp
index f122c0c..61b30d6 100644
--- a/src/landscape.cpp
+++ b/src/landscape.cpp
@@ -940,6 +940,7 @@ void OnTick_Station();
 void OnTick_Industry();
 
 void OnTick_Companies();
+void OnTick_LinkGraph();
 
 void CallLandscapeTick()
 {
@@ -949,4 +950,5 @@ void CallLandscapeTick()
 	OnTick_Industry();
 
 	OnTick_Companies();
+	OnTick_LinkGraph();
 }
diff --git a/src/lang/english.txt b/src/lang/english.txt
index e9f64e7..57ec35f 100644
--- a/src/lang/english.txt
+++ b/src/lang/english.txt
@@ -1296,12 +1296,40 @@ STR_CONFIG_SETTING_LARGER_TOWNS                                 :{LTBLUE}Proport
 STR_CONFIG_SETTING_LARGER_TOWNS_DISABLED                        :{LTBLUE}Proportion of towns that will become cities: {ORANGE}None
 STR_CONFIG_SETTING_CITY_SIZE_MULTIPLIER                         :{LTBLUE}Initial city size multiplier: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD                        :{LTBLUE}Remove absurd road-elements during the road construction: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_AVERAGE_UNIT                                 :{LTBLUE}Moving Average Unit: {ORANGE}{STRING1} days
+STR_CONFIG_SETTING_AVERAGE_LENGTH                               :{LTBLUE}Minimum Moving Average Length: {ORANGE}{STRING1} units
+
+STR_CONFIG_SETTING_LINKGRAPH_INTERVAL                           :{LTBLUE}Link graph recalculation interval: {ORANGE}{STRING1} days
+STR_CONFIG_SETTING_DEMAND_PAX                                   :{LTBLUE}Demand function for passengers: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_PAX_SYMMETRIC                         :symmetric
+STR_CONFIG_SETTING_DEMAND_PAX_ANTISYMMETRIC                     :antisymmetric
+STR_CONFIG_SETTING_DEMAND_PAX_UNHANDLED                         :unhandled
+STR_CONFIG_SETTING_DEMAND_MAIL                                  :{LTBLUE}Demand function for mail: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_MAIL_SYMMETRIC                        :symmetric
+STR_CONFIG_SETTING_DEMAND_MAIL_ANTISYMMETRIC                    :antisymmetric
+STR_CONFIG_SETTING_DEMAND_MAIL_UNHANDLED                        :unhandled
+STR_CONFIG_SETTING_DEMAND_EXPRESS                               :{LTBLUE}Demand function for the EXPRESS cargo class: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_EXPRESS_SYMMETRIC                     :symmetric
+STR_CONFIG_SETTING_DEMAND_EXPRESS_ANTISYMMETRIC                 :antisymmetric
+STR_CONFIG_SETTING_DEMAND_EXPRESS_UNHANDLED                     :unhandled
+STR_CONFIG_SETTING_DEMAND_ARMOURED                              :{LTBLUE}Demand function for the ARMOURED cargo class: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_ARMOURED_SYMMETRIC                    :symmetric
+STR_CONFIG_SETTING_DEMAND_ARMOURED_ANTISYMMETRIC                :antisymmetric
+STR_CONFIG_SETTING_DEMAND_ARMOURED_UNHANDLED                    :unhandled
+STR_CONFIG_SETTING_DEMAND_DEFAULT                               :{LTBLUE}Demand function for other cargo classes: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_DEFAULT_SYMMETRIC                     :symmetric
+STR_CONFIG_SETTING_DEMAND_DEFAULT_ANTISYMMETRIC                 :antisymmetric
+STR_CONFIG_SETTING_DEMAND_DEFAULT_UNHANDLED                     :unhandled
+STR_CONFIG_SETTING_LINKGRAPH_ACCURACY                           :{LTBLUE}Accuracy when calculating things on the link graph: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_DISTANCE                              :{LTBLUE}Effect of distance on demands: {ORANGE}{STRING1}%
+STR_CONFIG_SETTING_DEMAND_SIZE                                  :{LTBLUE}Effect of remote station's popularity on symmetric demands: {ORANGE}{STRING1}%
 
 STR_CONFIG_SETTING_GUI                                          :{ORANGE}Interface
 STR_CONFIG_SETTING_CONSTRUCTION                                 :{ORANGE}Construction
 STR_CONFIG_SETTING_VEHICLES                                     :{ORANGE}Vehicles
 STR_CONFIG_SETTING_STATIONS                                     :{ORANGE}Stations
 STR_CONFIG_SETTING_ECONOMY                                      :{ORANGE}Economy
+STR_CONFIG_SETTING_LINKGRAPH                                    :{ORANGE}Link graph
 STR_CONFIG_SETTING_AI                                           :{ORANGE}Competitors
 STR_CONFIG_SETTING_DISPLAY_OPTIONS                              :{ORANGE}Display options
 STR_CONFIG_SETTING_INTERACTION                                  :{ORANGE}Interaction
@@ -3292,6 +3320,7 @@ STR_GAME_SAVELOAD_ERROR_FILE_NOT_READABLE                       :File not readab
 STR_GAME_SAVELOAD_ERROR_FILE_NOT_WRITEABLE                      :File not writeable
 STR_GAME_SAVELOAD_ERROR_DATA_INTEGRITY_CHECK_FAILED             :Data integrity check failed
 STR_WARNING_LOADGAME_REMOVED_TRAMS                              :{WHITE}Game was saved in version without tram support. All trams have been removed.
+STR_WARNING_NONSTOP_CARGODIST                                   :{WHITE}You have set at least one cargo class to be automatically distributed in{}"Avanced Settings -> Link Graph"{}and disabled{}"New orders are 'non-stop' by default"{}in{}"Advanced Settings -> Vehicles"{}This is a BAD idea.
 
 # Map generation messages
 STR_ERROR_COULD_NOT_CREATE_TOWN                                 :{WHITE}Map generation aborted...{}... no suitable town locations
diff --git a/src/linkgraph/demand_settings.h b/src/linkgraph/demand_settings.h
new file mode 100644
index 0000000..8131a6b
--- /dev/null
+++ b/src/linkgraph/demand_settings.h
@@ -0,0 +1,20 @@
+/** @file demand_settings.h Declaration of distribution types for demand calculation. */
+
+#ifndef DEMAND_SETTINGS_H_
+#define DEMAND_SETTINGS_H_
+
+enum DistributionType {
+	DT_BEGIN = 0,
+	DT_SYMMETRIC = 0,
+	DT_ANTISYMMETRIC,
+	DT_UNHANDLED,
+	DT_NUM = 3,
+	DT_END = 3
+};
+
+/** It needs to be 8bits, because we save and load it as such
+ * Define basic enum properties */
+template <> struct EnumPropsT<DistributionType> : MakeEnumPropsT<DistributionType, byte, DT_BEGIN, DT_END, DT_NUM> {};
+typedef TinyEnumT<DistributionType> DistributionTypeByte; // typedefing-enumification of DistributionType
+
+#endif /* DEMAND_SETTINGS_H_ */
diff --git a/src/linkgraph/demands.cpp b/src/linkgraph/demands.cpp
new file mode 100644
index 0000000..f431689
--- /dev/null
+++ b/src/linkgraph/demands.cpp
@@ -0,0 +1,164 @@
+/** @file demands.h Definition of demand calculating link graph handler. */
+
+#include "demands.h"
+#include "../station_base.h"
+#include "../settings_type.h"
+#include "../newgrf_cargo.h"
+#include "../cargotype.h"
+#include "../core/math_func.hpp"
+#include <list>
+#include <iostream>
+
+typedef std::list<NodeID> NodeList;
+
+void DemandCalculator::PrintDemandMatrix(LinkGraphComponent * graph) {
+	for (NodeID from = 0; from < graph->GetSize(); ++from) {
+		std::cout << graph->GetNode(from).station << "\t";
+		for(NodeID to = 0; to < graph->GetSize(); ++to) {
+			if (from == to) {
+				std::cout << graph->GetNode(from).supply << "\t";
+			} else {
+				std::cout << graph->GetEdge(from, to).distance << ":" << graph->GetEdge(from, to).demand << "\t";
+			}
+		}
+		std::cout << "\n";
+	}
+}
+
+void DemandCalculator::CalcDemand(LinkGraphComponent * graph) {
+	NodeList supplies;
+	NodeList demands;
+	uint supply_sum = 0;
+	uint num_demands = 0;
+	uint num_supplies = 0;
+	for(NodeID node = 0; node < graph->GetSize(); node++) {
+		Node & n = graph->GetNode(node);
+		if (n.supply > 0) {
+			supplies.push_back(node);
+			supply_sum += n.supply;
+			num_supplies++;
+		}
+		if (n.demand > 0) {
+			demands.push_back(node);
+			num_demands++;
+		}
+	}
+
+	if (supply_sum == 0 || num_demands == 0) {
+		return;
+	}
+
+	uint demand_per_node = max(supply_sum / num_demands, (uint)1);
+	uint chance = 0;
+
+	while(!supplies.empty() && !demands.empty()) {
+		NodeID node1 = supplies.front();
+		supplies.pop_front();
+
+		Node & from = graph->GetNode(node1);
+
+		for(uint i = 0; i < num_demands; ++i) {
+			assert(!demands.empty());
+			NodeID node2 = demands.front();
+			demands.pop_front();
+			if (node1 == node2) {
+				if (demands.empty() && supplies.empty()) {
+					/* only one node with supply and demand left */
+					return;
+				} else {
+					demands.push_back(node2);
+					continue;
+				}
+			}
+			Node & to = graph->GetNode(node2);
+			Edge & forward = graph->GetEdge(node1, node2);
+			Edge & backward = graph->GetEdge(node2, node1);
+
+			int32 supply = from.supply;
+			if (this->mod_size > 0) {
+				supply = max(1, (int32)(supply * to.supply * this->mod_size / 100 / demand_per_node));
+			}
+			assert(supply > 0);
+
+			/* scale the distance by mod_dist around max_distance */
+			int32 distance = this->max_distance - (this->max_distance - (int32)forward.distance) * this->mod_dist / 100;
+
+			/* scale the accuracy by distance around accuracy / 2 */
+			int32 divisor = this->accuracy * (this->mod_dist - 50) / 100 + this->accuracy * distance / this->max_distance + 1;
+			assert(divisor > 0);
+
+			uint demand_forw = 0;
+			if (divisor < supply) {
+				demand_forw = supply / divisor;
+			} else if (++chance > this->accuracy * num_demands * num_supplies) {
+				/* after some trying distribute demand also to other nodes */
+				demand_forw = 1;
+			}
+
+			demand_forw = min(demand_forw, from.undelivered_supply);
+
+			if (this->mod_size > 0 && from.demand > 0) {
+				uint demand_back = demand_forw * this->mod_size / 100;
+				if (demand_back > to.undelivered_supply) {
+					demand_back = to.undelivered_supply;
+					demand_forw = demand_back * 100 / this->mod_size;
+				}
+				backward.demand += demand_back;
+				to.undelivered_supply -= demand_back;
+			}
+
+			forward.demand += demand_forw;
+			from.undelivered_supply -= demand_forw;
+
+			if (this->mod_size == 0 || to.undelivered_supply > 0) {
+				demands.push_back(node2);
+			} else {
+				num_demands--;
+			}
+
+			if (from.undelivered_supply == 0) {
+				break;
+			}
+		}
+		if (from.undelivered_supply != 0) {
+			supplies.push_back(node1);
+		}
+	}
+}
+
+void DemandCalculator::Run(LinkGraphComponent * graph) {
+	CargoID cargo = graph->GetCargo();
+	const LinkGraphSettings & settings = graph->GetSettings();
+	DistributionType type = settings.demand_default;
+	if (IsCargoInClass(cargo, CC_PASSENGERS)) {
+		type = settings.demand_pax;
+	} else if (IsCargoInClass(cargo, CC_MAIL)) {
+		type = settings.demand_mail;
+	} else if (IsCargoInClass(cargo, CC_EXPRESS)) {
+		type = settings.demand_express;
+	} else if (IsCargoInClass(cargo, CC_ARMOURED)) {
+		type = settings.demand_armoured;
+	}
+
+	this->accuracy = settings.accuracy;
+	this->mod_size = settings.demand_size;
+	this->mod_dist = settings.demand_distance;
+	if (this->mod_dist > 100) {
+		/* increase effect of mod_dist > 100 */
+		int over100 = this->mod_dist - 100;
+		this->mod_dist = 100 + over100 * over100;
+	}
+
+	switch (type) {
+	case DT_SYMMETRIC:
+		CalcDemand(graph);
+		break;
+	case DT_ANTISYMMETRIC:
+		this->mod_size = 0;
+		CalcDemand(graph);
+		break;
+	default:
+		/* ignore */
+		break;
+	}
+}
diff --git a/src/linkgraph/demands.h b/src/linkgraph/demands.h
new file mode 100644
index 0000000..61b9436
--- /dev/null
+++ b/src/linkgraph/demands.h
@@ -0,0 +1,26 @@
+/** @file demands.h Declaration of demand calculating link graph handler. */
+
+#ifndef DEMANDS_H_
+#define DEMANDS_H_
+
+#include "linkgraph.h"
+#include "demand_settings.h"
+#include "../stdafx.h"
+#include "../cargo_type.h"
+#include "../map_func.h"
+
+class DemandCalculator : public ComponentHandler {
+public:
+	DemandCalculator() : max_distance(MapSizeX() + MapSizeY() + 1) {}
+	virtual void Run(LinkGraphComponent * graph);
+	static void PrintDemandMatrix(LinkGraphComponent * graph);
+	virtual ~DemandCalculator() {}
+private:
+	int32 max_distance;
+	int32 mod_size;
+	int32 mod_dist;
+	int32 accuracy;
+	void CalcDemand(LinkGraphComponent * graph);
+};
+
+#endif /* DEMANDS_H_ */
diff --git a/src/linkgraph/linkgraph.cpp b/src/linkgraph/linkgraph.cpp
new file mode 100644
index 0000000..dd29d38
--- /dev/null
+++ b/src/linkgraph/linkgraph.cpp
@@ -0,0 +1,272 @@
+/** @file linkgraph.cpp Definition of link graph classes used for cargo distribution. */
+
+#include "linkgraph.h"
+#include "demands.h"
+#include "../date_func.h"
+#include "../variables.h"
+#include "../map_func.h"
+#include "../core/bitmath_func.hpp"
+#include "../debug.h"
+#include "../moving_average.h"
+#include <queue>
+
+LinkGraph _link_graphs[NUM_CARGO];
+
+typedef std::map<StationID, NodeID> ReverseNodeIndex;
+
+void LinkGraph::CreateComponent(Station * first) {
+	ReverseNodeIndex index;
+	NodeID node = 0;
+	std::queue<Station *> search_queue;
+	LinkGraphComponent * component = NULL;
+
+	search_queue.push(first);
+
+	first->goods[this->cargo].last_component = this->current_component_id;
+	component = new LinkGraphComponent(this->cargo, this->current_component_id);
+	GoodsEntry & good = first->goods[this->cargo];
+	node = component->AddNode(this->current_station_id, good.supply.Value(), HasBit(good.acceptance_pickup, GoodsEntry::ACCEPTANCE));
+	index[this->current_station_id++] = node;
+	// find all stations belonging to the current component
+	while(!search_queue.empty()) {
+		Station * source = search_queue.front();
+		StationID source_id = source->index;
+		search_queue.pop();
+		GoodsEntry & good = source->goods[cargo];
+		LinkStatMap & links = good.link_stats;
+		for(LinkStatMap::iterator i = links.begin(); i != links.end(); ++i) {
+			StationID target_id = i->first;
+			Station *target = Station::GetIfValid(target_id);
+			if (target == NULL) {
+				continue;
+			}
+			assert(target_id != source_id);
+			LinkStat & link_stat = i->second;
+			ReverseNodeIndex::iterator index_it = index.find(target_id);
+			if (index_it == index.end()) {
+				GoodsEntry & good = target->goods[cargo];
+				good.last_component = this->current_component_id;
+				search_queue.push(target);
+				node = component->AddNode(
+					target_id, good.supply.Value(),
+					HasBit(good.acceptance_pickup, GoodsEntry::ACCEPTANCE)
+				);
+				index[target_id] = node;
+			} else {
+				node = index_it->second;
+			}
+			
+			assert(!link_stat.IsNull());
+			component->AddEdge(index[source_id], node, link_stat.Capacity());
+		}
+	}
+	// here the list of nodes and edges for this component is complete.
+	component->CalculateDistances();
+	LinkGraphJob * job = new LinkGraphJob(component);
+	assert(job != NULL);
+	job->SpawnThread(this->cargo);
+	this->jobs.push_back(job);
+}
+
+void LinkGraph::NextComponent()
+{
+	while (!Station::IsValidID(this->current_station_id) && this->current_station_id > 0) {
+		--this->current_station_id;
+	}
+	StationID last_station_id = this->current_station_id;
+
+	do {
+		// find first station of next component
+		if (Station::IsValidID(this->current_station_id)) {
+			Station * station = Station::Get(this->current_station_id);
+			GoodsEntry & ge = station->goods[this->cargo];
+			if ((ge.last_component + this->current_component_id) % 2 != 0) {
+				// has not been seen in this run through the graph
+
+				LinkStatMap & links = station->goods[cargo].link_stats;
+				if (!links.empty()) {
+					this->current_component_id += 2;
+					CreateComponent(station);
+					return;
+				}
+			}
+		}
+
+		if (++this->current_station_id == Station::GetPoolSize()) {
+			this->current_station_id = 0;
+			if (this->current_component_id % 2 == 0) {
+				this->current_component_id = 1;
+			} else {
+				this->current_component_id = 0;
+			}
+		}
+	} while (this->current_station_id != last_station_id);
+}
+
+void OnTick_LinkGraph()
+{
+	bool spawn = (_tick_counter + LinkGraph::COMPONENTS_SPAWN_TICK) % DAY_TICKS == 0;
+	bool join =  (_tick_counter + LinkGraph::COMPONENTS_JOIN_TICK)  % DAY_TICKS == 0;
+	if (spawn || join) {
+		for(CargoID cargo = CT_BEGIN; cargo != CT_END; ++cargo) {
+			if ((_date + cargo) % _settings_game.linkgraph.recalc_interval == 0) {
+				LinkGraph & graph = _link_graphs[cargo];
+				if (spawn) {
+					graph.NextComponent();
+				} else {
+					graph.Join();
+				}
+			}
+		}
+	}
+}
+
+LinkGraph::LinkGraph()  : current_component_id(1), current_station_id(0), cargo(CT_INVALID)
+{
+	for (CargoID i = CT_BEGIN; i != CT_END; ++i) {
+		if (this == &(_link_graphs[i])) {
+			cargo = i;
+		}
+	}
+}
+
+NodeID LinkGraphComponent::AddNode(StationID st, uint supply, uint demand) {
+	nodes.push_back(Node(st, supply, demand));
+	for(NodeID i = 0; i < num_nodes; ++i) {
+		edges[i].push_back(Edge());
+	}
+	edges.push_back(std::vector<Edge>(++num_nodes));
+	return num_nodes - 1;
+}
+
+void LinkGraphComponent::AddEdge(NodeID from, NodeID to, uint capacity) {
+	assert(from != to);
+	edges[from][to].capacity = capacity;
+}
+
+void LinkGraphComponent::CalculateDistances() {
+	for(NodeID i = 0; i < num_nodes; ++i) {
+		for(NodeID j = 0; j < i; ++j) {
+			Station * st1 = Station::Get(nodes[i].station);
+			Station * st2 = Station::Get(nodes[j].station);
+			uint distance = DistanceManhattan(st1->xy, st2->xy);
+			edges[i][j].distance = distance;
+			edges[j][i].distance = distance;
+		}
+	}
+}
+
+void LinkGraphComponent::SetSize(uint size) {
+	num_nodes = size;
+	nodes.resize(num_nodes);
+	edges.resize(num_nodes, std::vector<Edge>(num_nodes));
+}
+
+LinkGraphComponent::LinkGraphComponent(CargoID car, LinkGraphComponentID col) :
+	settings(_settings_game.linkgraph),
+	cargo(car),
+	num_nodes(0),
+	index(col)
+{
+}
+
+void LinkGraph::Join() {
+	while (!this->jobs.empty()) {
+		LinkGraphJob * job = this->jobs.front();
+		assert(job != NULL);
+
+		/* also join if join date is far in the future. This prevents excessive memory use when resetting time */
+		if (job->GetJoinDate() > _date && job->GetJoinDate() <= _date + _settings_game.linkgraph.recalc_interval) {
+			return;
+		}
+		job->Join();
+
+		delete job;
+		this->jobs.pop_front();
+	}
+}
+
+void LinkGraph::AddComponent(LinkGraphComponent * component, uint join) {
+	LinkGraphComponentID index = component->GetIndex();
+	for(NodeID i = 0; i < component->GetSize(); ++i) {
+		Station *station = Station::GetIfValid(component->GetNode(i).station);
+		if (station != NULL) {
+			station->goods[cargo].last_component = index;
+		}
+	}
+	LinkGraphJob * job = new LinkGraphJob(component, join);
+	assert(job != NULL);
+	job->SpawnThread(this->cargo);
+	this->jobs.push_back(job);
+}
+
+void LinkGraphJob::Run() {
+	for (HandlerList::iterator i = this->handlers.begin(); i != this->handlers.end(); ++i) {
+		ComponentHandler * handler = *i;
+		handler->Run(this->component);
+	}
+}
+
+LinkGraphJob::~LinkGraphJob() {
+	for (HandlerList::iterator i = this->handlers.begin(); i != this->handlers.end(); ++i) {
+		ComponentHandler * handler = *i;
+		delete handler;
+	}
+	this->handlers.clear();
+	DEBUG(misc, 2, "removing job for cargo %d with index %d and join date %d at %d", this->component->GetCargo(),
+			this->component->GetIndex(), this->join_date, _date);
+	delete this->component;
+	delete this->thread;
+}
+
+void RunLinkGraphJob(void * j) {
+	LinkGraphJob * job = (LinkGraphJob *)j;
+	job->Run();
+}
+
+void LinkGraphJob::SpawnThread(CargoID cargo) {
+	AddHandler(new DemandCalculator);
+	if (!ThreadObject::New(&(RunLinkGraphJob), this, &thread)) {
+		thread = NULL;
+		// Of course this will hang a bit.
+		// On the other hand, if you want to play games which make this hang noticably
+		// on a platform without threads then you'll probably get other problems first.
+		// OK:
+		// If someone comes and tells me that this hangs for him/her, I'll implement a
+		// smaller grained "Step" method for all handlers and add some more ticks where
+		// "Step" is called. No problem in principle.
+		RunLinkGraphJob(this);
+	}
+}
+
+LinkGraphJob::LinkGraphJob(LinkGraphComponent * c) :
+	thread(NULL),
+	join_date(_date + c->GetSettings().recalc_interval),
+	component(c)
+{
+	DEBUG(misc, 2, "new job for cargo %d with index %d and join date %d at %d", c->GetCargo(), c->GetIndex(), join_date, _date);
+}
+
+LinkGraphJob::LinkGraphJob(LinkGraphComponent * c, Date join) :
+	thread(NULL),
+	join_date(join),
+	component(c)
+{
+	DEBUG(misc, 2, "new job for cargo %d with index %d and join date %d at %d", c->GetCargo(), c->GetIndex(), join_date, _date);
+}
+
+void LinkGraph::Clear() {
+	for (JobList::iterator i = jobs.begin(); i != jobs.end(); ++i) {
+		LinkGraphJob * job = *i;
+		assert(job != NULL);
+		job->Join();
+		delete job;
+	}
+	jobs.clear();
+	current_component_id = 1;
+	current_station_id = 0;
+}
+
+void InitializeLinkGraphs() {
+	for (CargoID c = CT_BEGIN; c != CT_END; ++c) _link_graphs[c].Clear();
+}
diff --git a/src/linkgraph/linkgraph.h b/src/linkgraph/linkgraph.h
new file mode 100644
index 0000000..bef5193
--- /dev/null
+++ b/src/linkgraph/linkgraph.h
@@ -0,0 +1,138 @@
+/** @file linkgraph.h Declaration of link graph classes used for cargo distribution. */
+
+#ifndef LINKGRAPH_H_
+#define LINKGRAPH_H_
+
+#include "../stdafx.h"
+#include "../station_base.h"
+#include "../cargo_type.h"
+#include "../thread/thread.h"
+#include "../settings_type.h"
+#include "linkgraph_type.h"
+#include <list>
+#include <vector>
+
+struct SaveLoad;
+
+class Node {
+public:
+	static const NodeID INVALID = UINT_MAX;
+	Node() : supply(0), undelivered_supply(0), demand(0), station(INVALID_STATION) {}
+	Node(StationID st, uint sup, uint dem) : supply(sup), undelivered_supply(sup), demand(dem), station(st) {}
+	uint supply;
+	uint undelivered_supply;
+	uint demand;
+	StationID station;
+};
+
+class Edge {
+public:
+	Edge() : distance(0), capacity(0), demand(0) {}
+	uint distance;
+	uint capacity;
+	uint demand;
+};
+
+class LinkGraphComponent {
+	typedef std::vector<Node> NodeVector;
+	typedef std::vector<std::vector<Edge> > EdgeMatrix;
+
+public:
+	LinkGraphComponent(CargoID cargo, LinkGraphComponentID c = 0);
+	Edge & GetEdge(NodeID from, NodeID to) {return edges[from][to];}
+	Node & GetNode(NodeID num) {return nodes[num];}
+	uint GetSize() const {return num_nodes;}
+	void SetSize(uint size);
+	NodeID AddNode(StationID st, uint supply, uint demand);
+	void AddEdge(NodeID from, NodeID to, uint capacity);
+	void CalculateDistances();
+	LinkGraphComponentID GetIndex() const {return index;}
+	CargoID GetCargo() const {return cargo;}
+	const LinkGraphSettings & GetSettings() const {return settings;}
+private:
+	friend const SaveLoad * GetLinkGraphComponentDesc();
+	LinkGraphSettings settings;
+	CargoID cargo;
+	uint num_nodes;
+	LinkGraphComponentID index;
+	NodeVector nodes;
+	EdgeMatrix edges;
+};
+
+class ComponentHandler {
+public:
+	virtual void Run(LinkGraphComponent * component) = 0;
+	virtual ~ComponentHandler() {}
+};
+
+class LinkGraphJob {
+	typedef std::list<ComponentHandler *> HandlerList;
+public:
+	LinkGraphJob(LinkGraphComponent * c);
+	LinkGraphJob(LinkGraphComponent * c, Date join);
+
+	void AddHandler(ComponentHandler * handler) {this->handlers.push_back(handler);}
+	void Run();
+	void SpawnThread(CargoID cargo);
+	void Join() {if (this->thread != NULL) this->thread->Join();}
+	Date GetJoinDate() {return this->join_date;}
+	LinkGraphComponent * GetComponent() {return this->component;}
+	~LinkGraphJob();
+private:
+	/**
+	 * there cannot be two identical LinkGraphJobs,
+	 */
+	LinkGraphJob(const LinkGraphJob & other) {NOT_REACHED();}
+	ThreadObject * thread;
+	Date join_date;
+	LinkGraphComponent * component;
+	HandlerList handlers;
+};
+
+typedef std::list<LinkGraphJob *> JobList;
+
+class LinkGraph {
+public:
+	LinkGraph();
+	void Clear();
+	CargoID GetCargo() const {return cargo;}
+	/**
+	 * Starts calcluation of the next component of the link graph.
+	 * Uses a breadth first search on the graph spanned by the
+	 * stations' link stats.
+	 *
+	 * TODO: This method could be changed to only search a defined number
+	 * of stations in each run, thus decreasing the delay. The state of
+	 * the search queue would have to be saved and loaded then.
+	 */
+	void NextComponent();
+
+	/**
+	 * Merges the results of the link graph calculation into the main
+	 * game state.
+	 *
+	 * TODO: This method could be changed to only merge a fixed number of
+	 * nodes in each run. In order to do so, the ID of last node merged
+	 * would have to be saved and loaded. Merging only a fixed  number
+	 * of nodes is faster than merging all nodes of the component.
+	 */
+	void Join();
+	size_t GetNumJobs() const {return jobs.size();}
+	JobList & GetJobs() {return jobs;}
+	void AddComponent(LinkGraphComponent * component, uint join);
+
+	const static uint COMPONENTS_JOIN_TICK  = 21;
+	const static uint COMPONENTS_SPAWN_TICK = 58;
+
+private:
+	friend const SaveLoad * GetLinkGraphDesc(uint);
+	void CreateComponent(Station * first);
+	LinkGraphComponentID current_component_id;
+	StationID current_station_id;
+	CargoID cargo;
+	JobList jobs;
+};
+
+extern LinkGraph _link_graphs[NUM_CARGO];
+
+#endif /* LINKGRAPH_H_ */
diff --git a/src/linkgraph/linkgraph_type.h b/src/linkgraph/linkgraph_type.h
new file mode 100644
index 0000000..b4e1fa2
--- /dev/null
+++ b/src/linkgraph/linkgraph_type.h
@@ -0,0 +1,10 @@
+/** @file linkgraph_type.h Declaration of link graph types used for cargo distribution. */
+
+#ifndef LINKGRAPH_TYPE_H_
+#define LINKGRAPH_TYPE_H_
+
+typedef uint16 LinkGraphComponentID;
+typedef uint NodeID;
+
+
+#endif /* LINKGRAPH_TYPE_H_ */
diff --git a/src/misc.cpp b/src/misc.cpp
index 995f0dd..c93acd6 100644
--- a/src/misc.cpp
+++ b/src/misc.cpp
@@ -53,6 +53,7 @@ void InitializeCompanies();
 void InitializeCheats();
 void InitializeNPF();
 void InitializeOldNames();
+void InitializeLinkGraphs();
 
 void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settings)
 {
@@ -114,6 +115,7 @@ void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settin
 #endif /* ENABLE_NETWORK */
 	InitializeAnimatedTiles();
 
+	InitializeLinkGraphs();
 	InitializeEconomy();
 
 	ResetObjectToPlace();
diff --git a/src/moving_average.cpp b/src/moving_average.cpp
new file mode 100644
index 0000000..08d42b9
--- /dev/null
+++ b/src/moving_average.cpp
@@ -0,0 +1,28 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.cpp Implementation of moving average functions */
+
+
+#include "moving_average.h"
+#include "variables.h"
+#include "station_base.h"
+
+template <class Titem> void RunAverages()
+{
+	uint interval = _settings_game.economy.moving_average_unit * DAY_TICKS;
+	for(uint id = _tick_counter % interval; id < Titem::GetPoolSize(); id += interval) {
+		Titem *item = Titem::GetIfValid(id);
+		if (item != NULL) {
+			item->RunAverages();
+		}
+	}
+}
+
+template void RunAverages<Station>();
diff --git a/src/moving_average.h b/src/moving_average.h
new file mode 100644
index 0000000..ca9dce2
--- /dev/null
+++ b/src/moving_average.h
@@ -0,0 +1,45 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.h Utility class for moving averages. */
+
+#ifndef MOVING_AVERAGE_H_
+#define MOVING_AVERAGE_H_
+
+#include "stdafx.h"
+#include "settings_type.h"
+#include "core/math_func.hpp"
+
+template<class Tvalue>
+class MovingAverage {
+protected:
+	uint length;
+
+public:
+	FORCEINLINE MovingAverage(uint length = _settings_game.economy.moving_average_length) : length(length) 
+		{assert(this->length > 0);}
+
+	FORCEINLINE uint Length() const
+		{return this->length;}
+
+	FORCEINLINE Tvalue Monthly(const Tvalue &value) const
+		{return value * 30 / (this->length * _settings_game.economy.moving_average_unit);}
+
+	FORCEINLINE Tvalue &Decrease(Tvalue &value) const
+	{
+		value *= this->length;
+		value /= (this->length + 1);
+		return value;
+	}
+};
+
+template<class Titem> void RunAverages();
+
+#endif /* MOVING_AVERAGE_H_ */
+
diff --git a/src/openttd.cpp b/src/openttd.cpp
index 9886b9e..3f76cb3 100644
--- a/src/openttd.cpp
+++ b/src/openttd.cpp
@@ -1080,6 +1080,13 @@ void SwitchToMode(SwitchMode new_mode)
 		default: NOT_REACHED();
 	}
 
+	LinkGraphSettings &lg = _settings_game.linkgraph;
+	if (!_settings_client.gui.new_nonstop) {
+		if ((lg.demand_armoured | lg.demand_default | lg.demand_express | lg.demand_mail | lg.demand_pax) != DT_UNHANDLED) {
+			ShowErrorMessage(STR_WARNING_NONSTOP_CARGODIST, INVALID_STRING_ID, WL_WARNING, 0, true);
+		}
+	}
+
 	if (_switch_mode_errorstr != INVALID_STRING_ID) {
 		ShowErrorMessage(_switch_mode_errorstr, INVALID_STRING_ID, WL_CRITICAL);
 	}
diff --git a/src/order_base.h b/src/order_base.h
index 3e74f4c..71783e1 100644
--- a/src/order_base.h
+++ b/src/order_base.h
@@ -261,6 +261,8 @@ struct OrderList : OrderListPool::PoolItem<&_orderlist_pool> {
 private:
 	friend void AfterLoadVehicles(bool part_of_load); ///< For instantiating the shared vehicle chain
 	friend const struct SaveLoad *GetOrderListDescription(); ///< Saving and loading of order lists.
+	const Order * GetNext(const Order * curr) const;
+	const Order * GetNextStoppingOrder(const Order * next, uint hops, bool check_nonstop) const;
 
 	Order *first;                   ///< First order of the order list
 	VehicleOrderID num_orders;      ///< NOSAVE: How many orders there are in the list
@@ -310,6 +312,8 @@ public:
 	 */
 	inline Order *GetLastOrder() const { return this->GetOrderAt(this->num_orders - 1); }
 
+	StationID GetNextStoppingStation(VehicleOrderID curr, bool check_nonstop) const;
+
 	/**
 	 * Get number of orders in the order list.
 	 * @return number of orders in the chain. */
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
index e198589..614e81d 100644
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -257,6 +257,67 @@ Order *OrderList::GetOrderAt(int index) const
 	return order;
 }
 
+const Order * OrderList::GetNext(const Order * curr) const
+{
+	const Order * next = curr->next;
+	if (next == NULL) {
+		next = GetFirstOrder();
+	}
+	return next;
+}
+
+const Order * OrderList::GetNextStoppingOrder(const Order * next, uint hops, bool check_nonstop) const
+{
+	if (next == NULL || hops > GetNumOrders()) {
+		return NULL;
+	}
+
+	if (next->GetType() == OT_CONDITIONAL) {
+		const Order * skip_to = GetNextStoppingOrder(GetOrderAt(next->GetConditionSkipToOrder()), hops + 1, check_nonstop);
+		const Order * advance = GetNextStoppingOrder(next, hops + 1, check_nonstop);
+		if (skip_to == advance) {
+			return skip_to; // skipping over non-stopping orders
+		} else {
+			return NULL; // nondeterministic
+		}
+	}
+
+	bool is_station = (next->GetType() == OT_GOTO_STATION);
+
+	if (check_nonstop) {
+		switch(next->GetNonStopType()) {
+		case ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS:
+			if (is_station) return next; // else fall through
+		case ONSF_NO_STOP_AT_ANY_STATION:
+			return GetNextStoppingOrder(GetNext(next), hops + 1, check_nonstop);
+		default: // nondeterministic
+			return NULL;
+		}
+	} else {
+		if (is_station) {
+			return next;
+		} else {
+			return GetNextStoppingOrder(GetNext(next), hops + 1, check_nonstop);
+		}
+	}
+}
+
+StationID OrderList::GetNextStoppingStation(VehicleOrderID curr_id, bool check_nonstop) const {
+	const Order * curr = GetOrderAt(curr_id);
+	if (curr == NULL) {
+		curr = GetFirstOrder();
+		if (curr == NULL) {
+			return INVALID_STATION;
+		}
+	}
+	const Order * next = GetNextStoppingOrder(GetNext(curr), 1, check_nonstop);
+	if (next == NULL) {
+		return INVALID_STATION;
+	} else {
+		return next->GetDestination();
+	}
+}
+
 void OrderList::InsertOrderAt(Order *new_order, int index)
 {
 	if (this->first == NULL) {
@@ -674,6 +735,8 @@ CommandCost CmdInsertOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 			}
 			/* Update any possible open window of the vehicle */
 			InvalidateVehicleOrder(u, INVALID_VEH_ORDER_ID | (sel_ord << 8));
+
+			RecalcFrozenIfLoading(u);
 		}
 
 		/* As we insert an order, the order to skip to will be 'wrong'. */
@@ -708,6 +771,9 @@ static CommandCost DecloneOrder(Vehicle *dst, DoCommandFlag flags)
 	if (flags & DC_EXEC) {
 		DeleteVehicleOrders(dst);
 		InvalidateVehicleOrder(dst, -1);
+
+		RecalcFrozenIfLoading(dst);
+
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(dst->type), 0);
 	}
 	return CommandCost();
@@ -757,6 +823,8 @@ CommandCost CmdDeleteOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 
 			/* Update any possible open window of the vehicle */
 			InvalidateVehicleOrder(u, sel_ord | (INVALID_VEH_ORDER_ID << 8));
+
+			RecalcFrozenIfLoading(u);
 		}
 
 		/* As we delete an order, the order to skip to will be 'wrong'. */
@@ -801,10 +869,10 @@ CommandCost CmdSkipToOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 	}
 
 	if (flags & DC_EXEC) {
-		v->cur_order_index = sel_ord;
-
 		if (v->current_order.IsType(OT_LOADING)) v->LeaveStation();
 
+		v->cur_order_index = sel_ord;
+
 		InvalidateVehicleOrder(v, -2);
 	}
 
@@ -867,6 +935,8 @@ CommandCost CmdMoveOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 			assert(v->orders.list == u->orders.list);
 			/* Update any possible open window of the vehicle */
 			InvalidateVehicleOrder(u, moving_order | (target_order << 8));
+
+			RecalcFrozenIfLoading(u);
 		}
 
 		/* As we move an order, the order to skip to will be 'wrong'. */
@@ -1117,6 +1187,8 @@ CommandCost CmdModifyOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 				u->current_order.SetLoadType(order->GetLoadType());
 			}
 			InvalidateVehicleOrder(u, -2);
+
+			RecalcFrozenIfLoading(u);
 		}
 	}
 
@@ -1242,6 +1314,8 @@ CommandCost CmdCloneOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 		default: return CMD_ERROR;
 	}
 
+	RecalcFrozenIfLoading(dst);
+
 	return CommandCost();
 }
 
@@ -1539,6 +1613,8 @@ void RemoveOrderFromAllVehicles(OrderType type, DestinationID destination)
 					/* In GUI, simulate by removing the order and adding it back */
 					InvalidateVehicleOrder(w, id | (INVALID_VEH_ORDER_ID << 8));
 					InvalidateVehicleOrder(w, (INVALID_VEH_ORDER_ID << 8) | id);
+
+					RecalcFrozenIfLoading(w);
 				}
 			}
 		}
@@ -1582,6 +1658,8 @@ void DeleteVehicleOrders(Vehicle *v, bool keep_orderlist)
 		v->orders.list->FreeChain(keep_orderlist);
 		if (!keep_orderlist) v->orders.list = NULL;
 	}
+
+	RecalcFrozenIfLoading(v);
 }
 
 uint16 GetServiceIntervalClamped(uint interval, CompanyID company_id)
@@ -1782,7 +1860,7 @@ bool ProcessOrders(Vehicle *v)
 	if (((v->current_order.IsType(OT_GOTO_STATION) && (v->current_order.GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION)) || v->current_order.IsType(OT_GOTO_WAYPOINT)) &&
 			IsTileType(v->tile, MP_STATION) &&
 			v->current_order.GetDestination() == GetStationIndex(v->tile)) {
-		if (v->current_order.IsType(OT_GOTO_STATION)) v->last_station_visited = v->current_order.GetDestination();
+		/* treat it like a waypoint and don't set last_station_visited */
 		UpdateVehicleTimetable(v, true);
 		v->IncrementOrderIndex();
 	}
diff --git a/src/roadveh_cmd.cpp b/src/roadveh_cmd.cpp
index 4a9ed1a..281e007 100644
--- a/src/roadveh_cmd.cpp
+++ b/src/roadveh_cmd.cpp
@@ -1432,9 +1432,10 @@ again:
 					v->owner == GetTileOwner(v->tile) && !v->current_order.IsType(OT_LEAVESTATION) &&
 					GetRoadStopType(v->tile) == (v->IsBus() ? ROADSTOP_BUS : ROADSTOP_TRUCK)) {
 				Station *st = Station::GetByTile(v->tile);
+				StationID previous_station = v->last_station_visited;
 				v->last_station_visited = st->index;
 				RoadVehArrivesAt(v, st);
-				v->BeginLoading();
+				v->BeginLoading(previous_station);
 			}
 			return false;
 		}
@@ -1488,12 +1489,12 @@ again:
 			}
 
 			rs->SetEntranceBusy(false);
-
+			StationID previous_station = v->last_station_visited;
 			v->last_station_visited = st->index;
 
 			if (IsDriveThroughStopTile(v->tile) || (v->current_order.IsType(OT_GOTO_STATION) && v->current_order.GetDestination() == st->index)) {
 				RoadVehArrivesAt(v, st);
-				v->BeginLoading();
+				v->BeginLoading(previous_station);
 				return false;
 			}
 		} else {
diff --git a/src/saveload/linkgraph_sl.cpp b/src/saveload/linkgraph_sl.cpp
new file mode 100644
index 0000000..945d41f
--- /dev/null
+++ b/src/saveload/linkgraph_sl.cpp
@@ -0,0 +1,146 @@
+/** @file linkgraph_sl.cpp Code handling saving and loading of link graphs */
+
+#include "../linkgraph/linkgraph.h"
+#include "../linkgraph/demands.h"
+#include "../settings_internal.h"
+#include "saveload.h"
+#include <vector>
+
+const SettingDesc *GetSettingDescription(uint index);
+
+static uint32 _num_components;
+static Date _join_date;
+
+enum {
+	LGRP_GRAPH = 0,
+	LGRP_COMPONENT = 1,
+	LGRP_NODE = 2,
+	LGRP_EDGE = 3,
+};
+
+const SaveLoad * GetLinkGraphComponentDesc() {
+
+	static const SaveLoad _component_desc[] = {
+		 SLE_CONDVAR(LinkGraphComponent, num_nodes,        SLE_UINT32, LINKGRAPH_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkGraphComponent, index,            SLE_UINT16, LINKGRAPH_SV, SL_MAX_VERSION),
+		SLEG_CONDVAR(                    _join_date,       SLE_INT32,  LINKGRAPH_SV, SL_MAX_VERSION),
+		 SLE_END()
+	};
+
+	size_t offset_gamesettings = cpp_offsetof(GameSettings, linkgraph);
+	size_t offset_component = cpp_offsetof(LinkGraphComponent, settings);
+
+	typedef std::vector<SaveLoad> SaveLoadVector;
+	static SaveLoadVector saveloads;
+	static const char * prefix = "linkgraph.";
+	size_t prefixlen = strlen(prefix);
+
+	int setting = 0;
+	const SettingDesc * desc = GetSettingDescription(setting);
+	while (desc->save.cmd != SL_END) {
+		if (desc->desc.name != NULL && strncmp(desc->desc.name, prefix, prefixlen) == 0) {
+			SaveLoad sl = desc->save;
+			char *& address = reinterpret_cast<char *&>(sl.address);
+			address -= offset_gamesettings;
+			address += offset_component;
+			saveloads.push_back(sl);
+		}
+		desc = GetSettingDescription(++setting);
+	}
+
+	int i = 0;
+	do {
+		saveloads.push_back(_component_desc[i++]);
+	} while (saveloads.back().cmd != SL_END);
+
+	return &saveloads[0];
+}
+
+const SaveLoad * GetLinkGraphDesc(uint type) {
+
+	static const SaveLoad _linkgraph_desc[] = {
+		SLEG_CONDVAR(           _num_components,      SLE_UINT32, LINKGRAPH_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkGraph, current_component_id, SLE_UINT16, LINKGRAPH_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkGraph, current_station_id,   SLE_UINT16, LINKGRAPH_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkGraph, cargo,                SLE_UINT8,  LINKGRAPH_SV, SL_MAX_VERSION),
+		 SLE_END()
+	};
+
+	static const SaveLoad * _component_desc = GetLinkGraphComponentDesc();
+
+	// edges and nodes are saved in the correct order, so we don't need to save their ids.
+
+	static const SaveLoad _node_desc[] = {
+		 SLE_CONDVAR(Node, supply,    SLE_UINT32, LINKGRAPH_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(Node, demand,    SLE_UINT32, LINKGRAPH_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(Node, station,   SLE_UINT16, LINKGRAPH_SV, SL_MAX_VERSION),
+		 SLE_END()
+	};
+
+	static const SaveLoad _edge_desc[] = {
+		 SLE_CONDVAR(Edge, distance,  SLE_UINT32, LINKGRAPH_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(Edge, capacity,  SLE_UINT32, LINKGRAPH_SV, SL_MAX_VERSION),
+		 SLE_END()
+	};
+
+	static const SaveLoad *_lgrp_descs[] = {
+		_linkgraph_desc,
+		_component_desc,
+		_node_desc,
+		_edge_desc,
+	};
+
+	return _lgrp_descs[type];
+
+}
+
+static void SaveLoad_LinkGraphComponent(LinkGraphComponent * comp) {
+	for (NodeID from = 0; from < comp->GetSize(); ++from) {
+		Node * node = &comp->GetNode(from);
+		SlObject(node, GetLinkGraphDesc(LGRP_NODE));
+		node->undelivered_supply = node->supply;
+		for (NodeID to = 0; to < comp->GetSize(); ++to) {
+			SlObject(&comp->GetEdge(from, to), GetLinkGraphDesc(LGRP_EDGE));
+		}
+	}
+}
+
+static void DoSave_LGRP(void *)
+{
+	for(CargoID cargo = CT_BEGIN; cargo != CT_END; ++cargo) {
+		LinkGraph & graph = _link_graphs[cargo];
+		_num_components = (uint32)graph.GetNumJobs();
+		SlObject(&graph, GetLinkGraphDesc(LGRP_GRAPH));
+		JobList & jobs = graph.GetJobs();
+		for (JobList::iterator i = jobs.begin(); i != jobs.end(); ++i) {
+			LinkGraphJob * job = *i;
+			LinkGraphComponent * comp = job->GetComponent();
+			_join_date = job->GetJoinDate();
+			SlObject(comp, GetLinkGraphDesc(LGRP_COMPONENT));
+			SaveLoad_LinkGraphComponent(comp);
+		}
+	}
+}
+
+static void Load_LGRP()
+{
+	for(CargoID cargo = CT_BEGIN; cargo != CT_END; ++cargo) {
+		LinkGraph & graph = _link_graphs[cargo];
+		SlObject(&graph, GetLinkGraphDesc(LGRP_GRAPH));
+		for (uint32 i = 0; i < _num_components; ++i) {
+			LinkGraphComponent * comp = new LinkGraphComponent(cargo);
+			SlObject(comp, GetLinkGraphDesc(LGRP_COMPONENT));
+			comp->SetSize(comp->GetSize());
+			SaveLoad_LinkGraphComponent(comp);
+			graph.AddComponent(comp, _join_date);
+		}
+	}
+}
+
+static void Save_LGRP() {
+	SlAutolength((AutolengthProc*)DoSave_LGRP, NULL);
+}
+
+extern const ChunkHandler _linkgraph_chunk_handlers[] = {
+	{ 'LGRP', Save_LGRP,      Load_LGRP,	NULL,      CH_LAST},
+};
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
index 7a9c81e..779ae84 100644
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -46,7 +46,7 @@
 
 #include "saveload_internal.h"
 
-extern const uint16 SAVEGAME_VERSION = 138;
+extern const uint16 SAVEGAME_VERSION = DEMANDS_SV;
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
@@ -128,6 +128,7 @@ extern const ChunkHandler _group_chunk_handlers[];
 extern const ChunkHandler _cargopacket_chunk_handlers[];
 extern const ChunkHandler _autoreplace_chunk_handlers[];
 extern const ChunkHandler _labelmaps_chunk_handlers[];
+extern const ChunkHandler _linkgraph_chunk_handlers[];
 
 static const ChunkHandler * const _chunk_handlers[] = {
 	_gamelog_chunk_handlers,
@@ -155,6 +156,7 @@ static const ChunkHandler * const _chunk_handlers[] = {
 	_cargopacket_chunk_handlers,
 	_autoreplace_chunk_handlers,
 	_labelmaps_chunk_handlers,
+	_linkgraph_chunk_handlers,
 	NULL,
 };
 
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
index 0914a50..16cb63c 100644
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -338,4 +338,9 @@ bool SaveloadCrashWithMissingNewGRFs();
 
 extern char _savegame_format[8];
 
+#define MOVING_AVERAGE_SV 149
+#define CAPACITIES_SV 150
+#define LINKGRAPH_SV 155
+#define DEMANDS_SV 160
+
 #endif /* SAVELOAD_H */
diff --git a/src/saveload/station_sl.cpp b/src/saveload/station_sl.cpp
index 72f107e..d342454 100644
--- a/src/saveload/station_sl.cpp
+++ b/src/saveload/station_sl.cpp
@@ -207,6 +207,7 @@ static const SaveLoad _old_station_desc[] = {
 };
 
 static uint16 _waiting_acceptance;
+static uint16 _num_links;
 static uint16 _cargo_source;
 static uint32 _cargo_source_xy;
 static uint16 _cargo_days;
@@ -219,6 +220,21 @@ static const SaveLoad _station_speclist_desc[] = {
 	SLE_END()
 };
 
+static StationID _station_id;
+
+const SaveLoad *GetLinkStatDesc() {
+	static const SaveLoad linkstat_desc[] = {
+		SLEG_CONDVAR(             _station_id,         SLE_UINT16,      CAPACITIES_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    length,              SLE_UINT32,      CAPACITIES_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    capacity,            SLE_UINT32,      CAPACITIES_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    frozen,              SLE_UINT32,      CAPACITIES_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    usage,               SLE_UINT32,      CAPACITIES_SV, SL_MAX_VERSION),
+		 SLE_END()
+	};
+	
+	return linkstat_desc;
+}
+
 /**
  * Wrapper function to get the GoodsEntry's internal structure while
  * some of the variables itself are private.
@@ -241,7 +257,9 @@ const SaveLoad *GetGoodsDesc()
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_FILE_U32 | SLE_VAR_I64, 14, 64),
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_INT64,                  65, 67),
 		 SLE_CONDLST(GoodsEntry, cargo.packets,       REF_CARGO_PACKET,           68, SL_MAX_VERSION),
-
+		 SLE_CONDVAR(GoodsEntry, supply.supply,       SLE_UINT32,      CAPACITIES_SV, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      CAPACITIES_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, last_component,      SLE_UINT16,       LINKGRAPH_SV, SL_MAX_VERSION),
 		SLE_END()
 	};
 
@@ -379,7 +397,14 @@ static void RealSave_STNN(BaseStation *bst)
 	if (!waypoint) {
 		Station *st = Station::From(bst);
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
-			SlObject(&st->goods[i], GetGoodsDesc());
+			GoodsEntry *ge = &st->goods[i];
+			LinkStatMap &stats = ge->link_stats;
+			_num_links = (uint16)stats.size();
+			SlObject(ge, GetGoodsDesc());
+			for (LinkStatMap::iterator i = stats.begin(); i != stats.end(); ++i) {
+				_station_id = i->first;
+				SlObject(&(i->second), GetLinkStatDesc());
+			}
 		}
 	}
 
@@ -411,7 +436,15 @@ static void Load_STNN()
 		if (!waypoint) {
 			Station *st = Station::From(bst);
 			for (CargoID i = 0; i < NUM_CARGO; i++) {
-				SlObject(&st->goods[i], GetGoodsDesc());
+				GoodsEntry *ge = &st->goods[i];
+				LinkStatMap &stats = ge->link_stats;
+				SlObject(ge, GetGoodsDesc());
+				LinkStat ls;
+				for (uint16 i = 0; i < _num_links; ++i) {
+					SlObject(&ls, GetLinkStatDesc());
+					assert(!ls.IsNull());
+					stats[_station_id] = ls;
+				}
 			}
 		}
 
@@ -435,6 +468,7 @@ static void Ptrs_STNN()
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
 			GoodsEntry *ge = &st->goods[i];
 			SlObject(ge, GetGoodsDesc());
+			// as there are no pointers in the link stats we don't have to consider them
 		}
 		SlObject(st, _station_desc);
 	}
diff --git a/src/settings.cpp b/src/settings.cpp
index 051a11e..60711f3 100644
--- a/src/settings.cpp
+++ b/src/settings.cpp
@@ -1437,7 +1437,7 @@ void DeleteGRFPresetFromConfig(const char *config_name)
 	delete ini;
 }
 
-static const SettingDesc *GetSettingDescription(uint index)
+const SettingDesc *GetSettingDescription(uint index)
 {
 	if (index >= lengthof(_settings)) return NULL;
 	return &_settings[index];
diff --git a/src/settings_gui.cpp b/src/settings_gui.cpp
index 70dc8a4..1a86867 100644
--- a/src/settings_gui.cpp
+++ b/src/settings_gui.cpp
@@ -1380,11 +1380,27 @@ static SettingEntry _settings_economy[] = {
 	SettingEntry(&_settings_economy_industries_page, STR_CONFIG_SETTING_ECONOMY_INDUSTRIES),
 	SettingEntry("economy.inflation"),
 	SettingEntry("economy.smooth_economy"),
+	SettingEntry("economy.moving_average_unit"),
+	SettingEntry("economy.moving_average_length"),
 	SettingEntry("economy.feeder_payment_share"),
 };
 /** Economy sub-page */
 static SettingsPage _settings_economy_page = {_settings_economy, lengthof(_settings_economy)};
 
+static SettingEntry _settings_linkgraph[] = {
+	SettingEntry("linkgraph.recalc_interval"),
+	SettingEntry("linkgraph.demand_pax"),
+	SettingEntry("linkgraph.demand_mail"),
+	SettingEntry("linkgraph.demand_express"),
+	SettingEntry("linkgraph.demand_armoured"),
+	SettingEntry("linkgraph.demand_default"),
+	SettingEntry("linkgraph.accuracy"),
+	SettingEntry("linkgraph.demand_distance"),
+	SettingEntry("linkgraph.demand_size"),
+};
+/** Linkgraph sub-page */
+static SettingsPage _settings_linkgraph_page = {_settings_linkgraph, lengthof(_settings_linkgraph)};
+
 static SettingEntry _settings_ai_npc[] = {
 	SettingEntry("ai.ai_in_multiplayer"),
 	SettingEntry("ai.ai_disable_veh_train"),
@@ -1475,6 +1491,7 @@ static SettingEntry _settings_main[] = {
 	SettingEntry(&_settings_vehicles_page,     STR_CONFIG_SETTING_VEHICLES),
 	SettingEntry(&_settings_stations_page,     STR_CONFIG_SETTING_STATIONS),
 	SettingEntry(&_settings_economy_page,      STR_CONFIG_SETTING_ECONOMY),
+	SettingEntry(&_settings_linkgraph_page,    STR_CONFIG_SETTING_LINKGRAPH),
 	SettingEntry(&_settings_ai_page,           STR_CONFIG_SETTING_AI),
 };
 
diff --git a/src/settings_type.h b/src/settings_type.h
index 8a7c15e..f18dbd4 100644
--- a/src/settings_type.h
+++ b/src/settings_type.h
@@ -17,6 +17,7 @@
 #include "transport_type.h"
 #include "network/core/config.h"
 #include "company_type.h"
+#include "linkgraph/demand_settings.h"
 
 /** Settings related to the difficulty of the game */
 struct DifficultySettings {
@@ -347,6 +348,20 @@ struct EconomySettings {
 	TownFoundingByte found_town;             ///< town founding, @see TownFounding
 	bool   station_noise_level;              ///< build new airports when the town noise level is still within accepted limits
 	uint16 town_noise_population[3];         ///< population to base decision on noise evaluation (@see town_council_tolerance)
+	uint16 moving_average_unit;              ///< unit of time to use for calculating the moving averages
+	uint16 moving_average_length;            ///< minimum length of moving averages
+};
+
+struct LinkGraphSettings {
+	uint16 recalc_interval;                  ///< minimum interval (in days) between subsequent recalculations of the same component of the link graph
+	DistributionTypeByte demand_pax;         ///< demand calculation for passengers
+	DistributionTypeByte demand_mail;        ///< demand calculation for mail
+	DistributionTypeByte demand_express;     ///< demand calculation for express cargo class
+	DistributionTypeByte demand_armoured;    ///< demand calculation for armoured cargo class
+	DistributionTypeByte demand_default;     ///< demand calculation for all other goods
+	uint8 accuracy;                          ///< accuracy when calculating things on the link graph. low accuracy => low running time
+	uint8 demand_size;                       ///< influence of supply ("station size") on the demand function
+	uint8 demand_distance;                   ///< influence of distance between stations on the demand function
 };
 
 /** Settings related to stations. */
@@ -389,6 +404,7 @@ struct GameSettings {
 	OrderSettings        order;              ///< settings related to orders
 	VehicleSettings      vehicle;            ///< options for vehicles
 	EconomySettings      economy;            ///< settings to change the economy
+	LinkGraphSettings    linkgraph;          ///< settings for link graph calculations
 	StationSettings      station;            ///< settings related to station management
 	LocaleSettings       locale;             ///< settings related to used currency/unit system in the current game
 };
diff --git a/src/ship_cmd.cpp b/src/ship_cmd.cpp
index ec907d2..a1550af 100644
--- a/src/ship_cmd.cpp
+++ b/src/ship_cmd.cpp
@@ -517,13 +517,14 @@ static void ShipController(Ship *v)
 									return;
 								}
 							} else if (v->current_order.IsType(OT_GOTO_STATION)) {
+								StationID previous_station = v->last_station_visited;
 								v->last_station_visited = v->current_order.GetDestination();
 
 								/* Process station in the orderlist. */
 								Station *st = Station::Get(v->current_order.GetDestination());
 								if (st->facilities & FACIL_DOCK) { // ugly, ugly workaround for problem with ships able to drop off cargo at wrong stations
 									ShipArrivesAt(v, st);
-									v->BeginLoading();
+									v->BeginLoading(previous_station);
 								} else { // leave stations without docks right aways
 									v->current_order.MakeLeaveStation();
 									v->IncrementOrderIndex();
diff --git a/src/station.cpp b/src/station.cpp
index 039be31..c64db6e 100644
--- a/src/station.cpp
+++ b/src/station.cpp
@@ -70,6 +70,14 @@ Station::~Station()
 		if (a->targetairport == this->index) a->targetairport = INVALID_STATION;
 	}
 
+	Station * st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID c = CT_BEGIN; c != CT_END; ++c) {
+			GoodsEntry & ge = st->goods[c];
+			ge.link_stats.erase(this->index);
+		}
+	}
+
 	Vehicle *v;
 	FOR_ALL_VEHICLES(v) {
 		/* Forget about this station if this station is removed */
diff --git a/src/station_base.h b/src/station_base.h
index e3aa8b7..b3a6962 100644
--- a/src/station_base.h
+++ b/src/station_base.h
@@ -17,12 +17,133 @@
 #include "newgrf_airport.h"
 #include "cargopacket.h"
 #include "industry_type.h"
+#include "linkgraph/linkgraph_type.h"
+#include "moving_average.h"
+#include <list>
+#include <map>
 
 typedef Pool<BaseStation, StationID, 32, 64000> StationPool;
 extern StationPool _station_pool;
 
 static const byte INITIAL_STATION_RATING = 175;
 
+class LinkStat : private MovingAverage<uint> {
+private:
+	/**
+	 * capacity of the link.
+	 * This is a moving average use MovingAverage::Monthly() to get a meaningful value 
+	 */
+	uint capacity;
+	
+	/**
+	 * capacity of currently loading vehicles
+	 */
+	uint frozen;
+	
+	/**
+	 * usage of the link.
+	 * This is a moving average use MovingAverage::Monthly() to get a meaningful value 
+	 */
+	uint usage;
+
+public:
+	friend const SaveLoad *GetLinkStatDesc();
+
+	FORCEINLINE LinkStat(uint distance = 1, uint capacity = 0, uint frozen = 0, uint usage = 0) :
+		MovingAverage<uint>(distance), capacity(capacity), frozen(frozen), usage(usage) {}
+
+	FORCEINLINE void Clear()
+	{
+		this->capacity = 0;
+		this->usage = 0;
+		this->frozen = 0;
+	}
+
+	FORCEINLINE void Decrease()
+	{
+		this->MovingAverage<uint>::Decrease(this->usage);
+		this->capacity = max(this->MovingAverage<uint>::Decrease(this->capacity), this->frozen);
+	}
+
+	FORCEINLINE uint Capacity() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->capacity);
+	}
+
+	FORCEINLINE uint Usage() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->usage);
+	}
+
+	FORCEINLINE uint Frozen() const
+	{
+		return this->frozen;
+	}
+
+	FORCEINLINE void Increase(uint capacity, uint usage)
+	{
+		this->capacity += capacity;
+		this->usage += usage;
+	}
+
+	FORCEINLINE void Freeze(uint capacity)
+	{
+		this->frozen += capacity;
+		this->capacity = max(this->frozen, this->capacity);
+	}
+
+	FORCEINLINE void Unfreeze(uint capacity)
+	{
+		this->frozen -= capacity;
+	}
+
+	FORCEINLINE void Unfreeze()
+	{
+		this->frozen = 0;
+	}
+
+	FORCEINLINE bool IsNull() const
+	{
+		return this->capacity == 0;
+	}
+};
+
+typedef std::map<StationID, LinkStat> LinkStatMap;
+
+uint GetMovingAverageLength(const Station *from, const Station *to);
+
+class SupplyMovingAverage {
+private:
+	uint supply;
+
+public:
+	friend const SaveLoad *GetGoodsDesc();
+
+	FORCEINLINE SupplyMovingAverage(uint supply = 0) : supply(supply) {}
+
+	FORCEINLINE void Increase(uint value) {this->supply += value;}
+
+	FORCEINLINE void Decrease() {MovingAverage<SupplyMovingAverage>().Decrease(*this);}
+
+	FORCEINLINE uint Value() const {return MovingAverage<uint>().Monthly(this->supply);}
+
+	FORCEINLINE SupplyMovingAverage &operator/=(uint divident)
+		{this->supply = DivideApprox(this->supply, divident); return *this;}
+
+	FORCEINLINE SupplyMovingAverage &operator*=(uint factor)
+		{this->supply *= factor; return *this;}
+
+	FORCEINLINE SupplyMovingAverage operator/(uint divident) const
+		{return SupplyMovingAverage(DivideApprox(this->supply, divident));}
+
+	FORCEINLINE SupplyMovingAverage operator*(uint factor) const
+		{return SupplyMovingAverage(this->supply * factor);}
+
+	FORCEINLINE bool IsNull() const
+		{return this->supply == 0;}
+};
+
+
 struct GoodsEntry {
 	enum AcceptancePickup {
 		ACCEPTANCE,
@@ -34,7 +155,8 @@ struct GoodsEntry {
 		days_since_pickup(255),
 		rating(INITIAL_STATION_RATING),
 		last_speed(0),
-		last_age(255)
+		last_age(255),
+		last_component(0)
 	{}
 
 	byte acceptance_pickup;
@@ -43,6 +165,9 @@ struct GoodsEntry {
 	byte last_speed;
 	byte last_age;
 	StationCargoList cargo; ///< The cargo packets of cargo waiting in this station
+	SupplyMovingAverage supply;
+	LinkStatMap link_stats; ///< capacities and usage statistics for outgoing links
+	LinkGraphComponentID last_component; ///< the component this station was last part of in this cargo's link graph
 };
 
 
@@ -137,6 +262,8 @@ public:
 	/* virtual */ uint32 GetNewGRFVariable(const ResolverObject *object, byte variable, byte parameter, bool *available) const;
 
 	/* virtual */ void GetTileArea(TileArea *ta, StationType type) const;
+
+	void RunAverages();
 };
 
 #define FOR_ALL_STATIONS(var) FOR_ALL_BASE_STATIONS_OF_TYPE(Station, var)
diff --git a/src/station_cmd.cpp b/src/station_cmd.cpp
index 51072e4..e626107 100644
--- a/src/station_cmd.cpp
+++ b/src/station_cmd.cpp
@@ -47,6 +47,7 @@
 #include "core/random_func.hpp"
 #include "company_base.h"
 #include "newgrf.h"
+#include "moving_average.h"
 #include "table/airporttile_ids.h"
 #include "newgrf_airporttiles.h"
 
@@ -3073,6 +3074,121 @@ static void UpdateStationRating(Station *st)
 	}
 }
 
+uint GetMovingAverageLength(const Station *from, const Station *to)
+{
+	return _settings_game.economy.moving_average_length + (DistanceManhattan(from->xy, to->xy) >> 2);
+}
+
+void Station::RunAverages() {
+	for(int goods_index = CT_BEGIN; goods_index != CT_END; ++goods_index) {
+		GoodsEntry & good = this->goods[goods_index];
+		good.supply.Decrease();
+		LinkStatMap & links = good.link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end();) {
+			StationID id = i->first;
+			Station *other = Station::GetIfValid(id);
+			if (other == NULL) {
+				links.erase(i++);
+			} else {
+				LinkStat & ls = i->second;
+				ls.Decrease();
+				if (ls.IsNull()) {
+					links.erase(i++);
+				} else {
+					++i;
+				}
+			}
+		}
+	}
+}
+
+void RecalcFrozenIfLoading(const Vehicle * v) {
+	if (v->current_order.IsType(OT_LOADING)) {
+		RecalcFrozen(Station::Get(v->last_station_visited));
+	}
+}
+
+void RecalcFrozen(Station * st) {
+	if (st->loading_vehicles.empty()) {
+		/* if no vehicles are there the frozen values are always correct */
+		return;
+	}
+
+	for(int goods_index = CT_BEGIN; goods_index != CT_END; ++goods_index) {
+		GoodsEntry & good = st->goods[goods_index];
+		LinkStatMap & links = good.link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end(); ++i) {
+			i->second.Unfreeze();
+		}
+	}
+
+	std::list<Vehicle *>::iterator v_it = st->loading_vehicles.begin();
+	while(v_it != st->loading_vehicles.end()) {
+		const Vehicle * front = *v_it;
+		OrderList * orders = front->orders.list;
+		if (orders != NULL) {
+			StationID next_station_id = orders->GetNextStoppingStation(front->cur_order_index, front->type == VEH_ROAD || front->type == VEH_TRAIN);
+			if (next_station_id != INVALID_STATION && next_station_id != st->index) {
+				IncreaseStats(st, front, next_station_id, true);
+			}
+		}
+		++v_it;
+	}
+}
+
+void DecreaseFrozen(Station *st, const Vehicle *front, StationID next_station_id) {
+	assert(st->index != next_station_id && next_station_id != INVALID_STATION);
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			LinkStatMap & link_stats = st->goods[v->cargo_type].link_stats;
+			LinkStatMap::iterator lstat_it = link_stats.find(next_station_id);
+			if (lstat_it == link_stats.end()) {
+				DEBUG(misc, 0, "frozen not in linkstat list.");
+				RecalcFrozen(st);
+				return;
+			} else {
+				LinkStat & link_stat = lstat_it->second;
+				if (link_stat.Frozen() < v->cargo_cap) {
+					DEBUG(misc, 0, "frozen is smaller than cargo cap.");
+					RecalcFrozen(st);
+					return;
+				} else {
+					link_stat.Unfreeze(v->cargo_cap);
+				}
+				assert(!link_stat.IsNull());
+			}
+		}
+	}
+}
+
+void IncreaseStats(Station *st, const Vehicle *front, StationID next_station_id, bool freeze) {
+	Station *next = Station::GetIfValid(next_station_id);
+	assert(st->index != next_station_id && next != NULL);
+	uint average_length = GetMovingAverageLength(st, next);
+
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			LinkStatMap &stats = st->goods[v->cargo_type].link_stats;
+			LinkStatMap::iterator i = stats.find(next_station_id);
+			if (i == stats.end()) {
+				stats.insert(std::make_pair(next_station_id, LinkStat(
+					average_length, v->cargo_cap,
+					freeze ? v->cargo_cap : 0,
+					freeze ? 0 : v->cargo.Count()
+				)));
+			} else {
+				LinkStat & link_stat = i->second;
+				if (freeze) {
+					link_stat.Freeze(v->cargo_cap);
+				} else {
+					link_stat.Increase(v->cargo_cap, v->cargo.Count());
+				}
+				assert(!link_stat.IsNull());
+			}
+		}
+	}
+}
+
 /* called for every station each tick */
 static void StationHandleSmallTick(BaseStation *st)
 {
@@ -3089,10 +3205,12 @@ void OnTick_Station()
 {
 	if (_game_mode == GM_EDITOR) return;
 
+	RunAverages<Station>();
+
 	BaseStation *st;
 	FOR_ALL_BASE_STATIONS(st) {
 		StationHandleSmallTick(st);
-
+		
 		/* Run 250 tick interval trigger for station animation.
 		 * Station index is included so that triggers are not all done
 		 * at the same time. */
@@ -3131,8 +3249,10 @@ void ModifyStationRatingAround(TileIndex tile, Owner owner, int amount, uint rad
 
 static void UpdateStationWaiting(Station *st, CargoID type, uint amount, SourceType source_type, SourceID source_id)
 {
-	st->goods[type].cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id));
-	SetBit(st->goods[type].acceptance_pickup, GoodsEntry::PICKUP);
+	GoodsEntry & good = st->goods[type];
+	good.cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id));
+	SetBit(good.acceptance_pickup, GoodsEntry::PICKUP);
+	good.supply.Increase(amount);
 
 	StationAnimationTrigger(st, st->xy, STAT_ANIM_NEW_CARGO, type);
 	AirportAnimationTrigger(st, AAT_STATION_NEW_CARGO, type);
diff --git a/src/station_func.h b/src/station_func.h
index 2a2d831..1ec2f5f 100644
--- a/src/station_func.h
+++ b/src/station_func.h
@@ -18,6 +18,7 @@
 #include "road_type.h"
 #include "cargo_type.h"
 #include "company_type.h"
+#include "vehicle_base.h"
 
 void ModifyStationRatingAround(TileIndex tile, Owner owner, int amount, uint radius);
 
@@ -49,4 +50,12 @@ bool IsStationTileElectrifiable(TileIndex tile);
 
 void UpdateAirportsNoise();
 
+void DecreaseFrozen(Station *st, const Vehicle *v, StationID next_station_id);
+
+void RecalcFrozen(Station * st);
+
+void RecalcFrozenIfLoading(const Vehicle * v);
+
+void IncreaseStats(Station *st, const Vehicle *v, StationID next_station_id, bool freeze);
+
 #endif /* STATION_FUNC_H */
diff --git a/src/table/settings.h b/src/table/settings.h
index 81b7a7a..5b58109 100644
--- a/src/table/settings.h
+++ b/src/table/settings.h
@@ -452,10 +452,22 @@ const SettingDesc _settings[] = {
 	     SDT_VAR(GameSettings, economy.dist_local_authority,         SLE_UINT8,                     0, 0,    20,     5,      60, 0, STR_NULL,                                  NULL),
 	     SDT_VAR(GameSettings, pf.wait_oneway_signal,                SLE_UINT8,                     0, 0,    15,     2,     255, 0, STR_NULL,                                  NULL),
 	     SDT_VAR(GameSettings, pf.wait_twoway_signal,                SLE_UINT8,                     0, 0,    41,     2,     255, 0, STR_NULL,                                  NULL),
+	 SDT_CONDVAR(GameSettings, economy.moving_average_unit,         SLE_UINT16, MOVING_AVERAGE_SV, SL_MAX_VERSION, 0, 0, 1, 1, 4096, 1,	STR_CONFIG_SETTING_AVERAGE_UNIT,   NULL),
+	 SDT_CONDVAR(GameSettings, economy.moving_average_length,       SLE_UINT16, MOVING_AVERAGE_SV, SL_MAX_VERSION, 0, 0, 64, 1, 4096, 4, STR_CONFIG_SETTING_AVERAGE_LENGTH,    NULL),
 	 SDT_CONDVAR(GameSettings, economy.town_noise_population[0],    SLE_UINT16, 96, SL_MAX_VERSION, 0, 0,   800,   200,   65535, 0, STR_NULL,                                  NULL),
 	 SDT_CONDVAR(GameSettings, economy.town_noise_population[1],    SLE_UINT16, 96, SL_MAX_VERSION, 0, 0,  2000,   400,   65535, 0, STR_NULL,                                  NULL),
 	 SDT_CONDVAR(GameSettings, economy.town_noise_population[2],    SLE_UINT16, 96, SL_MAX_VERSION, 0, 0,  4000,   800,   65535, 0, STR_NULL,                                  NULL),
 
+	 SDT_CONDVAR(GameSettings, linkgraph.recalc_interval,           SLE_UINT16, LINKGRAPH_SV, SL_MAX_VERSION,  0, 0,16, 1, 4096, 1, STR_CONFIG_SETTING_LINKGRAPH_INTERVAL,     NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_pax,                 SLE_UINT8,DEMANDS_SV, SL_MAX_VERSION,0,MS,DT_SYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DEMAND_PAX, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_mail,                SLE_UINT8,DEMANDS_SV,SL_MAX_VERSION,0,MS,DT_SYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DEMAND_MAIL, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_express,      SLE_UINT8,DEMANDS_SV,SL_MAX_VERSION,0,MS,DT_ANTISYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DEMAND_EXPRESS, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_armoured,        SLE_UINT8,DEMANDS_SV,SL_MAX_VERSION,0,MS,DT_SYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DEMAND_ARMOURED, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_default,      SLE_UINT8,DEMANDS_SV,SL_MAX_VERSION,0,MS,DT_ANTISYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DEMAND_DEFAULT, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.accuracy,                   SLE_UINT8,DEMANDS_SV, SL_MAX_VERSION, 0, 0,16,  2,      64, 1, STR_CONFIG_SETTING_LINKGRAPH_ACCURACY,     NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_distance,            SLE_UINT8,DEMANDS_SV, SL_MAX_VERSION, 0, 0,100, 0,     255, 5, STR_CONFIG_SETTING_DEMAND_DISTANCE,        NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_size,                SLE_UINT8,DEMANDS_SV, SL_MAX_VERSION, 0, 0,100, 0,     100, 5, STR_CONFIG_SETTING_DEMAND_SIZE,            NULL),
+
 	 SDT_CONDVAR(GameSettings, pf.wait_for_pbs_path,                 SLE_UINT8,100, SL_MAX_VERSION, 0, 0,    30,     2,     255, 0, STR_NULL,                                  NULL),
 	SDT_CONDBOOL(GameSettings, pf.reserve_paths,                               100, SL_MAX_VERSION, 0, 0, false,                    STR_NULL,                                  NULL),
 	 SDT_CONDVAR(GameSettings, pf.path_backoff_interval,             SLE_UINT8,100, SL_MAX_VERSION, 0, 0,    20,     1,     255, 0, STR_NULL,                                  NULL),
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
index c0575f9..65aea12 100644
--- a/src/train_cmd.cpp
+++ b/src/train_cmd.cpp
@@ -2976,6 +2976,7 @@ int Train::UpdateSpeed()
 
 static void TrainEnterStation(Train *v, StationID station)
 {
+	StationID previous_station = v->last_station_visited;
 	v->last_station_visited = station;
 
 	/* check if a train ever visited this station before */
@@ -2992,7 +2993,7 @@ static void TrainEnterStation(Train *v, StationID station)
 		AI::NewEvent(v->owner, new AIEventStationFirstVehicle(st->index, v->index));
 	}
 
-	v->BeginLoading();
+	v->BeginLoading(previous_station);
 
 	StationAnimationTrigger(st, v->tile, STAT_ANIM_TRAIN_ARRIVES);
 }
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index bba6a52..e41ce54 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -1542,7 +1542,7 @@ uint GetVehicleCapacity(const Vehicle *v, uint16 *mail_capacity)
 }
 
 
-void Vehicle::BeginLoading()
+void Vehicle::BeginLoading(StationID last_station_id)
 {
 	assert(IsTileType(tile, MP_STATION) || type == VEH_SHIP);
 
@@ -1562,7 +1562,23 @@ void Vehicle::BeginLoading()
 		current_order.MakeLoading(false);
 	}
 
-	Station::Get(this->last_station_visited)->loading_vehicles.push_back(this);
+	StationID curr_station_id = this->last_station_visited;
+	Station * curr_station = Station::Get(curr_station_id);
+	curr_station->loading_vehicles.push_back(this);
+
+	StationID next_station_id = INVALID_STATION;
+	OrderList * orders = this->orders.list;
+	if (orders != NULL) {
+		next_station_id = orders->GetNextStoppingStation(this->cur_order_index, this->type == VEH_ROAD || this->type == VEH_TRAIN);
+	}
+
+	if (last_station_id != INVALID_STATION && last_station_id != curr_station_id) {
+		IncreaseStats(Station::Get(last_station_id), this, curr_station_id, false);
+	}
+
+	if (next_station_id != INVALID_STATION && next_station_id != curr_station_id) {
+		IncreaseStats(curr_station, this, next_station_id, true);
+	}
 
 	PrepareUnload(this);
 
@@ -1589,6 +1605,17 @@ void Vehicle::LeaveStation()
 	Station *st = Station::Get(this->last_station_visited);
 	st->loading_vehicles.remove(this);
 
+	OrderList * orders = this->orders.list;
+	if (orders != NULL) {
+		StationID next_station_id = orders->GetNextStoppingStation(this->cur_order_index, this->type == VEH_ROAD || this->type == VEH_TRAIN);
+		if (next_station_id != INVALID_STATION && next_station_id != this->last_station_visited) {
+			DecreaseFrozen(st, this, next_station_id);
+		}
+	} else {
+		DEBUG(misc, 0, "orders are NULL");
+		RecalcFrozen(st);
+	}
+
 	HideFillingPercent(&this->fill_percent_te_id);
 
 	if (this->type == VEH_TRAIN && !(this->vehstatus & VS_CRASHED)) {
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index bea2485..c1207d1 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -193,7 +193,7 @@ public:
 	/** We want to 'destruct' the right class. */
 	virtual ~Vehicle();
 
-	void BeginLoading();
+	void BeginLoading(StationID last_station_id);
 	void LeaveStation();
 
 	/**
