Index: projects/openttd_vs80.vcproj
===================================================================
--- projects/openttd_vs80.vcproj	(revision 17081)
+++ projects/openttd_vs80.vcproj	(working copy)
@@ -592,6 +592,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1100,6 +1116,30 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\demand_settings.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_types.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -2132,6 +2172,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
Index: projects/openttd_vs90.vcproj
===================================================================
--- projects/openttd_vs90.vcproj	(revision 17081)
+++ projects/openttd_vs90.vcproj	(working copy)
@@ -589,6 +589,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1097,6 +1113,30 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\demand_settings.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_types.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -2129,6 +2169,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
Index: source.list
===================================================================
--- source.list	(revision 17081)
+++ source.list	(working copy)
@@ -33,6 +33,10 @@
 highscore.cpp
 ini.cpp
 landscape.cpp
+linkgraph/demands.cpp
+linkgraph/flowmapper.cpp
+linkgraph/linkgraph.cpp
+linkgraph/mcf.cpp
 map.cpp
 md5.cpp
 minilzo.cpp
@@ -203,6 +207,12 @@
 ini_type.h
 landscape.h
 landscape_type.h
+linkgraph/demands.h
+linkgraph/demand_settings.h
+linkgraph/flowmapper.h
+linkgraph/linkgraph.h
+linkgraph/linkgraph_types.h
+linkgraph/mcf.h
 livery.h
 lzoconf.h
 map_func.h
@@ -480,6 +490,7 @@
 saveload/group_sl.cpp
 saveload/industry_sl.cpp
 saveload/labelmaps_sl.cpp
+saveload/linkgraph_sl.cpp
 saveload/map_sl.cpp
 saveload/misc_sl.cpp
 saveload/newgrf_sl.cpp
Index: src/aircraft_cmd.cpp
===================================================================
--- src/aircraft_cmd.cpp	(revision 17081)
+++ src/aircraft_cmd.cpp	(working copy)
@@ -1359,6 +1359,7 @@
 	if (v->current_order.IsType(OT_GOTO_DEPOT)) return;
 
 	Station *st = Station::Get(v->targetairport);
+	StationID previous_station = v->last_station_visited;
 	v->last_station_visited = v->targetairport;
 
 	/* Check if station was ever visited before */
@@ -1375,7 +1376,7 @@
 		AI::NewEvent(v->owner, new AIEventStationFirstVehicle(st->index, v->index));
 	}
 
-	v->BeginLoading();
+	v->BeginLoading(previous_station);
 }
 
 static void AircraftLandAirplane(Aircraft *v)
Index: src/autoreplace_cmd.cpp
===================================================================
--- src/autoreplace_cmd.cpp	(revision 17081)
+++ src/autoreplace_cmd.cpp	(working copy)
@@ -111,7 +111,7 @@
 			uint amount = min(src->cargo.Count(), dest->cargo_cap - dest->cargo.Count());
 			if (amount <= 0) continue;
 
-			src->cargo.MoveTo(&dest->cargo, amount, CargoList::MTA_UNLOAD, NULL);
+			src->cargo.MoveToVehicle(&dest->cargo, amount);
 		}
 	}
 
Index: src/blitter/32bpp_anim.cpp
===================================================================
--- src/blitter/32bpp_anim.cpp	(revision 17081)
+++ src/blitter/32bpp_anim.cpp	(working copy)
@@ -18,8 +18,8 @@
 {
 	const SpriteData *src = (const SpriteData *)bp->sprite;
 
-	const Colour *src_px = (const Colour *)(src->data + src->offset[zoom][0]);
-	const uint8  *src_n  = (const uint8  *)(src->data + src->offset[zoom][1]);
+	const Colour *src_px = (const Colour *)(src->data + src->offset[zoom - ZOOM_LVL_BLITTER_MIN][0]);
+	const uint8  *src_n  = (const uint8  *)(src->data + src->offset[zoom - ZOOM_LVL_BLITTER_MIN][1]);
 
 	for (uint i = bp->skip_top; i != 0; i--) {
 		src_px = (const Colour *)((const byte *)src_px + *(const uint32 *)src_px);
Index: src/blitter/32bpp_optimized.cpp
===================================================================
--- src/blitter/32bpp_optimized.cpp	(revision 17081)
+++ src/blitter/32bpp_optimized.cpp	(working copy)
@@ -25,11 +25,11 @@
 
 	/* src_px : each line begins with uint32 n = 'number of bytes in this line',
 	 *          then n times is the Colour struct for this line */
-	const Colour *src_px = (const Colour *)(src->data + src->offset[zoom][0]);
+	const Colour *src_px = (const Colour *)(src->data + src->offset[zoom - ZOOM_LVL_BLITTER_MIN][0]);
 	/* src_n  : each line begins with uint32 n = 'number of bytes in this line',
 	 *          then interleaved stream of 'm' and 'n' channels. 'm' is remap,
 	 *          'n' is number of bytes with the same alpha channel class */
-	const uint8  *src_n  = (const uint8  *)(src->data + src->offset[zoom][1]);
+	const uint8  *src_n  = (const uint8  *)(src->data + src->offset[zoom - ZOOM_LVL_BLITTER_MIN][1]);
 
 	/* skip upper lines in src_px and src_n */
 	for (uint i = bp->skip_top; i != 0; i--) {
@@ -255,7 +255,7 @@
 	/* streams of pixels (a, r, g, b channels)
 	 *
 	 * stored in separated stream so data are always aligned on 4B boundary */
-	Colour *dst_px_orig[ZOOM_LVL_COUNT];
+	Colour *dst_px_orig[ZOOM_LVL_BLITTER_COUNT];
 
 	/* interleaved stream of 'm' channel and 'n' channel
 	 * 'n' is number if following pixels with the same alpha channel class
@@ -263,21 +263,22 @@
 	 *
 	 * it has to be stored in one stream so fewer registers are used -
 	 * x86 has problems with register allocation even with this solution */
-	uint8  *dst_n_orig[ZOOM_LVL_COUNT];
+	uint8  *dst_n_orig[ZOOM_LVL_BLITTER_COUNT];
 
 	/* lengths of streams */
-	uint32 lengths[ZOOM_LVL_COUNT][2];
+	uint32 lengths[ZOOM_LVL_BLITTER_COUNT][2];
 
-	for (ZoomLevel z = ZOOM_LVL_BEGIN; z < ZOOM_LVL_END; z++) {
-		const SpriteLoader::Sprite *src_orig = ResizeSprite(sprite, z);
+	ZoomLevel zoom_value = ZOOM_LVL_BLITTER_MIN;
+	for (int zoom_index = 0; zoom_index < ZOOM_LVL_BLITTER_COUNT; zoom_index++, zoom_value++) {
+		const SpriteLoader::Sprite *src_orig = ResizeSprite(sprite, zoom_value);
 
 		uint size = src_orig->height * src_orig->width;
 
-		dst_px_orig[z] = CallocT<Colour>(size + src_orig->height * 2);
-		dst_n_orig[z]  = CallocT<uint8>(size * 2 + src_orig->height * 4 * 2);
+		dst_px_orig[zoom_index] = CallocT<Colour>(size + src_orig->height * 2);
+		dst_n_orig[zoom_index]  = CallocT<uint8>(size * 2 + src_orig->height * 4 * 2);
 
-		uint32 *dst_px_ln = (uint32 *)dst_px_orig[z];
-		uint32 *dst_n_ln  = (uint32 *)dst_n_orig[z];
+		uint32 *dst_px_ln = (uint32 *)dst_px_orig[zoom_index];
+		uint32 *dst_n_ln  = (uint32 *)dst_n_orig[zoom_index];
 
 		const SpriteLoader::CommonPixel *src = (const SpriteLoader::CommonPixel *)src_orig->data;
 
@@ -344,15 +345,15 @@
 			dst_n_ln =  (uint32 *)dst_n;
 		}
 
-		lengths[z][0] = (byte *)dst_px_ln - (byte *)dst_px_orig[z]; // all are aligned to 4B boundary
-		lengths[z][1] = (byte *)dst_n_ln  - (byte *)dst_n_orig[z];
+		lengths[zoom_index][0] = (byte *)dst_px_ln - (byte *)dst_px_orig[zoom_index]; // all are aligned to 4B boundary
+		lengths[zoom_index][1] = (byte *)dst_n_ln  - (byte *)dst_n_orig[zoom_index];
 
 		free(src_orig->data);
 		free((void *)src_orig);
 	}
 
 	uint len = 0; // total length of data
-	for (ZoomLevel z = ZOOM_LVL_BEGIN; z < ZOOM_LVL_END; z++) {
+	for (int z = 0; z < ZOOM_LVL_BLITTER_COUNT; z++) {
 		len += lengths[z][0] + lengths[z][1];
 	}
 
@@ -365,8 +366,8 @@
 
 	SpriteData *dst = (SpriteData *)dest_sprite->data;
 
-	for (ZoomLevel z = ZOOM_LVL_BEGIN; z < ZOOM_LVL_END; z++) {
-		dst->offset[z][0] = z == ZOOM_LVL_BEGIN ? 0 : lengths[z - 1][1] + dst->offset[z - 1][1];
+	for (int z = 0; z < ZOOM_LVL_BLITTER_COUNT; z++) {
+		dst->offset[z][0] = z == 0 ? 0 : lengths[z - 1][1] + dst->offset[z - 1][1];
 		dst->offset[z][1] = lengths[z][0] + dst->offset[z][0];
 
 		memcpy(dst->data + dst->offset[z][0], dst_px_orig[z], lengths[z][0]);
Index: src/blitter/32bpp_optimized.hpp
===================================================================
--- src/blitter/32bpp_optimized.hpp	(revision 17081)
+++ src/blitter/32bpp_optimized.hpp	(working copy)
@@ -11,7 +11,7 @@
 class Blitter_32bppOptimized : public Blitter_32bppSimple {
 public:
 	struct SpriteData {
-		uint32 offset[ZOOM_LVL_COUNT][2];
+		uint32 offset[ZOOM_LVL_BLITTER_COUNT][2];
 		byte data[];
 	};
 
Index: src/blitter/8bpp_optimized.cpp
===================================================================
--- src/blitter/8bpp_optimized.cpp	(revision 17081)
+++ src/blitter/8bpp_optimized.cpp	(working copy)
@@ -14,7 +14,7 @@
 {
 	/* Find the offset of this zoom-level */
 	const SpriteData *sprite_src = (const SpriteData *)bp->sprite;
-	uint offset = sprite_src->offset[zoom];
+	uint offset = sprite_src->offset[zoom - ZOOM_LVL_BLITTER_MIN];
 
 	/* Find where to start reading in the source sprite */
 	const uint8 *src = sprite_src->data + offset;
@@ -107,7 +107,7 @@
 	/* Make memory for all zoom-levels */
 	uint memory = sizeof(SpriteData);
 
-	for (ZoomLevel i = ZOOM_LVL_BEGIN; i < ZOOM_LVL_END; i++) {
+	for (ZoomLevel i = ZOOM_LVL_BLITTER_MIN; i <= ZOOM_LVL_BLITTER_MAX; i++) {
 		memory += UnScaleByZoom(sprite->height, i) * UnScaleByZoom(sprite->width, i);
 	}
 
@@ -122,15 +122,16 @@
 	byte *dst = temp_dst->data;
 
 	/* Make the sprites per zoom-level */
-	for (ZoomLevel i = ZOOM_LVL_BEGIN; i < ZOOM_LVL_END; i++) {
+	ZoomLevel zoom_value = ZOOM_LVL_BLITTER_MIN;
+	for (int zoom_index = 0; zoom_index < ZOOM_LVL_BLITTER_COUNT; zoom_index++, zoom_value++) {
 		/* Store the index table */
 		uint offset = dst - temp_dst->data;
-		temp_dst->offset[i] = offset;
+		temp_dst->offset[zoom_index] = offset;
 
 		/* cache values, because compiler can't cache it */
-		int scaled_height = UnScaleByZoom(sprite->height, i);
-		int scaled_width  = UnScaleByZoom(sprite->width,  i);
-		int scaled_1      =   ScaleByZoom(1,              i);
+		int scaled_height = UnScaleByZoom(sprite->height, zoom_value);
+		int scaled_width  = UnScaleByZoom(sprite->width,  zoom_value);
+		int scaled_1      =   ScaleByZoom(1,              zoom_value);
 
 		for (int y = 0; y < scaled_height; y++) {
 			uint trans = 0;
@@ -139,7 +140,7 @@
 			byte *count_dst = NULL;
 
 			/* Store the scaled image */
-			const SpriteLoader::CommonPixel *src = &sprite->data[ScaleByZoom(y, i) * sprite->width];
+			const SpriteLoader::CommonPixel *src = &sprite->data[ScaleByZoom(y, zoom_value) * sprite->width];
 			const SpriteLoader::CommonPixel *src_end = &src[sprite->width];
 
 			for (int x = 0; x < scaled_width; x++) {
Index: src/blitter/8bpp_optimized.hpp
===================================================================
--- src/blitter/8bpp_optimized.hpp	(revision 17081)
+++ src/blitter/8bpp_optimized.hpp	(working copy)
@@ -11,8 +11,8 @@
 class Blitter_8bppOptimized : public Blitter_8bppBase {
 public:
 	struct SpriteData {
-		uint32 offset[ZOOM_LVL_COUNT]; ///< offsets (from .data) to streams for different zoom levels
-		byte data[];                   ///< data, all zoomlevels
+		uint32 offset[ZOOM_LVL_BLITTER_COUNT]; ///< offsets (from .data) to streams for different zoom levels
+		byte data[];                           ///< data, all zoomlevels
 	};
 
 	/* virtual */ void Draw(Blitter::BlitterParams *bp, BlitterMode mode, ZoomLevel zoom);
Index: src/cargo_type.h
===================================================================
--- src/cargo_type.h	(revision 17081)
+++ src/cargo_type.h	(working copy)
@@ -9,6 +9,7 @@
 
 /** Available types of cargo */
 enum CargoTypes {
+	CT_BEGIN        =  0,
 	/* Temperate */
 	CT_PASSENGERS   =  0,
 	CT_COAL         =  1,
@@ -50,6 +51,7 @@
 	CT_FIZZY_DRINKS = 11,
 
 	NUM_CARGO       = 32,
+	CT_END          = 32,
 
 	CT_NO_REFIT     = 0xFE,
 	CT_INVALID      = 0xFF
Index: src/cargopacket.cpp
===================================================================
--- src/cargopacket.cpp	(revision 17081)
+++ src/cargopacket.cpp	(working copy)
@@ -3,6 +3,7 @@
 /** @file cargopacket.cpp Implementation of the cargo packets */
 
 #include "stdafx.h"
+#include "station_base.h"
 #include "core/pool_func.hpp"
 #include "economy_base.h"
 #include "station_base.h"
@@ -16,11 +17,12 @@
 	_cargopacket_pool.CleanPool();
 }
 
-CargoPacket::CargoPacket(StationID source, uint16 count)
+CargoPacket::CargoPacket(StationID source, StationID next, uint16 count)
 {
 	if (source != INVALID_STATION) assert(count != 0);
 
 	this->source          = source;
+	this->next            = next;
 	this->source_xy       = (source != INVALID_STATION) ? Station::Get(source)->xy : 0;
 	this->loaded_at_xy    = this->source_xy;
 
@@ -75,6 +77,11 @@
 	InvalidateCache();
 }
 
+void CargoList::Import(List & list)
+{
+	packets.splice(packets.end(), list);
+	InvalidateCache();
+}
 
 void CargoList::Truncate(uint count)
 {
@@ -99,81 +106,182 @@
 	InvalidateCache();
 }
 
-bool CargoList::MoveTo(CargoList *dest, uint count, CargoList::MoveToAction mta, CargoPayment *payment, uint data)
-{
-	assert(mta == MTA_FINAL_DELIVERY || dest != NULL);
-	assert(mta == MTA_UNLOAD || mta == MTA_CARGO_LOAD || payment != NULL);
-	CargoList tmp;
+CargoPacket * CargoPacket::Split(uint new_size) {
+	CargoPacket *cp_new = new CargoPacket(source, next, new_size);
+	Money fs = feeder_share * new_size / static_cast<uint>(count);
+	feeder_share -= fs;
+	cp_new->source_xy       = source_xy;
+	cp_new->loaded_at_xy    = loaded_at_xy;
+	cp_new->days_in_transit = days_in_transit;
+	cp_new->feeder_share    = fs;
+	count -= new_size;
+	return cp_new;
+}
 
-	while (!packets.empty() && count > 0) {
-		CargoPacket *cp = *packets.begin();
-		if (cp->count <= count) {
-			/* Can move the complete packet */
-			packets.remove(cp);
-			switch (mta) {
-				case MTA_FINAL_DELIVERY:
-					if (cp->source == data) {
-						tmp.Append(cp);
-					} else {
-						payment->PayFinalDelivery(cp, cp->count);
-						count -= cp->count;
-						delete cp;
-					}
-					continue; // of the loop
+void CargoList::DeliverPacket(List::iterator & c, uint & remaining_unload, CargoPayment *payment) {
+	CargoPacket * p = *c;
+	if (p->count <= remaining_unload) {
+		remaining_unload -= p->count;
+		payment->PayFinalDelivery(p, p->count);
+		delete p;
+		packets.erase(c++);
+	} else {
+		payment->PayFinalDelivery(p, remaining_unload);
+		p->count -= remaining_unload;
+		remaining_unload = 0;
+		++c;
+	}
+}
 
-				case MTA_CARGO_LOAD:
-					cp->loaded_at_xy = data;
-					break;
+CargoPacket * CargoList::TransferPacket(List::iterator & c, uint & remaining_unload, GoodsEntry *dest, CargoPayment *payment) {
+	CargoPacket * p = *c;
+	if (p->count <= remaining_unload) {
+		packets.erase(c++);
+	} else {
+		p = p->Split(remaining_unload);
+		++c;
+	}
+	payment->PayTransfer(p, p->count);
+	dest->cargo.packets.push_back(p);
+	SetBit(dest->acceptance_pickup, GoodsEntry::PICKUP);
+	remaining_unload -= p->count;
+	return p;
+}
 
-				case MTA_TRANSFER:
-					payment->PayTransfer(cp, cp->count);
-					break;
+UnloadType CargoList::WillUnload(const UnloadDescription & ul, const CargoPacket * p) const {
+	if (ul.dest->flows[p->source].empty()) {
+		/* there is no plan: use normal unloading */
+		return WillUnloadOld(ul, p);
+	} else {
+		/* use cargodist unloading*/
+		return WillUnloadCargoDist(ul, p);
+	}
+}
 
-				case MTA_UNLOAD:
-					break;
+UnloadType CargoList::WillUnloadOld(const UnloadDescription & ul, const CargoPacket * p) const {
+	/* try to unload cargo */
+	bool move = (ul.flags & (UL_DELIVER | UL_ACCEPTED | UL_TRANSFER)) != 0;
+	/* try to deliver cargo if unloading */
+	bool deliver = (ul.flags & UL_ACCEPTED) && !(ul.flags & UL_TRANSFER) && (p->source != ul.curr_station);
+	/* transfer cargo if delivery was unsuccessful */
+	bool transfer = (ul.flags & (UL_TRANSFER | UL_DELIVER)) != 0;
+	if (move) {
+		if(deliver) {
+			return UL_DELIVER;
+		} else if (transfer) {
+			return UL_TRANSFER;
+		} else {
+			/* this case is for (non-)delivery to the source station without special flags.
+			 * like the code in MoveTo did, we keep the packet in this case
+			 */
+			return UL_KEEP;
+		}
+	} else {
+		return UL_KEEP;
+	}
+}
+
+UnloadType CargoList::WillUnloadCargoDist(const UnloadDescription & ul, const CargoPacket * p) const {
+	StationID via = ul.dest->flows[p->source].begin()->via;
+	if (via == ul.curr_station) {
+		/* this is the final destination, deliver ... */
+		if (ul.flags & UL_TRANSFER) {
+			/* .. except if explicitly told not to do so ... */
+			return UL_TRANSFER;
+		} else if (ul.flags & UL_ACCEPTED) {
+			return UL_DELIVER;
+		} else if (ul.flags & UL_DELIVER) {
+			/* .. or if the station suddenly doesn't accept our cargo, but we have an explicit deliver order... */
+			return UL_TRANSFER;
+		} else {
+			/* .. or else if it doesn't accept. */
+			return UL_KEEP;
+		}
+	} else {
+		/* packet has to travel on, find out if it can stay on board */
+		if (ul.flags & UL_DELIVER) {
+			/* order overrides cargodist:
+			 * play by the old loading rules here as player is interfering with cargodist
+			 * try to deliver, as move has been forced upon us */
+			if ((ul.flags & UL_ACCEPTED) && !(ul.flags & UL_TRANSFER) && p->source != ul.curr_station) {
+				return UL_DELIVER;
+			} else {
+				/* transfer cargo, as delivering didn't work */
+				/* plan might still be fulfilled as the packet can be picked up by another vehicle travelling to "via" */
+				return UL_TRANSFER;
 			}
-			count -= cp->count;
-			dest->packets.push_back(cp);
+		} else if (ul.flags & UL_TRANSFER) {
+			/* transfer forced, plan still fulfilled as above */
+			return UL_TRANSFER;
+		} else if (ul.next_station == via || ul.next_station == INVALID_STATION) {
+			/* vehicle goes to the packet's next hop or has nondeterministic order: keep the packet*/
+			return UL_KEEP;
 		} else {
-			/* Can move only part of the packet, so split it into two pieces */
-			if (mta != MTA_FINAL_DELIVERY) {
-				CargoPacket *cp_new = new CargoPacket();
+			/* vehicle goes somewhere else, transfer the packet*/
+			return UL_TRANSFER;
+		}
+	}
+}
 
-				Money fs = cp->feeder_share * count / static_cast<uint>(cp->count);
-				cp->feeder_share -= fs;
+uint CargoList::MoveToStation(GoodsEntry * dest, uint max_unload, OrderUnloadFlags flags, StationID curr_station, StationID next_station, CargoPayment *payment) {
+	uint remaining_unload = max_unload;
+	UnloadDescription ul(dest, curr_station, next_station, flags);
 
-				cp_new->source          = cp->source;
-				cp_new->source_xy       = cp->source_xy;
-				cp_new->loaded_at_xy    = (mta == MTA_CARGO_LOAD) ? data : cp->loaded_at_xy;
+	for(List::iterator c = packets.begin(); c != packets.end() && remaining_unload > 0;) {
 
-				cp_new->days_in_transit = cp->days_in_transit;
-				cp_new->feeder_share    = fs;
+		CargoPacket * p = *c;
+		StationID source = p->source;
+		uint last_remaining = remaining_unload;
+		UnloadType unload_flags = WillUnload(ul, p);
 
-				cp_new->count = count;
-				dest->packets.push_back(cp_new);
+		if (unload_flags & UL_DELIVER) {
+			DeliverPacket(c, remaining_unload, payment);
+			dest->UpdateFlowStats(source, last_remaining - remaining_unload, curr_station);
+		} else if (unload_flags & UL_TRANSFER) {
+			/* TransferPacket may split the packet and return the transferred part */
+			p = TransferPacket(c, remaining_unload, dest, payment);
+			p->next = dest->UpdateFlowStatsTransfer(source, last_remaining - remaining_unload, curr_station);
+		} else /* UL_KEEP */ {
+			++c;
+		}
+	}
 
-				if (mta == MTA_TRANSFER) payment->PayTransfer(cp_new, count);
+	dest->cargo.InvalidateCache();
+	InvalidateCache();
+	return max_unload - remaining_unload;
+}
+
+uint CargoList::LoadPackets(List * dest, uint cap, StationID next_station, List * rejected, TileIndex load_place) {
+	while(!packets.empty() && cap > 0) {
+		CargoPacket * p = packets.front();
+		if (rejected == NULL || p->next == next_station || p->next == INVALID_STATION || next_station == INVALID_STATION) {
+			/* load the packet if possible */
+			if (p->count <= cap) {
+				/* load all of the packet */
+				packets.pop_front();
 			} else {
-				payment->PayFinalDelivery(cp, count);
+				/* packet needs to be split */
+				p = p->Split(cap);
+				assert(p->count == cap);
 			}
-			cp->count -= count;
-
-			count = 0;
+			cap -= p->count;
+			dest->push_back(p);
+			if (load_place != INVALID_TILE) {
+				p->loaded_at_xy = load_place;
+			}
+		} else {
+			packets.pop_front();
+			rejected->push_back(p);
 		}
 	}
-
-	bool remaining = !packets.empty();
-
-	if (mta == MTA_FINAL_DELIVERY && !tmp.Empty()) {
-		/* There are some packets that could not be delivered at the station, put them back */
-		tmp.MoveTo(this, UINT_MAX, MTA_UNLOAD, NULL);
-		tmp.packets.clear();
-	}
-
-	if (dest != NULL) dest->InvalidateCache();
 	InvalidateCache();
+	return cap;
+}
 
-	return remaining;
+uint CargoList::MoveToVehicle(CargoList *dest, uint max_load, StationID next_station, List * rejected, TileIndex load_place) {
+	uint space_remaining = LoadPackets(&dest->packets, max_load, next_station, rejected, load_place);
+	dest->InvalidateCache();
+	return max_load - space_remaining;
 }
 
 void CargoList::InvalidateCache()
@@ -196,3 +304,34 @@
 	source = (*packets.begin())->source;
 }
 
+UnloadDescription::UnloadDescription(GoodsEntry * d, StationID curr, StationID next, OrderUnloadFlags order_flags) :
+	dest(d), curr_station(curr), next_station(next), flags(UL_KEEP)
+{
+	if (HasBit(dest->acceptance_pickup, GoodsEntry::ACCEPTANCE)) {
+		flags |= UL_ACCEPTED;
+	}
+	if (order_flags & OUFB_UNLOAD) {
+		flags |= UL_DELIVER;
+	}
+	if (order_flags & OUFB_TRANSFER) {
+		flags |= UL_TRANSFER;
+	}
+}
+
+void CargoList::RerouteStalePackets(StationID curr, StationID to, GoodsEntry * ge) {
+	for(List::iterator it = packets.begin(); it != packets.end(); ++it) {
+		CargoPacket * packet = *it;
+		if (packet->next == to) {
+			packet->next = ge->UpdateFlowStatsTransfer(packet->source, packet->count, curr);
+		}
+	}
+	InvalidateCache();
+}
+
+void CargoList::UpdateFlows(StationID next, GoodsEntry * ge) {
+	for(List::iterator i = packets.begin(); i != packets.end(); ++i) {
+		CargoPacket * p = *i;
+		ge->UpdateFlowStats(p->source, p->count, next);
+		p->next = next;
+	}
+}
Index: src/cargopacket.h
===================================================================
--- src/cargopacket.h	(revision 17081)
+++ src/cargopacket.h	(working copy)
@@ -9,10 +9,13 @@
 #include "economy_type.h"
 #include "tile_type.h"
 #include "station_type.h"
+#include "order_type.h"
 #include <list>
 
 typedef uint32 CargoPacketID;
 struct CargoPacket;
+struct GoodsEntry;
+class Payment;
 
 /** We want to use a pool */
 typedef Pool<CargoPacket, CargoPacketID, 1024, 1048576> CargoPacketPool;
@@ -26,6 +29,7 @@
 	TileIndex source_xy;    ///< The origin of the cargo (first station in feeder chain)
 	TileIndex loaded_at_xy; ///< Location where this cargo has been loaded into the vehicle
 	StationID source;       ///< The station where the cargo came from first
+	StationID next;         ///< The next hop where this cargo is trying to go
 
 	uint16 count;           ///< The amount of cargo in this packet
 	byte days_in_transit;   ///< Amount of days this packet has been in transit
@@ -36,7 +40,7 @@
 	 * @param count  the number of cargo entities to put in this packet
 	 * @pre count != 0 || source == INVALID_STATION
 	 */
-	CargoPacket(StationID source = INVALID_STATION, uint16 count = 0);
+	CargoPacket(StationID source = INVALID_STATION, StationID next = INVALID_STATION, uint16 count = 0);
 
 	/** Destroy the packet */
 	~CargoPacket() { }
@@ -49,8 +53,10 @@
 	 */
 	FORCEINLINE bool SameSource(const CargoPacket *cp) const
 	{
-		return this->source_xy == cp->source_xy && this->days_in_transit == cp->days_in_transit;
+		return this->source_xy == cp->source_xy && this->days_in_transit == cp->days_in_transit && this->next == cp->next;
 	}
+	
+	CargoPacket * Split(uint new_size);
 };
 
 /**
@@ -68,6 +74,30 @@
 
 extern const struct SaveLoad *GetGoodsDesc();
 
+enum UnloadType {
+	UL_KEEP     = 0,      ///< keep cargo on vehicle
+	UL_DELIVER  = 1 << 0, ///< deliver cargo
+	UL_TRANSFER = 1 << 1, ///< transfer cargo
+	UL_ACCEPTED = 1 << 2, ///< cargo is accepted
+};
+
+struct UnloadDescription {
+	UnloadDescription(GoodsEntry * d, StationID curr, StationID next, OrderUnloadFlags f);
+	GoodsEntry * dest;
+	/**
+	 * station we are trying to unload at now
+	 */
+	StationID curr_station;
+	/**
+	 * station the vehicle will unload at next
+	 */
+	StationID next_station;
+	/**
+	 * delivery flags
+	 */
+	byte flags;
+};
+
 /**
  * Simple collection class for a list of cargo packets
  */
@@ -76,14 +106,6 @@
 	/** List of cargo packets */
 	typedef std::list<CargoPacket *> List;
 
-	/** Kind of actions that could be done with packets on move */
-	enum MoveToAction {
-		MTA_FINAL_DELIVERY, ///< "Deliver" the packet to the final destination, i.e. destroy the packet
-		MTA_CARGO_LOAD,     ///< Load the packet onto a vehicle, i.e. set the last loaded station ID
-		MTA_TRANSFER,       ///< The cargo is moved as part of a transfer
-		MTA_UNLOAD,         ///< The cargo is moved as part of a forced unload
-	};
-
 private:
 	List packets;         ///< The cargo packets in this list
 
@@ -93,6 +115,12 @@
 	StationID source;     ///< Cache for the source of the packet
 	uint days_in_transit; ///< Cache for the number of days in transit
 
+	void DeliverPacket(List::iterator & c, uint & remaining_unload, CargoPayment *payment);
+	CargoPacket * TransferPacket(List::iterator & c, uint & remaining_unload, GoodsEntry * dest, CargoPayment *payment);
+	UnloadType WillUnloadOld(const UnloadDescription & ul, const CargoPacket * p) const;
+	UnloadType WillUnloadCargoDist(const UnloadDescription & ul, const CargoPacket * p) const;
+	uint LoadPackets(List * dest, uint cap, StationID next_station, List * rejected = NULL, TileIndex load_place = INVALID_TILE);
+
 public:
 	friend const struct SaveLoad *GetGoodsDesc();
 
@@ -153,6 +181,12 @@
 	void Append(CargoPacket *cp);
 
 	/**
+	 * imports a complete CargoList by splicing its elements into this one
+	 * runs in constant time.
+	 */
+	void Import(List & list);
+
+	/**
 	 * Truncates the cargo in this list to the given amount. It leaves the
 	 * first count cargo entities and removes the rest.
 	 * @param count the maximum amount of entities to be in the list after the command
@@ -160,28 +194,54 @@
 	void Truncate(uint count);
 
 	/**
-	 * Moves the given amount of cargo to another list.
-	 * Depending on the value of mta the side effects of this function differ:
-	 *  - MTA_FINAL_DELIVERY: destroys the packets that do not originate from a specific station
-	 *  - MTA_CARGO_LOAD:     sets the loaded_at_xy value of the moved packets
-	 *  - MTA_TRANSFER:       just move without side effects
-	 *  - MTA_UNLOAD:         just move without side effects
-	 * @param dest  the destination to move the cargo to
-	 * @param count the amount of cargo entities to move
-	 * @param mta   how to handle the moving (side effects)
-	 * @param data  Depending on mta the data of this variable differs:
-	 *              - MTA_FINAL_DELIVERY - station ID of packet's origin not to remove
-	 *              - MTA_CARGO_LOAD     - station's tile index of load
-	 *              - MTA_TRANSFER       - unused
-	 *              - MTA_UNLOAD         - unused
-	 * @param payment The payment helper
-	 *
-	 * @pre mta == MTA_FINAL_DELIVERY || dest != NULL
-	 * @pre mta == MTA_UNLOAD || mta == MTA_CARGO_LOAD || payment != NULL
-	 * @return true if there are still packets that might be moved from this cargo list
+	 * Moves the given amount of cargo from a vehicle to a station.
+	 * Depending on the value of flags and dest the side effects of this function differ:
+	 *  - dest->acceptance_pickup & GoodsEntry::ACCEPTANCE:
+	 *                        => MoveToStation sets OUF_UNLOAD_IF_POSSIBLE in the flags
+	 *                        packets are accepted here and may be unloaded and/or delivered (=destroyed);
+	 *                        if not using cargodist: all packets are unloaded and delivered
+	 *                        if using cargodist: only packets which have this station as final destination are unloaded and delivered
+	 *                        if using cargodist: other packets may or may not be unloaded, depending on next_station
+	 *                        if not set and using cargodist: packets may still be unloaded, but not delivered.
+	 *  - OUFB_UNLOAD: unload all packets unconditionally;
+	 *                        if OUF_UNLOAD_IF_POSSIBLE set and OUFB_TRANSFER not set: also deliver packets (no matter if using cargodist)
+	 *  - OUFB_TRANSFER: don't deliver any packets;
+	 *                        overrides delivering aspect of OUF_UNLOAD_IF_POSSIBLE
+	 * @param dest         the destination to move the cargo to
+	 * @param max_unload   the maximum amount of cargo entities to move
+	 * @param flags        how to handle the moving (side effects)
+	 * @param curr_station the station where the cargo currently resides
+	 * @param next_station the next unloading station in the vehicle's order list
+	 * @return the number of cargo entities actually moved
 	 */
-	bool MoveTo(CargoList *dest, uint count, CargoList::MoveToAction mta, CargoPayment *payment, uint data = 0);
+	uint MoveToStation(GoodsEntry * dest, uint max_unload, OrderUnloadFlags flags, StationID curr_station, StationID next_station, CargoPayment *payment);
 
+	UnloadType WillUnload(const UnloadDescription & ul, const CargoPacket * p) const;
+
+	/**
+	 * Moves the given amount of cargo to a vehicle.
+	 * @param dest         the destination to move the cargo to
+	 * @param max_load     the maximum amount of cargo entities to move
+	 * @param force_load   if set, move cargo unconditionally,
+	 *                     else only move if CargoPacket::next==next_station or CargoPacket::next==INVALID_STATION
+	 * @param load_place   The place where the loading takes/took place;
+	 *                     if load_place != INVALID_TILE CargoPacket::loaded_at_xy will be set accordingly
+	 */
+	uint MoveToVehicle(CargoList *dest, uint max_load, StationID next_station = INVALID_STATION, List * rejected = NULL, TileIndex load_place = INVALID_TILE);
+
+	/**
+	 * route all packets with station "to" as next hop to a different place, except "curr"
+	 */
+	void RerouteStalePackets(StationID curr, StationID to, GoodsEntry * ge);
+
+	void ReservePacketsForLoading(List * reserved, uint cap, StationID next_station, List * rejected)
+		{LoadPackets(reserved, cap, next_station, rejected);}
+
+	/**
+	 * send all packets to the specified station and update the flow stats at the GoodsEntry accordingly
+	 */
+	void UpdateFlows(StationID next, GoodsEntry * ge);
+
 	/** Invalidates the cached data and rebuild it */
 	void InvalidateCache();
 };
Index: src/cargotype.h
===================================================================
--- src/cargotype.h	(revision 17081)
+++ src/cargotype.h	(working copy)
@@ -105,6 +105,9 @@
 CargoID GetCargoIDByLabel(CargoLabel cl);
 CargoID GetCargoIDByBitnum(uint8 bitnum);
 
+/* set up the cargos to be displayed in the smallmap's route legend */
+void BuildRouteMapLegend();
+
 static inline bool IsCargoInClass(CargoID c, uint16 cc)
 {
 	return (CargoSpec::Get(c)->classes & cc) != 0;
Index: src/core/math_func.cpp
===================================================================
--- src/core/math_func.cpp	(revision 17081)
+++ src/core/math_func.cpp	(working copy)
@@ -39,3 +39,21 @@
 	return a;
 
 }
+
+
+/**
+ * Deterministic approximate division.
+ * Cancels out division errors stemming from the integer nature of the division over multiple runs.
+ */
+int DivideApprox(int a, int b) {
+	int random_like = ((a + b) * (a - b)) % b;
+
+	int remainder = a % b;
+
+	int ret = a / b;
+	if (abs(random_like) < abs(remainder)) {
+		ret += (a * b < 0) ? -1 : 1;
+	}
+
+	return ret;
+}
Index: src/core/math_func.hpp
===================================================================
--- src/core/math_func.hpp	(revision 17081)
+++ src/core/math_func.hpp	(working copy)
@@ -264,5 +264,6 @@
 
 int LeastCommonMultiple(int a, int b);
 int GreatestCommonDivisor(int a, int b);
+int DivideApprox(int a, int b);
 
 #endif /* MATH_FUNC_HPP */
Index: src/economy.cpp
===================================================================
--- src/economy.cpp	(revision 17081)
+++ src/economy.cpp	(working copy)
@@ -1182,7 +1182,7 @@
  * Prepare the vehicle to be unloaded.
  * @param front_v the vehicle to be unloaded
  */
-void PrepareUnload(Vehicle *front_v)
+void PrepareUnload(Station * curr_station, Vehicle *front_v, StationID next_station_id)
 {
 	/* At this moment loading cannot be finished */
 	ClrBit(front_v->vehicle_flags, VF_LOADING_FINISHED);
@@ -1190,11 +1190,15 @@
 	/* Start unloading in at the first possible moment */
 	front_v->load_unload_time_rem = 1;
 
-	if ((front_v->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
+	if (front_v->current_order.GetUnloadType() & OUFB_NO_UNLOAD) {
+		/* vehicle will keep all its cargo and LoadUnloadVehicle will never call MoveToStation */
+		UpdateFlows(curr_station, front_v, next_station_id);
+	} else {
 		for (Vehicle *v = front_v; v != NULL; v = v->Next()) {
 			if (v->cargo_cap > 0 && !v->cargo.Empty()) {
 				SetBit(v->vehicle_flags, VF_CARGO_UNLOADING);
 			}
+			v->cargo.InvalidateCache();
 		}
 	}
 
@@ -1203,32 +1207,62 @@
 }
 
 /**
+ * Moves packets from the reservation list back into the station
+ */
+static void ReimportReserved(Station * st, CargoReservation & reserved) {
+	for (CargoReservation::iterator i = reserved.begin(); i != reserved.end(); ++i) {
+		st->goods[i->first].cargo.Import(i->second);
+	}
+}
+
+/**
+ * reserves cargo if the full load order and improved_load is set. Moves rejected packets from the rejection list
+ * back into the station
+ */
+static void ReserveAndUnreject(Station * st, Vehicle * u, StationID next_station, CargoReservation & reserved, CargoReservation & rejected)
+{
+	if (_settings_game.order.improved_load && (u->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
+		/* Update reserved cargo */
+		for (Vehicle * v = u; v != NULL; v = v->Next()) {
+			CargoID cargo = v->cargo_type;
+			CargoList & list = st->goods[cargo].cargo;
+			list.ReservePacketsForLoading(&reserved[cargo], v->cargo_cap - v->cargo.Count(), next_station, &rejected[cargo]);
+		}
+	}
+	ReimportReserved(st, rejected);
+}
+
+/**
  * Loads/unload the vehicle if possible.
  * @param v the vehicle to be (un)loaded
- * @param cargo_left the amount of each cargo type that is
- *                   virtually left on the platform to be
+ * @param reserved   the amount of each cargo type that is
+ *                   left on the platform to be
  *                   picked up by another vehicle when all
  *                   previous vehicles have loaded.
  */
-static void LoadUnloadVehicle(Vehicle *v, int *cargo_left)
+static void LoadUnloadVehicle(Vehicle *v, CargoReservation & reserved)
 {
+	CargoReservation rejected;
 	assert(v->current_order.IsType(OT_LOADING));
 	assert(v->load_unload_time_rem != 0);
 
+	Vehicle *u = v;
+	StationID last_visited = u->last_station_visited;
+	Station *st = Station::Get(last_visited);
+
+	StationID next_station = INVALID_STATION;
+	OrderList * orders = u->orders.list;
+	if (orders != NULL) {
+		next_station = orders->GetNextStoppingStation(u->cur_order_index, v->type == VEH_TRAIN || v->type == VEH_ROAD);
+	}
+
 	/* We have not waited enough time till the next round of loading/unloading */
-	if (--v->load_unload_time_rem != 0) {
-		if (_settings_game.order.improved_load && (v->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
-			/* 'Reserve' this cargo for this vehicle, because we were first. */
-			for (; v != NULL; v = v->Next()) {
-				int cap_left = v->cargo_cap - v->cargo.Count();
-				if (cap_left > 0) cargo_left[v->cargo_type] -= cap_left;
-			}
-		}
+	if (--u->load_unload_time_rem != 0) {
+		ReserveAndUnreject(st, u, next_station, reserved, rejected);
 		return;
 	}
 
-	StationID last_visited = v->last_station_visited;
-	Station *st = Station::Get(last_visited);
+	OrderUnloadFlags unload_flags = u->current_order.GetUnloadType();
 
 	if (v->type == VEH_TRAIN && (!IsTileType(v->tile, MP_STATION) || GetStationIndex(v->tile) != st->index)) {
 		/* The train reversed in the station. Take the "easy" way
@@ -1238,7 +1272,7 @@
 	}
 
 	int unloading_time = 0;
-	Vehicle *u = v;
+
 	int result = 0;
 
 	bool completely_emptied = true;
@@ -1266,58 +1300,28 @@
 
 		GoodsEntry *ge = &st->goods[v->cargo_type];
 
-		if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING) && (u->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
+		if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING) && (unload_flags & OUFB_NO_UNLOAD) == 0) {
+			/* vehicle wants to unload something */
+
 			uint cargo_count = v->cargo.Count();
 			uint amount_unloaded = _settings_game.order.gradual_loading ? min(cargo_count, load_amount) : cargo_count;
-			bool remaining = false; // Are there cargo entities in this vehicle that can still be unloaded here?
-			bool accepted  = false; // Is the cargo accepted by the station?
 
 			payment->SetCargo(v->cargo_type);
+			uint delivered = v->cargo.MoveToStation(ge, amount_unloaded, unload_flags, last_visited, next_station, payment);
 
-			if (HasBit(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE) && !(u->current_order.GetUnloadType() & OUFB_TRANSFER)) {
-				/* The cargo has reached it's final destination, the packets may now be destroyed */
-				remaining = v->cargo.MoveTo(NULL, amount_unloaded, CargoList::MTA_FINAL_DELIVERY, payment, last_visited);
-
-				result |= 1;
-				accepted = true;
-			}
-
-			/* The !accepted || v->cargo.Count == cargo_count clause is there
-			 * to make it possible to force unload vehicles at the station where
-			 * they were loaded, but to not force unload the vehicle when the
-			 * station is still accepting the cargo in the vehicle. It doesn't
-			 * accept cargo that was loaded at the same station. */
-			if ((u->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) && (!accepted || v->cargo.Count() == cargo_count)) {
-				remaining = v->cargo.MoveTo(&ge->cargo, amount_unloaded, u->current_order.GetUnloadType() & OUFB_TRANSFER ? CargoList::MTA_TRANSFER : CargoList::MTA_UNLOAD, payment);
-				SetBit(ge->acceptance_pickup, GoodsEntry::PICKUP);
-
-				result |= 2;
-			} else if (!accepted) {
-				/* The order changed while unloading (unset unload/transfer) or the
-				 * station does not accept our goods. */
-				ClrBit(v->vehicle_flags, VF_CARGO_UNLOADING);
-
-				/* Say we loaded something, otherwise we'll think we didn't unload
-				 * something and we didn't load something, so we must be finished
-				 * at this station. Setting the unloaded means that we will get a
-				 * retry for loading in the next cycle. */
-				anything_unloaded = true;
-				continue;
-			}
-
-			/* Deliver goods to the station */
 			st->time_since_unload = 0;
+			unloading_time += delivered;
+			anything_unloaded = true;
+			result |= 1;
 
-			unloading_time += amount_unloaded;
-
-			anything_unloaded = true;
-			if (_settings_game.order.gradual_loading && remaining) {
-				completely_emptied = false;
-			} else {
-				/* We have finished unloading (cargo count == 0) */
+			if (!_settings_game.order.gradual_loading || delivered < amount_unloaded || delivered == 0){
+				/* done delivering */
+				if (!v->cargo.Empty()) {
+					completely_emptied = false;
+					v->cargo.UpdateFlows(next_station, ge);
+				}
 				ClrBit(v->vehicle_flags, VF_CARGO_UNLOADING);
 			}
-
 			continue;
 		}
 
@@ -1340,49 +1344,51 @@
 		/* If there's goods waiting at the station, and the vehicle
 		 * has capacity for it, load it on the vehicle. */
 		int cap_left = v->cargo_cap - v->cargo.Count();
-		if (!ge->cargo.Empty() && cap_left > 0) {
-			uint cap = cap_left;
-			uint count = ge->cargo.Count();
+		if (cap_left > 0) {
+			if (!ge->cargo.Empty()) {
+				uint cap = cap_left;
+				uint count = ge->cargo.Count();
 
-			/* Skip loading this vehicle if another train/vehicle is already handling
-			 * the same cargo type at this station */
-			if (_settings_game.order.improved_load && cargo_left[v->cargo_type] <= 0) {
-				SetBit(cargo_not_full, v->cargo_type);
-				continue;
-			}
+				if (cap > count) cap = count;
+				if (_settings_game.order.gradual_loading) cap = min(cap, load_amount);
 
-			if (cap > count) cap = count;
-			if (_settings_game.order.gradual_loading) cap = min(cap, load_amount);
-			if (_settings_game.order.improved_load) {
-				/* Don't load stuff that is already 'reserved' for other vehicles */
-				cap = min((uint)cargo_left[v->cargo_type], cap);
-				cargo_left[v->cargo_type] -= cap;
-			}
+				if (v->cargo.Empty()) TriggerVehicle(v, VEHICLE_TRIGGER_NEW_CARGO);
 
-			if (v->cargo.Empty()) TriggerVehicle(v, VEHICLE_TRIGGER_NEW_CARGO);
+				/* The full load order could be seen as interference by the user.
+				 * In that case force_load should be set and all cargo available
+				 * be moved onto the vehicle.
+				 */
+				uint loaded = ge->cargo.MoveToVehicle(&v->cargo, cap, next_station, &rejected[v->cargo_type], st->xy);
 
-			/* TODO: Regarding this, when we do gradual loading, we
-			 * should first unload all vehicles and then start
-			 * loading them. Since this will cause
-			 * VEHICLE_TRIGGER_EMPTY to be called at the time when
-			 * the whole vehicle chain is really totally empty, the
-			 * completely_emptied assignment can then be safely
-			 * removed; that's how TTDPatch behaves too. --pasky */
-			completely_emptied = false;
-			anything_loaded = true;
+				/* TODO: Regarding this, when we do gradual loading, we
+				 * should first unload all vehicles and then start
+				 * loading them. Since this will cause
+				 * VEHICLE_TRIGGER_EMPTY to be called at the time when
+				 * the whole vehicle chain is really totally empty, the
+				 * completely_emptied assignment can then be safely
+				 * removed; that's how TTDPatch behaves too. --pasky */
+				if (loaded > 0) {
+					completely_emptied = false;
+					anything_loaded = true;
+				}
 
-			ge->cargo.MoveTo(&v->cargo, cap, CargoList::MTA_CARGO_LOAD, NULL, st->xy);
+				st->time_since_load = 0;
+				st->last_vehicle_type = v->type;
 
-			st->time_since_load = 0;
-			st->last_vehicle_type = v->type;
+				StationAnimationTrigger(st, st->xy, STAT_ANIM_CARGO_TAKEN, v->cargo_type);
 
-			StationAnimationTrigger(st, st->xy, STAT_ANIM_CARGO_TAKEN, v->cargo_type);
+				unloading_time += loaded;
 
-			unloading_time += cap;
-
-			result |= 2;
+				result |= 2;
+			} else if (_settings_game.order.improved_load && !reserved[v->cargo_type].empty()) {
+				/* Skip loading this vehicle if another train/vehicle is already handling
+				 * the same cargo type at this station */
+				SetBit(cargo_not_full, v->cargo_type);
+				continue;
+			}
 		}
 
+
 		if (v->cargo.Count() >= v->cargo_cap) {
 			SetBit(cargo_full, v->cargo_type);
 		} else {
@@ -1397,13 +1403,7 @@
 	 * all wagons at the same time instead of using the same 'improved'
 	 * loading algorithm for the wagons (only fill wagon when there is
 	 * enough to fill the previous wagons) */
-	if (_settings_game.order.improved_load && (u->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
-		/* Update left cargo */
-		for (v = u; v != NULL; v = v->Next()) {
-			int cap_left = v->cargo_cap - v->cargo.Count();
-			if (cap_left > 0) cargo_left[v->cargo_type] -= cap_left;
-		}
-	}
+	ReserveAndUnreject(st, u, next_station, reserved, rejected);
 
 	v = u;
 
@@ -1489,16 +1489,16 @@
 	/* No vehicle is here... */
 	if (st->loading_vehicles.empty()) return;
 
-	int cargo_left[NUM_CARGO];
+	CargoReservation reserved;
 
-	for (uint i = 0; i < NUM_CARGO; i++) cargo_left[i] = st->goods[i].cargo.Count();
-
 	std::list<Vehicle *>::iterator iter;
 	for (iter = st->loading_vehicles.begin(); iter != st->loading_vehicles.end(); ++iter) {
 		Vehicle *v = *iter;
-		if (!(v->vehstatus & (VS_STOPPED | VS_CRASHED))) LoadUnloadVehicle(v, cargo_left);
+		if (!(v->vehstatus & (VS_STOPPED | VS_CRASHED))) LoadUnloadVehicle(v, reserved);
 	}
 
+	ReimportReserved(st, reserved);
+
 	/* Call the production machinery of industries */
 	const Industry * const *isend = _cargo_delivery_destinations.End();
 	for (Industry **iid = _cargo_delivery_destinations.Begin(); iid != isend; iid++) {
Index: src/economy_func.h
===================================================================
--- src/economy_func.h	(revision 17081)
+++ src/economy_func.h	(working copy)
@@ -14,6 +14,8 @@
 #include "industry_type.h"
 #include "company_type.h"
 #include "station_type.h"
+#include "cargopacket.h"
+#include <map>
 
 void ResetPriceBaseMultipliers();
 void SetPriceBaseMultiplier(uint price, byte factor);
@@ -27,6 +29,7 @@
 extern uint16 _price_frac[NUM_PRICES];
 extern Money  _cargo_payment_rates[NUM_CARGO];
 extern uint16 _cargo_payment_rates_frac[NUM_CARGO];
+typedef std::map<CargoID, CargoList::List> CargoReservation;
 
 int UpdateCompanyRatingAndValue(Company *c, bool update);
 void StartupIndustryDailyChanges(bool init_counter);
@@ -34,7 +37,7 @@
 Money GetTransportedGoodsIncome(uint num_pieces, uint dist, byte transit_days, CargoID cargo_type);
 uint MoveGoodsToStation(TileIndex tile, int w, int h, CargoID type, uint amount);
 
-void PrepareUnload(Vehicle *front_v);
+void PrepareUnload(Station * curr_station, Vehicle *front_v, StationID next_station_id);
 void LoadUnloadStation(Station *st);
 
 Money GetPriceByIndex(uint8 index);
Index: src/landscape.cpp
===================================================================
--- src/landscape.cpp	(revision 17081)
+++ src/landscape.cpp	(working copy)
@@ -929,6 +929,7 @@
 
 void OnTick_Companies();
 void OnTick_Train();
+void OnTick_LinkGraph();
 
 void CallLandscapeTick()
 {
@@ -939,4 +940,5 @@
 
 	OnTick_Companies();
 	OnTick_Train();
+	OnTick_LinkGraph();
 }
Index: src/lang/english.txt
===================================================================
--- src/lang/english.txt	(revision 17081)
+++ src/lang/english.txt	(working copy)
@@ -13,6 +13,20 @@
 ##id 0x0000
 STR_NULL                                                        :
 STR_EMPTY                                                       :
+STR_STATION_VIEW_WAITING                                        :Waiting
+STR_STATION_VIEW_PLANNED                                        :Planned
+STR_STATION_VIEW_SENT                                           :Sent
+STR_TOGGLE_CARGO_VIEW                                           :{BLACK}Toggle between waiting, planned and sent cargo
+STR_STATION_FROM                                                :{YELLOW}{SHORTCARGO} from {STATION}
+STR_STATION_VIA                                                 :{YELLOW}{SHORTCARGO} via {STATION}
+STR_STATION_TO                                                  :{YELLOW}{SHORTCARGO} to {STATION}
+STR_STATION_FROM_ANY                                            :{RED}{SHORTCARGO} from unknown station
+STR_STATION_TO_ANY                                              :{RED}{SHORTCARGO} to any station
+STR_STATION_VIA_ANY                                             :{RED}{SHORTCARGO} via any station
+STR_STATION_FROM_HERE                                           :{GREEN}{SHORTCARGO} from this station
+STR_STATION_VIA_HERE                                            :{GREEN}{SHORTCARGO} stopping at this station
+STR_STATION_TO_HERE                                             :{GREEN}{SHORTCARGO} to this station
+STR_NONSTOP                                                     :{YELLOW}{SHORTCARGO} non-stop
 STR_UNDEFINED                                                   :(undefined string)
 STR_JUST_NOTHING                                                :Nothing
 
@@ -244,6 +258,13 @@
 STR_SORT_BY_POPULATION                                          :{BLACK}Population
 STR_SORT_BY_NAME                                                :{BLACK}Name
 STR_SORT_BY_DATE                                                :{BLACK}Date
+STR_GROUP_TIP                                                   :{BLACK}Select grouping order
+STR_GROUP_S_V_D                                                 :Source-Via-Destination
+STR_GROUP_S_D_V                                                 :Source-Destination-Via
+STR_GROUP_V_S_D                                                 :Via-Source-Destination
+STR_GROUP_V_D_S                                                 :Via-Destination-Source
+STR_GROUP_D_S_V                                                 :Destination-Source-Via
+STR_GROUP_D_V_S                                                 :Destination-Via-Source
 STR_SORT_BY_PRODUCTION                                          :Production
 STR_SORT_BY_TYPE                                                :Type
 STR_SORT_BY_TRANSPORTED                                         :Transported
@@ -262,6 +283,8 @@
 STR_SORT_BY_WAITING                                             :Waiting cargo value
 STR_SORT_BY_RATING_MAX                                          :Highest cargo rating
 STR_SORT_BY_RATING_MIN                                          :Lowest cargo rating
+STR_SORT_BY_AMOUNT                                              :{BLACK}Amount
+STR_SORT_BY_STATION                                             :{BLACK}Station
 STR_SORT_BY_ENGINE_ID                                           :EngineID (classic sort)
 STR_SORT_BY_COST                                                :Cost
 STR_SORT_BY_POWER                                               :Power
@@ -622,12 +645,14 @@
 STR_SMALLMAP_TYPE_CONTOURS                                      :Contours
 STR_SMALLMAP_TYPE_VEHICLES                                      :Vehicles
 STR_SMALLMAP_TYPE_INDUSTRIES                                    :Industries
+STR_SMALLMAP_TYPE_ROUTEMAP                                      :Link Statistics
 STR_SMALLMAP_TYPE_ROUTES                                        :Routes
 STR_SMALLMAP_TYPE_VEGETATION                                    :Vegetation
 STR_SMALLMAP_TYPE_OWNERS                                        :Owners
 STR_SMALLMAP_TOOLTIP_SHOW_LAND_CONTOURS_ON_MAP                  :{BLACK}Show land contours on map
 STR_SMALLMAP_TOOLTIP_SHOW_VEHICLES_ON_MAP                       :{BLACK}Show vehicles on map
 STR_SMALLMAP_TOOLTIP_SHOW_INDUSTRIES_ON_MAP                     :{BLACK}Show industries on map
+STR_SMALLMAP_TOOLTIP_SHOW_LINK_STATS_ON_MAP                     :{BLACK}Show link statistics on map
 STR_SMALLMAP_TOOLTIP_SHOW_TRANSPORT_ROUTES_ON                   :{BLACK}Show transport routes on map
 STR_SMALLMAP_TOOLTIP_SHOW_VEGETATION_ON_MAP                     :{BLACK}Show vegetation on map
 STR_SMALLMAP_TOOLTIP_SHOW_LAND_OWNERS_ON_MAP                    :{BLACK}Show land owners on map
@@ -665,11 +690,18 @@
 STR_SMALLMAP_LEGENDA_INDUSTRIES                                 :{TINYFONT}{BLACK}Industries
 STR_SMALLMAP_LEGENDA_DESERT                                     :{TINYFONT}{BLACK}Desert
 STR_SMALLMAP_LEGENDA_SNOW                                       :{TINYFONT}{BLACK}Snow
+STR_SMALLMAP_LEGEND_CAPACITY                                    :{TINYFONT}Capacity
+STR_SMALLMAP_LEGEND_USAGE                                       :{TINYFONT}Usage
+STR_SMALLMAP_LEGEND_PLANNED                                     :{TINYFONT}Planned Flow
+STR_SMALLMAP_LEGEND_SENT                                        :{TINYFONT}Sent Cargo
+STR_SMALLMAP_LEGEND_SHOW_TEXT                                   :{TINYFONT}As Text
+STR_SMALLMAP_LEGEND_SHOW_GRAPH                                  :{TINYFONT}As Graphs
 
 STR_SMALLMAP_TOOLTIP_TOGGLE_TOWN_NAMES_ON_OFF                   :{BLACK}Toggle town names on/off on map
 STR_SMALLMAP_CENTER                                             :{BLACK}Center the smallmap on the current position
 STR_SMALLMAP_INDUSTRY                                           :{TINYFONT}{STRING} ({NUM})
 STR_SMALLMAP_TOWN                                               :{TINYFONT}{WHITE}{TOWN}
+STR_SMALLMAP_ROUTEMAP_LEGEND                                    :{TINYFONT}{STRING}
 STR_SMALLMAP_DISABLE_ALL                                        :{BLACK}Disable all
 STR_SMALLMAP_ENABLE_ALL                                         :{BLACK}Enable all
 
@@ -1236,12 +1268,41 @@
 STR_CONFIG_SETTING_LARGER_TOWNS_DISABLED                        :{LTBLUE}Proportion of towns that will become cities: {ORANGE}None
 STR_CONFIG_SETTING_CITY_SIZE_MULTIPLIER                         :{LTBLUE}Initial city size multiplier: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD                        :{LTBLUE}Remove absurd road-elements during the road construction: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_AVERAGE_UNIT                                 :{LTBLUE}Moving Average Unit: {ORANGE}{STRING1} days
+STR_CONFIG_SETTING_AVERAGE_LENGTH                               :{LTBLUE}Moving Average Length: {ORANGE}{STRING1} units
 
+STR_CONFIG_SETTING_LINKGRAPH_INTERVAL                           :{LTBLUE}Link graph recalculation interval: {ORANGE}{STRING1} days
+STR_CONFIG_SETTING_DEMAND_PAX                                   :{LTBLUE}Demand function for passengers: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_PAX_SYMMETRIC                         :symmetric
+STR_CONFIG_SETTING_DEMAND_PAX_ANTISYMMETRIC                     :antisymmetric
+STR_CONFIG_SETTING_DEMAND_PAX_UNHANDLED                         :unhandled
+STR_CONFIG_SETTING_DEMAND_MAIL                                  :{LTBLUE}Demand function for mail: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_MAIL_SYMMETRIC                        :symmetric
+STR_CONFIG_SETTING_DEMAND_MAIL_ANTISYMMETRIC                    :antisymmetric
+STR_CONFIG_SETTING_DEMAND_MAIL_UNHANDLED                        :unhandled
+STR_CONFIG_SETTING_DEMAND_EXPRESS                               :{LTBLUE}Demand function for the EXPRESS cargo class: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_EXPRESS_SYMMETRIC                     :symmetric
+STR_CONFIG_SETTING_DEMAND_EXPRESS_ANTISYMMETRIC                 :antisymmetric
+STR_CONFIG_SETTING_DEMAND_EXPRESS_UNHANDLED                     :unhandled
+STR_CONFIG_SETTING_DEMAND_ARMOURED                              :{LTBLUE}Demand function for the ARMOURED cargo class: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_ARMOURED_SYMMETRIC                    :symmetric
+STR_CONFIG_SETTING_DEMAND_ARMOURED_ANTISYMMETRIC                :antisymmetric
+STR_CONFIG_SETTING_DEMAND_ARMOURED_UNHANDLED                    :unhandled
+STR_CONFIG_SETTING_DEMAND_DEFAULT                               :{LTBLUE}Demand function for other cargo classes: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_DEFAULT_SYMMETRIC                     :symmetric
+STR_CONFIG_SETTING_DEMAND_DEFAULT_ANTISYMMETRIC                 :antisymmetric
+STR_CONFIG_SETTING_DEMAND_DEFAULT_UNHANDLED                     :unhandled
+STR_CONFIG_SETTING_LINKGRAPH_ACCURACY                           :{LTBLUE}Accuracy when calculating things on the link graph: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_DISTANCE                              :{LTBLUE}Influence of distance on demands: {ORANGE}{STRING1}%
+STR_CONFIG_SETTING_DEMAND_SIZE                                  :{LTBLUE}Influence of supply at stations on demands: {ORANGE}{STRING1}%
+STR_CONFIG_SETTING_SHORT_PATH_SATURATION                        :{LTBLUE}Saturation of short paths before using capacious paths: {ORANGE}{STRING1}%
+
 STR_CONFIG_SETTING_GUI                                          :{ORANGE}Interface
 STR_CONFIG_SETTING_CONSTRUCTION                                 :{ORANGE}Construction
 STR_CONFIG_SETTING_VEHICLES                                     :{ORANGE}Vehicles
 STR_CONFIG_SETTING_STATIONS                                     :{ORANGE}Stations
 STR_CONFIG_SETTING_ECONOMY                                      :{ORANGE}Economy
+STR_CONFIG_SETTING_LINKGRAPH                                    :{ORANGE}Link graph
 STR_CONFIG_SETTING_AI                                           :{ORANGE}Competitors
 STR_CONFIG_SETTING_DISPLAY_OPTIONS                              :{ORANGE}Display options
 STR_CONFIG_SETTING_INTERACTION                                  :{ORANGE}Interaction
@@ -3996,6 +4057,10 @@
 STR_PLANE                                                       :{BLACK}{PLANE}
 STR_SHIP                                                        :{BLACK}{SHIP}
 
+STR_NUM                                                         :{BLACK}{NUM}
 STR_NUM_1                                                       :{BLACK}{SKIP}{NUM}
 STR_NUM_2                                                       :{BLACK}{SKIP}{SKIP}{NUM}
 STR_NUM_3                                                       :{BLACK}{SKIP}{SKIP}{SKIP}{NUM}
+STR_NUM_RELATION_2                                              :{BLACK}{NUM}/{NUM}
+STR_NUM_RELATION_3                                              :{BLACK}{NUM}/{NUM}/{NUM}
+STR_NUM_RELATION_4                                              :{BLACK}{NUM}/{NUM}/{NUM}/{NUM}
Index: src/main_gui.cpp
===================================================================
--- src/main_gui.cpp	(revision 17081)
+++ src/main_gui.cpp	(working copy)
@@ -132,7 +132,7 @@
 
 	switch (how) {
 		case ZOOM_IN:
-			if (vp->zoom == ZOOM_LVL_MIN) return false;
+			if (vp->zoom == ZOOM_LVL_BLITTER_MIN) return false;
 			vp->zoom = (ZoomLevel)((int)vp->zoom - 1);
 			vp->virtual_width >>= 1;
 			vp->virtual_height >>= 1;
@@ -143,7 +143,7 @@
 			w->viewport->dest_scrollpos_y = w->viewport->scrollpos_y;
 			break;
 		case ZOOM_OUT:
-			if (vp->zoom == ZOOM_LVL_MAX) return false;
+			if (vp->zoom == ZOOM_LVL_BLITTER_MAX) return false;
 			vp->zoom = (ZoomLevel)((int)vp->zoom + 1);
 
 			w->viewport->scrollpos_x -= vp->virtual_width >> 1;
@@ -171,7 +171,7 @@
 
 	if (_game_mode != GM_MENU) {
 		ViewPort *vp = w->viewport;
-		if ((in && vp->zoom == ZOOM_LVL_MIN) || (!in && vp->zoom == ZOOM_LVL_MAX))
+		if ((in && vp->zoom == ZOOM_LVL_BLITTER_MIN) || (!in && vp->zoom == ZOOM_LVL_BLITTER_MAX))
 			return;
 
 		Point pt = GetTileZoomCenterWindow(in, w);
Index: src/misc.cpp
===================================================================
--- src/misc.cpp	(revision 17081)
+++ src/misc.cpp	(working copy)
@@ -51,6 +51,7 @@
 void InitializeCheats();
 void InitializeNPF();
 void InitializeOldNames();
+void InitializeLinkGraphs();
 
 void InitializeGame(uint size_x, uint size_y, bool reset_date)
 {
@@ -113,6 +114,7 @@
 	InitializeAnimatedTiles();
 
 	InitializeLandscapeVariables(false);
+	InitializeLinkGraphs();
 
 	ResetObjectToPlace();
 
Index: src/newgrf.cpp
===================================================================
--- src/newgrf.cpp	(revision 17081)
+++ src/newgrf.cpp	(working copy)
@@ -6131,6 +6131,9 @@
 	/* Create dynamic list of industry legends for smallmap_gui.cpp */
 	BuildIndustriesLegend();
 
+	/* build the routemap legend, based on the available cargos */
+	BuildRouteMapLegend();
+
 	/* Update the townname generators list */
 	InitGRFTownGeneratorNames();
 
Index: src/order_base.h
===================================================================
--- src/order_base.h	(revision 17081)
+++ src/order_base.h	(working copy)
@@ -252,6 +252,8 @@
 private:
 	friend void AfterLoadVehicles(bool part_of_load); ///< For instantiating the shared vehicle chain
 	friend const struct SaveLoad *GetOrderListDescription(); ///< Saving and loading of order lists.
+	const Order * GetNext(const Order * curr) const;
+	const Order * GetNextStoppingOrder(const Order * next, uint hops, bool check_nonstop) const;
 
 	Order *first;                   ///< First order of the order list
 	VehicleOrderID num_orders;      ///< NOSAVE: How many orders there are in the list
@@ -301,6 +303,8 @@
 	 */
 	inline Order *GetLastOrder() const { return this->GetOrderAt(this->num_orders - 1); }
 
+	StationID GetNextStoppingStation(VehicleOrderID curr, bool check_nonstop) const;
+
 	/**
 	 * Get number of orders in the order list.
 	 * @return number of orders in the chain. */
Index: src/order_cmd.cpp
===================================================================
--- src/order_cmd.cpp	(revision 17081)
+++ src/order_cmd.cpp	(working copy)
@@ -255,6 +255,67 @@
 	return order;
 }
 
+const Order * OrderList::GetNext(const Order * curr) const
+{
+	const Order * next = curr->next;
+	if (next == NULL) {
+		next = GetFirstOrder();
+	}
+	return next;
+}
+
+const Order * OrderList::GetNextStoppingOrder(const Order * next, uint hops, bool check_nonstop) const
+{
+	if (next == NULL || hops > GetNumOrders()) {
+		return NULL;
+	}
+
+	if (next->GetType() == OT_CONDITIONAL) {
+		const Order * skip_to = GetNextStoppingOrder(GetOrderAt(next->GetConditionSkipToOrder()), hops + 1, check_nonstop);
+		const Order * advance = GetNextStoppingOrder(next, hops + 1, check_nonstop);
+		if (skip_to == advance) {
+			return skip_to; // skipping over non-stopping orders
+		} else {
+			return NULL; // nondeterministic
+		}
+	}
+
+	bool is_station = (next->GetType() == OT_GOTO_STATION);
+
+	if (check_nonstop) {
+		switch(next->GetNonStopType()) {
+		case ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS:
+			if (is_station) return next; // else fall through
+		case ONSF_NO_STOP_AT_ANY_STATION:
+			return GetNextStoppingOrder(GetNext(next), hops + 1, check_nonstop);
+		default: // nondeterministic
+			return NULL;
+		}
+	} else {
+		if (is_station) {
+			return next;
+		} else {
+			return GetNextStoppingOrder(GetNext(next), hops + 1, check_nonstop);
+		}
+	}
+}
+
+StationID OrderList::GetNextStoppingStation(VehicleOrderID curr_id, bool check_nonstop) const {
+	const Order * curr = GetOrderAt(curr_id);
+	if (curr == NULL) {
+		curr = GetFirstOrder();
+		if (curr == NULL) {
+			return INVALID_STATION;
+		}
+	}
+	const Order * next = GetNextStoppingOrder(GetNext(curr), 1, check_nonstop);
+	if (next == NULL) {
+		return INVALID_STATION;
+	} else {
+		return next->GetDestination();
+	}
+}
+
 void OrderList::InsertOrderAt(Order *new_order, int index)
 {
 	if (this->first == NULL) {
Index: src/roadveh_cmd.cpp
===================================================================
--- src/roadveh_cmd.cpp	(revision 17081)
+++ src/roadveh_cmd.cpp	(working copy)
@@ -1689,12 +1689,12 @@
 			}
 
 			rs->SetEntranceBusy(false);
-
+			StationID previous_station = v->last_station_visited;
 			v->last_station_visited = st->index;
 
 			if (IsDriveThroughStopTile(v->tile) || (v->current_order.IsType(OT_GOTO_STATION) && v->current_order.GetDestination() == st->index)) {
 				RoadVehArrivesAt(v, st);
-				v->BeginLoading();
+				v->BeginLoading(previous_station);
 				return false;
 			}
 		} else {
Index: src/saveload/cargopacket_sl.cpp
===================================================================
--- src/saveload/cargopacket_sl.cpp	(revision 17081)
+++ src/saveload/cargopacket_sl.cpp	(working copy)
@@ -9,6 +9,7 @@
 
 static const SaveLoad _cargopacket_desc[] = {
 	     SLE_VAR(CargoPacket, source,          SLE_UINT16),
+	 SLE_CONDVAR(CargoPacket, next,            SLE_UINT16, FLOWMAP_SV, SL_MAX_VERSION),
 	     SLE_VAR(CargoPacket, source_xy,       SLE_UINT32),
 	     SLE_VAR(CargoPacket, loaded_at_xy,    SLE_UINT32),
 	     SLE_VAR(CargoPacket, count,           SLE_UINT16),
Index: src/saveload/misc_sl.cpp
===================================================================
--- src/saveload/misc_sl.cpp	(revision 17081)
+++ src/saveload/misc_sl.cpp	(working copy)
@@ -45,7 +45,8 @@
 	w->viewport->dest_scrollpos_y = _saved_scrollpos_y;
 
 	ViewPort *vp = w->viewport;
-	vp->zoom = min(_saved_scrollpos_zoom, ZOOM_LVL_MAX);
+	vp->zoom = min(_saved_scrollpos_zoom, ZOOM_LVL_BLITTER_MAX);
+	vp->zoom = max(_saved_scrollpos_zoom, ZOOM_LVL_BLITTER_MIN);
 	vp->virtual_width = ScaleByZoom(vp->width, vp->zoom);
 	vp->virtual_height = ScaleByZoom(vp->height, vp->zoom);
 
Index: src/saveload/oldloader_sl.cpp
===================================================================
--- src/saveload/oldloader_sl.cpp	(revision 17081)
+++ src/saveload/oldloader_sl.cpp	(working copy)
@@ -1391,7 +1391,7 @@
 		if (_old_next_ptr != 0xFFFF) v->next = (Vehicle *)(size_t)_old_next_ptr;
 
 		if (_cargo_count != 0) {
-			CargoPacket *cp = new CargoPacket((_cargo_source == 0xFF) ? INVALID_STATION : _cargo_source, _cargo_count);
+			CargoPacket *cp = new CargoPacket((_cargo_source == 0xFF) ? INVALID_STATION : _cargo_source, INVALID_STATION, _cargo_count);
 			cp->days_in_transit = _cargo_days;
 			v->cargo.Append(cp);
 		}
Index: src/saveload/saveload.cpp
===================================================================
--- src/saveload/saveload.cpp	(revision 17081)
+++ src/saveload/saveload.cpp	(working copy)
@@ -41,7 +41,7 @@
 
 #include "saveload_internal.h"
 
-extern const uint16 SAVEGAME_VERSION = 124;
+extern const uint16 SAVEGAME_VERSION = FLOWMAP_SV;
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
@@ -1439,6 +1439,7 @@
 extern const ChunkHandler _cargopacket_chunk_handlers[];
 extern const ChunkHandler _autoreplace_chunk_handlers[];
 extern const ChunkHandler _labelmaps_chunk_handlers[];
+extern const ChunkHandler _linkgraph_chunk_handlers[];
 
 static const ChunkHandler * const _chunk_handlers[] = {
 	_gamelog_chunk_handlers,
@@ -1466,6 +1467,7 @@
 	_cargopacket_chunk_handlers,
 	_autoreplace_chunk_handlers,
 	_labelmaps_chunk_handlers,
+	_linkgraph_chunk_handlers,
 	NULL,
 };
 
Index: src/saveload/saveload.h
===================================================================
--- src/saveload/saveload.h	(revision 17081)
+++ src/saveload/saveload.h	(working copy)
@@ -326,4 +326,10 @@
 
 extern char _savegame_format[8];
 
+#define CAPACITIES_SV 130
+#define LINKGRAPH_SV 140
+#define DEMANDS_SV 150
+#define MCF_SV 160
+#define FLOWMAP_SV 170
+
 #endif /* SAVELOAD_H */
Index: src/saveload/station_sl.cpp
===================================================================
--- src/saveload/station_sl.cpp	(revision 17081)
+++ src/saveload/station_sl.cpp	(working copy)
@@ -181,6 +181,8 @@
 };
 
 static uint16 _waiting_acceptance;
+static uint16 _num_links;
+static uint16 _num_flows;
 static uint16 _cargo_source;
 static uint32 _cargo_source_xy;
 static uint16 _cargo_days;
@@ -193,6 +195,31 @@
 	SLE_END()
 };
 
+static StationID _station_id;
+
+static const SaveLoad _linkstat_desc[] = {
+		SLEG_CONDVAR(             _station_id,         SLE_UINT16,      CAPACITIES_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    capacity,            SLE_UINT32,      CAPACITIES_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    frozen,              SLE_UINT32,      CAPACITIES_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    usage,               SLE_UINT32,      CAPACITIES_SV, SL_MAX_VERSION),
+		 SLE_END()
+};
+
+static const SaveLoad _flowstat_desc[] = {
+		SLEG_CONDVAR(             _station_id,         SLE_UINT16,         FLOWMAP_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    via,                 SLE_UINT16,         FLOWMAP_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    planned,             SLE_UINT32,         FLOWMAP_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    sent,                SLE_UINT32,         FLOWMAP_SV, SL_MAX_VERSION),
+		 SLE_END()
+};
+
+void CountFlows(FlowStatMap & flows) {
+	_num_flows = 0;
+	for(FlowStatMap::iterator i = flows.begin(); i != flows.end(); ++i) {
+		_num_flows += i->second.size();
+	}
+}
+
 const SaveLoad *GetGoodsDesc()
 {
 	static const SaveLoad goods_desc[] = {
@@ -210,7 +237,10 @@
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_FILE_U32 | SLE_VAR_I64, 14, 64),
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_INT64,                  65, 67),
 		 SLE_CONDLST(GoodsEntry, cargo.packets,       REF_CARGO_PACKET,           68, SL_MAX_VERSION),
-
+		 SLE_CONDVAR(GoodsEntry, supply,              SLE_UINT32,      CAPACITIES_SV, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      CAPACITIES_SV, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_flows,          SLE_UINT16,         FLOWMAP_SV, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, last_component,      SLE_UINT16,       LINKGRAPH_SV, SL_MAX_VERSION),
 		SLE_END()
 	};
 
@@ -231,6 +261,10 @@
 		uint num_cargo = CheckSavegameVersion(55) ? 12 : NUM_CARGO;
 		for (CargoID i = 0; i < num_cargo; i++) {
 			GoodsEntry *ge = &st->goods[i];
+			LinkStatMap & stats = ge->link_stats;
+			FlowStatMap & flows = ge->flows;
+			_num_links = stats.size(); // for saving, is overwritten by next line when loading
+			CountFlows(flows);
 			SlObject(ge, GetGoodsDesc());
 			if (CheckSavegameVersion(68)) {
 				SB(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE, 1, HasBit(_waiting_acceptance, 15));
@@ -249,6 +283,33 @@
 					ge->cargo.Append(cp);
 				}
 			}
+			FlowStat fs;
+			if (stats.empty() && flows.empty()) { // loading
+				LinkStat ls;
+				for (uint i = 0; i < _num_links; ++i) {
+					SlObject(&ls, _linkstat_desc);
+					assert(ls.capacity > 0);
+					stats[_station_id] = ls;
+				}
+				for (uint i = 0; i < _num_flows; ++i) {
+					SlObject(&fs, _flowstat_desc);
+					flows[_station_id].insert(fs);
+				}
+			} else { // saving
+				for (LinkStatMap::iterator i = stats.begin(); i != stats.end(); ++i) {
+					_station_id = i->first;
+					assert(i->second.capacity > 0);
+					SlObject(&(i->second), _linkstat_desc);
+				}
+				for (FlowStatMap::iterator i = flows.begin(); i != flows.end(); ++i) {
+					_station_id = i->first;
+					FlowStatSet & flow_set = i->second;
+					for (FlowStatSet::iterator j = flow_set.begin(); j != flow_set.end(); ++j) {
+						fs = *j;
+						SlObject(&fs, _flowstat_desc);
+					}
+				}
+			}
 		}
 
 		if (st->num_specs != 0) {
Index: src/settings.cpp
===================================================================
--- src/settings.cpp	(revision 17081)
+++ src/settings.cpp	(working copy)
@@ -1377,7 +1377,7 @@
 	delete ini;
 }
 
-static const SettingDesc *GetSettingDescription(uint index)
+const SettingDesc *GetSettingDescription(uint index)
 {
 	if (index >= lengthof(_settings)) return NULL;
 	return &_settings[index];
Index: src/settings_gui.cpp
===================================================================
--- src/settings_gui.cpp	(revision 17081)
+++ src/settings_gui.cpp	(working copy)
@@ -1242,10 +1242,27 @@
 	SettingEntry(&_settings_economy_industries_page, STR_CONFIG_SETTING_ECONOMY_INDUSTRIES),
 	SettingEntry("economy.inflation"),
 	SettingEntry("economy.smooth_economy"),
+	SettingEntry("economy.moving_average_unit"),
+	SettingEntry("economy.moving_average_length"),
 };
 /** Economy sub-page */
 static SettingsPage _settings_economy_page = {_settings_economy, lengthof(_settings_economy)};
 
+static SettingEntry _settings_linkgraph[] = {
+	SettingEntry("linkgraph.recalc_interval"),
+	SettingEntry("linkgraph.demand_pax"),
+	SettingEntry("linkgraph.demand_mail"),
+	SettingEntry("linkgraph.demand_express"),
+	SettingEntry("linkgraph.demand_armoured"),
+	SettingEntry("linkgraph.demand_default"),
+	SettingEntry("linkgraph.accuracy"),
+	SettingEntry("linkgraph.demand_distance"),
+	SettingEntry("linkgraph.demand_size"),
+	SettingEntry("linkgraph.short_path_saturation"),
+};
+/** Linkgraph sub-page */
+static SettingsPage _settings_linkgraph_page = {_settings_linkgraph, lengthof(_settings_linkgraph)};
+
 static SettingEntry _settings_ai_npc[] = {
 	SettingEntry("ai.ai_in_multiplayer"),
 	SettingEntry("ai.ai_disable_veh_train"),
@@ -1334,6 +1351,7 @@
 	SettingEntry(&_settings_vehicles_page,     STR_CONFIG_SETTING_VEHICLES),
 	SettingEntry(&_settings_stations_page,     STR_CONFIG_SETTING_STATIONS),
 	SettingEntry(&_settings_economy_page,      STR_CONFIG_SETTING_ECONOMY),
+	SettingEntry(&_settings_linkgraph_page,    STR_CONFIG_SETTING_LINKGRAPH),
 	SettingEntry(&_settings_ai_page,           STR_CONFIG_SETTING_AI),
 };
 
Index: src/settings_type.h
===================================================================
--- src/settings_type.h	(revision 17081)
+++ src/settings_type.h	(working copy)
@@ -10,6 +10,7 @@
 #include "transport_type.h"
 #include "network/core/config.h"
 #include "company_type.h"
+#include "linkgraph/demand_settings.h"
 
 /** Settings related to the difficulty of the game */
 struct DifficultySettings {
@@ -91,6 +92,10 @@
 
 	uint16 console_backlog_timeout;          ///< the minimum amount of time items should be in the console backlog before they will be removed in ~3 seconds granularity.
 	uint16 console_backlog_length;           ///< the minimum amount of items in the console backlog before items will be removed.
+
+	uint8  station_gui_group_order;          ///< the order of grouping cargo entries in the station gui
+	uint8  station_gui_sort_by;              ///< sort cargo entries in the station gui by station name or amount
+	uint8  station_gui_sort_order;           ///< the sort order of entries in the station gui - ascending or descending
 #ifdef ENABLE_NETWORK
 	uint16 network_chat_box_width;           ///< width of the chat box in pixels
 	uint8  network_chat_box_height;          ///< height of the chat box in lines
@@ -320,8 +325,23 @@
 	bool   allow_town_roads;                 ///< towns are allowed to build roads (always allowed when generating world / in SE)
 	bool   station_noise_level;              ///< build new airports when the town noise level is still within accepted limits
 	uint16 town_noise_population[3];         ///< population to base decision on noise evaluation (@see town_council_tolerance)
+	uint16 moving_average_unit;              ///< unit of time to use for calculating the moving average of capacities and usage of links
+	uint16 moving_average_length;            ///< length of the moving average for capacities and usage of links
 };
 
+struct LinkGraphSettings {
+	uint16 recalc_interval;                  ///< minimum interval (in days) between subsequent recalculations of the same component of the link graph
+	DistributionTypeByte demand_pax;         ///< demand calculation for passengers
+	DistributionTypeByte demand_mail;        ///< demand calculation for mail
+	DistributionTypeByte demand_express;     ///< demand calculation for express cargo class
+	DistributionTypeByte demand_armoured;    ///< demand calculation for armoured cargo class
+	DistributionTypeByte demand_default;     ///< demand calculation for all other goods
+	uint8 accuracy;                          ///< accuracy when calculating things on the link graph. low accuracy => low running time
+	uint8 demand_size;                       ///< influence of supply ("station size") on the demand function
+	uint8 demand_distance;                   ///< influence of distance between stations on the demand function
+	uint8 short_path_saturation;             ///< percentage up to which short paths are saturated before saturating most capacious paths
+};
+
 /** Settings related to stations. */
 struct StationSettings {
 	bool   modified_catchment;               ///< different-size catchment areas
@@ -362,6 +382,7 @@
 	OrderSettings        order;              ///< settings related to orders
 	VehicleSettings      vehicle;            ///< options for vehicles
 	EconomySettings      economy;            ///< settings to change the economy
+	LinkGraphSettings    linkgraph;          ///< settings for link graph calculations
 	StationSettings      station;            ///< settings related to station management
 	LocaleSettings       locale;             ///< settings related to used currency/unit system in the current game
 };
Index: src/ship_cmd.cpp
===================================================================
--- src/ship_cmd.cpp	(revision 17081)
+++ src/ship_cmd.cpp	(working copy)
@@ -642,13 +642,14 @@
 									return;
 								}
 							} else if (v->current_order.IsType(OT_GOTO_STATION)) {
+								StationID previous_station = v->last_station_visited;
 								v->last_station_visited = v->current_order.GetDestination();
 
 								/* Process station in the orderlist. */
 								Station *st = Station::Get(v->current_order.GetDestination());
 								if (st->facilities & FACIL_DOCK) { // ugly, ugly workaround for problem with ships able to drop off cargo at wrong stations
 									ShipArrivesAt(v, st);
-									v->BeginLoading();
+									v->BeginLoading(previous_station);
 								} else { // leave stations without docks right aways
 									v->current_order.MakeLeaveStation();
 									v->IncrementOrderIndex();
Index: src/smallmap_gui.cpp
===================================================================
--- src/smallmap_gui.cpp	(revision 17081)
+++ src/smallmap_gui.cpp	(working copy)
@@ -20,10 +20,16 @@
 #include "vehicle_base.h"
 #include "sound_func.h"
 #include "window_func.h"
+#include "cargotype.h"
+#include "openttd.h"
+#include "company_func.h"
+#include "station_base.h"
 
 #include "table/strings.h"
 #include "table/sprites.h"
 
+#include <cmath>
+
 /** Widget numbers of the small map window. */
 enum SmallMapWindowWidgets {
 	SM_WIDGET_CLOSEBOX,
@@ -33,17 +39,21 @@
 	SM_WIDGET_MAP,
 	SM_WIDGET_LEGEND,
 	SM_WIDGET_BUTTONSPANEL,
+	SM_WIDGET_BLANK,
+	SM_WIDGET_ZOOM_IN,
+	SM_WIDGET_ZOOM_OUT,
 	SM_WIDGET_CONTOUR,
 	SM_WIDGET_VEHICLES,
 	SM_WIDGET_INDUSTRIES,
+	SM_WIDGET_ROUTEMAP,
 	SM_WIDGET_ROUTES,
 	SM_WIDGET_VEGETATION,
 	SM_WIDGET_OWNERS,
 	SM_WIDGET_CENTERMAP,
 	SM_WIDGET_TOGGLETOWNNAME,
 	SM_WIDGET_BOTTOMPANEL,
-	SM_WIDGET_ENABLEINDUSTRIES,
-	SM_WIDGET_DISABLEINDUSTRIES,
+	SM_WIDGET_ENABLE_ALL,
+	SM_WIDGET_DISABLE_ALL,
 	SM_WIDGET_RESIZEBOX,
 };
 
@@ -53,19 +63,23 @@
 { WWT_STICKYBOX,     RESIZE_LR,  COLOUR_BROWN,   338,   349,     0,    13, 0x0,                      STR_TOOLTIP_STICKY},                              // SM_WIDGET_STICKYBOX
 {     WWT_PANEL,     RESIZE_RB,  COLOUR_BROWN,     0,   349,    14,   157, 0x0,                      STR_NULL},                                       // SM_WIDGET_MAP_BORDER
 {     WWT_INSET,     RESIZE_RB,  COLOUR_BROWN,     2,   347,    16,   155, 0x0,                      STR_NULL},                                       // SM_WIDGET_MAP
-{     WWT_PANEL,    RESIZE_RTB,  COLOUR_BROWN,     0,   261,   158,   201, 0x0,                      STR_NULL},                                       // SM_WIDGET_LEGEND
-{     WWT_PANEL,   RESIZE_LRTB,  COLOUR_BROWN,   262,   349,   158,   158, 0x0,                      STR_NULL},                                       // SM_WIDGET_BUTTONSPANEL
+{     WWT_PANEL,    RESIZE_RTB,  COLOUR_BROWN,     0,   217,   158,   201, 0x0,                      STR_NULL},                                       // SM_WIDGET_LEGEND
+{     WWT_PANEL,   RESIZE_LRTB,  COLOUR_BROWN,   218,   349,   158,   158, 0x0,                      STR_NULL},                                       // SM_WIDGET_BUTTONSPANEL
+{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   262,   283,   158,   179, SPR_DOT_SMALL,            STR_EMPTY},                                      // SM_WIDGET_BLANK
+{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   218,   239,   158,   179, SPR_IMG_ZOOMIN,           STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_IN},           // SM_WIDGET_ZOOM_IN
+{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   218,   239,   180,   201, SPR_IMG_ZOOMOUT,          STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_OUT},          // SM_WIDGET_ZOOM_OUT
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   284,   305,   158,   179, SPR_IMG_SHOW_COUNTOURS,   STR_SMALLMAP_TOOLTIP_SHOW_LAND_CONTOURS_ON_MAP}, // SM_WIDGET_CONTOUR
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   306,   327,   158,   179, SPR_IMG_SHOW_VEHICLES,    STR_SMALLMAP_TOOLTIP_SHOW_VEHICLES_ON_MAP},      // SM_WIDGET_VEHICLES
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   328,   349,   158,   179, SPR_IMG_INDUSTRY,         STR_SMALLMAP_TOOLTIP_SHOW_INDUSTRIES_ON_MAP},    // SM_WIDGET_INDUSTRIES
+{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   262,   283,   180,   201, SPR_IMG_GRAPHS,           STR_SMALLMAP_TOOLTIP_SHOW_LINK_STATS_ON_MAP},    // SM_WIDGET_ROUTEMAP
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   284,   305,   180,   201, SPR_IMG_SHOW_ROUTES,      STR_SMALLMAP_TOOLTIP_SHOW_TRANSPORT_ROUTES_ON},  // SM_WIDGET_ROUTES
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   306,   327,   180,   201, SPR_IMG_PLANTTREES,       STR_SMALLMAP_TOOLTIP_SHOW_VEGETATION_ON_MAP},    // SM_WIDGET_VEGETATION
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   328,   349,   180,   201, SPR_IMG_COMPANY_GENERAL,  STR_SMALLMAP_TOOLTIP_SHOW_LAND_OWNERS_ON_MAP},   // SM_WIDGET_OWNERS
-{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   262,   283,   158,   179, SPR_IMG_SMALLMAP,         STR_SMALLMAP_CENTER},                            // SM_WIDGET_CENTERMAP
-{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   262,   283,   180,   201, SPR_IMG_TOWN,             STR_SMALLMAP_TOOLTIP_TOGGLE_TOWN_NAMES_ON_OFF},  // SM_WIDGET_TOGGLETOWNNAME
+{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   240,   261,   158,   179, SPR_IMG_SMALLMAP,         STR_SMALLMAP_CENTER},                            // SM_WIDGET_CENTERMAP
+{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   240,   261,   180,   201, SPR_IMG_TOWN,             STR_SMALLMAP_TOOLTIP_TOGGLE_TOWN_NAMES_ON_OFF},  // SM_WIDGET_TOGGLETOWNNAME
 {     WWT_PANEL,    RESIZE_RTB,  COLOUR_BROWN,     0,   337,   202,   213, 0x0,                      STR_NULL},                                       // SM_WIDGET_BOTTOMPANEL
-{   WWT_TEXTBTN,     RESIZE_TB,  COLOUR_BROWN,     0,    99,   202,   213, STR_SMALLMAP_ENABLE_ALL,  STR_NULL},                                       // SM_WIDGET_ENABLEINDUSTRIES
-{   WWT_TEXTBTN,     RESIZE_TB,  COLOUR_BROWN,   100,   201,   202,   213, STR_SMALLMAP_DISABLE_ALL, STR_NULL},                                       // SM_WIDGET_DISABLEINDUSTRIES
+{   WWT_TEXTBTN,     RESIZE_TB,  COLOUR_BROWN,     0,    99,   202,   213, STR_MESSAGES_ENABLE_ALL,  STR_NULL},                                       // SM_WIDGET_ENABLE_ALL
+{   WWT_TEXTBTN,     RESIZE_TB,  COLOUR_BROWN,   100,   201,   202,   213, STR_MESSAGES_DISABLE_ALL, STR_NULL},                                       // SM_WIDGET_DISABLE_ALL
 { WWT_RESIZEBOX,   RESIZE_LRTB,  COLOUR_BROWN,   338,   349,   202,   213, 0x0,                      STR_TOOLTIP_RESIZE},                              // SM_WIDGET_RESIZEBOX
 {  WIDGETS_END},
 };
@@ -86,13 +100,17 @@
 	EndContainer(),
 	/* Panel. */
 	NWidget(NWID_HORIZONTAL),
-		NWidget(WWT_PANEL, COLOUR_BROWN, SM_WIDGET_LEGEND), SetMinimalSize(262, 44), SetResize(1, 0), EndContainer(),
+		NWidget(WWT_PANEL, COLOUR_BROWN, SM_WIDGET_LEGEND), SetMinimalSize(218, 44), SetResize(1, 0), EndContainer(),
 		NWidget(NWID_LAYERED),
 			NWidget(NWID_VERTICAL),
 				/* Top button row. */
 				NWidget(NWID_HORIZONTAL),
+					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_ZOOM_IN), SetMinimalSize(22, 22),
+												SetDataTip(SPR_IMG_ZOOMIN, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_IN),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_CENTERMAP), SetMinimalSize(22, 22),
 												SetDataTip(SPR_IMG_SMALLMAP, STR_SMALLMAP_CENTER),
+					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_BLANK), SetMinimalSize(22, 22),
+												SetDataTip(SPR_DOT_SMALL, STR_EMPTY),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_CONTOUR), SetMinimalSize(22, 22),
 												SetDataTip(SPR_IMG_SHOW_COUNTOURS, STR_SMALLMAP_TOOLTIP_SHOW_LAND_CONTOURS_ON_MAP),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_VEHICLES), SetMinimalSize(22, 22),
@@ -102,8 +120,12 @@
 				EndContainer(),
 				/* Bottom button row. */
 				NWidget(NWID_HORIZONTAL),
+					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_ZOOM_OUT), SetMinimalSize(22, 22),
+												SetDataTip(SPR_IMG_ZOOMOUT, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_OUT),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_TOGGLETOWNNAME), SetMinimalSize(22, 22),
 												SetDataTip(SPR_IMG_TOWN, STR_SMALLMAP_TOOLTIP_TOGGLE_TOWN_NAMES_ON_OFF),
+					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_ROUTEMAP), SetMinimalSize(22, 22),
+												SetDataTip(SPR_IMG_GRAPHS, STR_SMALLMAP_TOOLTIP_SHOW_LINK_STATS_ON_MAP),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_ROUTES), SetMinimalSize(22, 22),
 												SetDataTip(SPR_IMG_SHOW_ROUTES, STR_SMALLMAP_TOOLTIP_SHOW_TRANSPORT_ROUTES_ON),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, SM_WIDGET_VEGETATION), SetMinimalSize(22, 22),
@@ -113,7 +135,7 @@
 				EndContainer(),
 			EndContainer(),
 			NWidget(NWID_VERTICAL),
-				NWidget(WWT_PANEL, COLOUR_BROWN, SM_WIDGET_BUTTONSPANEL), SetMinimalSize(88, 1), SetFill(0, 0), EndContainer(),
+				NWidget(WWT_PANEL, COLOUR_BROWN, SM_WIDGET_BUTTONSPANEL), SetMinimalSize(132, 1), SetFill(0, 0), EndContainer(),
 				NWidget(NWID_SPACER), SetFill(0, 1),
 			EndContainer(),
 		EndContainer(),
@@ -122,8 +144,8 @@
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_PANEL, COLOUR_BROWN, SM_WIDGET_BOTTOMPANEL),
 			NWidget(NWID_HORIZONTAL),
-				NWidget(WWT_TEXTBTN, COLOUR_BROWN, SM_WIDGET_ENABLEINDUSTRIES), SetMinimalSize(100, 12), SetDataTip(STR_SMALLMAP_ENABLE_ALL, STR_NULL),
-				NWidget(WWT_TEXTBTN, COLOUR_BROWN, SM_WIDGET_DISABLEINDUSTRIES), SetMinimalSize(102, 12), SetDataTip(STR_SMALLMAP_DISABLE_ALL, STR_NULL),
+ 				NWidget(WWT_TEXTBTN, COLOUR_BROWN, SM_WIDGET_ENABLE_ALL), SetMinimalSize(100, 12), SetDataTip(STR_MESSAGES_ENABLE_ALL, STR_NULL),
+ 				NWidget(WWT_TEXTBTN, COLOUR_BROWN, SM_WIDGET_DISABLE_ALL), SetMinimalSize(102, 12), SetDataTip(STR_MESSAGES_DISABLE_ALL, STR_NULL),
 				NWidget(NWID_SPACER), SetFill(1, 0), SetResize(1, 0),
 			EndContainer(),
 		EndContainer(),
@@ -135,6 +157,21 @@
 /* number of used industries */
 static int _smallmap_industry_count;
 
+/* number of cargos in the routemap legend */
+static int _smallmap_cargo_count;
+
+enum SmallMapStats {
+	STAT_CAPACITY,
+	STAT_BEGIN = STAT_CAPACITY,
+	STAT_USAGE,
+	STAT_PLANNED,
+	STAT_SENT,
+	STAT_TEXT,
+	STAT_GRAPH,
+	STAT_END,
+	NUM_STATS = STAT_END,
+};
+
 /** Macro for ordinary entry of LegendAndColour */
 #define MK(a, b) {a, b, INVALID_INDUSTRYTYPE, true, false, false}
 /** Macro for end of list marker in arrays of LegendAndColour */
@@ -255,10 +292,81 @@
 	_smallmap_industry_count = j;
 }
 
+static LegendAndColour _legend_routemap[NUM_CARGO + NUM_STATS + 1];
+
+/**
+ * Populate legend table for the route map view.
+ */
+void BuildRouteMapLegend()
+{
+	/* Clear the legend */
+	memset(_legend_routemap, 0, sizeof(_legend_routemap));
+
+	uint i = 0;
+
+	for (CargoID c = CT_BEGIN; c != CT_END; ++c) {
+		const CargoSpec *cs = CargoSpec::Get(c);
+		if (!cs->IsValid()) continue;
+
+		_legend_routemap[i].legend = cs->name;
+		_legend_routemap[i].colour = cs->legend_colour;
+		_legend_routemap[i].type = c;
+		_legend_routemap[i].show_on_map = true;
+
+		i++;
+	}
+
+	_legend_routemap[i].col_break = true;
+
+	_smallmap_cargo_count = i;
+
+	/* the colours cannot be resolved before the gfx system is initialized.
+	 * So we have to build the legend when creating the window.
+	 */
+	for (uint st = 0; st < NUM_STATS; ++st) {
+		LegendAndColour & legend_entry = _legend_routemap[i + st];
+		switch(st) {
+		case STAT_CAPACITY:
+			legend_entry.colour = _colour_gradient[COLOUR_WHITE][7];
+			legend_entry.legend = STR_SMALLMAP_LEGEND_CAPACITY;
+			legend_entry.show_on_map = true;
+			break;
+		case STAT_USAGE:
+			legend_entry.colour = _colour_gradient[COLOUR_GREY][1];
+			legend_entry.legend = STR_SMALLMAP_LEGEND_USAGE;
+			legend_entry.show_on_map = false;
+			break;
+		case STAT_PLANNED:
+			legend_entry.colour = _colour_gradient[COLOUR_RED][5];
+			legend_entry.legend = STR_SMALLMAP_LEGEND_PLANNED;
+			legend_entry.show_on_map = true;
+			break;
+		case STAT_SENT:
+			legend_entry.colour = _colour_gradient[COLOUR_YELLOW][5];
+			legend_entry.legend = STR_SMALLMAP_LEGEND_SENT;
+			legend_entry.show_on_map = false;
+			break;
+		case STAT_TEXT:
+			legend_entry.colour = _colour_gradient[COLOUR_GREY][7];
+			legend_entry.legend = STR_SMALLMAP_LEGEND_SHOW_TEXT;
+			legend_entry.show_on_map = false;
+			break;
+		case STAT_GRAPH:
+			legend_entry.colour = _colour_gradient[COLOUR_GREY][7];
+			legend_entry.legend = STR_SMALLMAP_LEGEND_SHOW_GRAPH;
+			legend_entry.show_on_map = true;
+			break;
+		}
+	}
+
+	_legend_routemap[i + NUM_STATS].end = true;
+}
+
 static const LegendAndColour * const _legend_table[] = {
 	_legend_land_contours,
 	_legend_vehicles,
 	_legend_from_industries,
+	_legend_routemap,
 	_legend_routes,
 	_legend_vegetation,
 	_legend_land_owners,
@@ -497,19 +605,6 @@
 	return _owner_colours[o];
 }
 
-
-static const uint32 _smallmap_mask_left[3] = {
-	MKCOLOUR(0xFF000000),
-	MKCOLOUR(0xFFFF0000),
-	MKCOLOUR(0xFFFFFF00),
-};
-
-static const uint32 _smallmap_mask_right[] = {
-	MKCOLOUR(0x000000FF),
-	MKCOLOUR(0x0000FFFF),
-	MKCOLOUR(0x00FFFFFF),
-};
-
 /* each tile has 4 x pixels and 1 y pixel */
 
 static GetSmallMapPixels *_smallmap_draw_procs[] = {
@@ -517,6 +612,7 @@
 	GetSmallMapVehiclesPixels,
 	GetSmallMapIndustriesPixels,
 	GetSmallMapRoutesPixels,
+	GetSmallMapRoutesPixels,
 	GetSmallMapVegetationPixels,
 	GetSmallMapOwnerPixels,
 };
@@ -538,95 +634,521 @@
 	GfxFillRect(x2 - 3, y, x2,    y2, 69);
 }
 
+
+void DrawVertex(int x, int y, int size, int colour)
+{
+	size--;
+	int w1 = size / 2;
+	int w2 = size / 2 + size % 2;
+
+	GfxFillRect(x - w1, y - w1, x + w2, y + w2, colour);
+
+	w1++;
+	w2++;
+	GfxDrawLine(x - w1, y - w1, x + w2, y - w1, 0x0);
+	GfxDrawLine(x - w1, y + w2, x + w2, y + w2, 0x0);
+	GfxDrawLine(x - w1, y - w1, x - w1, y + w2, 0x0);
+	GfxDrawLine(x + w2, y - w1, x + w2, y + w2, 0x0);
+}
+
 class SmallMapWindow : public Window
 {
 	enum SmallMapType {
 		SMT_CONTOUR,
 		SMT_VEHICLES,
 		SMT_INDUSTRY,
+		SMT_ROUTEMAP,
 		SMT_ROUTES,
 		SMT_VEGETATION,
 		SMT_OWNER,
 	};
 
+	typedef std::map<VehicleID, TileIndex> VehiclePositionMap;
+
+	VehiclePositionMap vehicles_on_map;
+
 	static SmallMapType map_type;
 	static bool show_towns;
 
 	int32 scroll_x;
 	int32 scroll_y;
-	int32 subscroll;
+
 	uint8 refresh;
+	static const int FORCE_REFRESH = 0x1F;
 
-	static const int COLUMN_WIDTH = 119;
+	/**
+	 * zoom level of the smallmap.
+	 * May be something between ZOOM_LVL_MIN and ZOOM_LVL_MAX.
+	 */
+	ZoomLevel zoom;
+
+	static const int LEGEND_COLUMN_WIDTH = 119;
 	static const int MIN_LEGEND_HEIGHT = 6 * 7;
+	static const int MAP_COLUMN_WIDTH = 4;
+	static const int MAP_ROW_OFFSET = 2;
+	static const int MIN_INDUSTRY_PIXELS = 3;
 
+	/** size of left and right borders of the smallmap window */
+	static const int SPACING_SIDE = 2;
+
+	/** size of top border (and title bar) of the smallmap window */
+	static const int SPACING_TOP = 16;
+
+	bool HasButtons()
+	{
+		return this->map_type == SMT_INDUSTRY || this->map_type == SMT_ROUTEMAP;
+	}
+
+	/* The order of calculations when remapping is _very_ important as it introduces rounding errors.
+	 * Everything has to be done just like when drawing the background otherwise the rounding errors are
+	 * different on the background and on the overlay which creates "jumping" behaviour. This means:
+	 * 1. UnScaleByZoom
+	 * 2. divide by TILE_SIZE
+	 * 3. subtract or add things or RemapCoords
+	 * Note:
+	 * We can't divide scroll_{x|y} by TILE_SIZE before scaling as that would mean we can only scroll full tiles.
+	 */
+
 	/**
-	 * Remap a map's tile X coordinate (TileX(TileIndex)) to
-	 * a location on this smallmap.
-	 * @param tile_x the tile's X coordinate.
+	 * remap coordinates on the main map into coordinates on the smallmap
+	 * @param pos_x X position on the main map
+	 * @param pos_y Y position on the main map
+	 * @return Point in the smallmap
+	 */
+	inline Point RemapPlainCoords(int pos_x, int pos_y)
+	{
+		return RemapCoords(
+				RemapX(pos_x),
+				RemapY(pos_y),
+				0
+				);
+	}
+
+	/**
+	 * remap a tile coordinate into coordinates on the smallmap
+	 * @param tile the tile to be remapped
+	 * @return Point with coordinates of the tile's upper left corner in the smallmap
+	 */
+	inline Point RemapTileCoords(TileIndex tile)
+	{
+		return RemapPlainCoords(TileX(tile) * TILE_SIZE, TileY(tile) * TILE_SIZE);
+	}
+
+	/**
+	 * scale a coordinate from the main map into the smallmap dimension
+	 * @param pos coordinate to be scaled
+	 * @return scaled coordinate
+	 */
+	inline int UnScalePlainCoord(int pos)
+	{
+		return UnScaleByZoomLower(pos, this->zoom) / TILE_SIZE;
+	}
+
+	/**
+	 * Remap a map X coordinate to a location on this smallmap.
+	 * @param pos_x the tile's X coordinate.
 	 * @return the X coordinate to draw on.
 	 */
-	inline int RemapX(int tile_x)
+	inline int RemapX(int pos_x)
 	{
-		return tile_x - this->scroll_x / TILE_SIZE;
+		return UnScalePlainCoord(pos_x) - UnScalePlainCoord(this->scroll_x);
 	}
 
 	/**
-	 * Remap a map's tile Y coordinate (TileY(TileIndex)) to
-	 * a location on this smallmap.
-	 * @param tile_y the tile's Y coordinate.
+	 * Remap a map Y coordinate to a location on this smallmap.
+	 * @param pos_y the tile's Y coordinate.
 	 * @return the Y coordinate to draw on.
 	 */
-	inline int RemapY(int tile_y)
+	inline int RemapY(int pos_y)
 	{
-		return tile_y - this->scroll_y / TILE_SIZE;
+		return UnScalePlainCoord(pos_y) - UnScalePlainCoord(this->scroll_y);
 	}
 
 	/**
-	 * Draws one column of the small map in a certain mode onto the screen buffer. This
-	 * function looks exactly the same for all types
+	 * Draws at most MAP_COLUMN_WIDTH columns (of one pixel each) of the small map in a certain
+	 * mode onto the screen buffer. This function looks exactly the same for all types. Due to
+	 * the constraints that no less than MAP_COLUMN_WIDTH pixels can be resolved at once via a
+	 * GetSmallMapPixels function and that a single tile may be mapped onto more than one pixel
+	 * in the smallmap dst, xc and yc may point to a place outside the area to be drawn.
 	 *
+	 * col_start, col_end, row_start and row_end give a more precise description of that area which
+	 * is respected when drawing.
+	 *
 	 * @param dst Pointer to a part of the screen buffer to write to.
-	 * @param xc The X coordinate of the first tile in the column.
-	 * @param yc The Y coordinate of the first tile in the column
-	 * @param pitch Number of pixels to advance in the screen buffer each time a pixel is written.
-	 * @param reps Number of lines to draw
-	 * @param mask ?
-	 * @param proc Pointer to the colour function
+	 * @param xc First unscaled X coordinate of the first tile in the column.
+	 * @param yc First unscaled Y coordinate of the first tile in the column
+	 * @param col_start the first column in the buffer to be actually drawn
+	 * @param col_end the last column to be actually drawn
+	 * @param row_start the first row to be actually drawn
+	 * @param row_end the last row to be actually drawn
 	 * @see GetSmallMapPixels(TileIndex)
 	 */
-	inline void DrawSmallMapStuff(void *dst, uint xc, uint yc, int pitch, int reps, uint32 mask, GetSmallMapPixels *proc)
+	inline void DrawSmallMapStuff(void *dst, uint xc, uint yc, int col_start, int col_end, int row_start, int row_end)
 	{
 		Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
-		void *dst_ptr_abs_end = blitter->MoveTo(_screen.dst_ptr, 0, _screen.height);
-		void *dst_ptr_end = blitter->MoveTo(dst_ptr_abs_end, -4, 0);
+		GetSmallMapPixels *proc = _smallmap_draw_procs[this->map_type];
+		for (int row = 0; row < row_end; row += MAP_ROW_OFFSET) {
+			if (row >= row_start) {
+				/* check if the tile (xc,yc) is within the map range */
+				uint min_xy = _settings_game.construction.freeform_edges ? 1 : 0;
+				uint x = ScaleByZoomLower(xc, this->zoom);
+				uint y = ScaleByZoomLower(yc, this->zoom);
+				uint32 val = 0;
+				if (IsInsideMM(x, min_xy, MapMaxX()) && IsInsideMM(y, min_xy, MapMaxY())) {
+					val = proc(TileXY(x, y));
+				}
+				uint8 *val8 = (uint8 *)&val;
+				for (int i = col_start; i < col_end; ++i ) {
+					blitter->SetPixel(dst, i, 0, val8[i]);
+				}
+			}
 
-		do {
-			/* check if the tile (xc,yc) is within the map range */
-			uint min_xy = _settings_game.construction.freeform_edges ? 1 : 0;
-			if (IsInsideMM(xc, min_xy, MapMaxX()) && IsInsideMM(yc, min_xy, MapMaxY())) {
-				/* check if the dst pointer points to a pixel inside the screen buffer */
-				if (dst < _screen.dst_ptr) continue;
-				if (dst >= dst_ptr_abs_end) continue;
+			/* switch to next row in the column */
+			xc++;
+			yc++;
+			dst = blitter->MoveTo(dst, 0, MAP_ROW_OFFSET);
+		}
+	}
 
-				uint32 val = proc(TileXY(xc, yc)) & mask;
-				uint8 *val8 = (uint8 *)&val;
+	void DrawVehicles(DrawPixelInfo *dpi) {
+		if (this->map_type == SMT_CONTOUR || this->map_type == SMT_VEHICLES) {
+			VehiclePositionMap new_vehicles;
+			Vehicle *v;
 
-				if (dst <= dst_ptr_end) {
-					blitter->SetPixelIfEmpty(dst, 0, 0, val8[0]);
-					blitter->SetPixelIfEmpty(dst, 1, 0, val8[1]);
-					blitter->SetPixelIfEmpty(dst, 2, 0, val8[2]);
-					blitter->SetPixelIfEmpty(dst, 3, 0, val8[3]);
+			FOR_ALL_VEHICLES(v) {
+				if (v->type != VEH_EFFECT &&
+						(v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) == 0) {
+					DrawVehicle(dpi, v, new_vehicles);
+				}
+			}
+
+			if (this->zoom < ZOOM_LVL_NORMAL) {
+				if(this->refresh != FORCE_REFRESH && new_vehicles.size() != this->vehicles_on_map.size()) {
+					/* redraw the whole map if the vehicles have changed. This prevents artifacts. */
+					this->refresh = FORCE_REFRESH;
+				}
+				std::swap(new_vehicles, this->vehicles_on_map);
+			}
+		}
+	}
+
+	/**
+	 * draws a vehicle in the smallmap if it's in the selected drawing area.
+	 * @param dpi the part of the smallmap to be drawn into
+	 * @param v the vehicle to be drawn
+	 */
+	void DrawVehicle(DrawPixelInfo *dpi, Vehicle *v, VehiclePositionMap &new_vehicles)
+	{
+		Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
+		int scale = 1;
+		if (this->zoom < ZOOM_LVL_NORMAL) {
+			scale = 1 << (ZOOM_LVL_NORMAL - this->zoom);
+		}
+
+		/* Remap into flat coordinates. */
+		Point pt = RemapTileCoords(v->tile);
+
+		int x = pt.x - dpi->left;
+		int y = pt.y - dpi->top;
+
+		/* Check if rhombus is inside bounds */
+		if ((x + 2 * scale < 0) || //left
+				(y + 2 * scale < 0) || //top
+				(x - 2 * scale >= dpi->width) || //right
+				(y - 2 * scale >= dpi->height)) { //bottom
+			return;
+		}
+
+		if (this->zoom < ZOOM_LVL_NORMAL) {
+			if (this->refresh != FORCE_REFRESH) {
+				VehiclePositionMap::iterator i = this->vehicles_on_map.find(v->index);
+				if (i == vehicles_on_map.end() || i->second != v->tile) {
+					/* redraw the whole map if the vehicles have changed. This prevents artifacts. */
+					this->refresh = FORCE_REFRESH;
+				}
+			}
+			new_vehicles[v->index] = v->tile;
+		}
+
+		byte colour = (this->map_type == SMT_VEHICLES) ? _vehicle_type_colours[v->type]	: 0xF;
+
+		/* Draw rhombus */
+		for (int dy = 0; dy < scale; dy++) {
+			for (int dx = 0; dx < scale; dx++) {
+				pt = RemapCoords(-dx, -dy, 0);
+				if (IsInsideMM(y + pt.y, 0, dpi->height)) {
+					if (IsInsideMM(x + pt.x, 0, dpi->width)) {
+						blitter->SetPixel(dpi->dst_ptr, x + pt.x, y + pt.y, colour);
+					}
+					if (IsInsideMM(x + pt.x + 1, 0, dpi->width)) {
+						blitter->SetPixel(dpi->dst_ptr, x + pt.x + 1, y + pt.y, colour);
+					}
+				}
+			}
+		}
+	}
+
+	inline Point GetStationMiddle(const Station * st) {
+		int x = (st->rect.right + st->rect.left - 1) * TILE_SIZE / 2;
+		int y = (st->rect.bottom + st->rect.top - 1) * TILE_SIZE / 2;
+		return RemapPlainCoords(x, y);
+	}
+
+	void DrawStationDots() {
+		/* Colour for player owned stations */
+		//int p_colour = _colour_gradient[GetCompany(_local_company)->colour][6];
+		/* Colour for non-player owned stations */
+		//int o_colour = _colour_gradient[COLOUR_GREY][4];
+
+		const Station *st;
+
+		FOR_ALL_STATIONS(st) {
+			if (st->owner != _local_company && Company::IsValidID(st->owner)) continue;
+
+			Point pt = GetStationMiddle(st);
+
+			/* Add up cargo supplied for each selected cargo type */
+			uint q = 0;
+			int colour = 0;
+			int numCargos = 0;
+			for (int i = 0; i < _smallmap_cargo_count; ++i) {
+				const LegendAndColour &tbl = _legend_table[this->map_type][i];
+				if (!tbl.show_on_map) continue;
+				CargoID c = tbl.type;
+				int add = st->goods[c].supply;
+				if (add > 0) {
+					q += add * 30 / _settings_game.economy.moving_average_length / _settings_game.economy.moving_average_unit;
+					colour += tbl.colour;
+					numCargos++;
+				}
+			}
+			if (numCargos > 1)
+				colour /= numCargos;
+
+			uint r = 2;
+			if (q >= 10) r++;
+			if (q >= 20) r++;
+			if (q >= 40) r++;
+			if (q >= 80) r++;
+			if (q >= 160) r++;
+
+			DrawVertex(pt.x, pt.y, r, colour);
+		}
+	}
+
+	class LinkDrawer {
+		typedef std::set<StationID> StationIDSet;
+
+	protected:
+		virtual void DrawContent(Point & pta, Point & ptb) = 0;
+		virtual void AddLink(const LinkStat & orig_link, const FlowStat & orig_flow, const LegendAndColour &cargo_entry) = 0;
+
+		SmallMapWindow * window;
+		StationIDSet seen_stations;
+
+	public:
+		virtual ~LinkDrawer() {}
+
+		void DrawLinks(SmallMapWindow * window)
+		{
+			this->window = window;
+			const Station * sta;
+			FOR_ALL_STATIONS(sta) {
+				for (int i = 0; i < _smallmap_cargo_count; ++i) {
+					const LegendAndColour &tbl = _legend_table[window->map_type][i];
+					if (!tbl.show_on_map) continue;
+
+					CargoID c = tbl.type;
+					const LinkStatMap & links = sta->goods[c].link_stats;
+					for (LinkStatMap::const_iterator i = links.begin(); i != links.end(); ++i) {
+						StationID to = i->first;
+						if (Station::IsValidID(to) && seen_stations.find(to) == seen_stations.end()) {
+							const Station *stb = Station::Get(to);
+							if (sta->owner != _local_company && Company::IsValidID(sta->owner)) continue;
+							if (stb->owner != _local_company && Company::IsValidID(stb->owner)) continue;
+							for (int i = 0; i < _smallmap_cargo_count; ++i) {
+								const LegendAndColour &cargo_entry = _legend_table[window->map_type][i];
+								CargoID cargo = cargo_entry.type;
+								if (cargo_entry.show_on_map) {
+									FlowStat sum_flows = sta->goods[cargo].GetSumFlowVia(stb->index);
+									const LinkStatMap ls_map = sta->goods[cargo].link_stats;
+									LinkStatMap::const_iterator i = ls_map.find(stb->index);
+									if (i != ls_map.end()) {
+										AddLink(i->second, sum_flows, cargo_entry);
+									}
+								}
+							}
+							Point pta = window->GetStationMiddle(sta);
+							Point ptb = window->GetStationMiddle(stb);
+
+							DrawContent(pta, ptb);
+
+							seen_stations.insert(to);
+						}
+					}
+				}
+				seen_stations.clear();
+			}
+		}
+	};
+
+	class LinkLineDrawer : public LinkDrawer {
+	public:
+		LinkLineDrawer() : colour(0), num_colours(0) {}
+
+	protected:
+		uint16 colour;
+		int num_colours;
+		virtual void AddLink(const LinkStat & orig_link, const FlowStat & orig_flow, const LegendAndColour &cargo_entry) {
+			this->colour += cargo_entry.colour;
+			num_colours++;
+		}
+
+		virtual void DrawContent(Point & pta, Point & ptb) {
+			GfxDrawLine(pta.x - 1, pta.y, ptb.x - 1, ptb.y, _colour_gradient[COLOUR_GREY][1]);
+			GfxDrawLine(pta.x + 1, pta.y, ptb.x + 1, ptb.y, _colour_gradient[COLOUR_GREY][1]);
+			GfxDrawLine(pta.x, pta.y - 1, ptb.x, ptb.y - 1, _colour_gradient[COLOUR_GREY][1]);
+			GfxDrawLine(pta.x, pta.y + 1, ptb.x, ptb.y + 1, _colour_gradient[COLOUR_GREY][1]);
+			GfxDrawLine(pta.x, pta.y, ptb.x, ptb.y, this->colour / this->num_colours);
+			this->colour = 0;
+			this->num_colours = 0;
+		}
+	};
+
+	class LinkValueDrawer : public LinkDrawer {
+	protected:
+		LinkStat link;
+		FlowStat flow;
+		uint scale;
+
+		LinkValueDrawer() :
+			scale(_settings_game.economy.moving_average_length * _settings_game.economy.moving_average_unit)
+		{}
+
+		virtual void AddLink(const LinkStat & orig_link, const FlowStat & orig_flow, const LegendAndColour &cargo_entry)
+		{
+			this->link += orig_link;
+			this->flow += orig_flow;
+		}
+
+		void Scale()
+		{
+			this->link *= 30;
+			this->link /= this->scale;
+			this->flow *= 30;
+			this->flow /= this->scale;
+		}
+	};
+
+	class LinkTextDrawer : public LinkValueDrawer {
+	protected:
+		virtual void DrawContent(Point & pta, Point & ptb) {
+			Scale();
+			Point ptm;
+			ptm.x = (pta.x + 2*ptb.x) / 3;
+			ptm.y = (pta.y + 2*ptb.y) / 3;
+			int nums = 0;
+			if (_legend_routemap[_smallmap_cargo_count + STAT_CAPACITY].show_on_map) {
+				SetDParam(nums++, this->link.capacity);
+			}
+			if (_legend_routemap[_smallmap_cargo_count + STAT_USAGE].show_on_map) {
+				SetDParam(nums++, this->link.usage);
+			}
+			if (_legend_routemap[_smallmap_cargo_count + STAT_PLANNED].show_on_map) {
+				SetDParam(nums++, this->flow.planned);
+			}
+			if (_legend_routemap[_smallmap_cargo_count + STAT_SENT].show_on_map) {
+				SetDParam(nums++, this->flow.sent);
+			}
+			StringID str;
+			switch (nums) {
+			case 0:
+				str = STR_EMPTY; break;
+			case 1:
+				str = STR_NUM; break;
+			case 2:
+				str = STR_NUM_RELATION_2; break;
+			case 3:
+				str = STR_NUM_RELATION_3; break;
+			case 4:
+				str = STR_NUM_RELATION_4; break;
+			default:
+				NOT_REACHED();
+			}
+			DrawString(ptm.x, ptm.x + LEGEND_COLUMN_WIDTH, ptm.y, str , TC_BLACK);
+			this->flow.Clear();
+			this->link.Clear();
+		}
+	};
+
+	class LinkGraphDrawer : public LinkValueDrawer {
+		typedef std::multimap<uint, byte, std::greater<uint> > SizeMap;
+	protected:
+		virtual void DrawContent(Point & pta, Point & ptb) {
+			Scale();
+			Point ptm;
+			SizeMap sizes;
+			/* these floats only serve to calculate the size of the coloured boxes for capacity, usage, planned, sent
+			 * they are not reused anywhere, so it's network safe.
+			 */
+			const LegendAndColour *legend_entry = _legend_routemap + _smallmap_cargo_count + STAT_USAGE;
+			if (legend_entry->show_on_map && this->link.usage > 0) {
+				sizes.insert(std::make_pair((uint)sqrt((float)this->link.usage), legend_entry->colour));
+			}
+			legend_entry = _legend_routemap + _smallmap_cargo_count + STAT_CAPACITY;
+			if (legend_entry->show_on_map && this->link.capacity > 0) {
+				sizes.insert(std::make_pair((uint)sqrt((float)this->link.capacity), legend_entry->colour));
+			}
+			legend_entry = _legend_routemap + _smallmap_cargo_count + STAT_PLANNED;
+			if (legend_entry->show_on_map && this->flow.planned > 0) {
+				sizes.insert(std::make_pair((uint)sqrt((float)this->flow.planned),  legend_entry->colour));
+			}
+			legend_entry = _legend_routemap + _smallmap_cargo_count + STAT_SENT;
+			if (legend_entry->show_on_map && this->flow.sent > 0) {
+				sizes.insert(std::make_pair((uint)sqrt((float)this->flow.sent), legend_entry->colour));
+			}
+
+			ptm.x = (pta.x + ptb.x) / 2;
+			ptm.y = (pta.y + ptb.y) / 2;
+
+			for (SizeMap::iterator i = sizes.begin(); i != sizes.end(); ++i) {
+				if (pta.x > ptb.x) {
+					ptm.x -= 1;
+					GfxFillRect(ptm.x - i->first / 2, ptm.y - i->first * 2, ptm.x, ptm.y, i->second);
 				} else {
-					/* It happens that there are only 1, 2 or 3 pixels left to fill, so in that special case, write till the end of the video-buffer */
-					int i = 0;
-					do {
-						blitter->SetPixelIfEmpty(dst, 0, 0, val8[i]);
-					} while (i++, dst = blitter->MoveTo(dst, 1, 0), dst < dst_ptr_abs_end);
+					ptm.x += 1;
+					GfxFillRect(ptm.x, ptm.y - i->first * 2, ptm.x + i->first / 2, ptm.y, i->second);
 				}
 			}
-		/* switch to next tile in the column */
-		} while (xc++, yc++, dst = blitter->MoveTo(dst, pitch, 0), --reps != 0);
+			this->flow.Clear();
+			this->link.Clear();
+		}
+	};
+
+	void DrawIndustries(DrawPixelInfo *dpi) {
+		/* Emphasize all industries if current view is zoomed out "Industreis" */
+		Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
+		if ((this->map_type == SMT_INDUSTRY) && (this->zoom > ZOOM_LVL_NORMAL)) {
+			const Industry *i;
+			FOR_ALL_INDUSTRIES(i) {
+				if (_legend_from_industries[_industry_to_list_pos[i->type]].show_on_map) {
+					Point pt = RemapTileCoords(i->xy);
+
+					int y = pt.y - dpi->top;
+					if (!IsInsideMM(y, 0, dpi->height)) continue;
+
+					int x = pt.x - dpi->left;
+					byte colour = GetIndustrySpec(i->type)->map_colour;
+
+					for (int offset = 0; offset < MIN_INDUSTRY_PIXELS; ++offset) {
+						if (IsInsideMM(x + offset, 0, dpi->width)) {
+							blitter->SetPixel(dpi->dst_ptr, x + offset, y, colour);
+						}
+					}
+				}
+			}
+		}
+
 	}
 
 public:
@@ -652,9 +1174,6 @@
 		old_dpi = _cur_dpi;
 		_cur_dpi = dpi;
 
-		/* clear it */
-		GfxFillRect(dpi->left, dpi->top, dpi->left + dpi->width - 1, dpi->top + dpi->height - 1, 0);
-
 		/* setup owner table */
 		if (this->map_type == SMT_OWNER) {
 			const Company *c;
@@ -672,114 +1191,100 @@
 			}
 		}
 
-		int tile_x = this->scroll_x / TILE_SIZE;
-		int tile_y = this->scroll_y / TILE_SIZE;
+		int tile_x = UnScalePlainCoord(this->scroll_x);
+		int tile_y = UnScalePlainCoord(this->scroll_y);
 
-		int dx = dpi->left + this->subscroll;
+		int dx = dpi->left;
 		tile_x -= dx / 4;
 		tile_y += dx / 4;
-		dx &= 3;
 
 		int dy = dpi->top;
 		tile_x += dy / 2;
 		tile_y += dy / 2;
 
+		/* prevent some artifacts when partially redrawing.
+		 * I have no idea how this works.
+		 */
+		dx &= 3;
+		dx += 1;
 		if (dy & 1) {
 			tile_x++;
 			dx += 2;
-			if (dx > 3) {
-				dx -= 4;
-				tile_x--;
-				tile_y++;
-			}
 		}
 
-		void *ptr = blitter->MoveTo(dpi->dst_ptr, -dx - 4, 0);
-		int x = - dx - 4;
+		/**
+		 * As we can resolve no less than 4 pixels of the smallmap at once we have to start drawing at an X position <= -4
+		 * otherwise we get artifacts when partially redrawing.
+		 * Make sure dx provides for that and update tile_x and tile_y accordingly.
+		 */
+		while(dx < MAP_COLUMN_WIDTH) {
+			dx += MAP_COLUMN_WIDTH;
+			tile_x++;
+			tile_y--;
+		}
+
+		/* The map background is off by a little less than one tile in y direction compared to vehicles and signs.
+		 * I have no idea why this is the case.
+		 * on zoom levels >= ZOOM_LVL_NORMAL this isn't visible as only full tiles can be shown. However, beginning
+		 * at ZOOM_LVL_OUT_2X it's again off by 1 pixel
+		 */
+		dy = 0;
+		if (this->zoom < ZOOM_LVL_NORMAL) {
+			dy = UnScaleByZoomLower(2, this->zoom) - 2;
+		} else if (this->zoom > ZOOM_LVL_NORMAL) {
+			dy = 1;
+		}
+
+		/* correct the various problems mentioned above by moving the initial drawing pointer a little */
+		void *ptr = blitter->MoveTo(dpi->dst_ptr, -dx, -dy);
+		int x = -dx;
 		int y = 0;
 
 		for (;;) {
-			uint32 mask = 0xFFFFFFFF;
-
 			/* distance from left edge */
-			if (x >= -3) {
-				if (x < 0) {
-					/* mask to use at the left edge */
-					mask = _smallmap_mask_left[x + 3];
-				}
+			if (x > -MAP_COLUMN_WIDTH) {
 
 				/* distance from right edge */
-				int t = dpi->width - x;
-				if (t < 4) {
-					if (t <= 0) break; // exit loop
-					/* mask to use at the right edge */
-					mask &= _smallmap_mask_right[t - 1];
-				}
+				if (dpi->width - x <= 0) break;
 
-				/* number of lines */
-				int reps = (dpi->height - y + 1) / 2;
-				if (reps > 0) {
-					this->DrawSmallMapStuff(ptr, tile_x, tile_y, dpi->pitch * 2, reps, mask, _smallmap_draw_procs[this->map_type]);
-				}
+				int col_start = x < 0 ? -x : 0;
+				int col_end = x + MAP_COLUMN_WIDTH > dpi->width ? dpi->width - x : MAP_COLUMN_WIDTH;
+				int row_start = dy - y;
+				int row_end = dy + dpi->height - y;
+				this->DrawSmallMapStuff(ptr, tile_x, tile_y, col_start, col_end, row_start, row_end);
 			}
 
 			if (y == 0) {
 				tile_y++;
 				y++;
-				ptr = blitter->MoveTo(ptr, 0, 1);
+				ptr = blitter->MoveTo(ptr, 0, MAP_ROW_OFFSET / 2);
 			} else {
 				tile_x--;
 				y--;
-				ptr = blitter->MoveTo(ptr, 0, -1);
+				ptr = blitter->MoveTo(ptr, 0, -MAP_ROW_OFFSET / 2);
 			}
-			ptr = blitter->MoveTo(ptr, 2, 0);
-			x += 2;
+			ptr = blitter->MoveTo(ptr, MAP_COLUMN_WIDTH / 2, 0);
+			x += MAP_COLUMN_WIDTH / 2;
 		}
 
-		/* draw vehicles? */
-		if (this->map_type == SMT_CONTOUR || this->map_type == SMT_VEHICLES) {
-			Vehicle *v;
+		DrawVehicles(dpi);
 
-			FOR_ALL_VEHICLES(v) {
-				if (v->type != VEH_EFFECT &&
-						(v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) == 0) {
-					/* Remap into flat coordinates. */
-					Point pt = RemapCoords(
-							this->RemapX(v->x_pos / TILE_SIZE),
-							this->RemapY(v->y_pos / TILE_SIZE),
-							0);
-					x = pt.x;
-					y = pt.y;
+		DrawIndustries(dpi);
 
-					/* Check if y is out of bounds? */
-					y -= dpi->top;
-					if (!IsInsideMM(y, 0, dpi->height)) continue;
+		if (this->map_type == SMT_ROUTEMAP && _game_mode == GM_NORMAL) {
+			LinkLineDrawer lines;
+			lines.DrawLinks(this);
 
-					/* Default is to draw both pixels. */
-					bool skip = false;
+			DrawStationDots();
 
-					/* Offset X coordinate */
-					x -= this->subscroll + 3 + dpi->left;
-
-					if (x < 0) {
-						/* if x+1 is 0, that means we're on the very left edge,
-						 *  and should thus only draw a single pixel */
-						if (++x != 0) continue;
-						skip = true;
-					} else if (x >= dpi->width - 1) {
-						/* Check if we're at the very right edge, and if so draw only a single pixel */
-						if (x != dpi->width - 1) continue;
-						skip = true;
-					}
-
-					/* Calculate pointer to pixel and the colour */
-					byte colour = (this->map_type == SMT_VEHICLES) ? _vehicle_type_colours[v->type] : 0xF;
-
-					/* And draw either one or two pixels depending on clipping */
-					blitter->SetPixel(dpi->dst_ptr, x, y, colour);
-					if (!skip) blitter->SetPixel(dpi->dst_ptr, x + 1, y, colour);
-				}
+			if (_legend_routemap[_smallmap_cargo_count + STAT_TEXT].show_on_map) {
+				LinkTextDrawer text;
+				text.DrawLinks(this);
 			}
+			if (_legend_routemap[_smallmap_cargo_count + STAT_GRAPH].show_on_map) {
+				LinkGraphDrawer graph;
+				graph.DrawLinks(this);
+			}
 		}
 
 		if (this->show_towns) {
@@ -787,11 +1292,8 @@
 
 			FOR_ALL_TOWNS(t) {
 				/* Remap the town coordinate */
-				Point pt = RemapCoords(
-						this->RemapX(TileX(t->xy)),
-						this->RemapY(TileY(t->xy)),
-						0);
-				x = pt.x - this->subscroll + 3 - (t->sign.width_small >> 1);
+				Point pt = RemapTileCoords(t->xy);
+				x = pt.x - (t->sign.width_small >> 1);
 				y = pt.y;
 
 				/* Check if the town sign is within bounds */
@@ -812,16 +1314,12 @@
 		/* Draw map indicators */
 		Point pt = RemapCoords(this->scroll_x, this->scroll_y, 0);
 
-		x = vp->virtual_left - pt.x;
-		y = vp->virtual_top - pt.y;
-		int x2 = (x + vp->virtual_width) / TILE_SIZE;
-		int y2 = (y + vp->virtual_height) / TILE_SIZE;
-		x /= TILE_SIZE;
-		y /= TILE_SIZE;
+		/* UnScale everything separately to produce the same rounding errors as when drawing the background */
+		x = UnScalePlainCoord(vp->virtual_left) - UnScalePlainCoord(pt.x);
+		y = UnScalePlainCoord(vp->virtual_top) - UnScalePlainCoord(pt.y);
+		int x2 = x + UnScalePlainCoord(vp->virtual_width);
+		int y2 = y + UnScalePlainCoord(vp->virtual_height);
 
-		x -= this->subscroll;
-		x2 -= this->subscroll;
-
 		DrawVertMapIndicator(x, y, x, y2);
 		DrawVertMapIndicator(x2, y, x2, y2);
 
@@ -834,20 +1332,60 @@
 	{
 		ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
 
-		int x = ((vp->virtual_width  - (this->widget[SM_WIDGET_MAP].right  - this->widget[SM_WIDGET_MAP].left) * TILE_SIZE) / 2 + vp->virtual_left) / 4;
-		int y = ((vp->virtual_height - (this->widget[SM_WIDGET_MAP].bottom - this->widget[SM_WIDGET_MAP].top ) * TILE_SIZE) / 2 + vp->virtual_top ) / 2 - TILE_SIZE * 2;
-		this->scroll_x = (y - x) & ~0xF;
-		this->scroll_y = (x + y) & ~0xF;
+		int zoomed_width = ScaleByZoom((this->widget[SM_WIDGET_MAP].right  - this->widget[SM_WIDGET_MAP].left) * TILE_SIZE, this->zoom);
+		int zoomed_height = ScaleByZoom((this->widget[SM_WIDGET_MAP].bottom - this->widget[SM_WIDGET_MAP].top) * TILE_SIZE, this->zoom);
+		int x  = ((vp->virtual_width - zoomed_width) / 2 + vp->virtual_left);
+		int y  = ((vp->virtual_height - zoomed_height) / 2 + vp->virtual_top);
+		this->scroll_x = (y * 2 - x) / 4;
+		this->scroll_y = (x + y * 2) / 4;
 		this->SetDirty();
 	}
 
+	/**
+	 * Zoom in the map by one level.
+	 * @param cx horizontal coordinate of center point, relative to SM_WIDGET_MAP widget
+	 * @param cy vertical coordinate of center point, relative to SM_WIDGET_MAP widget
+	 */
+	void ZoomIn(int cx, int cy)
+	{
+		if (this->zoom > ZOOM_LVL_MIN) {
+			this->zoom--;
+			this->DoScroll(cx, cy);
+			this->SetWidgetDisabledState(SM_WIDGET_ZOOM_IN, this->zoom == ZOOM_LVL_MIN);
+			this->EnableWidget(SM_WIDGET_ZOOM_OUT);
+			this->SetDirty();
+		}
+	}
+
+	/**
+	 * Zoom out the map by one level.
+	 * @param cx horizontal coordinate of center point, relative to SM_WIDGET_MAP widget
+	 * @param cy vertical coordinate of center point, relative to SM_WIDGET_MAP widget
+	 */
+	void ZoomOut(int cx, int cy)
+	{
+		if (this->zoom < ZOOM_LVL_MAX) {
+			this->zoom++;
+			this->DoScroll(cx / -2, cy / -2);
+			this->EnableWidget(SM_WIDGET_ZOOM_IN);
+			this->SetWidgetDisabledState(SM_WIDGET_ZOOM_OUT, this->zoom == ZOOM_LVL_MAX);
+			this->SetDirty();
+		}
+	}
+
 	void ResizeLegend()
 	{
 		Widget *legend = &this->widget[SM_WIDGET_LEGEND];
 		int rows = (legend->bottom - legend->top) - 1;
-		int columns = (legend->right - legend->left) / COLUMN_WIDTH;
-		int new_rows = (this->map_type == SMT_INDUSTRY) ? ((_smallmap_industry_count + columns - 1) / columns) * 6 : MIN_LEGEND_HEIGHT;
+		int columns = (legend->right - legend->left) / LEGEND_COLUMN_WIDTH;
+		int new_rows = 0;
 
+		if (this->map_type == SMT_INDUSTRY) {
+			new_rows = ((_smallmap_industry_count + columns - 1) / columns) * 6;
+		} else if (this->map_type == SMT_ROUTEMAP) {
+			new_rows = ((_smallmap_cargo_count + columns - 1) / columns) * 6;
+		}
+
 		new_rows = max(new_rows, MIN_LEGEND_HEIGHT);
 
 		if (new_rows != rows) {
@@ -870,8 +1408,13 @@
 		}
 	}
 
-	SmallMapWindow(const WindowDesc *desc, int window_number) : Window(desc, window_number)
+	SmallMapWindow(const WindowDesc *desc, int window_number) : Window(desc, window_number), zoom(ZOOM_LVL_NORMAL)
 	{
+		this->SetWidgetDisabledState(SM_WIDGET_ROUTEMAP, _smallmap_cargo_count == 0);
+		if (_smallmap_cargo_count == 0 && this->map_type == SMT_ROUTEMAP) {
+			this->map_type = SMT_CONTOUR;
+		}
+
 		this->LowerWidget(this->map_type + SM_WIDGET_CONTOUR);
 		this->SetWidgetLoweredState(SM_WIDGET_TOGGLETOWNNAME, this->show_towns);
 
@@ -884,8 +1427,8 @@
 		DrawPixelInfo new_dpi;
 
 		/* Hide Enable all/Disable all buttons if is not industry type small map*/
-		this->SetWidgetHiddenState(SM_WIDGET_ENABLEINDUSTRIES, this->map_type != SMT_INDUSTRY);
-		this->SetWidgetHiddenState(SM_WIDGET_DISABLEINDUSTRIES, this->map_type != SMT_INDUSTRY);
+		this->SetWidgetHiddenState(SM_WIDGET_ENABLE_ALL, !this->HasButtons());
+		this->SetWidgetHiddenState(SM_WIDGET_DISABLE_ALL, !this->HasButtons());
 
 		/* draw the window */
 		SetDParam(0, STR_SMALLMAP_TYPE_CONTOURS + this->map_type);
@@ -901,7 +1444,7 @@
 			if (tbl->col_break || y >= legend->bottom) {
 				/* Column break needed, continue at top, COLUMN_WIDTH pixels
 				 * (one "row") to the right. */
-				x += COLUMN_WIDTH;
+				x += LEGEND_COLUMN_WIDTH;
 				y = y_org;
 			}
 
@@ -914,15 +1457,25 @@
 				if (!tbl->show_on_map) {
 					/* Simply draw the string, not the black border of the legend colour.
 					 * This will enforce the idea of the disabled item */
-					DrawString(x + 11, x + COLUMN_WIDTH - 1, y, STR_SMALLMAP_INDUSTRY, TC_GREY);
+					DrawString(x + 11, x + LEGEND_COLUMN_WIDTH - 1, y, STR_SMALLMAP_INDUSTRY, TC_GREY);
 				} else {
-					DrawString(x + 11, x + COLUMN_WIDTH - 1, y, STR_SMALLMAP_INDUSTRY, TC_BLACK);
+					DrawString(x + 11, x + LEGEND_COLUMN_WIDTH - 1, y, STR_SMALLMAP_INDUSTRY, TC_BLACK);
 					GfxFillRect(x, y + 1, x + 8, y + 5, 0); // outer border of the legend colour
 				}
+			} else if (this->map_type == SMT_ROUTEMAP) {
+				SetDParam(0, tbl->legend);
+				if (!tbl->show_on_map) {
+					/* Simply draw the string, not the black border of the legend colour.
+					 * This will enforce the idea of the disabled item */
+					DrawString(x + 11, x + LEGEND_COLUMN_WIDTH - 1, y, STR_SMALLMAP_ROUTEMAP_LEGEND, TC_GREY);
+				} else {
+					DrawString(x + 11, x + LEGEND_COLUMN_WIDTH - 1, y, STR_SMALLMAP_ROUTEMAP_LEGEND, TC_BLACK);
+					GfxFillRect(x, y + 1, x + 8, y + 5, 0); // outer border of the legend colour
+				}
 			} else {
 				/* Anything that is not an industry is using normal process */
 				GfxFillRect(x, y + 1, x + 8, y + 5, 0);
-				DrawString(x + 11, x + COLUMN_WIDTH - 1, y, tbl->legend);
+				DrawString(x + 11, x + LEGEND_COLUMN_WIDTH - 1, y, tbl->legend);
 			}
 			GfxFillRect(x + 1, y + 2, x + 7, y + 4, tbl->colour); // legend colour
 
@@ -952,15 +1505,32 @@
 				Point pt = RemapCoords(this->scroll_x, this->scroll_y, 0);
 				Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
 				w->viewport->follow_vehicle = INVALID_VEHICLE;
-				w->viewport->dest_scrollpos_x = pt.x + ((_cursor.pos.x - this->left + 2) << 4) - (w->viewport->virtual_width >> 1);
-				w->viewport->dest_scrollpos_y = pt.y + ((_cursor.pos.y - this->top - 16) << 4) - (w->viewport->virtual_height >> 1);
+				int scaled_x_off = ScaleByZoom((_cursor.pos.x - this->left - this->SPACING_SIDE) * TILE_SIZE, this->zoom);
+				int scaled_y_off = ScaleByZoom((_cursor.pos.y - this->top - this->SPACING_TOP) * TILE_SIZE, this->zoom);
+				w->viewport->dest_scrollpos_x = pt.x + scaled_x_off - w->viewport->virtual_width / 2;
+				w->viewport->dest_scrollpos_y = pt.y + scaled_y_off - w->viewport->virtual_height / 2;
 
 				this->SetDirty();
 			} break;
 
+			case SM_WIDGET_ZOOM_OUT:
+				this->ZoomOut(
+						(this->widget[SM_WIDGET_MAP].right - this->widget[SM_WIDGET_MAP].left) / 2,
+						(this->widget[SM_WIDGET_MAP].bottom - this->widget[SM_WIDGET_MAP].top) / 2
+				);
+				SndPlayFx(SND_15_BEEP);
+				break;
+			case SM_WIDGET_ZOOM_IN:
+				this->ZoomIn(
+						(this->widget[SM_WIDGET_MAP].right - this->widget[SM_WIDGET_MAP].left) / 2,
+						(this->widget[SM_WIDGET_MAP].bottom - this->widget[SM_WIDGET_MAP].top) / 2
+				);
+				SndPlayFx(SND_15_BEEP);
+				break;
 			case SM_WIDGET_CONTOUR:    // Show land contours
 			case SM_WIDGET_VEHICLES:   // Show vehicles
 			case SM_WIDGET_INDUSTRIES: // Show industries
+			case SM_WIDGET_ROUTEMAP:   // Show route map
 			case SM_WIDGET_ROUTES:     // Show transport routes
 			case SM_WIDGET_VEGETATION: // Show vegetation
 			case SM_WIDGET_OWNERS:     // Show land owners
@@ -991,48 +1561,87 @@
 
 			case SM_WIDGET_LEGEND: // Legend
 				/* if industry type small map*/
-				if (this->map_type == SMT_INDUSTRY) {
+				if (this->map_type == SMT_INDUSTRY || this->map_type == SMT_ROUTEMAP) {
 					/* if click on industries label, find right industry type and enable/disable it */
 					Widget *wi = &this->widget[SM_WIDGET_LEGEND]; // label panel
-					uint column = (pt.x - 4) / COLUMN_WIDTH;
+					uint column = (pt.x - 4) / LEGEND_COLUMN_WIDTH;
 					uint line = (pt.y - wi->top - 2) / 6;
 					int rows_per_column = (wi->bottom - wi->top) / 6;
 
 					/* check if click is on industry label*/
-					int industry_pos = (column * rows_per_column) + line;
-					if (industry_pos < _smallmap_industry_count) {
-						_legend_from_industries[industry_pos].show_on_map = !_legend_from_industries[industry_pos].show_on_map;
+					int click_pos = (column * rows_per_column) + line;
+					if (this->map_type == SMT_INDUSTRY) {
+						if (click_pos < _smallmap_industry_count) {
+							_legend_from_industries[click_pos].show_on_map = !_legend_from_industries[click_pos].show_on_map;
+						}
+					} else if (this->map_type == SMT_ROUTEMAP) {
+						if (click_pos < _smallmap_cargo_count) {
+							_legend_routemap[click_pos].show_on_map = !_legend_routemap[click_pos].show_on_map;
+						} else {
+							uint stats_column = _smallmap_cargo_count / rows_per_column;
+							if (_smallmap_cargo_count % rows_per_column != 0) stats_column++;
+
+							if (column == stats_column && line < NUM_STATS) {
+								click_pos = _smallmap_cargo_count + line;
+								_legend_routemap[click_pos].show_on_map = !_legend_routemap[click_pos].show_on_map;
+							}
+						}
 					}
 
 					/* Raise the two buttons "all", as we have done a specific choice */
-					this->RaiseWidget(SM_WIDGET_ENABLEINDUSTRIES);
-					this->RaiseWidget(SM_WIDGET_DISABLEINDUSTRIES);
+					this->RaiseWidget(SM_WIDGET_ENABLE_ALL);
+					this->RaiseWidget(SM_WIDGET_DISABLE_ALL);
 					this->SetDirty();
 				}
 				break;
 
-			case SM_WIDGET_ENABLEINDUSTRIES: // Enable all industries
-				for (int i = 0; i != _smallmap_industry_count; i++) {
-					_legend_from_industries[i].show_on_map = true;
+			case SM_WIDGET_ENABLE_ALL: { // Enable all items
+				LegendAndColour *tbl = (this->map_type == SMT_INDUSTRY) ? _legend_from_industries : _legend_routemap;
+				for (; !tbl->end; ++tbl) {
+					tbl->show_on_map = true;
 				}
 				/* toggle appeareance indicating the choice */
-				this->LowerWidget(SM_WIDGET_ENABLEINDUSTRIES);
-				this->RaiseWidget(SM_WIDGET_DISABLEINDUSTRIES);
+				this->LowerWidget(SM_WIDGET_ENABLE_ALL);
+				this->RaiseWidget(SM_WIDGET_DISABLE_ALL);
 				this->SetDirty();
 				break;
+			}
 
-			case SM_WIDGET_DISABLEINDUSTRIES: // disable all industries
-				for (int i = 0; i != _smallmap_industry_count; i++) {
-					_legend_from_industries[i].show_on_map = false;
+			case SM_WIDGET_DISABLE_ALL: { // Disable all items
+				LegendAndColour *tbl = (this->map_type == SMT_INDUSTRY) ? _legend_from_industries : _legend_routemap;
+				for (; !tbl->end; ++tbl) {
+					tbl->show_on_map = false;
 				}
 				/* toggle appeareance indicating the choice */
-				this->RaiseWidget(SM_WIDGET_ENABLEINDUSTRIES);
-				this->LowerWidget(SM_WIDGET_DISABLEINDUSTRIES);
+				this->RaiseWidget(SM_WIDGET_ENABLE_ALL);
+				this->LowerWidget(SM_WIDGET_DISABLE_ALL);
 				this->SetDirty();
 				break;
+			}
 		}
 	}
 
+	virtual void OnMouseWheel(int wheel)
+	{
+	        /* Cursor position relative to window */
+	        int cx = _cursor.pos.x - this->left;
+	        int cy = _cursor.pos.y - this->top;
+
+	        /* Is cursor over the map ? */
+	        if (IsInsideMM(cx, this->widget[SM_WIDGET_MAP].left, this->widget[SM_WIDGET_MAP].right + 1) &&
+	                                                IsInsideMM(cy, this->widget[SM_WIDGET_MAP].top, this->widget[SM_WIDGET_MAP].bottom + 1)) {
+	                /* Cursor position relative to map */
+	                cx -= this->widget[SM_WIDGET_MAP].left;
+	                cy -= this->widget[SM_WIDGET_MAP].top;
+
+	                if (wheel < 0) {
+	                        this->ZoomIn(cx, cy);
+	                } else {
+	                        this->ZoomOut(cx, cy);
+	                }
+	        }
+	};
+
 	virtual void OnRightClick(Point pt, int widget)
 	{
 		if (widget == SM_WIDGET_MAP) {
@@ -1046,66 +1655,63 @@
 	virtual void OnTick()
 	{
 		/* update the window every now and then */
-		if ((++this->refresh & 0x1F) == 0) this->SetDirty();
+		if (this->refresh++ == FORCE_REFRESH) {
+			this->refresh = 0;
+			this->SetDirty();
+		}
 	}
 
 	virtual void OnScroll(Point delta)
 	{
 		_cursor.fix_at = true;
+		DoScroll(delta.x, delta.y);
+		this->SetDirty();
+	}
 
-		int x = this->scroll_x;
-		int y = this->scroll_y;
+	/**
+	 * Do the actual scrolling, but don't fix the cursor or set the window dirty.
+	 * @param dx x offset to scroll in screen dimension
+	 * @param dy y offset to scroll in screen dimension
+	 */
+	void DoScroll(int dx, int dy)
+	{
+		/* divide as late as possible to avoid premature reduction to 0, which causes "jumpy" behaviour
+		 * at the same time make sure this is the exact reverse function of the drawing methods in order to
+		 * avoid map indicators shifting around:
+		 * 1. add/subtract
+		 * 2. * TILE_SIZE
+		 * 3. scale
+		 */
+		int x = dy * 2 - dx;
+		int y = dx + dy * 2;
 
-		int sub = this->subscroll + delta.x;
-
-		x -= (sub >> 2) << 4;
-		y += (sub >> 2) << 4;
-		sub &= 3;
-
-		x += (delta.y >> 1) << 4;
-		y += (delta.y >> 1) << 4;
-
-		if (delta.y & 1) {
-			x += TILE_SIZE;
-			sub += 2;
-			if (sub > 3) {
-				sub -= 4;
-				x -= TILE_SIZE;
-				y += TILE_SIZE;
-			}
+		/* round to next divisible by 4 to allow for smoother scrolling */
+		int rem_x = abs(x % 4);
+		int rem_y = abs(y % 4);
+		if (rem_x != 0) {
+			x += x > 0 ? 4 - rem_x : rem_x - 4;
 		}
-
-		int hx = (this->widget[SM_WIDGET_MAP].right  - this->widget[SM_WIDGET_MAP].left) / 2;
-		int hy = (this->widget[SM_WIDGET_MAP].bottom - this->widget[SM_WIDGET_MAP].top ) / 2;
-		int hvx = hx * -4 + hy * 8;
-		int hvy = hx *  4 + hy * 8;
-		if (x < -hvx) {
-			x = -hvx;
-			sub = 0;
+		if (rem_y != 0) {
+			y += y > 0 ? 4 - rem_y : rem_y - 4;
 		}
-		if (x > (int)MapMaxX() * TILE_SIZE - hvx) {
-			x = MapMaxX() * TILE_SIZE - hvx;
-			sub = 0;
-		}
-		if (y < -hvy) {
-			y = -hvy;
-			sub = 0;
-		}
-		if (y > (int)MapMaxY() * TILE_SIZE - hvy) {
-			y = MapMaxY() * TILE_SIZE - hvy;
-			sub = 0;
-		}
 
-		this->scroll_x = x;
-		this->scroll_y = y;
-		this->subscroll = sub;
+		this->scroll_x += ScaleByZoomLower(x / 4 * TILE_SIZE, this->zoom);
+		this->scroll_y += ScaleByZoomLower(y / 4 * TILE_SIZE, this->zoom);
 
-		this->SetDirty();
+		/* enforce the screen limits */
+		int hx = this->widget[SM_WIDGET_MAP].right  - this->widget[SM_WIDGET_MAP].left;
+		int hy = this->widget[SM_WIDGET_MAP].bottom - this->widget[SM_WIDGET_MAP].top;
+		int hvx = ScaleByZoomLower(hy * 4 - hx * 2, this->zoom);
+		int hvy = ScaleByZoomLower(hx * 2 + hy * 4, this->zoom);
+		this->scroll_x = max(-hvx, this->scroll_x);
+		this->scroll_y = max(-hvy, this->scroll_y);
+		this->scroll_x = min(MapMaxX() * TILE_SIZE, this->scroll_x);
+		this->scroll_y = min(MapMaxY() * TILE_SIZE - hvy, this->scroll_y);
 	}
 
 	virtual void OnResize(Point delta)
 	{
-		if (delta.x != 0 && this->map_type == SMT_INDUSTRY) this->ResizeLegend();
+		if (delta.x != 0 && (this->map_type == SMT_INDUSTRY || this->map_type == SMT_ROUTEMAP)) this->ResizeLegend();
 	}
 };
 
Index: src/sound.cpp
===================================================================
--- src/sound.cpp	(revision 17081)
+++ src/sound.cpp	(working copy)
@@ -147,7 +147,7 @@
 
 
 static const byte _vol_factor_by_zoom[] = {255, 190, 134, 87};
-assert_compile(lengthof(_vol_factor_by_zoom) == ZOOM_LVL_COUNT);
+assert_compile(lengthof(_vol_factor_by_zoom) == ZOOM_LVL_BLITTER_COUNT);
 
 static const byte _sound_base_vol[] = {
 	128,  90, 128, 128, 128, 128, 128, 128,
@@ -211,7 +211,7 @@
 			StartSound(
 				sound,
 				panning,
-				(msf.effect_vol * _vol_factor_by_zoom[vp->zoom - ZOOM_LVL_BEGIN]) / 256
+				(msf.effect_vol * _vol_factor_by_zoom[vp->zoom - ZOOM_LVL_BLITTER_MIN]) / 256
 			);
 			return;
 		}
Index: src/station.cpp
===================================================================
--- src/station.cpp	(revision 17081)
+++ src/station.cpp	(working copy)
@@ -69,6 +69,16 @@
 		if (a->targetairport == this->index) a->targetairport = INVALID_STATION;
 	}
 
+	Station * st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID c = CT_BEGIN; c != CT_END; ++c) {
+			GoodsEntry & ge = st->goods[c];
+			ge.link_stats.erase(this->index);
+			DeleteStaleFlows(st->index, c, this->index);
+			ge.cargo.RerouteStalePackets(this->index, this->index, &ge);
+		}
+	}
+	
 	Vehicle *v;
 	FOR_ALL_VEHICLES(v) {
 		/* Forget about this station if this station is removed */
Index: src/station_base.h
===================================================================
--- src/station_base.h	(revision 17081)
+++ src/station_base.h	(working copy)
@@ -12,13 +12,106 @@
 #include "vehicle_type.h"
 #include "industry_type.h"
 #include "core/geometry_type.hpp"
+#include "linkgraph/linkgraph_types.h"
 #include <list>
+#include <map>
+#include <set>
 
 typedef Pool<BaseStation, StationID, 32, 64000> StationPool;
 extern StationPool _station_pool;
 
 static const byte INITIAL_STATION_RATING = 175;
 
+class LinkStat {
+public:
+	uint capacity;
+	uint frozen;
+	uint usage;
+	LinkStat() : capacity(0), frozen(0), usage(0) {}
+
+	inline LinkStat & operator*=(uint factor) {
+		capacity *= factor;
+		usage *= factor;
+		return *this;
+	}
+
+	inline LinkStat & operator/=(uint divident) {
+		capacity /= divident;
+		if (capacity < frozen) {
+			capacity = frozen;
+		}
+		usage /= divident;
+		return *this;
+	}
+
+	inline LinkStat & operator+=(const LinkStat & other)
+	{
+		this->capacity += other.capacity;
+		this->usage += other.usage;
+		this->frozen += other.frozen;
+		return *this;
+	}
+
+	inline void Clear()
+	{
+		this->capacity = 0;
+		this->usage = 0;
+		this->frozen = 0;
+	}
+};
+
+class FlowStat {
+public:
+	FlowStat(StationID st = INVALID_STATION, uint p = 0, uint s = 0) :
+		planned(p), sent(s), via(st) {}
+	uint planned;
+	uint sent;
+	StationID via;
+	struct comp {
+		bool operator()(const FlowStat & x, const FlowStat & y) const {
+			int diff_x = (int)x.planned - (int)x.sent;
+			int diff_y = (int)y.planned - (int)y.sent;
+			if (diff_x != diff_y) {
+				return diff_x > diff_y;
+			} else {
+				return x.via > y.via;
+			}
+		}
+	};
+
+	inline FlowStat & operator*=(uint factor) {
+		planned *= factor;
+		sent *= factor;
+		return *this;
+	}
+
+	inline FlowStat & operator/=(uint divident) {
+		planned /= divident;
+		sent /= divident;
+		return *this;
+	}
+
+	inline FlowStat & operator+=(const FlowStat & other)
+	{
+		assert(this->via == INVALID_STATION || other.via == INVALID_STATION || this->via == other.via);
+		this->via = other.via;
+		this->planned += other.planned;
+		this->sent += other.sent;
+		return *this;
+	}
+
+	inline void Clear()
+	{
+		this->planned = 0;
+		this->sent = 0;
+		this->via = INVALID_STATION;
+	}
+};
+
+typedef std::set<FlowStat, FlowStat::comp> FlowStatSet; ///< percentage of flow to be sent via specified station (or consumed locally)
+typedef std::map<StationID, LinkStat> LinkStatMap;
+typedef std::map<StationID, FlowStatSet> FlowStatMap; ///< flow descriptions by origin stations
+
 struct GoodsEntry {
 	enum AcceptancePickup {
 		ACCEPTANCE,
@@ -30,7 +123,8 @@
 		days_since_pickup(255),
 		rating(INITIAL_STATION_RATING),
 		last_speed(0),
-		last_age(255)
+		last_age(255),
+		last_component(0)
 	{}
 
 	byte acceptance_pickup;
@@ -38,7 +132,26 @@
 	byte rating;
 	byte last_speed;
 	byte last_age;
-	CargoList cargo; ///< The cargo packets of cargo waiting in this station
+	CargoList cargo;        ///< The cargo packets of cargo waiting in this station
+	uint supply;
+	FlowStatMap flows;      ///< The planned flows through this station
+	LinkStatMap link_stats; ///< capacities and usage statistics for outgoing links
+	LinkGraphComponentID last_component; ///< the component this station was last part of in this cargo's link graph
+	
+	FlowStat GetSumFlowVia(StationID via) const;
+
+	/**
+	 * update the flow stats for count cargo from source sent to next
+	 */
+	void UpdateFlowStats(StationID source, uint count, StationID next);
+
+	/**
+	 * update the flow stats for count cargo that cannot be delivered here
+	 * return the direction where it is sent
+	 */
+	StationID UpdateFlowStatsTransfer(StationID source, uint count, StationID curr);
+private:
+	void UpdateFlowStats(FlowStatSet & flow_stats, FlowStatSet::iterator flow_it, uint count);
 };
 
 
Index: src/station_cmd.cpp
===================================================================
--- src/station_cmd.cpp	(revision 17081)
+++ src/station_cmd.cpp	(working copy)
@@ -2785,6 +2785,157 @@
 	}
 }
 
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to) {
+	FlowStatMap & flows = Station::Get(at)->goods[c_id].flows;
+	for (FlowStatMap::iterator f_it = flows.begin(); f_it != flows.end();) {
+		FlowStatSet & s_flows = f_it->second;
+		for (FlowStatSet::iterator s_it = s_flows.begin(); s_it != s_flows.end();) {
+			if (s_it->via == to) {
+				s_flows.erase(s_it++);
+			} else {
+				++s_it;
+			}
+		}
+		if (s_flows.empty()) {
+			flows.erase(f_it++);
+		} else {
+			++f_it;
+		}
+	}
+}
+
+static void UpdateStationStats(Station * st) {
+	uint length = _settings_game.economy.moving_average_length;
+	FlowStatSet new_flows;
+	for(int goods_index = CT_BEGIN; goods_index != CT_END; ++goods_index) {
+		GoodsEntry & good = st->goods[goods_index];
+		good.supply = DivideApprox(good.supply * length, length + 1);
+		LinkStatMap & links = good.link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end();) {
+			StationID id = i->first;
+			if (!Station::IsValidID(id)) {
+				links.erase(i++);
+			} else {
+				LinkStat & ls = i->second;
+				ls *= length;
+				ls /= (length + 1);
+				if (ls.capacity == 0) {
+					DeleteStaleFlows(st->index, goods_index, id);
+					good.cargo.RerouteStalePackets(st->index, id, &good);
+					links.erase(i++);
+				} else {
+					++i;
+				}
+			}
+		}
+
+		FlowStatMap & flows = good.flows;
+		for (FlowStatMap::iterator i = flows.begin(); i != flows.end();) {
+			StationID source = i->first;
+			if (!Station::IsValidID(source)) {
+				flows.erase(i++);
+			} else {
+				FlowStatSet & flow_set = i->second;
+				for (FlowStatSet::iterator j = flow_set.begin(); j != flow_set.end(); ++j) {
+					StationID via = j->via;
+					if (Station::IsValidID(via)) {
+						new_flows.insert(FlowStat(via, j->planned, (j->sent * length) / (length + 1)));
+					}
+				}
+				flow_set.swap(new_flows);
+				new_flows.clear();
+				++i;
+			}
+		}
+	}
+}
+
+void UpdateFlows(Station * st, Vehicle *front, StationID next_station_id) {
+	if (next_station_id == INVALID_STATION) {
+		return;
+	} else {
+		for (Vehicle *v = front; v != NULL; v = v->Next()) {
+			GoodsEntry *ge = &st->goods[v->cargo_type];
+			v->cargo.UpdateFlows(next_station_id, ge);
+		}
+	}
+}
+
+void IncreaseFrozen(Station *st, Vehicle *front, StationID next_station_id) {
+	assert(st->index != next_station_id && next_station_id != INVALID_STATION);
+	for (Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			LinkStat & ls = st->goods[v->cargo_type].link_stats[next_station_id];
+			ls.frozen += v->cargo_cap;
+			ls.capacity = max(ls.capacity, ls.frozen);
+			assert(ls.capacity > 0);
+		}
+	}
+}
+
+void RecalcFrozen(Station * st) {
+	if (st->loading_vehicles.empty()) {
+		/* if no vehicles are there the frozen values are always correct */
+		return;
+	}
+
+	for(int goods_index = CT_BEGIN; goods_index != CT_END; ++goods_index) {
+		GoodsEntry & good = st->goods[goods_index];
+		LinkStatMap & links = good.link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end(); ++i) {
+			i->second.frozen = 0;
+		}
+	}
+
+	std::list<Vehicle *>::iterator v_it = st->loading_vehicles.begin();
+	while(v_it != st->loading_vehicles.end()) {
+		Vehicle * front = *v_it;
+		OrderList * orders = front->orders.list;
+		if (orders != NULL) {
+			StationID next_station_id = orders->GetNextStoppingStation(front->cur_order_index, front->type == VEH_ROAD || front->type == VEH_TRAIN);
+			if (next_station_id != INVALID_STATION && next_station_id != st->index) {
+				IncreaseFrozen(st, front, next_station_id);
+			}
+		}
+		++v_it;
+	}
+}
+
+void DecreaseFrozen(Station *st, Vehicle *front, StationID next_station_id) {
+	assert(st->index != next_station_id && next_station_id != INVALID_STATION);
+	for (Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			LinkStatMap & link_stats = st->goods[v->cargo_type].link_stats;
+			LinkStatMap::iterator lstat_it = link_stats.find(next_station_id);
+			if (lstat_it == link_stats.end()) {
+				RecalcFrozen(st);
+				return;
+			} else {
+				LinkStat & link_stat = lstat_it->second;
+				if (link_stat.frozen < v->cargo_cap) {
+					RecalcFrozen(st);
+					return;
+				} else {
+					link_stat.frozen -= v->cargo_cap;
+				}
+				assert(link_stat.capacity > 0);
+			}
+		}
+	}
+}
+
+void IncreaseStats(Station *st, Vehicle *front, StationID next_station_id) {
+	assert(st->index != next_station_id && next_station_id != INVALID_STATION);
+	for (Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			LinkStat & link_stat = st->goods[v->cargo_type].link_stats[next_station_id];
+			link_stat.capacity += v->cargo_cap;
+			link_stat.usage += v->cargo.Count();
+			assert(link_stat.capacity > 0);
+		}
+	}
+}
+
 /* called for every station each tick */
 static void StationHandleSmallTick(BaseStation *st)
 {
@@ -2804,7 +2955,18 @@
 	BaseStation *st;
 	FOR_ALL_BASE_STATIONS(st) {
 		StationHandleSmallTick(st);
+		if (Station::IsExpected(st)) {
+			Station * real_st = Station::From(st);
+			// update the station statistics every <unit> days
+			if ((_tick_counter + real_st->index) % (DAY_TICKS * _settings_game.economy.moving_average_unit) == 0) {
+				UpdateStationStats(real_st);
+			}
 
+			/* recalculate the frozen values every month */
+			if ((_tick_counter + real_st->index) % (DAY_TICKS * 30) == 0) {
+				RecalcFrozen(real_st);
+			}
+		}
 		/* Run 250 tick interval trigger for station animation.
 		 * Station index is included so that triggers are not all done
 		 * at the same time. */
@@ -2842,8 +3004,23 @@
 
 static void UpdateStationWaiting(Station *st, CargoID type, uint amount)
 {
-	st->goods[type].cargo.Append(new CargoPacket(st->index, amount));
-	SetBit(st->goods[type].acceptance_pickup, GoodsEntry::PICKUP);
+	GoodsEntry & good = st->goods[type];
+	StationID id = st->index;
+	StationID next = INVALID_STATION;
+	FlowStatSet & flow_stats = good.flows[id];
+	FlowStatSet::iterator i = flow_stats.begin();
+	if (i != flow_stats.end()) {
+		StationID via = i->via;
+		uint planned = i->planned;
+		uint sent = i->sent + amount;
+		flow_stats.erase(i);
+		flow_stats.insert(FlowStat(via, planned, sent));
+		next = via;
+	}
+	CargoPacket * packet = new CargoPacket(id, next, amount);
+	good.cargo.Append(packet);
+	SetBit(good.acceptance_pickup, GoodsEntry::PICKUP);
+	good.supply += amount;
 
 	StationAnimationTrigger(st, st->xy, STAT_ANIM_NEW_CARGO, type);
 
@@ -3186,7 +3363,67 @@
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 }
 
+void GoodsEntry::UpdateFlowStats(FlowStatSet & flow_stats, FlowStatSet::iterator flow_it, uint count) {
+	uint planned = flow_it->planned;
+	uint sent = flow_it->sent + count;
+	StationID via = flow_it->via;
+	flow_stats.erase(flow_it);
+	flow_stats.insert(FlowStat(via, planned, sent));
+}
 
+void GoodsEntry::UpdateFlowStats(StationID source, uint count, StationID next) {
+	if (source == INVALID_STATION || next == INVALID_STATION || flows.empty()) return;
+	FlowStatSet & flow_stats = flows[source];
+	FlowStatSet::iterator flow_it = flow_stats.begin();
+	if (flow_it != flow_stats.end()) {
+		StationID via = flow_it->via;
+		if (via == next) {
+			UpdateFlowStats(flow_stats, flow_it, count);
+			return;
+		} else {
+			while(++flow_it != flow_stats.end()) {
+				via = flow_it->via;
+				if (via == next) {
+					UpdateFlowStats(flow_stats, flow_it, count);
+					return;
+				}
+			}
+		}
+	}
+}
+
+StationID GoodsEntry::UpdateFlowStatsTransfer(StationID source, uint count, StationID curr) {
+	if (source == INVALID_STATION || flows.empty()) return INVALID_STATION;
+	FlowStatSet & flow_stats = flows[source];
+	FlowStatSet::iterator flow_it = flow_stats.begin();
+	while (flow_it != flow_stats.end()) {
+		StationID via = flow_it->via;
+		if (via != curr) {
+			UpdateFlowStats(flow_stats, flow_it, count);
+			return via;
+		}
+		else {
+			++flow_it;
+		}
+	}
+	return INVALID_STATION;
+}
+
+FlowStat GoodsEntry::GetSumFlowVia(StationID via) const {
+	FlowStat ret(via);
+	for(FlowStatMap::const_iterator i = flows.begin(); i != flows.end(); ++i) {
+		const FlowStatSet & flow_set = i->second;
+		for (FlowStatSet::const_iterator j = flow_set.begin(); j != flow_set.end(); ++j) {
+			const FlowStat & flow = *j;
+			if (flow.via == via) {
+				ret.planned += flow.planned;
+				ret.sent += flow.sent;
+			}
+		}
+	}
+	return ret;
+}
+
 extern const TileTypeProcs _tile_type_station_procs = {
 	DrawTile_Station,           // draw_tile_proc
 	GetSlopeZ_Station,          // get_slope_z_proc
Index: src/station_func.h
===================================================================
--- src/station_func.h	(revision 17081)
+++ src/station_func.h	(working copy)
@@ -45,4 +45,16 @@
 
 void UpdateAirportsNoise();
 
+void DecreaseFrozen(Station *st, Vehicle *v, StationID next_station_id);
+
+void IncreaseFrozen(Station *st, Vehicle *v, StationID next_station_id);
+
+void RecalcFrozen(Station * st);
+
+void IncreaseStats(Station *st, Vehicle *v, StationID next_station_id);
+
+void UpdateFlows(Station * st, Vehicle *v, StationID next_station_id);
+
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to);
+
 #endif /* STATION_FUNC_H */
Index: src/station_gui.cpp
===================================================================
--- src/station_gui.cpp	(revision 17081)
+++ src/station_gui.cpp	(working copy)
@@ -30,6 +30,8 @@
 #include "table/strings.h"
 #include "table/sprites.h"
 
+#include <vector>
+
 /**
  * Draw small boxes of cargo amount and ratings data at the given
  * coordinates. If amount exceeds 576 units, it is shown 'full', same
@@ -682,17 +684,21 @@
 {   WWT_CLOSEBOX,   RESIZE_NONE,  COLOUR_GREY,     0,    10,     0,    13, STR_BLACK_CROSS,                 STR_TOOLTIP_CLOSE_WINDOW},             // SVW_CLOSEBOX
 {    WWT_CAPTION,  RESIZE_RIGHT,  COLOUR_GREY,    11,   236,     0,    13, STR_STATION_VIEW_CAPTION,        STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS},
 {  WWT_STICKYBOX,     RESIZE_LR,  COLOUR_GREY,   237,   248,     0,    13, 0x0,                             STR_TOOLTIP_STICKY},
-{      WWT_PANEL,     RESIZE_RB,  COLOUR_GREY,     0,   236,    14,    65, 0x0,                             STR_NULL},                             // SVW_WAITING
-{  WWT_SCROLLBAR,    RESIZE_LRB,  COLOUR_GREY,   237,   248,    14,    65, 0x0,                             STR_TOOLTIP_VSCROLL_BAR_SCROLLS_LIST},
-{      WWT_PANEL,    RESIZE_RTB,  COLOUR_GREY,     0,   248,    66,    97, 0x0,                             STR_NULL},                             // SVW_ACCEPTLIST / SVW_RATINGLIST
-{ WWT_PUSHTXTBTN,     RESIZE_TB,  COLOUR_GREY,     0,    59,    98,   109, STR_BUTTON_LOCATION,             STR_STATION_VIEW_CENTER_TOOLTIP},      // SVW_LOCATION
-{ WWT_PUSHTXTBTN,     RESIZE_TB,  COLOUR_GREY,    60,   120,    98,   109, STR_STATION_VIEW_RATINGS_BUTTON, STR_STATION_VIEW_RATINGS_TOOLTIP},     // SVW_RATINGS / SVW_ACCEPTS
-{ WWT_PUSHTXTBTN,    RESIZE_RTB,  COLOUR_GREY,   121,   180,    98,   109, STR_BUTTON_RENAME,                STR_STATION_VIEW_RENAME_TOOLTIP},      // SVW_RENAME
-{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   181,   194,    98,   109, STR_TRAIN,                       STR_STATION_VIEW_SCHEDULED_TRAINS_TOOLTIP },            // SVW_TRAINS
-{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   195,   208,    98,   109, STR_LORRY,                       STR_STATION_VIEW_SCHEDULED_ROAD_VEHICLES_TOOLTIP },     // SVW_ROADVEHS
-{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   209,   222,    98,   109, STR_PLANE,                       STR_STATION_VIEW_SCHEDULED_AIRCRAFT_TOOLTIP },          // SVW_PLANES
-{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   223,   236,    98,   109, STR_SHIP,                        STR_STATION_VIEW_SCHEDULED_SHIPS_TOOLTIP },             // SVW_SHIPS
-{  WWT_RESIZEBOX,   RESIZE_LRTB,  COLOUR_GREY,   237,   248,    98,   109, 0x0,                             STR_TOOLTIP_RESIZE},
+{    WWT_TEXTBTN,   RESIZE_NONE,  COLOUR_GREY,     0,    80,    14,    25, STR_SORT_BY,                     STR_SORT_ORDER_TIP},                   // SVW_SORT_ORDER
+{    WWT_TEXTBTN,  RESIZE_RIGHT,  COLOUR_GREY,    81,   248,    14,    25, 0x0,                             STR_SORT_CRITERIA_TIP},                // SVW_SORT_BY
+{   WWT_DROPDOWN,   RESIZE_NONE,  COLOUR_GREY,     0,    80,    26,    37, STR_STATION_VIEW_WAITING,        STR_TOGGLE_CARGO_VIEW},                // SVW_MODE
+{   WWT_DROPDOWN,  RESIZE_RIGHT,  COLOUR_GREY,    81,   248,    26,    37, 0x0,                             STR_GROUP_TIP},                        // SVW_GROUP_BY
+{      WWT_PANEL,     RESIZE_RB,  COLOUR_GREY,     0,   236,    38,    81, 0x0,                             STR_NULL},                             // SVW_WAITING
+{  WWT_SCROLLBAR,    RESIZE_LRB,  COLOUR_GREY,   237,   248,    38,    81, 0x0,                             STR_TOOLTIP_VSCROLL_BAR_SCROLLS_LIST},
+{      WWT_PANEL,    RESIZE_RTB,  COLOUR_GREY,     0,   248,    82,   104, 0x0,                             STR_NULL},                             // SVW_ACCEPTLIST / SVW_RATINGLIST
+{ WWT_PUSHTXTBTN,     RESIZE_TB,  COLOUR_GREY,     0,    59,   105,   116, STR_BUTTON_LOCATION,             STR_STATION_VIEW_CENTER_TOOLTIP},      // SVW_LOCATION
+{ WWT_PUSHTXTBTN,     RESIZE_TB,  COLOUR_GREY,    60,   120,   105,   116, STR_STATION_VIEW_ACCEPTS_BUTTON, STR_STATION_VIEW_ACCEPTS_TOOLTIP},     // SVW_RATINGS / SVW_ACCEPTS
+{ WWT_PUSHTXTBTN,    RESIZE_RTB,  COLOUR_GREY,   121,   180,   105,   116, STR_QUERY_RENAME,                STR_STATION_VIEW_RENAME_TOOLTIP},      // SVW_RENAME
+{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   181,   194,   105,   116, STR_TRAIN,                       STR_SCHEDULED_TRAINS_TIP },            // SVW_TRAINS
+{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   195,   208,   105,   116, STR_LORRY,                       STR_SCHEDULED_ROAD_VEHICLES_TIP },     // SVW_ROADVEHS
+{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   209,   222,   105,   116, STR_PLANE,                       STR_SCHEDULED_AIRCRAFT_TIP },          // SVW_PLANES
+{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   223,   236,   105,   116, STR_SHIP,                        STR_SCHEDULED_SHIPS_TIP },             // SVW_SHIPS
+{  WWT_RESIZEBOX,   RESIZE_LRTB,  COLOUR_GREY,   237,   248,   105,   116, 0x0,                             STR_RESIZE_BUTTON},
 {   WIDGETS_END},
 };
 
@@ -703,13 +709,21 @@
 		NWidget(WWT_STICKYBOX, COLOUR_GREY, SVW_STICKYBOX),
 	EndContainer(),
 	NWidget(NWID_HORIZONTAL),
-		NWidget(WWT_PANEL, COLOUR_GREY, SVW_WAITING), SetMinimalSize(237, 52), SetResize(1, 10), EndContainer(),
+ 		NWidget(WWT_TEXTBTN, COLOUR_GREY, SVW_SORT_ORDER), SetMinimalSize(81, 12), SetDataTip(STR_SORT_BY, STR_SORT_ORDER_TIP),
+ 		NWidget(WWT_TEXTBTN, COLOUR_GREY, SVW_SORT_BY), SetMinimalSize(168, 12), SetResize(1, 0), SetDataTip(0x0, STR_SORT_CRITERIA_TIP),
+ 	EndContainer(),
+ 	NWidget(NWID_HORIZONTAL),
+ 		NWidget(WWT_DROPDOWN, COLOUR_GREY, SVW_MODE), SetMinimalSize(81, 12), SetDataTip(STR_STATION_VIEW_WAITING, STR_TOGGLE_CARGO_VIEW),
+ 		NWidget(WWT_DROPDOWN, COLOUR_GREY, SVW_GROUP_BY), SetMinimalSize(168, 12), SetResize(1, 0), SetDataTip(0x0, STR_GROUP_TIP),
+ 	EndContainer(),
+ 	NWidget(NWID_HORIZONTAL),
+ 		NWidget(WWT_PANEL, COLOUR_GREY, SVW_WAITING), SetMinimalSize(237, 44), SetResize(1, 10), EndContainer(),
 		NWidget(WWT_SCROLLBAR, COLOUR_GREY, SVW_SCROLLBAR),
 	EndContainer(),
-	NWidget(WWT_PANEL, COLOUR_GREY, SVW_ACCEPTLIST), SetMinimalSize(249, 32), SetResize(1, 0), EndContainer(),
+ 	NWidget(WWT_PANEL, COLOUR_GREY, SVW_ACCEPTLIST), SetMinimalSize(249, 23), SetResize(1, 0), EndContainer(),
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, SVW_LOCATION), SetMinimalSize(60, 12), SetDataTip(STR_BUTTON_LOCATION, STR_STATION_VIEW_CENTER_TOOLTIP),
-		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, SVW_ACCEPTS), SetMinimalSize(61, 12), SetDataTip(STR_STATION_VIEW_RATINGS_BUTTON, STR_STATION_VIEW_RATINGS_TOOLTIP),
+ 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, SVW_ACCEPTS), SetMinimalSize(61, 12), SetDataTip(STR_STATION_VIEW_ACCEPTS_BUTTON, STR_STATION_VIEW_ACCEPTS_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, SVW_RENAME), SetMinimalSize(60, 12), SetResize(1, 0), SetDataTip(STR_BUTTON_RENAME, STR_STATION_VIEW_RENAME_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, SVW_TRAINS), SetMinimalSize(14, 12), SetDataTip(STR_TRAIN, STR_STATION_VIEW_SCHEDULED_TRAINS_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, SVW_ROADVEHS), SetMinimalSize(14, 12), SetDataTip(STR_LORRY, STR_STATION_VIEW_SCHEDULED_ROAD_VEHICLES_TOOLTIP),
@@ -757,34 +771,230 @@
 	} while (--num);
 }
 
-struct CargoData {
-	CargoID cargo;
-	StationID source;
-	uint count;
+CargoDataEntry::CargoDataEntry() :
+	parent(NULL),
+	station(INVALID_STATION),
+	size(0),
+	count(0),
+	subentries(new CargoDataSet(CargoSorter(ST_CARGO_ID)))
+{}
 
-	CargoData(CargoID cargo, StationID source, uint count) :
-		cargo(cargo),
-		source(source),
-		count(count)
-	{ }
-};
+CargoDataEntry::CargoDataEntry(CargoID car, uint c, CargoDataEntry * p) :
+	parent(p),
+	cargo(car),
+	size(0),
+	count(c),
+	subentries(new CargoDataSet)
+{}
 
-typedef std::list<CargoData> CargoDataList;
+CargoDataEntry::CargoDataEntry(StationID st, uint c, CargoDataEntry * p) :
+	parent(p),
+	station(st),
+	size(0),
+	count(c),
+	subentries(new CargoDataSet)
+{}
 
+CargoDataEntry::CargoDataEntry(StationID st) :
+	parent(NULL),
+	station(st),
+	size(0),
+	count(0),
+	subentries(NULL)
+{}
+
+CargoDataEntry::CargoDataEntry(CargoID ca) :
+	parent(NULL),
+	cargo(ca),
+	size(0),
+	count(0),
+	subentries(NULL)
+{}
+
+CargoDataEntry::~CargoDataEntry() {
+	if (subentries != NULL) {
+		for (CargoDataSet::iterator i = subentries->begin(); i != subentries->end(); ++i) {
+			delete *i;
+		}
+		delete subentries;
+	}
+}
+
+template<class ID>
+CargoDataEntry * CargoDataEntry::Update(ID s, uint c) {
+	CargoDataEntry tmp(s);
+	CargoDataSet::iterator i = subentries->find(&tmp);
+	if (i == subentries->end()) {
+		IncrementSize();
+		return *(subentries->insert(new CargoDataEntry(s, c, this)).first);
+	} else {
+		CargoDataEntry * ret = *i;
+		assert(subentries->value_comp().GetSortType() != ST_COUNT);
+		ret->count += c;
+		return ret;
+	}
+}
+
+void CargoDataEntry::IncrementSize() {
+	 ++size;
+	 if (parent != NULL) parent->IncrementSize();
+}
+
+void CargoDataEntry::Resort(SortType type, SortOrder order) {
+	CargoDataSet * new_subs = new CargoDataSet(subentries->begin(), subentries->end(), CargoSorter(type, order));
+	delete subentries;
+	subentries = new_subs;
+}
+
+CargoDataEntry * CargoDataEntry::Retrieve(CargoDataSet::iterator i) const {
+	if (i == subentries->end()) {
+		return NULL;
+	} else {
+		assert(subentries->value_comp().GetSortType() != ST_COUNT);
+		return *i;
+	}
+}
+
+bool CargoSorter::operator()(const CargoDataEntry * cd1, const CargoDataEntry * cd2) const {
+	switch (type) {
+	case ST_STATION_ID:
+		return SortId<StationID>(cd1->GetStation(), cd2->GetStation());
+		break;
+	case ST_CARGO_ID:
+		return SortId<CargoID>(cd1->GetCargo(), cd2->GetCargo());
+		break;
+	case ST_COUNT:
+		return SortCount(cd1, cd2);
+		break;
+	case ST_STATION:
+		return SortStation(cd1->GetStation(), cd2->GetStation());
+		break;
+	}
+	NOT_REACHED();
+	return false;
+}
+
+template<class ID>
+bool CargoSorter::SortId(ID st1, ID st2) const {
+	if (order == SO_ASCENDING) {
+		return st1 < st2;
+	} else {
+		return st2 < st1;
+	}
+}
+
+bool CargoSorter::SortCount(const CargoDataEntry *cd1, const CargoDataEntry *cd2) const {
+	uint c1 = cd1->GetCount();
+	uint c2 = cd2->GetCount();
+	if (c1 == c2) {
+		return SortStation(cd1->GetStation(), cd2->GetStation());
+	} else if (order == SO_ASCENDING) {
+		return c1 < c2;
+	} else {
+		return c2 < c1;
+	}
+}
+
+bool CargoSorter::SortStation(StationID st1, StationID st2) const {
+	static char buf1[64];
+	static char buf2[64];
+
+	if (!Station::IsValidID(st1)) {
+		if (!Station::IsValidID(st2)) {
+			return SortId(st1, st2);
+		} else {
+			return order == SO_ASCENDING;
+		}
+	} else if (!Station::IsValidID(st2)) {
+		return order == SO_DESCENDING;
+	}
+
+	SetDParam(0, st1);
+	GetString(buf1, STR_STATION_NAME, lastof(buf1));
+	SetDParam(0, st2);
+	GetString(buf2, STR_STATION_NAME, lastof(buf2));
+
+	int res = strcmp(buf1, buf2);
+	if (res == 0) {
+		return SortId(st1, st2);
+	} else if (res < 0) {
+		return order == SO_ASCENDING;
+	} else {
+		return order == SO_DESCENDING;
+	}
+}
+
 /**
  * The StationView window
  */
 struct StationViewWindow : public Window {
-	uint32 cargo;                 ///< Bitmask of cargo types to expand
-	uint16 cargo_rows[NUM_CARGO]; ///< Header row for each cargo type
+	struct RowDisplay {
+		RowDisplay(CargoDataEntry * f, StationID n) : filter(f), next_station(n) {}
+		RowDisplay(CargoDataEntry * f, CargoID n) : filter(f), next_cargo(n) {}
+		CargoDataEntry * filter;
+		union {
+			StationID next_station;
+			CargoID next_cargo;
+		};
+	};
+	typedef std::vector<RowDisplay> CargoDataVector;
+	typedef std::map<StationID, uint> DestinationMap;
 
-	StationViewWindow(const WindowDesc *desc, WindowNumber window_number) : Window(desc, window_number)
+	static const int _spacing_side = 2;
+	static const int _spacing_symbol = 10;
+	static const int _spacing_column = 10;
+	static const int _spacing_row = 10;
+	static const int _spacing_icons = 4;
+	static const int _spacing_top = 30;
+	static const int _num_columns = 4;
+
+	enum Grouping {
+		SOURCE,
+		NEXT,
+		DESTINATION,
+		CARGO,
+	};
+
+	enum Sorting {
+		GROUPING = 0,
+		COUNT = 1
+	};
+
+	enum Mode {
+		WAITING,
+		PLANNED,
+		SENT
+	};
+
+	static const StringID _sort_names[];
+	static const StringID _group_names[];
+	static const StringID _mode_names[];
+
+	Sorting sortings[_num_columns];
+	SortOrder sort_orders[_num_columns];
+
+	int scroll_to_row;
+	int grouping_index;
+	Mode current_mode;
+	Grouping groupings[_num_columns];
+
+	CargoDataEntry expanded_rows;
+	CargoDataVector displayed_rows;
+
+	StationViewWindow(const WindowDesc *desc, WindowNumber window_number) :
+		Window(desc, window_number), scroll_to_row(INT_MAX), grouping_index(0), current_mode(WAITING)
 	{
+		this->groupings[0] = CARGO;
+		this->sortings[0] = GROUPING;
+		SelectGroupBy(_settings_client.gui.station_gui_group_order);
+		SelectSortBy((Sorting)_settings_client.gui.station_gui_sort_by);
+		sort_orders[0] = SO_ASCENDING;
+		SelectSortOrder((SortOrder)_settings_client.gui.station_gui_sort_order);
+		SelectMode(WAITING);
 		Owner owner = Station::Get(window_number)->owner;
 		if (owner != OWNER_NONE) this->owner = owner;
-		this->vscroll.cap = 5;
+		this->vscroll.cap = 4;
 		this->resize.step_height = 10;
-
 		this->FindWindowPlacementAndResize(desc);
 	}
 
@@ -799,54 +1009,284 @@
 		DeleteWindowById(WC_AIRCRAFT_LIST, wno | (VEH_AIRCRAFT << 11), false);
 	}
 
-	virtual void OnPaint()
-	{
-		StationID station_id = this->window_number;
-		const Station *st = Station::Get(station_id);
-		CargoDataList cargolist;
-		uint32 transfers = 0;
+	void ShowCargo(CargoDataEntry * data, CargoID cargo, StationID source, StationID next, StationID dest, uint count) {
+		const CargoDataEntry * expand = &expanded_rows;
+		for (int i = 0; i < _num_columns && expand != NULL; ++i) {
+			switch (groupings[i]) {
+			case CARGO:
+				assert(i == 0);
+				data = data->Update(cargo, count);
+				expand = expand->Retrieve(cargo);
+				break;
+			case SOURCE:
+				data = data->Update(source, count);
+				expand = expand->Retrieve(source);
+				break;
+			case NEXT:
+				data = data->Update(next, count);
+				expand = expand->Retrieve(next);
+				break;
+			case DESTINATION:
+				data = data->Update(dest, count);
+				expand = expand->Retrieve(dest);
+				break;
+			}
+		}
+	}
 
-		/* count types of cargos waiting in station */
+	void EstimateDestinations(CargoID cargo, StationID source, StationID next, uint count, DestinationMap & dest, bool sent) {
+		if (Station::IsValidID(next) && Station::IsValidID(source)) {
+			DestinationMap tmp;
+			uint sum_flows = 0;
+			FlowStatMap & flowmap = Station::Get(next)->goods[cargo].flows;
+			FlowStatMap::iterator map_it = flowmap.find(source);
+			if (map_it != flowmap.end()) {
+				FlowStatSet & flows = map_it->second;
+				for (FlowStatSet::iterator i = flows.begin(); i != flows.end(); ++i) {
+					uint flow = 0;
+					if (sent) {
+						flow =  i->sent;
+					} else {
+						flow =  i->planned;
+					}
+					sum_flows += flow;
+					tmp[i->via] = flow;
+				}
+			}
+
+			if (sum_flows == 0) {
+				dest[INVALID_STATION] += count;
+			} else {
+				uint sum_estimated = 0;
+				while(sum_estimated < count) {
+					for(DestinationMap::iterator i = tmp.begin(); i != tmp.end() && sum_estimated < count; ++i) {
+						uint estimate = DivideApprox(i->second * count, sum_flows);
+						sum_estimated += estimate;
+						if (sum_estimated > count) {
+							estimate -= sum_estimated - count;
+							sum_estimated = count;
+						}
+
+						if (estimate > 0) {
+							if (i->first == next) {
+								dest[next] += estimate;
+							} else {
+								EstimateDestinations(cargo, source, i->first, estimate, dest, sent);
+							}
+						}
+					}
+					if (sum_flows > 1) {
+						sum_flows--;
+					}
+				}
+			}
+		} else {
+			dest[INVALID_STATION] += count;
+		}
+	}
+
+	void BuildFlowList(CargoID i, const FlowStatMap & flows, CargoDataEntry * cargo) {
+		uint scale = _settings_game.economy.moving_average_length * _settings_game.economy.moving_average_unit;
+		for (FlowStatMap::const_iterator it = flows.begin(); it != flows.end(); ++it) {
+			StationID from = it->first;
+			const FlowStatSet & flow_set = it->second;
+			for (FlowStatSet::const_iterator flow_it = flow_set.begin(); flow_it != flow_set.end(); ++flow_it) {
+				const FlowStat & stat = *flow_it;
+				uint val = 0;
+				DestinationMap dest;
+				if (this->current_mode == PLANNED) {
+					val = DivideApprox(stat.planned * 30, scale);
+				} else {
+					val = DivideApprox(stat.sent * 30, scale);
+				}
+
+				if (stat.via == this->window_number) {
+					dest[this->window_number] = val;
+				} else {
+					EstimateDestinations(i, from, stat.via, val, dest, this->current_mode == SENT);
+				}
+
+				for (DestinationMap::iterator dest_it = dest.begin(); dest_it != dest.end(); ++dest_it) {
+					if (dest_it->second > 0) {
+						ShowCargo(cargo, i, from, stat.via, dest_it->first, dest_it->second);
+					}
+				}
+			}
+		}
+	}
+
+	void BuildCargoList(CargoID i, const CargoList & packets, CargoDataEntry * cargo) {
+		for (CargoList::List::const_iterator it = packets.Packets()->begin(); it != packets.Packets()->end(); it++) {
+			const CargoPacket *cp = *it;
+			DestinationMap dest;
+			EstimateDestinations(i, cp->source, cp->next, cp->count, dest, false);
+			for (DestinationMap::iterator dest_it = dest.begin(); dest_it != dest.end(); ++dest_it) {
+				if (dest_it->second > 0) {
+					ShowCargo(cargo, i, cp->source, cp->next, dest_it->first, dest_it->second);
+				}
+			}
+		}
+	}
+
+	void BuildCargoList(CargoDataEntry * cargo, const Station * st) {
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
-			if (st->goods[i].cargo.Empty()) {
-				this->cargo_rows[i] = 0;
+			if (this->current_mode == WAITING) {
+				BuildCargoList(i, st->goods[i].cargo, cargo);
 			} else {
-				/* Add an entry for total amount of cargo of this type waiting. */
-				cargolist.push_back(CargoData(i, INVALID_STATION, st->goods[i].cargo.Count()));
+				BuildFlowList(i, st->goods[i].flows, cargo);
+			}
+		}
+	}
 
-				/* Set the row for this cargo entry for the expand/hide button */
-				this->cargo_rows[i] = (uint16)cargolist.size();
+	void SetDisplayedRow(const CargoDataEntry * data) {
+		std::list<StationID> stations;
+		const CargoDataEntry * parent = data->GetParent();
+		if (parent->GetParent() == NULL) {
+			displayed_rows.push_back(RowDisplay(&expanded_rows, data->GetCargo()));
+			return;
+		}
 
-				/* Add an entry for each distinct cargo source. */
-				const CargoList::List *packets = st->goods[i].cargo.Packets();
-				for (CargoList::List::const_iterator it = packets->begin(); it != packets->end(); it++) {
-					const CargoPacket *cp = *it;
-					if (cp->source != station_id) {
-						bool added = false;
+		StationID next = data->GetStation();
+		while(parent->GetParent()->GetParent() != NULL) {
+			stations.push_back(parent->GetStation());
+			parent = parent->GetParent();
+		}
 
-						/* Enable the expand/hide button for this cargo type */
-						SetBit(transfers, i);
+		CargoID cargo = parent->GetCargo();
+		CargoDataEntry * filter = expanded_rows.Retrieve(cargo);
+		while(!stations.empty()) {
+			filter = filter->Retrieve(stations.back());
+			stations.pop_back();
+		}
 
-						/* Don't add cargo lines if not expanded */
-						if (!HasBit(this->cargo, i)) break;
+		displayed_rows.push_back(RowDisplay(filter, next));
+	}
 
-						/* Check if we already have this source in the list */
-						for (CargoDataList::iterator jt = cargolist.begin(); jt != cargolist.end(); jt++) {
-							CargoData *cd = &(*jt);
-							if (cd->cargo == i && cd->source == cp->source) {
-								cd->count += cp->count;
-								added = true;
-								break;
-							}
+	StringID GetEntryString(StationID station, StringID here, StringID other_station, StringID any) {
+		if (station == this->window_number) {
+			return here;
+		} else if (station != INVALID_STATION) {
+			SetDParam(2, station);
+			return other_station;
+		} else {
+			return any;
+		}
+	}
+
+	StringID SearchNonStop(CargoDataEntry * cd, StationID station, int column) {
+		CargoDataEntry * parent = cd->GetParent();
+		for (int i = column - 1; i > 0; --i) {
+			if (groupings[i] == DESTINATION) {
+				if (parent->GetStation() == station) {
+					return STR_NONSTOP;
+				} else {
+					return STR_STATION_VIA;
+				}
+			}
+			parent = parent->GetParent();
+		}
+
+		if (groupings[column + 1] == DESTINATION) {
+			CargoDataSet::iterator begin = cd->Begin();
+			CargoDataSet::iterator end = cd->End();
+			if (begin != end && ++(cd->Begin()) == end && (*(begin))->GetStation() == station) {
+				return STR_NONSTOP;
+			} else {
+				return STR_STATION_VIA;
+			}
+		}
+
+		return STR_STATION_VIA;
+	}
+
+	int DrawEntries(CargoDataEntry * entry, int pos, int maxrows, int column, CargoID cargo = CT_INVALID) {
+		if (sortings[column] == GROUPING) {
+			if (groupings[column] != CARGO) {
+				entry->Resort(ST_STATION, sort_orders[column]);
+			}
+		} else {
+			entry->Resort(ST_COUNT, sort_orders[column]);
+		}
+		for (CargoDataSet::iterator i = entry->Begin(); i != entry->End(); ++i) {
+			CargoDataEntry *cd = *i;
+
+			if (groupings[column] == CARGO) {
+				cargo = cd->GetCargo();
+			}
+
+			if (pos > -maxrows && --pos < 0) {
+				StringID str = STR_EMPTY;
+
+				SetDParam(0, cargo);
+				SetDParam(1, cd->GetCount());
+
+				if (groupings[column] == CARGO) {
+					str = STR_STATION_VIEW_WAITING_CARGO;
+					DrawCargoIcons(
+							cd->GetCargo(),
+							cd->GetCount(),
+							_spacing_side + column * _spacing_column,
+							_spacing_top - pos * _spacing_row,
+							this->widget[SVW_WAITING].right - this->widget[SVW_WAITING].left - _spacing_icons
+					);
+				} else {
+					StationID station = cd->GetStation();
+
+					switch(groupings[column]) {
+					case SOURCE:
+						str = GetEntryString(station, STR_STATION_FROM_HERE, STR_STATION_FROM, STR_STATION_FROM_ANY);
+						break;
+					case NEXT:
+						str = GetEntryString(station, STR_STATION_VIA_HERE, STR_STATION_VIA, STR_STATION_VIA_ANY);
+						if (str == STR_STATION_VIA) {
+							str = SearchNonStop(cd, station, column);
 						}
-
-						if (!added) cargolist.push_back(CargoData(i, cp->source, cp->count));
+						break;
+					case DESTINATION:
+						str = GetEntryString(station, STR_STATION_TO_HERE, STR_STATION_TO, STR_STATION_TO_ANY);
+						break;
+					default:
+						NOT_REACHED();
 					}
+					if (pos == -scroll_to_row - 1 && Station::IsValidID(station)) {
+						ScrollMainWindowToTile(Station::Get(station)->xy);
+					}
 				}
+				DrawString(
+						this->widget[SVW_WAITING].left + _spacing_side + column * _spacing_column,
+						this->widget[SVW_WAITING].right - _spacing_side - _spacing_symbol,
+						_spacing_top - pos * _spacing_row,
+						str,
+						TC_FROMSTRING
+				);
+
+				if (column < _num_columns - 1) {
+					const char *sym = cd->Size() > 0 ? "-" : "+";
+					DrawString(
+							this->widget[SVW_WAITING].right - _spacing_symbol,
+							this->widget[SVW_WAITING].right,
+							_spacing_top - pos * _spacing_row,
+							sym,
+							TC_YELLOW
+					);
+				}
+				SetDisplayedRow(cd);
 			}
+			pos = DrawEntries(cd, pos, maxrows, column + 1, cargo);
+
 		}
-		SetVScrollCount(this, (int)cargolist.size() + 1); // update scrollbar
+		return pos;
+	}
 
+	virtual void OnPaint()
+	{
+		StationID station_id = this->window_number;
+		const Station *st = Station::Get(station_id);
+		CargoDataEntry cargo;
+		BuildCargoList(&cargo, st);
+
+		SetVScrollCount(this, cargo.Size()); // update scrollbar
+
 		/* disable some buttons */
 		this->SetWidgetDisabledState(SVW_RENAME,   st->owner != _local_company);
 		this->SetWidgetDisabledState(SVW_TRAINS,   !(st->facilities & FACIL_TRAIN));
@@ -858,53 +1298,19 @@
 		SetDParam(1, st->facilities);
 		this->DrawWidgets();
 
-		int x = 2;  ///< coordinates used for printing waiting/accepted/rating of cargo
-		int y = 15;
+		/* draw arrow pointing up/down for ascending/descending sorting */
+		this->DrawSortButtonState(SVW_SORT_ORDER, sort_orders[1] == SO_ASCENDING ? SBS_UP : SBS_DOWN);
+
 		int pos = this->vscroll.pos; ///< = this->vscroll.pos
 
-		uint width = this->widget[SVW_WAITING].right - this->widget[SVW_WAITING].left - 4;
 		int maxrows = this->vscroll.cap;
 
-		StringID str;
+		displayed_rows.clear();
 
-		if (--pos < 0) {
-			str = STR_JUST_NOTHING;
-			for (CargoID i = 0; i < NUM_CARGO; i++) {
-				if (!st->goods[i].cargo.Empty()) str = STR_EMPTY;
-			}
-			SetDParam(0, str);
-			DrawString(x, this->widget[SVW_WAITING].right - 2, y, STR_STATION_VIEW_WAITING_TITLE);
-			y += 10;
-		}
+		DrawEntries(&cargo, pos, maxrows, 0);
+		scroll_to_row = INT_MAX;
 
-		for (CargoDataList::const_iterator it = cargolist.begin(); it != cargolist.end() && pos > -maxrows; ++it) {
-			if (--pos < 0) {
-				const CargoData *cd = &(*it);
-				if (cd->source == INVALID_STATION) {
-					/* Heading */
-					DrawCargoIcons(cd->cargo, cd->count, x, y, width);
-					SetDParam(0, cd->cargo);
-					SetDParam(1, cd->count);
-					if (HasBit(transfers, cd->cargo)) {
-						/* This cargo has transfers waiting so show the expand or shrink 'button' */
-						const char *sym = HasBit(this->cargo, cd->cargo) ? "-" : "+";
-						DrawString(this->widget[SVW_WAITING].left, this->widget[SVW_WAITING].right - 12, y, STR_STATION_VIEW_WAITING_CARGO, TC_FROMSTRING, SA_RIGHT);
-						DrawString(this->widget[SVW_WAITING].right - 10, this->widget[SVW_WAITING].right, y, sym, TC_YELLOW);
-					} else {
-						DrawString(this->widget[SVW_WAITING].left, this->widget[SVW_WAITING].right - 4, y, STR_STATION_VIEW_WAITING_CARGO, TC_FROMSTRING, SA_RIGHT);
-					}
-				} else {
-					SetDParam(0, cd->cargo);
-					SetDParam(1, cd->count);
-					SetDParam(2, cd->source);
-					DrawString(x, x + width, y, STR_STATION_VIEW_EN_ROUTE_FROM, TC_FROMSTRING, SA_RIGHT);
-				}
-
-				y += 10;
-			}
-		}
-
-		if (this->widget[SVW_ACCEPTS].data == STR_STATION_VIEW_RATINGS_BUTTON) { // small window with list of accepted cargo
+		if (this->widget[SVW_ACCEPTS].data == STR_STATION_VIEW_ACCEPTS_BUTTON) { // small window with list of accepted cargo
 			char string[512];
 			char *b = string;
 			bool first = true;
@@ -936,7 +1342,7 @@
 			SetDParamStr(0, string);
 			DrawStringMultiLine(this->widget[SVW_ACCEPTLIST].left + 2, this->widget[SVW_ACCEPTLIST].right - 2, this->widget[SVW_ACCEPTLIST].top + 1, this->widget[SVW_ACCEPTLIST].bottom - 1, STR_JUST_RAW_STRING);
 		} else { // extended window with list of cargo ratings
-			y = this->widget[SVW_RATINGLIST].top + 1;
+			int y = this->widget[SVW_RATINGLIST].top + 1;
 
 			DrawString(this->widget[SVW_ACCEPTLIST].left + 2, this->widget[SVW_ACCEPTLIST].right - 2, y, STR_STATION_VIEW_CARGO_RATINGS_TITLE);
 			y += 10;
@@ -955,24 +1361,36 @@
 		}
 	}
 
+	template<class ID>
+	void HandleCargoWaitingClick(CargoDataEntry * filter, ID next) {
+		if (filter->Retrieve(next) != NULL) {
+			filter->Remove(next);
+		} else {
+			filter->Update(next);
+		}
+	}
+
 	void HandleCargoWaitingClick(int row)
 	{
-		if (row == 0) return;
-
-		for (CargoID c = 0; c < NUM_CARGO; c++) {
-			if (this->cargo_rows[c] == row) {
-				ToggleBit(this->cargo, c);
-				this->InvalidateWidget(SVW_WAITING);
-				break;
+		if (row < 0 || (uint)row >= displayed_rows.size()) return;
+		if (_ctrl_pressed) {
+			scroll_to_row = row;
+		} else {
+			RowDisplay & display = displayed_rows[row];
+			if (display.filter == &expanded_rows) {
+				HandleCargoWaitingClick<CargoID>(display.filter, display.next_cargo);
+			} else {
+				HandleCargoWaitingClick<StationID>(display.filter, display.next_station);
 			}
 		}
+		this->InvalidateWidget(SVW_WAITING);
 	}
 
 	virtual void OnClick(Point pt, int widget)
 	{
 		switch (widget) {
 			case SVW_WAITING:
-				this->HandleCargoWaitingClick((pt.y - this->widget[SVW_WAITING].top) / 10 + this->vscroll.pos);
+				this->HandleCargoWaitingClick((pt.y - this->widget[SVW_WAITING].top) / 10);
 				break;
 
 			case SVW_LOCATION:
@@ -990,12 +1408,12 @@
 					/* Switch to ratings view */
 					this->widget[SVW_RATINGS].data = STR_STATION_VIEW_ACCEPTS_BUTTON;
 					this->widget[SVW_RATINGS].tooltips = STR_STATION_VIEW_ACCEPTS_TOOLTIP;
-					ResizeWindowForWidget(this, SVW_ACCEPTLIST, 0, 100);
+					ResizeWindowForWidget(this, SVW_ACCEPTLIST, 0, -100);
 				} else {
 					/* Switch to accepts view */
 					this->widget[SVW_RATINGS].data = STR_STATION_VIEW_RATINGS_BUTTON;
 					this->widget[SVW_RATINGS].tooltips = STR_STATION_VIEW_RATINGS_TOOLTIP;
-					ResizeWindowForWidget(this, SVW_ACCEPTLIST, 0, -100);
+					ResizeWindowForWidget(this, SVW_ACCEPTLIST, 0, 100);
 				}
 
 				this->SetDirty();
@@ -1033,9 +1451,103 @@
 				ShowVehicleListWindow(owner, VEH_SHIP, (StationID)this->window_number);
 				break;
 			}
+
+			case SVW_MODE: {
+				ShowDropDownMenu(this, _mode_names, this->current_mode, SVW_MODE, 0, 0);
+				break;
+			}
+
+			case SVW_SORT_BY: {
+				Sorting sorting = (sortings[1] == GROUPING ? COUNT : GROUPING);
+				SelectSortBy(sorting);
+				this->flags4 |= WF_TIMEOUT_BEGIN;
+				this->LowerWidget(SVW_SORT_BY);
+				break;
+			}
+
+			case SVW_GROUP_BY: {
+				ShowDropDownMenu(this, _group_names, this->grouping_index, SVW_GROUP_BY, 0, 0);
+				break;
+			}
+
+			case SVW_SORT_ORDER: { // flip sorting method asc/desc
+				SortOrder order = (sort_orders[1] == SO_ASCENDING ? SO_DESCENDING : SO_ASCENDING);
+				SelectSortOrder(order);
+				this->flags4 |= WF_TIMEOUT_BEGIN;
+				this->LowerWidget(SVW_SORT_ORDER);
+				break;
+			}
 		}
 	}
 
+	void SelectSortBy(Sorting sorting) {
+		_settings_client.gui.station_gui_sort_by = sorting;
+		sortings[1] = sortings[2] = sortings[3] = sorting;
+		/* Display the current sort variant */
+		this->widget[SVW_SORT_BY].data = this->_sort_names[sorting];
+		this->SetDirty();
+	}
+
+	void SelectSortOrder(SortOrder order) {
+		sort_orders[1] = sort_orders[2] = sort_orders[3] = order;
+		_settings_client.gui.station_gui_sort_order = sort_orders[1];
+		this->SetDirty();
+	}
+
+	void SelectMode(int index) {
+		this->current_mode = (Mode)index;
+		this->widget[SVW_MODE].data = _mode_names[index];
+		this->SetDirty();
+	}
+
+	void SelectGroupBy(int index) {
+		this->grouping_index = index;
+		_settings_client.gui.station_gui_group_order = index;
+		this->widget[SVW_GROUP_BY].data = _group_names[index];
+		switch(_group_names[index]) {
+		case STR_GROUP_S_V_D:
+			groupings[1] = SOURCE;
+			groupings[2] = NEXT;
+			groupings[3] = DESTINATION;
+			break;
+		case STR_GROUP_S_D_V:
+			groupings[1] = SOURCE;
+			groupings[2] = DESTINATION;
+			groupings[3] = NEXT;
+			break;
+		case STR_GROUP_V_S_D:
+			groupings[1] = NEXT;
+			groupings[2] = SOURCE;
+			groupings[3] = DESTINATION;
+			break;
+		case STR_GROUP_V_D_S:
+			groupings[1] = NEXT;
+			groupings[2] = DESTINATION;
+			groupings[3] = SOURCE;
+			break;
+		case STR_GROUP_D_S_V:
+			groupings[1] = DESTINATION;
+			groupings[2] = SOURCE;
+			groupings[3] = NEXT;
+			break;
+		case STR_GROUP_D_V_S:
+			groupings[1] = DESTINATION;
+			groupings[2] = NEXT;
+			groupings[3] = SOURCE;
+			break;
+		}
+		this->SetDirty();
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		if (widget == SVW_MODE) {
+			SelectMode(index);
+		} else {
+			SelectGroupBy(index);
+		}
+	}
+
 	virtual void OnQueryTextFinished(char *str)
 	{
 		if (str == NULL) return;
@@ -1051,8 +1563,31 @@
 };
 
 
+const StringID StationViewWindow::_sort_names[] = {
+	STR_SORT_BY_STATION,
+	STR_SORT_BY_AMOUNT,
+	INVALID_STRING_ID
+};
+
+const StringID StationViewWindow::_mode_names[] = {
+	STR_STATION_VIEW_WAITING,
+	STR_STATION_VIEW_PLANNED,
+	STR_STATION_VIEW_SENT,
+	INVALID_STRING_ID
+};
+
+const StringID StationViewWindow::_group_names[] = {
+	STR_GROUP_S_V_D,
+	STR_GROUP_S_D_V,
+	STR_GROUP_V_S_D,
+	STR_GROUP_V_D_S,
+	STR_GROUP_D_S_V,
+	STR_GROUP_D_V_S,
+	INVALID_STRING_ID
+};
+
 static const WindowDesc _station_view_desc(
-	WDP_AUTO, WDP_AUTO, 249, 110, 249, 110,
+	WDP_AUTO, WDP_AUTO, 249, 117, 249, 117,
 	WC_STATION_VIEW, WC_NONE,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON | WDF_RESIZABLE,
 	_station_view_widgets, _nested_station_view_widgets, lengthof(_nested_station_view_widgets)
Index: src/station_gui.h
===================================================================
--- src/station_gui.h	(revision 17081)
+++ src/station_gui.h	(working copy)
@@ -7,21 +7,26 @@
 
 #include "command_type.h"
 #include "station_type.h"
+#include <set>
 
 /** Enum for StationView, referring to _station_view_widgets and _station_view_expanded_widgets */
 enum StationViewWidgets {
 	SVW_CLOSEBOX   =  0, ///< Close 'X' button
 	SVW_CAPTION    =  1, ///< Caption of the window
 	SVW_STICKYBOX  =  2, ///< Sticky button
-	SVW_WAITING    =  3, ///< List of waiting cargo
-	SVW_SCROLLBAR  =  4, ///< Scrollbar
-	SVW_ACCEPTLIST =  5, ///< List of accepted cargos
-	SVW_RATINGLIST =  5, ///< Ratings of cargos
-	SVW_LOCATION   =  6, ///< 'Location' button
-	SVW_RATINGS    =  7, ///< 'Ratings' button
-	SVW_ACCEPTS    =  7, ///< 'Accepts' button
-	SVW_RENAME     =  8, ///< 'Rename' button
-	SVW_TRAINS     =  9, ///< List of scheduled trains button
+	SVW_SORT_ORDER =  3, ///< 'Sort order' button
+	SVW_SORT_BY    =  4, ///< 'Sort by' button
+	SVW_MODE       =  5, ///< button for toggling planned and real flows
+	SVW_GROUP_BY   =  6, ///< 'Group by' button
+	SVW_WAITING    =  7, ///< List of waiting cargo
+	SVW_SCROLLBAR  =  8, ///< Scrollbar
+	SVW_ACCEPTLIST =  9, ///< List of accepted cargos
+	SVW_RATINGLIST =  9, ///< Ratings of cargos
+	SVW_LOCATION   = 10, ///< 'Location' button
+	SVW_RATINGS    = 11, ///< 'Ratings' button
+	SVW_ACCEPTS    = 11, ///< 'Accepts' button
+	SVW_RENAME     = 12, ///< 'Rename' button
+	SVW_TRAINS     = 13, ///< List of scheduled trains button
 	SVW_ROADVEHS,        ///< List of scheduled road vehs button
 	SVW_PLANES,          ///< List of scheduled planes button
 	SVW_SHIPS,           ///< List of scheduled ships button
@@ -40,4 +45,81 @@
 void ShowSelectStationIfNeeded(CommandContainer cmd, TileArea ta);
 void ShowSelectWaypointIfNeeded(CommandContainer cmd, TileArea ta);
 
+enum SortOrder {
+	SO_DESCENDING,
+	SO_ASCENDING
+};
+
+enum SortType {
+	ST_STATION,
+	ST_STATION_ID,
+	ST_CARGO_ID,
+	ST_COUNT,
+};
+
+class CargoDataEntry;
+
+class CargoSorter {
+public:
+	CargoSorter(SortType t = ST_STATION_ID, SortOrder o = SO_ASCENDING) : type(t), order(o) {}
+	SortType GetSortType() {return type;}
+	bool operator()(const CargoDataEntry * cd1, const CargoDataEntry * cd2) const;
+
+private:
+	SortType type;
+	SortOrder order;
+
+	template<class ID>
+	bool SortId(ID st1, ID st2) const;
+	bool SortCount(const CargoDataEntry *cd1, const CargoDataEntry *cd2) const;
+	bool SortStation (StationID st1, StationID st2) const;
+};
+
+typedef std::set<CargoDataEntry *, CargoSorter> CargoDataSet;
+
+class CargoDataEntry {
+public:
+	CargoDataEntry();
+	~CargoDataEntry();
+
+	CargoDataEntry * Update(StationID s, uint c = 0) {return Update<StationID>(s, c);}
+	CargoDataEntry * Update(CargoID car, uint c = 0) {return Update<CargoID>(car, c);}
+
+	void Remove(StationID s) {CargoDataEntry t(s); subentries->erase(&t);}
+	void Remove(CargoID c) {CargoDataEntry t(c); subentries->erase(&t);}
+
+	CargoDataEntry * Retrieve(StationID s) const {CargoDataEntry t(s); return Retrieve(subentries->find(&t));}
+	CargoDataEntry * Retrieve(CargoID c) const {CargoDataEntry t(c);return Retrieve(subentries->find(&t));}
+
+	void Resort(SortType type, SortOrder order);
+
+	StationID GetStation() const {return station;}
+	CargoID GetCargo() const {return cargo;}
+	uint GetCount() const {return count;}
+	CargoDataEntry * GetParent() const {return parent;}
+	uint Size() const {return size;}
+
+	CargoDataSet::iterator Begin() const {return subentries->begin();}
+	CargoDataSet::iterator End() const {return subentries->end();}
+
+private:
+
+	CargoDataEntry(StationID st, uint c, CargoDataEntry * p);
+	CargoDataEntry(CargoID car, uint c, CargoDataEntry * p);
+	CargoDataEntry(StationID s);
+	CargoDataEntry(CargoID c);
+	CargoDataEntry * Retrieve(CargoDataSet::iterator i) const;
+	template<class ID>
+	CargoDataEntry * Update(ID s, uint c);
+	void IncrementSize();
+	CargoDataEntry * parent;
+	const union {
+		StationID station;
+		CargoID cargo;
+	};
+	uint size;
+	uint count;
+	CargoDataSet * subentries;
+};
+
 #endif /* STATION_GUI_H */
Index: src/table/settings.h
===================================================================
--- src/table/settings.h	(revision 17081)
+++ src/table/settings.h	(working copy)
@@ -438,7 +438,20 @@
 	     SDT_VAR(GameSettings, pf.wait_oneway_signal,                SLE_UINT8,                     0, 0,    15,     2,     255, 0, STR_NULL,                                  NULL),
 	     SDT_VAR(GameSettings, pf.wait_twoway_signal,                SLE_UINT8,                     0, 0,    41,     2,     255, 0, STR_NULL,                                  NULL),
 	SDT_CONDLISTO(GameSettings, economy.town_noise_population, 3,   SLE_UINT16, 96, SL_MAX_VERSION, 0,D0, "800,2000,4000",          STR_NULL,                                  NULL, CheckNoiseToleranceLevel),
+	 SDT_CONDVAR(GameSettings, economy.moving_average_unit,         SLE_UINT16, CAPACITIES_SV, SL_MAX_VERSION, 0, 0, 1, 1, 4096, 1,	STR_CONFIG_SETTING_AVERAGE_UNIT,           NULL),
+	 SDT_CONDVAR(GameSettings, economy.moving_average_length,       SLE_UINT16, CAPACITIES_SV, SL_MAX_VERSION, 0, 0, 128, 1, 4096, 4, STR_CONFIG_SETTING_AVERAGE_LENGTH,       NULL),
 
+	 SDT_CONDVAR(GameSettings, linkgraph.recalc_interval,           SLE_UINT16, LINKGRAPH_SV, SL_MAX_VERSION,  0, 0,16, 1, 4096, 1, STR_CONFIG_SETTING_LINKGRAPH_INTERVAL,     NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_pax,                 SLE_UINT8,DEMANDS_SV, SL_MAX_VERSION,0,MS,DT_SYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DEMAND_PAX, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_mail,                SLE_UINT8,DEMANDS_SV,SL_MAX_VERSION,0,MS,DT_SYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DEMAND_MAIL, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_express,      SLE_UINT8,DEMANDS_SV,SL_MAX_VERSION,0,MS,DT_ANTISYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DEMAND_EXPRESS, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_armoured,        SLE_UINT8,DEMANDS_SV,SL_MAX_VERSION,0,MS,DT_SYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DEMAND_ARMOURED, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_default,      SLE_UINT8,DEMANDS_SV,SL_MAX_VERSION,0,MS,DT_ANTISYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DEMAND_DEFAULT, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.accuracy,                   SLE_UINT8,DEMANDS_SV, SL_MAX_VERSION, 0, 0,16,  2,     255, 1, STR_CONFIG_SETTING_LINKGRAPH_ACCURACY,     NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_distance,            SLE_UINT8,DEMANDS_SV, SL_MAX_VERSION, 0, 0,100, 0,     100, 5, STR_CONFIG_SETTING_DEMAND_DISTANCE,        NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_size,                SLE_UINT8,DEMANDS_SV, SL_MAX_VERSION, 0, 0,100, 0,     100, 5, STR_CONFIG_SETTING_DEMAND_SIZE,            NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.short_path_saturation,      SLE_UINT8,  MCF_SV, SL_MAX_VERSION, 0, 0,80,    0,     100, 5, STR_CONFIG_SETTING_SHORT_PATH_SATURATION,  NULL),
+
 	 SDT_CONDVAR(GameSettings, pf.wait_for_pbs_path,                 SLE_UINT8,100, SL_MAX_VERSION, 0, 0,    30,     2,     255, 0, STR_NULL,                                  NULL),
 	SDT_CONDBOOL(GameSettings, pf.reserve_paths,                               100, SL_MAX_VERSION, 0, 0, false,                    STR_NULL,                                  NULL),
 	 SDT_CONDVAR(GameSettings, pf.path_backoff_interval,             SLE_UINT8,100, SL_MAX_VERSION, 0, 0,    20,     1,     255, 0, STR_NULL,                                  NULL),
@@ -567,6 +580,9 @@
 
 	  SDTC_VAR(gui.console_backlog_timeout,  SLE_UINT16, S,  0,   100,       10,    65500, 0, STR_NULL,                                       NULL),
 	  SDTC_VAR(gui.console_backlog_length,   SLE_UINT16, S,  0,   100,       10,    65500, 0, STR_NULL,                                       NULL),
+	  SDTC_VAR(gui.station_gui_group_order,   SLE_UINT8, S,  0,     0,        0,        5, 1, STR_NULL,                                       NULL),
+	  SDTC_VAR(gui.station_gui_sort_by,       SLE_UINT8, S,  0,     0,        0,        1, 1, STR_NULL,                                       NULL),
+	  SDTC_VAR(gui.station_gui_sort_order,    SLE_UINT8, S,  0,     0,        0,        1, 1, STR_NULL,                                       NULL),
 #ifdef ENABLE_NETWORK
 	  SDTC_VAR(gui.network_chat_box_width,   SLE_UINT16, S,  0,   700,      200,    65535, 0, STR_NULL,                                       NULL),
 	  SDTC_VAR(gui.network_chat_box_height,   SLE_UINT8, S,  0,    25,        5,      255, 0, STR_NULL,                                       NULL),
Index: src/train_cmd.cpp
===================================================================
--- src/train_cmd.cpp	(revision 17081)
+++ src/train_cmd.cpp	(working copy)
@@ -3396,6 +3396,7 @@
 
 static void TrainEnterStation(Train *v, StationID station)
 {
+	StationID previous_station = v->last_station_visited;
 	v->last_station_visited = station;
 
 	/* check if a train ever visited this station before */
@@ -3412,7 +3413,7 @@
 		AI::NewEvent(v->owner, new AIEventStationFirstVehicle(st->index, v->index));
 	}
 
-	v->BeginLoading();
+	v->BeginLoading(previous_station);
 
 	StationAnimationTrigger(st, v->tile, STAT_ANIM_TRAIN_ARRIVES);
 }
Index: src/vehicle.cpp
===================================================================
--- src/vehicle.cpp	(revision 17081)
+++ src/vehicle.cpp	(working copy)
@@ -1393,7 +1393,7 @@
 }
 
 
-void Vehicle::BeginLoading()
+void Vehicle::BeginLoading(StationID last_station_id)
 {
 	assert(IsTileType(tile, MP_STATION) || type == VEH_SHIP);
 
@@ -1413,10 +1413,26 @@
 		current_order.MakeLoading(false);
 	}
 
-	Station::Get(this->last_station_visited)->loading_vehicles.push_back(this);
+	StationID curr_station_id = this->last_station_visited;
+	Station * curr_station = Station::Get(curr_station_id);
+	curr_station->loading_vehicles.push_back(this);
 
-	PrepareUnload(this);
+	StationID next_station_id = INVALID_STATION;
+	OrderList * orders = this->orders.list;
+	if (orders != NULL) {
+		next_station_id = orders->GetNextStoppingStation(this->cur_order_index, this->type == VEH_ROAD || this->type == VEH_TRAIN);
+	}
 
+	if (last_station_id != INVALID_STATION && last_station_id != curr_station_id) {
+		IncreaseStats(Station::Get(last_station_id), this, curr_station_id);
+	}
+
+	if (next_station_id != INVALID_STATION && next_station_id != curr_station_id) {
+		IncreaseFrozen(curr_station, this, next_station_id);
+	}
+
+	PrepareUnload(curr_station, this, next_station_id);
+
 	InvalidateWindow(GetWindowClassForVehicleType(this->type), this->owner);
 	InvalidateWindowWidget(WC_VEHICLE_VIEW, this->index, VVW_WIDGET_START_STOP_VEH);
 	InvalidateWindow(WC_VEHICLE_DETAILS, this->index);
@@ -1440,6 +1456,16 @@
 	Station *st = Station::Get(this->last_station_visited);
 	st->loading_vehicles.remove(this);
 
+	OrderList * orders = this->orders.list;
+	if (orders != NULL) {
+		StationID next_station_id = orders->GetNextStoppingStation(this->cur_order_index, this->type == VEH_ROAD || this->type == VEH_TRAIN);
+		if (next_station_id != INVALID_STATION && next_station_id != this->last_station_visited) {
+			DecreaseFrozen(st, this, next_station_id);
+		}
+	} else {
+		RecalcFrozen(st);
+	}
+
 	HideFillingPercent(&this->fill_percent_te_id);
 
 	if (this->type == VEH_TRAIN && !(this->vehstatus & VS_CRASHED)) {
Index: src/vehicle_base.h
===================================================================
--- src/vehicle_base.h	(revision 17081)
+++ src/vehicle_base.h	(working copy)
@@ -191,7 +191,7 @@
 	/** We want to 'destruct' the right class. */
 	virtual ~Vehicle();
 
-	void BeginLoading();
+	void BeginLoading(StationID last_station_id);
 	void LeaveStation();
 
 	/**
Index: src/viewport.cpp
===================================================================
--- src/viewport.cpp	(revision 17081)
+++ src/viewport.cpp	(working copy)
@@ -454,10 +454,10 @@
  * @param widget_zoom_out widget index for window with zoom-out button */
 void HandleZoomMessage(Window *w, const ViewPort *vp, byte widget_zoom_in, byte widget_zoom_out)
 {
-	w->SetWidgetDisabledState(widget_zoom_in, vp->zoom == ZOOM_LVL_MIN);
+	w->SetWidgetDisabledState(widget_zoom_in, vp->zoom == ZOOM_LVL_BLITTER_MIN);
 	w->InvalidateWidget(widget_zoom_in);
 
-	w->SetWidgetDisabledState(widget_zoom_out, vp->zoom == ZOOM_LVL_MAX);
+	w->SetWidgetDisabledState(widget_zoom_out, vp->zoom == ZOOM_LVL_BLITTER_MAX);
 	w->InvalidateWidget(widget_zoom_out);
 }
 
@@ -1290,14 +1290,14 @@
  */
 void ViewportSign::MarkDirty() const
 {
-	/* We use ZOOM_LVL_MAX here, as every viewport can have an other zoom,
+	/* We use ZOOM_LVL_BLITTER_MAX here, as every viewport can have an other zoom,
 	 *  and there is no way for us to know which is the biggest. So make the
 	 *  biggest area dirty, and we are safe for sure. */
 	MarkAllViewportsDirty(
 		this->left - 6,
 		this->top  - 3,
-		this->left + ScaleByZoom(this->width_normal + 12, ZOOM_LVL_MAX),
-		this->top  + ScaleByZoom(12, ZOOM_LVL_MAX));
+		this->left + ScaleByZoom(this->width_normal + 12, ZOOM_LVL_BLITTER_MAX),
+		this->top  + ScaleByZoom(12, ZOOM_LVL_BLITTER_MAX));
 }
 
 static void ViewportDrawTileSprites(const TileSpriteToDrawVector *tstdv)
Index: src/waypoint_gui.cpp
===================================================================
--- src/waypoint_gui.cpp	(revision 17081)
+++ src/waypoint_gui.cpp	(working copy)
@@ -53,7 +53,7 @@
 
 		this->flags4 |= WF_DISABLE_VP_SCROLL;
 		NWidgetViewport *nvp = (NWidgetViewport *)this->nested_array[WAYPVW_VIEWPORT];
-		nvp->InitializeViewport(this, this->wp->xy, ZOOM_LVL_MIN);
+		nvp->InitializeViewport(this, this->wp->xy, ZOOM_LVL_BLITTER_MIN);
 
 		this->OnInvalidateData(0);
 	}
Index: src/zoom_type.h
===================================================================
--- src/zoom_type.h	(revision 17081)
+++ src/zoom_type.h	(working copy)
@@ -9,16 +9,14 @@
 
 enum ZoomLevel {
 	/* Our possible zoom-levels */
-	ZOOM_LVL_BEGIN  = 0,
-	ZOOM_LVL_NORMAL = 0,
+	ZOOM_LVL_IN_8X,
+	ZOOM_LVL_IN_4X,
+	ZOOM_LVL_IN_2X,
+	ZOOM_LVL_NORMAL,
 	ZOOM_LVL_OUT_2X,
 	ZOOM_LVL_OUT_4X,
 	ZOOM_LVL_OUT_8X,
-	ZOOM_LVL_END,
 
-	/* Number of zoom levels */
-	ZOOM_LVL_COUNT = ZOOM_LVL_END - ZOOM_LVL_BEGIN,
-
 	/* Here we define in which zoom viewports are */
 	ZOOM_LVL_VIEWPORT = ZOOM_LVL_NORMAL,
 	ZOOM_LVL_NEWS     = ZOOM_LVL_NORMAL,
@@ -30,10 +28,22 @@
 	ZOOM_LVL_ROADVEH  = ZOOM_LVL_NORMAL,
 	ZOOM_LVL_WORLD_SCREENSHOT = ZOOM_LVL_NORMAL,
 
-	ZOOM_LVL_DETAIL   = ZOOM_LVL_OUT_2X, ///< All zoomlevels below or equal to this, will result in details on the screen, like road-work, ...
+	ZOOM_LVL_DETAIL   = ZOOM_LVL_OUT_2X, ///< All zoomlevels with higher resolution or equal to this, will result in details on the screen, like road-work, ...
 
-	ZOOM_LVL_MIN      = ZOOM_LVL_NORMAL,
+	/* min/max for all zoom levels */
+	ZOOM_LVL_MIN      = ZOOM_LVL_IN_8X,
 	ZOOM_LVL_MAX      = ZOOM_LVL_OUT_8X,
+	ZOOM_LVL_COUNT    = ZOOM_LVL_MAX + 1 - ZOOM_LVL_MIN,
+
+	/* min/max for zoom levels the blitter can handle
+	 *
+	 * This distinction makes it possible to introduce more zoom levels for other windows.
+	 * For example the smallmap is drawn independently from the main viewport and thus
+	 * could support different zoom levels.
+	 */
+	ZOOM_LVL_BLITTER_MIN   = ZOOM_LVL_NORMAL,
+	ZOOM_LVL_BLITTER_MAX   = ZOOM_LVL_OUT_8X,
+	ZOOM_LVL_BLITTER_COUNT = ZOOM_LVL_BLITTER_MAX + 1 - ZOOM_LVL_BLITTER_MIN,
 };
 DECLARE_POSTFIX_INCREMENT(ZoomLevel)
 
