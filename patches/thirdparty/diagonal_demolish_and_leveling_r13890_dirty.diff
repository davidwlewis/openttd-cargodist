Index: src/terraform_cmd.cpp
===================================================================
--- src/terraform_cmd.cpp	(Revision 13890)
+++ src/terraform_cmd.cpp	(Arbeitskopie)
@@ -344,7 +344,8 @@
  * @param tile end tile of area-drag
  * @param flags for this command type
  * @param p1 start tile of area drag
- * @param p2 height difference; eg raise (+1), lower (-1) or level (0)
+ * @param p2 mode; rectangular level: LEVEL_ORTH, diagonal level: LEVEL_DIAG, 
+ * lower: LEVEL_LOWER, raise: LEVEL_RAISE; I know this is ugly.
  * @return  error or cost of terraforming
  */
 CommandCost CmdLevelLand(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
@@ -354,46 +355,109 @@
 	/* remember level height */
 	uint oldh = TileHeight(p1);
 
-	/* compute new height */
-	uint h = oldh + p2;
-
-	/* Check range of destination height */
-	if (h > MAX_TILE_HEIGHT) return_cmd_error((oldh == 0) ? STR_1003_ALREADY_AT_SEA_LEVEL : STR_1004_TOO_HIGH);
-
-	/* make sure sx,sy are smaller than ex,ey */
+	/* coordinates of end and start points */
 	int ex = TileX(tile);
 	int ey = TileY(tile);
 	int sx = TileX(p1);
 	int sy = TileY(p1);
-	if (ex < sx) Swap(ex, sx);
-	if (ey < sy) Swap(ey, sy);
-	tile = TileXY(sx, sy);
 
-	int size_x = ex - sx + 1;
-	int size_y = ey - sy + 1;
-
 	Money money = GetAvailableMoneyForCommand();
 	CommandCost cost(EXPENSES_CONSTRUCTION);
+	CommandCost ret;
 
-	BEGIN_TILE_LOOP(tile2, size_x, size_y, tile) {
-		uint curh = TileHeight(tile2);
-		while (curh != h) {
-			CommandCost ret = DoCommand(tile2, SLOPE_N, (curh > h) ? 0 : 1, flags & ~DC_EXEC, CMD_TERRAFORM_LAND);
-			if (CmdFailed(ret)) break;
+	if (p2 != LEVEL_DIAG) { // normal rectangle leveling
+		/* make sure sx,sy are smaller than ex,ey */
+		if (ex < sx) Swap(ex, sx);
+		if (ey < sy) Swap(ey, sy);
+		tile = TileXY(sx, sy);
 
-			if (flags & DC_EXEC) {
-				money -= ret.GetCost();
-				if (money < 0) {
-					_additional_cash_required = ret.GetCost();
-					return cost;
+		int size_x = ex - sx + 1;
+		int size_y = ey - sy + 1;
+		/* compute new height */
+		uint h = oldh;
+		if (p2 == LEVEL_RAISE)
+			h++;
+		else if (p2 == LEVEL_LOWER)
+			h--;
+
+		/* Check range of destination height */
+		if (h > MAX_TILE_HEIGHT) return_cmd_error((oldh == 0) ? 
+			STR_1003_ALREADY_AT_SEA_LEVEL : STR_1004_TOO_HIGH);
+
+
+		BEGIN_TILE_LOOP(tile2, size_x, size_y, tile) {
+				uint curh = TileHeight(tile2);
+			while (curh != h) {
+				ret = DoCommand(tile2, SLOPE_N, (curh > h) ? 0 : 1, 
+					flags & ~DC_EXEC, CMD_TERRAFORM_LAND);
+				if (CmdFailed(ret)) break;
+
+				if (flags & DC_EXEC) {
+					money -= ret.GetCost();
+					if (money < 0) {
+						_additional_cash_required = ret.GetCost();
+						return cost;
+					}
+					DoCommand(tile2, SLOPE_N, (curh > h) ? 0 : 1, flags, 
+						CMD_TERRAFORM_LAND);
 				}
-				DoCommand(tile2, SLOPE_N, (curh > h) ? 0 : 1, flags, CMD_TERRAFORM_LAND);
+
+				cost.AddCost(ret);
+				curh += (curh > h) ? -1 : 1;
 			}
-
-			cost.AddCost(ret);
-			curh += (curh > h) ? -1 : 1;
-		}
-	} END_TILE_LOOP(tile2, size_x, size_y, tile)
-
+		} END_TILE_LOOP(tile2, size_x, size_y, tile)
+	} else { // diagonal leveling
+		int dx = ex - sx, dy =  ey - sy; // distance between begin and endpoints
+		int fx = dx + dy, fy = dx - dy; /* x and y coordinate in rotated coordinate 
+																		 * system (for diagonal clearing)
+							     									 */
+		/* fx, fy form a diagonal coordinate system.
+		 * fx counts the number of diagonals in 1 direction, fy in another.
+		 * However with this method you only count half the squares. Compare with a 
+		 * checkboard with alternating black and white squares. You only count one 
+		 * color. That is why we count double the amount of rows and columns and 
+		 * divide inside the loop.
+		 */
+    int sfx = fx < 0 ? -1 : +1;
+    int sfy = fy < 0 ? -1 : +1;
+    /* loop over fx and fy, but include the last tile, too. ix != fx + sfx is 
+     * equivalent to ix <= fx when fx >= 0, but also works when fx < 0
+     */
+    for (int ix = 0; ix != fx + sfx; ix += sfx) {
+    	for (int iy = 0; iy != fy + sfy; iy += sfy) {
+    		int x = sx + (ix + iy) / 2;
+    		int y = sy + (ix - iy) / 2;
+				
+				uint curh = TileHeight(TileXY(x,y));
+				while (curh != oldh) {
+					ret = DoCommand(TileXY(x,y), 8, (curh > oldh) ? 0 : 1, 
+							flags & ~DC_EXEC, CMD_TERRAFORM_LAND);
+					if (CmdFailed(ret)) {
+						money -= ret.GetCost();
+						curh += (curh > oldh) ? -1 : 1;
+						continue;
+					}
+					
+					/* To be able to determine how much the operation will cost,
+					 * add the cost to cost. 
+					 */
+					cost.AddCost(ret);
+					if (flags & DC_EXEC) {
+						if (money < 0) {
+							_additional_cash_required = ret.GetCost();
+							/* Remove cost for not executed DoCommand 
+							 * from cost. So it is not billed anyway.
+							 */
+							cost.AddCost(-ret.GetCost());
+							return cost;
+						}
+						DoCommand(TileXY(x,y), 8, (curh > oldh) ? 0 : 1, 
+								flags, CMD_TERRAFORM_LAND);
+          }
+					curh += (curh > oldh) ? -1 : 1;
+				}
+			}
+		 }
+	}
 	return (cost.GetCost() == 0) ? CMD_ERROR : cost;
 }
Index: src/terraform_gui.cpp
===================================================================
--- src/terraform_gui.cpp	(Revision 13890)
+++ src/terraform_gui.cpp	(Arbeitskopie)
@@ -114,16 +114,16 @@
 {
 	switch (proc) {
 		case DDSP_DEMOLISH_AREA:
-			DoCommandP(end_tile, start_tile, 0, CcPlaySound10, CMD_CLEAR_AREA | CMD_MSG(STR_00B5_CAN_T_CLEAR_THIS_AREA));
+			DoCommandP(end_tile, start_tile, _ctrl_pressed, CcPlaySound10, CMD_CLEAR_AREA | CMD_MSG(STR_00B5_CAN_T_CLEAR_THIS_AREA));
 			break;
 		case DDSP_RAISE_AND_LEVEL_AREA:
-			DoCommandP(end_tile, start_tile, 1, CcTerraform, CMD_LEVEL_LAND | CMD_MSG(STR_0808_CAN_T_RAISE_LAND_HERE));
+			DoCommandP(end_tile, start_tile, LEVEL_RAISE, CcTerraform, CMD_LEVEL_LAND | CMD_MSG(STR_0808_CAN_T_RAISE_LAND_HERE));
 			break;
 		case DDSP_LOWER_AND_LEVEL_AREA:
-			DoCommandP(end_tile, start_tile, (uint32)-1, CcTerraform, CMD_LEVEL_LAND | CMD_MSG(STR_0809_CAN_T_LOWER_LAND_HERE));
+			DoCommandP(end_tile, start_tile, LEVEL_LOWER, CcTerraform, CMD_LEVEL_LAND | CMD_MSG(STR_0809_CAN_T_LOWER_LAND_HERE));
 			break;
 		case DDSP_LEVEL_AREA:
-			DoCommandP(end_tile, start_tile, 0, CcPlaySound10, CMD_LEVEL_LAND);
+			DoCommandP(end_tile, start_tile, _ctrl_pressed ? LEVEL_DIAG : LEVEL_ORTH, CcPlaySound10, CMD_LEVEL_LAND);
 			break;
 		case DDSP_CREATE_ROCKS:
 			GenerateRockyArea(end_tile, start_tile);
Index: src/command_type.h
===================================================================
--- src/command_type.h	(Revision 13890)
+++ src/command_type.h	(Arbeitskopie)
@@ -376,4 +376,13 @@
  */
 typedef void CommandCallback(bool success, TileIndex tile, uint32 p1, uint32 p2);
 
+/**
+ * argument for CmdLevelLand describing what to do
+ */
+enum {
+	LEVEL_LOWER = (uint)-1,
+	LEVEL_ORTH = 0,
+	LEVEL_RAISE = 1,
+	LEVEL_DIAG = 255,
+};
 #endif /* COMMAND_TYPE_H */
Index: src/landscape.cpp
===================================================================
--- src/landscape.cpp	(Revision 13890)
+++ src/landscape.cpp	(Arbeitskopie)
@@ -570,50 +570,117 @@
  * @param tile end tile of area dragging
  * @param p1 start tile of area dragging
  * @param flags of operation to conduct
- * @param p2 unused
+ * @param p2 0 if clearing a normal rectangle, 1 if leveling a 45° rotated (diagonal) rectangle
  */
 CommandCost CmdClearArea(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	if (p1 >= MapSize()) return CMD_ERROR;
 
-	/* make sure sx,sy are smaller than ex,ey */
 	int ex = TileX(tile);
 	int ey = TileY(tile);
 	int sx = TileX(p1);
 	int sy = TileY(p1);
-	if (ex < sx) Swap(ex, sx);
-	if (ey < sy) Swap(ey, sy);
 
 	Money money = GetAvailableMoneyForCommand();
 	CommandCost cost(EXPENSES_CONSTRUCTION);
 	bool success = false;
 
-	for (int x = sx; x <= ex; ++x) {
-		for (int y = sy; y <= ey; ++y) {
-			CommandCost ret = DoCommand(TileXY(x, y), 0, 0, flags & ~DC_EXEC, CMD_LANDSCAPE_CLEAR);
-			if (CmdFailed(ret)) continue;
-			success = true;
+	if (p2 == 0) {
+		/* make sure sx,sy are smaller than ex,ey */
+		if (ex < sx) Swap(ex, sx);
+		if (ey < sy) Swap(ey, sy);
+		for (int x = sx; x <= ex; ++x) {
+			for (int y = sy; y <= ey; ++y) {
+				CommandCost ret = DoCommand(TileXY(x, y), 0, 0, flags & ~DC_EXEC, 
+						CMD_LANDSCAPE_CLEAR);
+				if (CmdFailed(ret)) continue;
+				success = true;
 
-			if (flags & DC_EXEC) {
-				money -= ret.GetCost();
-				if (ret.GetCost() > 0 && money < 0) {
-					_additional_cash_required = ret.GetCost();
-					return cost;
+				if (flags & DC_EXEC) {
+					money -= ret.GetCost();
+					if (ret.GetCost() > 0 && money < 0) {
+						_additional_cash_required = ret.GetCost();
+						return cost;
+					}
+					DoCommand(TileXY(x, y), 0, 0, flags, CMD_LANDSCAPE_CLEAR);
+
+					/* draw explosion animation... */
+					if ((x == sx || x == ex) && (y == sy || y == ey)) {
+						/* big explosion in each corner, or small explosion 
+						 * for single tiles 
+						 */
+						CreateEffectVehicleAbove(x * TILE_SIZE + TILE_SIZE /
+								2, y * TILE_SIZE + TILE_SIZE / 2, 2,
+								sy == ey && sx == ex ? 
+								EV_EXPLOSION_SMALL : 
+								EV_EXPLOSION_LARGE
+						);
+					}
 				}
-				DoCommand(TileXY(x, y), 0, 0, flags, CMD_LANDSCAPE_CLEAR);
+				cost.AddCost(ret);
+			}
+		}
+	} else {
+		int dx = ex - sx, dy =  ey - sy; // distance between begin and endpoints
+		int fx = dx + dy, fy = dx - dy; /* x and y coordinate in rotated coordinate 
+																		 * system (for diagonal clearing)
+							     									 */
+		/* fx, fy form a diagonal coordinate system.
+		 * fx counts the number of diagonals in 1 direction, fy in another.
+		 * However with this method you only count half the squares. Compare with a 
+		 * checkboard with alternating black and white squares. You only count one 
+		 * color. That is why we count double the amount of rows and columns and 
+		 * divide inside the loop.
+		 */
+		int sfx = fx < 0 ? -1 : +1;
+		int sfy = fy < 0 ? -1 : +1;
+		/* loop over fx and fy, but include the last tile, too. ix != fx + sfx is 
+		 * equivalent to ix <= fx when fx >= 0, but also works when fx < 0
+		 */
+		for (int ix = 0; ix != fx + sfx; ix += sfx) {
+			for (int iy = 0; iy != fy + sfy; iy += sfy) {
+				int x = sx + (ix + iy) / 2;
+				int y = sy + (ix - iy) / 2;
 
-				/* draw explosion animation... */
-				if ((x == sx || x == ex) && (y == sy || y == ey)) {
-					/* big explosion in each corner, or small explosion for single tiles */
-					CreateEffectVehicleAbove(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 2,
-						sy == ey && sx == ex ? EV_EXPLOSION_SMALL : EV_EXPLOSION_LARGE
-					);
+				CommandCost ret = DoCommand(TileXY(x, y), 0, 0, flags & ~DC_EXEC,
+						CMD_LANDSCAPE_CLEAR);
+				if (CmdFailed(ret)) continue;
+
+				/* To be able to determine how much the operation will cost, add 
+				 * the cost to cost.
+				 */
+				cost.AddCost(ret);
+				success = true;
+
+				if (flags & DC_EXEC) {
+					money -= ret.GetCost();
+					if (ret.GetCost() > 0 && money < 0) {
+						_additional_cash_required = ret.GetCost();
+
+						/* Remove cost for not executed DoCommand from cost.
+						 * So it is not billed anyway.
+						 */
+						cost.AddCost(-ret.GetCost());
+						return cost;
+					}
+
+					DoCommand(TileXY(x, y), 0, 0, flags, CMD_LANDSCAPE_CLEAR);
+					/* draw explosion animation... */
+					if ((x == sx || x == ex) && (y == sy || y == ey)) {
+						/* big explosion in 2 corners, or small explosion 
+						 * for single tiles 
+						 */
+						CreateEffectVehicleAbove(x * TILE_SIZE + TILE_SIZE 
+								/ 2, y * TILE_SIZE + TILE_SIZE / 2, 
+								2, sy == ey && sx == ex ? 
+								EV_EXPLOSION_SMALL : 
+								EV_EXPLOSION_LARGE
+						);
+					}
 				}
 			}
-			cost.AddCost(ret);
 		}
 	}
-
 	return (success) ? cost : CMD_ERROR;
 }
 
Index: src/landscape.h
===================================================================
--- src/landscape.h	(Revision 13890)
+++ src/landscape.h	(Arbeitskopie)
@@ -56,4 +56,5 @@
 
 TileIndex AdjustTileCoordRandomly(TileIndex a, byte rng);
 
+
 #endif /* LANDSCAPE_H */
Index: src/viewport.cpp
===================================================================
--- src/viewport.cpp	(Revision 13890)
+++ src/viewport.cpp	(Arbeitskopie)
@@ -692,6 +692,17 @@
 	_vd.combine_sprites = 0;
 }
 
+bool IsInsideRotatedRectangle(int x, int y)
+{
+	int fx = (_thd.size.x + _thd.size.y); // Rotated coordinate system for selected rectangle
+	int fy = (_thd.size.x - _thd.size.y); // We don't have to divide by 2. It's all relative!
+	int xx = ((x - _thd.pos.x) + (y - _thd.pos.y)); // Rotated coordinate system for the point under scrutiny
+	int yy = ((x - _thd.pos.x) - (y - _thd.pos.y));
+
+	return ((fx >= 0 && xx <= fx && xx >= 0) || (fx < 0 && xx >= fx && xx <= 0)) &&
+			((fy >= 0 && yy <= fy && yy >= 0) || (fy < 0 && yy >= fy && yy <= 0));
+}
+
 /**
  * Add a child sprite to a parent sprite.
  *
@@ -877,6 +888,26 @@
 	/* no selection active? */
 	if (_thd.drawstyle == 0) return;
 
+	if (_thd.diagonal) { // We're drawing a 45° rotated (diagonal) rectangle
+		if (IsInsideRotatedRectangle((int)ti->x, (int)ti->y)) {
+			if (_thd.drawstyle & HT_RECT) { // highlighting a square (clear land)
+				SpriteID image = SPR_SELECT_TILE + _tileh_to_sprite[ti->tileh];
+				DrawSelectionSprite(image, _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE, ti, 7, FOUNDATION_PART_NORMAL);
+			}else { // highlighting a dot (level land)
+				/* Figure out the Z coordinate for the single dot. */
+				byte z = ti->z;
+				if (ti->tileh & 8) {
+					z += 8;
+					if (!(ti->tileh & 2) && (ti->tileh & 0x10)) {
+						z += 8;
+					}
+				}
+				DrawGroundSpriteAt(_cur_dpi->zoom != 2 ? SPR_DOT : SPR_DOT_SMALL, PAL_NONE, ti->x, ti->y, z);
+			}
+		}
+		return;
+	}
+
 	/* Inside the inner area? */
 	if (IsInsideBS(ti->x, _thd.pos.x, _thd.size.x) &&
 			IsInsideBS(ti->y, _thd.pos.y, _thd.size.y)) {
@@ -1713,26 +1744,40 @@
 	x_size = _thd.size.x;
 	y_size = _thd.size.y;
 
-	if (_thd.outersize.x) {
-		x_size += _thd.outersize.x;
-		x += _thd.offs.x;
-		y_size += _thd.outersize.y;
-		y += _thd.offs.y;
-	}
+	if (!_thd.diagonal) { // Selecting in a straigth rectangle (or a single square)
+		if (_thd.outersize.x) {
+			x_size += _thd.outersize.x;
+			x += _thd.offs.x;
+			y_size += _thd.outersize.y;
+			y += _thd.offs.y;
+		}
+		assert(x_size > 0);
+		assert(y_size > 0);
 
-	assert(x_size > 0);
-	assert(y_size > 0);
+		x_size += x;
+		y_size += y;
 
-	x_size += x;
-	y_size += y;
+		do {
+			int y_bk = y;
+			do {
+				MarkTileDirty(x, y);
+			} while ((y += TILE_SIZE) != y_size);
+			y = y_bk;
+		} while ((x += TILE_SIZE) != x_size);
+	} else { // Selecting in a 45° rotated (diagonal) rectangle.
+		int fx = x_size + y_size, fy = x_size - y_size; // fx, fy describe rotated coordinate axis
 
-	do {
-		int y_bk = y;
-		do {
-			MarkTileDirty(x, y);
-		} while ( (y += TILE_SIZE) != y_size);
-		y = y_bk;
-	} while ( (x += TILE_SIZE) != x_size);
+		int sxt = fx < 0 ? -TILE_SIZE : TILE_SIZE;
+		int syt = fy < 0 ? -TILE_SIZE : TILE_SIZE;
+
+		for (int ix = -sxt; ix != fx + sxt; ix += sxt) {
+			for (int iy = -syt; iy != fy + syt; iy += syt) {
+				x = _thd.pos.x + (ix + iy) / 2;
+				y = _thd.pos.y + (ix - iy) / 2;
+				MarkTileDirty(x, y);
+			}
+		}
+	}
 }
 
 
@@ -2123,6 +2168,12 @@
 	return HT_RAIL | _autorail_piece[x & 0xF][y & 0xF];
 }
 
+static inline bool DraggingDiagonal()
+{
+	return _ctrl_pressed && ((_thd.select_proc == DDSP_DEMOLISH_AREA && _thd.select_method == VPM_X_AND_Y) ||
+								(_thd.select_proc == DDSP_LEVEL_AREA && _thd.select_method == VPM_X_AND_Y));
+}
+
 /**
  * Updates tile highlighting for all cases.
  * Uses _thd.selstart and _thd.selend and _thd.place_mode (set elsewhere) to determine _thd.pos and _thd.size
@@ -2137,6 +2188,7 @@
 	int y1;
 
 	_thd.new_drawstyle = 0;
+	_thd.new_diagonal = false;
 
 	if (_thd.place_mode == VHM_SPECIAL) {
 		x1 = _thd.selend.x;
@@ -2147,12 +2199,20 @@
 			x1 &= ~0xF;
 			y1 &= ~0xF;
 
-			if (x1 >= x2) Swap(x1, x2);
-			if (y1 >= y2) Swap(y1, y2);
+			if ( DraggingDiagonal() )
+				_thd.new_diagonal = true;
+			else {
+				if (x1 >= x2) Swap(x1,x2);
+				if (y1 >= y2) Swap(y1,y2);
+			}
 			_thd.new_pos.x = x1;
 			_thd.new_pos.y = y1;
-			_thd.new_size.x = x2 - x1 + TILE_SIZE;
-			_thd.new_size.y = y2 - y1 + TILE_SIZE;
+			_thd.new_size.x = x2 - x1;
+			_thd.new_size.y = y2 - y1;
+			if (!_thd.new_diagonal) {
+				_thd.new_size.x += TILE_SIZE;
+				_thd.new_size.y += TILE_SIZE;
+			}
 			_thd.new_drawstyle = _thd.next_drawstyle;
 		}
 	} else if (_thd.place_mode != VHM_NONE) {
@@ -2186,7 +2246,8 @@
 			_thd.pos.x != _thd.new_pos.x || _thd.pos.y != _thd.new_pos.y ||
 			_thd.size.x != _thd.new_size.x || _thd.size.y != _thd.new_size.y ||
 			_thd.outersize.x != _thd.new_outersize.x ||
-			_thd.outersize.y != _thd.new_outersize.y) {
+			_thd.outersize.y != _thd.new_outersize.y ||
+			_thd.diagonal    != _thd.new_diagonal) {
 		/* clear the old selection? */
 		if (_thd.drawstyle) SetSelectionTilesDirty();
 
@@ -2194,6 +2255,7 @@
 		_thd.pos = _thd.new_pos;
 		_thd.size = _thd.new_size;
 		_thd.outersize = _thd.new_outersize;
+		_thd.diagonal = _thd.new_diagonal;
 		_thd.dirty = 0xff;
 
 		/* draw the new selection? */
Index: src/tilehighlight_type.h
===================================================================
--- src/tilehighlight_type.h	(Revision 13890)
+++ src/tilehighlight_type.h	(Arbeitskopie)
@@ -72,6 +72,8 @@
 	ViewportDragDropSelectionProcess select_proc;
 
 	TileIndex redsq;
+	bool diagonal;     ///< true if dragging a 45° rotated rectangle
+	bool new_diagonal;
 };
 
 #endif /* TILEHIGHLIGHT_TYPE_H */
