diff --git a/projects/openttd_vs80.vcproj b/projects/openttd_vs80.vcproj
index da52f33..2cf61f0 100644
--- a/projects/openttd_vs80.vcproj
+++ b/projects/openttd_vs80.vcproj
@@ -592,6 +592,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1092,6 +1100,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -1108,6 +1128,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -2144,6 +2172,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
diff --git a/projects/openttd_vs90.vcproj b/projects/openttd_vs90.vcproj
index 6d0e652..b5bb22b 100644
--- a/projects/openttd_vs90.vcproj
+++ b/projects/openttd_vs90.vcproj
@@ -589,6 +589,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1089,6 +1097,18 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -1105,6 +1125,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -2141,6 +2169,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
diff --git a/source.list b/source.list
index b32af81..311702d 100644
--- a/source.list
+++ b/source.list
@@ -33,6 +33,8 @@ heightmap.cpp
 highscore.cpp
 ini.cpp
 landscape.cpp
+linkgraph/demands.cpp
+linkgraph/linkgraph.cpp
 map.cpp
 misc.cpp
 mixer.cpp
@@ -182,10 +184,15 @@ industrytype.h
 ini_type.h
 landscape.h
 landscape_type.h
+linkgraph/demands.h
+linkgraph/linkgraph.h
+linkgraph/linkgraph_type.h
 livery.h
 map_func.h
 map_type.h
 mixer.h
+moving_average.h
+moving_average.cpp
 network/network.h
 network/network_base.h
 network/network_client.h
@@ -465,6 +472,7 @@ saveload/gamelog_sl.cpp
 saveload/group_sl.cpp
 saveload/industry_sl.cpp
 saveload/labelmaps_sl.cpp
+saveload/linkgraph_sl.cpp
 saveload/map_sl.cpp
 saveload/misc_sl.cpp
 saveload/newgrf_sl.cpp
diff --git a/src/aircraft_cmd.cpp b/src/aircraft_cmd.cpp
index 4e3a116..0a8bc7a 100644
--- a/src/aircraft_cmd.cpp
+++ b/src/aircraft_cmd.cpp
@@ -1304,6 +1304,7 @@ static void AircraftEntersTerminal(Aircraft *v)
 	if (v->current_order.IsType(OT_GOTO_DEPOT)) return;
 
 	Station *st = Station::Get(v->targetairport);
+	StationID previous_station = v->last_station_visited;
 	v->last_station_visited = v->targetairport;
 
 	/* Check if station was ever visited before */
@@ -1320,7 +1321,7 @@ static void AircraftEntersTerminal(Aircraft *v)
 		AI::NewEvent(v->owner, new AIEventStationFirstVehicle(st->index, v->index));
 	}
 
-	v->BeginLoading();
+	v->BeginLoading(previous_station);
 }
 
 static void AircraftLandAirplane(Aircraft *v)
diff --git a/src/cargo_type.h b/src/cargo_type.h
index 8d9a1a8..2e0e355 100644
--- a/src/cargo_type.h
+++ b/src/cargo_type.h
@@ -23,6 +23,7 @@ typedef byte CargoID;
 
 /** Available types of cargo */
 enum CargoTypes {
+	CT_BEGIN        =  0,
 	/* Temperate */
 	CT_PASSENGERS   =  0,
 	CT_COAL         =  1,
@@ -64,6 +65,7 @@ enum CargoTypes {
 	CT_FIZZY_DRINKS = 11,
 
 	NUM_CARGO       = 32,   ///< Maximal number of cargo types in a game.
+	CT_END          = 32,
 
 	CT_NO_REFIT     = 0xFE, ///< Do not refit cargo of a vehicle (used in vehicle orders and auto-replace/auto-new).
 	CT_INVALID      = 0xFF, ///< Invalid cargo type.
diff --git a/src/core/math_func.cpp b/src/core/math_func.cpp
index 7f0630a..1a9f398 100644
--- a/src/core/math_func.cpp
+++ b/src/core/math_func.cpp
@@ -46,3 +46,21 @@ int GreatestCommonDivisor(int a, int b)
 	return a;
 
 }
+
+
+/**
+ * Deterministic approximate division.
+ * Cancels out division errors stemming from the integer nature of the division over multiple runs.
+ */
+int DivideApprox(int a, int b) {
+	int random_like = ((a + b) * (a - b)) % b;
+
+	int remainder = a % b;
+
+	int ret = a / b;
+	if (abs(random_like) < abs(remainder)) {
+		ret += ((a < 0) ^ (b < 0)) ? -1 : 1;
+	}
+
+	return ret;
+}
diff --git a/src/core/math_func.hpp b/src/core/math_func.hpp
index 19f2f53..a824af3 100644
--- a/src/core/math_func.hpp
+++ b/src/core/math_func.hpp
@@ -317,6 +317,7 @@ static FORCEINLINE uint ToPercent16(uint i)
 
 int LeastCommonMultiple(int a, int b);
 int GreatestCommonDivisor(int a, int b);
+int DivideApprox(int a, int b);
 
 /**
  * Computes ceil(a / b) for non-negative a and b.
diff --git a/src/landscape.cpp b/src/landscape.cpp
index 25b41d1..71a8e56 100644
--- a/src/landscape.cpp
+++ b/src/landscape.cpp
@@ -948,6 +948,7 @@ void OnTick_Station();
 void OnTick_Industry();
 
 void OnTick_Companies();
+void OnTick_LinkGraph();
 
 void CallLandscapeTick()
 {
@@ -957,4 +958,5 @@ void CallLandscapeTick()
 	OnTick_Industry();
 
 	OnTick_Companies();
+	OnTick_LinkGraph();
 }
diff --git a/src/lang/english.txt b/src/lang/english.txt
index 743efbd..fde03bf 100644
--- a/src/lang/english.txt
+++ b/src/lang/english.txt
@@ -1304,12 +1304,40 @@ STR_CONFIG_SETTING_LARGER_TOWNS                                 :{LTBLUE}Proport
 STR_CONFIG_SETTING_LARGER_TOWNS_DISABLED                        :{LTBLUE}Proportion of towns that will become cities: {ORANGE}None
 STR_CONFIG_SETTING_CITY_SIZE_MULTIPLIER                         :{LTBLUE}Initial city size multiplier: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD                        :{LTBLUE}Remove absurd road-elements during the road construction: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_AVERAGE_UNIT                                 :{LTBLUE}Moving Average Unit: {ORANGE}{STRING1} days
+STR_CONFIG_SETTING_AVERAGE_LENGTH                               :{LTBLUE}Minimum Moving Average Length: {ORANGE}{STRING1} units
+
+STR_CONFIG_SETTING_LINKGRAPH_INTERVAL                           :{LTBLUE}Link graph recalculation interval: {ORANGE}{STRING1} days
+STR_CONFIG_SETTING_DISTRIBUTION_PAX                             :{LTBLUE}Distribution for passengers: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_PAX_SYMMETRIC                   :symmetric
+STR_CONFIG_SETTING_DISTRIBUTION_PAX_ASYMMETRIC                  :asymmetric
+STR_CONFIG_SETTING_DISTRIBUTION_PAX_MANUAL                      :manual
+STR_CONFIG_SETTING_DISTRIBUTION_MAIL                            :{LTBLUE}Distribution for mail: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_MAIL_SYMMETRIC                  :symmetric
+STR_CONFIG_SETTING_DISTRIBUTION_MAIL_ASYMMETRIC                 :asymmetric
+STR_CONFIG_SETTING_DISTRIBUTION_MAIL_MANUAL                     :manual
+STR_CONFIG_SETTING_DISTRIBUTION_EXPRESS                         :{LTBLUE}Distribution for the EXPRESS cargo class: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_EXPRESS_SYMMETRIC               :symmetric
+STR_CONFIG_SETTING_DISTRIBUTION_EXPRESS_ASYMMETRIC              :asymmetric
+STR_CONFIG_SETTING_DISTRIBUTION_EXPRESS_MANUAL                  :manual
+STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED                        :{LTBLUE}Distribution for the ARMOURED cargo class: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED_SYMMETRIC              :symmetric
+STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED_ASYMMETRIC             :asymmetric
+STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED_MANUAL                 :manual
+STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT                         :{LTBLUE}Distribution for other cargo classes: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT_SYMMETRIC               :symmetric
+STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT_ASYMMETRIC              :asymmetric
+STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT_MANUAL                  :manual
+STR_CONFIG_SETTING_LINKGRAPH_ACCURACY                           :{LTBLUE}Accuracy when calculating things on the link graph: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_DISTANCE                              :{LTBLUE}Effect of distance on demands: {ORANGE}{STRING1}%
+STR_CONFIG_SETTING_DEMAND_SIZE                                  :{LTBLUE}Effect of remote station's popularity on symmetric demands: {ORANGE}{STRING1}%
 
 STR_CONFIG_SETTING_GUI                                          :{ORANGE}Interface
 STR_CONFIG_SETTING_CONSTRUCTION                                 :{ORANGE}Construction
 STR_CONFIG_SETTING_VEHICLES                                     :{ORANGE}Vehicles
 STR_CONFIG_SETTING_STATIONS                                     :{ORANGE}Stations
 STR_CONFIG_SETTING_ECONOMY                                      :{ORANGE}Economy
+STR_CONFIG_SETTING_LINKGRAPH                                    :{ORANGE}Link graph
 STR_CONFIG_SETTING_AI                                           :{ORANGE}Competitors
 STR_CONFIG_SETTING_DISPLAY_OPTIONS                              :{ORANGE}Display options
 STR_CONFIG_SETTING_INTERACTION                                  :{ORANGE}Interaction
@@ -3342,6 +3370,7 @@ STR_GAME_SAVELOAD_ERROR_FILE_NOT_READABLE                       :File not readab
 STR_GAME_SAVELOAD_ERROR_FILE_NOT_WRITEABLE                      :File not writeable
 STR_GAME_SAVELOAD_ERROR_DATA_INTEGRITY_CHECK_FAILED             :Data integrity check failed
 STR_WARNING_LOADGAME_REMOVED_TRAMS                              :{WHITE}Game was saved in version without tram support. All trams have been removed.
+STR_WARNING_NONSTOP_CARGODIST                                   :{WHITE}You have set at least one cargo class to be automatically distributed in{}"Avanced Settings -> Link Graph"{}and disabled{}"New orders are 'non-stop' by default"{}in{}"Advanced Settings -> Vehicles"{}This is a BAD idea.
 
 # Map generation messages
 STR_ERROR_COULD_NOT_CREATE_TOWN                                 :{WHITE}Map generation aborted...{}... no suitable town locations
diff --git a/src/linkgraph/demands.cpp b/src/linkgraph/demands.cpp
new file mode 100644
index 0000000..05df7fa
--- /dev/null
+++ b/src/linkgraph/demands.cpp
@@ -0,0 +1,182 @@
+/** @file demands.h Definition of demand calculating link graph handler. */
+
+#include "demands.h"
+#include "../station_base.h"
+#include "../settings_type.h"
+#include "../newgrf_cargo.h"
+#include "../cargotype.h"
+#include "../core/math_func.hpp"
+#include <list>
+
+typedef std::list<NodeID> NodeList;
+
+/**
+ * Set the demands between two nodes using the given base demand. In symmetric mode
+ * this sets demands in both directions.
+ * @param graph The link graph
+ * @param from_id The supplying node
+ * @þaram to_id The receiving node
+ * @param demand_forw Demand calculated for the "forward" direction
+ */
+void SymmetricScaler::SetDemands(LinkGraphComponent * graph, NodeID from_id, NodeID to_id, uint demand_forw)
+{
+	if (graph->GetNode(from_id).demand > 0) {
+		uint demand_back = demand_forw * this->mod_size / 100;
+		uint undelivered = graph->GetNode(to_id).undelivered_supply;
+		if (demand_back > undelivered) {
+			demand_back = undelivered;
+			demand_forw = max(1U, demand_back * 100 / this->mod_size);
+		}
+		this->Scaler::SetDemands(graph, to_id, from_id, demand_back);
+	}
+
+	this->Scaler::SetDemands(graph, from_id, to_id, demand_forw);
+}
+
+/**
+ * Set the demands between two nodes using the given base demand. In asymmetric mode
+ * this only sets demand in the "forward" direction.
+ * @param graph The link graph
+ * @param from_id The supplying node
+ * @þaram to_id The receiving node
+ * @param demand_forw Demand calculated for the "forward" direction
+ */
+FORCEINLINE void Scaler::SetDemands(LinkGraphComponent * graph, NodeID from_id, NodeID to_id, uint demand_forw)
+{
+	Edge &forward = graph->GetEdge(from_id, to_id);
+	forward.demand += demand_forw;
+	graph->GetNode(from_id).undelivered_supply -= demand_forw;
+}
+
+/**
+ * Do the actual demand calculation, called from constructor.
+ * @param graph the component to calculate the demands for
+ */
+template<class Tscaler>
+void DemandCalculator::CalcDemand(LinkGraphComponent *graph, Tscaler scaler)
+{
+	NodeList supplies;
+	NodeList demands;
+	uint num_supplies = 0;
+	uint num_demands = 0;
+
+	for(NodeID node = 0; node < graph->GetSize(); node++) {
+		Node &n = graph->GetNode(node);
+		scaler.AddNode(n);
+		if (n.supply > 0) {
+			supplies.push_back(node);
+			num_supplies++;
+		}
+		if (n.demand > 0) {
+			demands.push_back(node);
+			num_demands++;
+		}
+	}
+
+	if (num_supplies == 0 || num_demands == 0) return;
+
+	/* mean acceptance attributed to each node. If the distribution is
+	 * symmetric this is relative to remote supply, otherwise it is
+	 * relative to remote demand.
+	 */
+	scaler.SetDemandPerNode(num_demands);
+	uint chance = 0;
+
+	while(!supplies.empty() && !demands.empty()) {
+		NodeID node1 = supplies.front();
+		supplies.pop_front();
+
+		Node &from = graph->GetNode(node1);
+
+		for(uint i = 0; i < num_demands; ++i) {
+			assert(!demands.empty());
+			NodeID node2 = demands.front();
+			demands.pop_front();
+			if (node1 == node2) {
+				if (demands.empty() && supplies.empty()) {
+					/* only one node with supply and demand left */
+					return;
+				} else {
+					demands.push_back(node2);
+					continue;
+				}
+			}
+			Node &to = graph->GetNode(node2);
+
+			int32 supply = scaler.EffectiveSupply(from, to);
+			assert(supply > 0);
+
+			/* scale the distance by mod_dist around max_distance */
+			int32 distance = this->max_distance - (this->max_distance -
+					(int32)graph->GetEdge(node1, node2).distance) * this->mod_dist / 100;
+
+			/* scale the accuracy by distance around accuracy / 2 */
+			int32 divisor = this->accuracy * (this->mod_dist - 50) / 100 +
+					this->accuracy * distance / this->max_distance + 1;
+
+			assert(divisor > 0);
+
+			uint demand_forw = 0;
+			if (divisor <= supply) {
+				/* at first only distribute demand if
+				 * effective supply / accuracy divisor >= 1
+				 * Others are too small or too far away to be considered.
+				 */
+				demand_forw = supply / divisor;
+			} else if (++chance > this->accuracy * num_demands * num_supplies) {
+				/* After some trying, if there is still supply left, distribute
+				 * demand also to other nodes.
+				 */
+				demand_forw = 1;
+			}
+
+			demand_forw = min(demand_forw, from.undelivered_supply);
+
+			scaler.SetDemands(graph, node1, node2, demand_forw);
+
+			if (scaler.DemandLeft(to)) {
+				demands.push_back(node2);
+			} else {
+				num_demands--;
+			}
+
+			if (from.undelivered_supply == 0) break;
+
+		}
+		if (from.undelivered_supply != 0) {
+			supplies.push_back(node1);
+		} else {
+			num_supplies--;
+		}
+	}
+}
+
+/**
+ * Create the DemandCalculator and immediately do the calculation.
+ * @param graph the component to calculate the demands for
+ */
+DemandCalculator::DemandCalculator(LinkGraphComponent *graph) :
+	max_distance(MapSizeX() + MapSizeY() + 1)
+{
+	CargoID cargo = graph->GetCargo();
+	const LinkGraphSettings &settings = graph->GetSettings();
+
+	this->accuracy = settings.accuracy;
+	this->mod_dist = settings.demand_distance;
+	if (this->mod_dist > 100) {
+		/* increase effect of mod_dist > 100 */
+		int over100 = this->mod_dist - 100;
+		this->mod_dist = 100 + over100 * over100;
+	}
+
+	switch (settings.GetDistributionType(cargo)) {
+	case DT_SYMMETRIC:
+		this->CalcDemand<SymmetricScaler>(graph, SymmetricScaler(settings.demand_size));
+		break;
+	case DT_ASYMMETRIC:
+		this->CalcDemand<AsymmetricScaler>(graph, AsymmetricScaler());
+		break;
+	default:
+		NOT_REACHED();
+	}
+}
diff --git a/src/linkgraph/demands.h b/src/linkgraph/demands.h
new file mode 100644
index 0000000..8b6f8bb
--- /dev/null
+++ b/src/linkgraph/demands.h
@@ -0,0 +1,151 @@
+/** @file demands.h Declaration of demand calculating link graph handler. */
+
+#ifndef DEMANDS_H_
+#define DEMANDS_H_
+
+#include "linkgraph.h"
+#include "../stdafx.h"
+#include "../cargo_type.h"
+#include "../map_func.h"
+
+/**
+ * scale various things according to symmetric/asymmetric distribution
+ */
+class Scaler {
+public:
+	Scaler() : demand_per_node(0) {}
+
+	void SetDemands(LinkGraphComponent * graph, NodeID from, NodeID to, uint demand_forw);
+protected:
+	uint demand_per_node; ///< mean demand associated with each node
+};
+
+/**
+ * Scaler for symmetric distribution
+ */
+class SymmetricScaler : public Scaler {
+public:
+	FORCEINLINE SymmetricScaler(uint mod_size) :
+		mod_size(mod_size), supply_sum(0) {}
+
+	/**
+	 * count a node's supply into the sum of supplies
+	 * @param node the node
+	 */
+	FORCEINLINE void AddNode(const Node &node)
+		{this->supply_sum += node.supply;}
+
+	/**
+	 * calculate the mean demand per node using the sum of supplies
+	 * @param num_demands the number of accepting nodes
+	 */
+	FORCEINLINE void SetDemandPerNode(uint num_demands)
+		{this->demand_per_node = max(this->supply_sum / num_demands, 1U);}
+
+	/**
+	 * get the effective supply of one node towards another one. In symmetric
+	 * distribution the supply of the other node is weighed in.
+	 * @param from The supplying node
+	 * @param to The receiving node
+	 * @return the effective supply
+	 */
+	FORCEINLINE uint EffectiveSupply(const Node &from, const Node &to)
+		{return max(from.supply * max(1U, to.supply) * this->mod_size / 100 / this->demand_per_node, 1U);}
+
+	/**
+	 * Check if there is any acceptance left for this node. In symmetric distribution
+	 * nodes only accept anything if they also supply something. So if
+	 * undelivered_supply == 0 at the node there isn't any demand left either
+	 * @param to The node to be checked
+	 */
+	FORCEINLINE bool DemandLeft(Node &to)
+		{return (to.supply == 0 || to.undelivered_supply > 0) && to.demand > 0;}
+
+	void SetDemands(LinkGraphComponent * graph, NodeID from, NodeID to, uint demand_forw);
+
+private:
+	uint mod_size;
+	uint supply_sum;
+};
+
+/**
+ * A scaler for asymmetric distribution.
+ */
+class AsymmetricScaler : public Scaler {
+public:
+	AsymmetricScaler() : demand_sum(0) {}
+
+	/**
+	 * count a node's demand into the sum of demands
+	 * @param node The node to be counted
+	 */
+	FORCEINLINE void AddNode(const Node &node)
+		{this->demand_sum += node.demand;}
+
+	/**
+	 * calculate the mean demand per node using the sum of demands
+	 * @param num_demands the number of accepting nodes
+	 */
+	FORCEINLINE void SetDemandPerNode(uint num_demands)
+		{this->demand_per_node = max(this->demand_sum / num_demands, (uint)1);}
+
+	/**
+	 * get the effective supply of one node towards another one. In asymmetric
+	 * distribution the demand of the other node is weighed in.
+	 * @param from The supplying node
+	 * @param to The receiving node
+	 */
+	FORCEINLINE uint EffectiveSupply(const Node &from, const Node &to)
+		{return max(from.supply * to.demand / this->demand_per_node, (uint)1);}
+
+	/**
+	 * Check if there is any acceptance left for this node. In asymmetric distribution
+	 * nodes always accept as long as their demand > 0.
+	 * @param to The node to be checked
+	 */
+	FORCEINLINE bool DemandLeft(Node &to)
+		{return to.demand > 0;}
+
+private:
+	uint demand_sum;
+
+};
+
+/**
+ * Calculate the demands. This class has a state, but is recreated for each
+ * call to of DemandHandler::Run.
+ */
+
+class DemandCalculator {
+public:
+	DemandCalculator(LinkGraphComponent *graph);
+
+private:
+	int32 max_distance; ///< maximum distance possible on the map
+	int32 mod_dist;     ///< distance modifier, determines how much demands decrease with distance
+	int32 accuracy;     ///< accuracy of the calculation
+
+	template<class Tscaler>
+	void CalcDemand(LinkGraphComponent *graph, Tscaler scaler);
+};
+
+/**
+ * Stateless, thread safe demand hander. Doesn't do anything but call DemandCalculator.
+ */
+class DemandHandler : public ComponentHandler {
+public:
+
+	/**
+	 * Call the demand calculator on the given component-
+	 * @param graph the component to calculate the demands for.
+	 */
+	virtual void Run(LinkGraphComponent *graph)
+		{DemandCalculator c(graph);}
+
+	/**
+	 * Virtual destructor has to be defined because of virtual Run().
+	 */
+	virtual ~DemandHandler() {}
+};
+
+#endif /* DEMANDS_H_ */
diff --git a/src/linkgraph/linkgraph.cpp b/src/linkgraph/linkgraph.cpp
new file mode 100644
index 0000000..3fb973d
--- /dev/null
+++ b/src/linkgraph/linkgraph.cpp
@@ -0,0 +1,361 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph.cpp Definition of link graph classes used for cargo distribution. */
+
+#include "linkgraph.h"
+#include "demands.h"
+#include "../variables.h"
+#include "../map_func.h"
+#include "../core/bitmath_func.hpp"
+#include "../debug.h"
+#include "../moving_average.h"
+#include <queue>
+
+/**
+ * Global array of link graphs, one for each cargo.
+ */
+LinkGraph _link_graphs[NUM_CARGO];
+
+/**
+ * Handlers to be run for each job.
+ */
+LinkGraphJob::HandlerList LinkGraphJob::_handlers;
+
+/**
+ * Create a node.
+ * @param st ID of the associated station
+ * @param sup supply of cargo at the station last month
+ * @param dem acceptance for cargo at the station
+ */
+FORCEINLINE void Node::Init(StationID st, uint sup, uint dem)
+{
+	this->supply = sup;
+	this->undelivered_supply = sup;
+	this->demand = dem;
+	this->station = st;
+}
+
+/**
+ * Create an edge.
+ * @param distance length of the link as manhattan distance
+ * @param capacity capacity of the link
+ */
+FORCEINLINE void Edge::Init(uint distance, uint capacity)
+{
+	this->distance = distance;
+	this->capacity = capacity;
+	this->demand = 0;
+}
+
+
+/**
+ * 1. Build the link graph component containing the given station by using BFS on the link stats.
+ * 2. Set every included station's last_component to the new component's ID (this->current_component_id).
+ * 3. Start a link graph job with the new component.
+ * @param first Station to start the search at
+ */
+void LinkGraph::CreateComponent(Station *first)
+{
+	std::map<Station *, NodeID> index;
+	index[first] = this->AddNode(first);
+
+	std::queue<Station *> search_queue;
+	search_queue.push(first);
+
+	/* find all stations belonging to the current component */
+	while(!search_queue.empty()) {
+		Station *source = search_queue.front();
+		search_queue.pop();
+
+		LinkStatMap &links = source->goods[this->cargo].link_stats;
+		for(LinkStatMap::iterator i = links.begin(); i != links.end(); ++i) {
+			Station *target = Station::GetIfValid(i->first);
+			if (target == NULL) continue;
+
+			std::map<Station *, NodeID>::iterator index_it = index.find(target);
+			if (index_it == index.end()) {
+				search_queue.push(target);
+				NodeID node = this->AddNode(target);
+				index[target] = node;
+
+				this->AddEdge(index[source], node,	i->second.Capacity());
+			} else {
+				this->AddEdge(index[source], index_it->second,	i->second.Capacity());
+			}
+		}
+	}
+
+	/* here the list of nodes and edges for this component is complete. */
+	this->SpawnThread();
+}
+
+/**
+ * Looks for a suitable station to create the next link graph component from.
+ * Linearly searches all stations starting from current_station_id for one that
+ * hasn't been visited in this run over the link graph. The current run and the
+ * last run are differentiated by giving the components IDs divisible by 2
+ * every second run and ones not divisible by 2 on the other runs.
+ *
+ * If such a station is found current_station_id is set to that station's ID
+ * and CreateComponent is called with it.
+ *
+ * The search wraps around and changes current_component_id to 0 or 1
+ * accordingly. If the starting point is reached again it stops.
+ */
+void LinkGraph::NextComponent()
+{
+	if (this->GetSize() > 0) return; // don't mess with running jobs (might happen when changing interval)
+	StationID last_station_id = this->current_station_id;
+	LinkGraphComponentID current_component_id = this->LinkGraphComponent::index;
+
+	do {
+		if (++this->current_station_id >= Station::GetPoolSize()) {
+			/* Wrap around and recycle the component IDs. Use different
+			 * divisibility by 2 than in the last run so that we can find out
+			 * which stations haven't been seen in this run.
+			 */
+			this->current_station_id = 0;
+			if (current_component_id % 2 == 0) {
+				current_component_id = 1;
+			} else {
+				current_component_id = 0;
+			}
+		}
+
+		/* find first station of next component */
+		Station *station = Station::GetIfValid(this->current_station_id);
+		if (station != NULL) {
+			GoodsEntry &ge = station->goods[this->cargo];
+			if (ge.last_component == INVALID_LINKGRAPH_COMPONENT ||
+					(ge.last_component + current_component_id) % 2 != 0) {
+				/* Different divisibility by 2: This station has not been seen
+				 * in the current run over the link graph.
+				 */
+
+				if (!ge.link_stats.empty()) {
+					this->LinkGraphComponent::Init(current_component_id + 2);
+					CreateComponent(station);
+					return;
+				}
+			}
+		}
+
+	} while (this->current_station_id != last_station_id);
+}
+
+/**
+ * Spawn or join a link graph component if any link graph is due to do so.
+ * Spawning is done on COMPONENTS_SPAWN_TICK every day, joining on
+ * COMPONENT_JOIN_TICK. Each link graph is due every recalc_interval days.
+ */
+void OnTick_LinkGraph()
+{
+	if (_date_fract == LinkGraph::COMPONENTS_SPAWN_TICK ||
+			_date_fract == LinkGraph::COMPONENTS_JOIN_TICK) {
+
+		LinkGraphSettings &settings = _settings_game.linkgraph;
+
+		/* This creates a fair distribution of all link graphs' turns over
+		 * the available dates.
+		 */
+		uint interval = settings.recalc_interval;
+		for (uint cargo = _date % interval; cargo < CT_END; cargo += interval) {
+
+			/* don't calculate a link graph if the distribution is manual */
+			if (settings.GetDistributionType(cargo) == DT_MANUAL) continue;
+
+			if (_date_fract == LinkGraph::COMPONENTS_SPAWN_TICK) {
+				_link_graphs[cargo].NextComponent();
+			} else /* LinkGraph::COMPONENTS_JOIN_TICK */ {
+				_link_graphs[cargo].Join();
+			}
+		}
+	}
+}
+
+/**
+ * Add a node to the component and create empty edges associated with it. Set
+ * the station's last_component to this component. Calculate the distances to all
+ * other nodes. The distances to _all_ nodes are important as the demand
+ * calculator relies on their availability.
+ * @param st the new node's station
+ * @return the new node's ID
+ */
+NodeID LinkGraphComponent::AddNode(Station *st)
+{
+	GoodsEntry &good = st->goods[this->cargo];
+	good.last_component = this->index;
+
+	bool do_resize = (this->nodes.size() == this->num_nodes);
+
+	if (do_resize) {
+		this->nodes.push_back(Node());
+		this->edges.push_back(std::vector<Edge>(this->num_nodes + 1));
+	}
+
+	this->nodes[this->num_nodes].Init(st->index, good.supply,
+			HasBit(good.acceptance_pickup, GoodsEntry::ACCEPTANCE));
+
+	std::vector<Edge> &new_edges = this->edges[this->num_nodes];
+	for(NodeID i = 0; i < this->num_nodes; ++i) {
+		uint distance = DistanceManhattan(st->xy, Station::Get(this->nodes[i].station)->xy);
+		if (do_resize) this->edges[i].push_back(Edge());
+		new_edges[i].Init(distance);
+		this->edges[i][this->num_nodes].Init(distance);
+	}
+
+	return this->num_nodes++;
+}
+
+/**
+ * Fill an edge with values from a link.
+ * @param from source node of the link
+ * @param to destination node of the link
+ * @param capacity capacity of the link
+ */
+FORCEINLINE void LinkGraphComponent::AddEdge(NodeID from, NodeID to, uint capacity)
+{
+	assert(from != to);
+	this->edges[from][to].capacity = capacity;
+}
+
+/**
+ * Resize the component and fill it with empty nodes and edges. Used when
+ * loading from save games.
+ *
+ * WARNING: The nodes and edges are expected to contain anything while
+ * num_nodes is expected to contain the desired size. Normally this is an
+ * invalid state, but just after loading the component's structure it is valid.
+ * This method should only be called from Load_LGRP.
+ */
+void LinkGraphComponent::SetSize()
+{
+	if (this->nodes.size() < this->num_nodes) {
+		this->nodes.resize(this->num_nodes);
+		this->edges.resize(this->num_nodes, std::vector<Edge>(this->num_nodes));
+	}
+
+	for(uint i = 0; i < this->num_nodes; ++i) {
+		this->nodes[i].Init();
+		for (uint j = 0; j < this->num_nodes; ++j) {
+			this->edges[i][j].Init();
+		}
+	}
+}
+
+/**
+ * Create an empty component.
+ */
+LinkGraphComponent::LinkGraphComponent() :
+		settings(_settings_game.linkgraph),
+		cargo(INVALID_CARGO),
+		num_nodes(0),
+		index(INVALID_LINKGRAPH_COMPONENT)
+{}
+
+/**
+ * (re-)initialize this component with a new ID and a new copy of the settings.
+ */
+void LinkGraphComponent::Init(LinkGraphComponentID id)
+{
+	assert(this->num_nodes == 0);
+	this->index = id;
+	this->settings = _settings_game.linkgraph;
+}
+
+/**
+ * Merge the current job's results into the main game state.
+ */
+void LinkGraph::Join()
+{
+	this->LinkGraphJob::Join();
+
+	this->LinkGraphComponent::Clear();
+}
+
+/**
+ * Run all handlers for the given Job.
+ * @param j a pointer to a link graph job
+ */
+/* static */ void LinkGraphJob::RunLinkGraphJob(void *j)
+{
+	LinkGraphJob *job = (LinkGraphJob *)j;
+	for (HandlerList::iterator i = _handlers.begin(); i != _handlers.end(); ++i) {
+		(*i)->Run(job);
+	}
+}
+
+/**
+ * Clear the handlers.
+ */
+/* static */ void LinkGraphJob::ClearHandlers()
+{
+	for(HandlerList::iterator i = _handlers.begin(); i != _handlers.end(); ++i) {
+		delete (*i);
+	}
+	_handlers.clear();
+}
+
+/**
+ * Join the calling thread with this job's thread if threading is enabled.
+ */
+FORCEINLINE void LinkGraphJob::Join() {
+	if (this->thread != NULL) {
+		this->thread->Join();
+		delete this->thread;
+		this->thread = NULL;
+	}
+}
+
+/**
+ * Spawn a thread if possible and run the link graph job in the thread. If
+ * that's not possible run the job right now in the current thread.
+ */
+void LinkGraphJob::SpawnThread()
+{
+	assert(this->thread == NULL);
+	if (!ThreadObject::New(&(LinkGraphJob::RunLinkGraphJob), this, &(this->thread))) {
+		this->thread = NULL;
+		/* Of course this will hang a bit.
+		 * On the other hand, if you want to play games which make this hang noticably
+		 * on a platform without threads then you'll probably get other problems first.
+		 * OK:
+		 * If someone comes and tells me that this hangs for him/her, I'll implement a
+		 * smaller grained "Step" method for all handlers and add some more ticks where
+		 * "Step" is called. No problem in principle.
+		 */
+		LinkGraphJob::RunLinkGraphJob(this);
+	}
+}
+
+/**
+ * (Re-)Initialize the link graph: join all jobs and set current_station_id and
+ * cargo to their start values.
+ * @param cargo the new cargo ID for the link graph
+ */
+void LinkGraph::Init(CargoID cargo)
+{
+	this->LinkGraphJob::Join();
+	this->LinkGraphComponent::Clear();
+
+	this->current_station_id = 0;
+	this->LinkGraphComponent::cargo = cargo;
+}
+
+/**
+ * Inititialize all link graphs. Used when loading a game.
+ */
+void InitializeLinkGraphs()
+{
+	for (CargoID c = CT_BEGIN; c != CT_END; ++c) _link_graphs[c].Init(c);
+
+	LinkGraphJob::ClearHandlers();
+	LinkGraphJob::AddHandler(new DemandHandler);
+}
diff --git a/src/linkgraph/linkgraph.h b/src/linkgraph/linkgraph.h
new file mode 100644
index 0000000..a929891
--- /dev/null
+++ b/src/linkgraph/linkgraph.h
@@ -0,0 +1,246 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph.h Declaration of link graph classes used for cargo distribution. */
+
+#ifndef LINKGRAPH_H_
+#define LINKGRAPH_H_
+
+#include "../stdafx.h"
+#include "../station_base.h"
+#include "../cargo_type.h"
+#include "../thread/thread.h"
+#include "../settings_type.h"
+#include "../date_func.h"
+#include "linkgraph_type.h"
+#include <list>
+#include <vector>
+
+struct SaveLoad;
+
+/**
+ * Node of the link graph. contains all relevant information from the associated
+ * station. It's copied so that the link graph job can work on its own data set
+ * in a separate thread.
+ */
+class Node {
+public:
+	uint supply;             ///< supply at the station
+	uint undelivered_supply; ///< amount of supply that hasn't been distributed yet
+	uint demand;             ///< acceptance at the station
+	StationID station;       ///< the station's ID
+
+	void Init(StationID st = INVALID_STATION, uint sup = 0, uint dem = 0);
+};
+
+/**
+ * An edge in the link graph. Corresponds to a link between two stations.
+ */
+class Edge {
+public:
+	uint distance; ///< length of the link
+	uint capacity; ///< capacity of the link
+	uint demand;   ///< transport demand between the nodes
+
+	void Init(uint distance = 0, uint capacity = 0);
+};
+
+/**
+ * A connected component of a link graph. Contains a complete set of stations
+ * connected by links as nodes and edges. Each component also holds a copy of
+ * the link graph settings at the time of its creation. The global settings
+ * might change between the creation and join time so we can't rely on them.
+ */
+class LinkGraphComponent {
+private:
+	typedef std::vector<Node> NodeVector;
+	typedef std::vector<std::vector<Edge> > EdgeMatrix;
+
+public:
+	LinkGraphComponent();
+
+	void Init(LinkGraphComponentID id);
+
+	/**
+	 * Get a reference to an edge.
+	 * @param from the origin node
+	 * @param the destination node
+	 * @return the edge between from and to
+	 */
+	FORCEINLINE Edge &GetEdge(NodeID from, NodeID to)
+	{
+		return this->edges[from][to];
+	}
+
+	/**
+	 * Get a reference to a node with the specified id.
+	 * @param num ID of the node
+	 * @return the requested node
+	 */
+	FORCEINLINE Node &GetNode(NodeID num)
+	{
+		return this->nodes[num];
+	}
+
+	/**
+	 * Get the current size of the component.
+	 * @return the size
+	 */
+	FORCEINLINE uint GetSize() const
+	{
+		return this->num_nodes;
+	}
+
+	void SetSize();
+
+	NodeID AddNode(Station *st);
+
+	void AddEdge(NodeID from, NodeID to, uint capacity);
+
+	/**
+	 * Get the ID of this component.
+	 * @return the ID
+	 */
+	FORCEINLINE LinkGraphComponentID GetIndex() const
+	{
+		return this->index;
+	}
+
+	/**
+	 * Get the cargo ID this component's link graph refers to.
+	 * @return the cargo ID
+	 */
+	FORCEINLINE CargoID GetCargo() const
+	{
+		return this->cargo;
+	}
+
+	/**
+	 * Get the link graph settings for this component.
+	 * @return the settings
+	 */
+	FORCEINLINE const LinkGraphSettings &GetSettings() const
+	{
+		return this->settings;
+	}
+
+	/**
+	 * Mark this component as empty.
+	 */
+	FORCEINLINE void Clear()
+	{
+		this->num_nodes = 0;
+	}
+
+protected:
+	LinkGraphSettings settings; ///< Copy of _settings_game.linkgraph at creation time
+	CargoID cargo;              ///< Cargo of this component's link graph
+	uint num_nodes;             ///< Number of nodes in the component
+	LinkGraphComponentID index; ///< ID of the component
+	NodeVector nodes;           ///< Nodes in the component
+	EdgeMatrix edges;           ///< Edges in the component
+};
+
+/**
+ * A handler doing "something" on a link graph component. It must not keep any
+ * state as it is called concurrently from different threads.
+ */
+class ComponentHandler {
+public:
+	/**
+	 * Destroy the handler. Must be given due to virtual Run.
+	 */
+	virtual ~ComponentHandler() {}
+
+	/**
+	 * Run the handler. A link graph handler must not read or write any data
+	 * outside the given component as that would create a potential desync.
+	 */
+	virtual void Run(LinkGraphComponent *component) = 0;
+};
+
+/**
+ * A job to be executed on a link graph component. It inherits a component and
+ * keeps a static list of handlers to be run on it. It may or may not run in a
+ * thread and contains a thread object for this option.
+ */
+class LinkGraphJob : public LinkGraphComponent {
+private:
+	typedef std::list<ComponentHandler *> HandlerList;
+
+public:
+
+	LinkGraphJob() : thread(NULL) {}
+
+	/**
+	 * Destructor; Clean up the thread if it's there.
+	 */
+	~LinkGraphJob()
+	{
+		this->Join();
+	}
+
+	static void RunLinkGraphJob(void *j);
+
+	/**
+	 * Add a handler to the end of the list.
+	 * @param handler the handler to be added
+	 */
+	static void AddHandler(ComponentHandler *handler)
+	{
+		LinkGraphJob::_handlers.push_back(handler);
+	}
+
+	static void ClearHandlers();
+
+	void SpawnThread();
+
+	void Join();
+
+private:
+	static HandlerList _handlers;   ///< Handlers the job is executing
+	ThreadObject *thread;           ///< Thread the job is running in or NULL if it's running in the main thread
+
+	/**
+	 * Private Copy-Constructor: there cannot be two identical LinkGraphJobs.
+	 * @param other hypothetical other job to be copied.
+	 */
+	LinkGraphJob(const LinkGraphJob &other) {NOT_REACHED();}
+};
+
+/**
+ * A link graph, inheriting one job.
+ */
+class LinkGraph : public LinkGraphJob {
+public:
+	static const uint COMPONENTS_JOIN_TICK  = 21; ///< tick when jobs are joined every day
+	static const uint COMPONENTS_SPAWN_TICK = 58; ///< tick when jobs are spawned every day
+
+	/**
+	 * Create a link graph.
+	 */
+	LinkGraph() : current_station_id(0) {}
+
+	void Init(CargoID cargo);
+
+	void NextComponent();
+
+	void Join();
+
+private:
+	StationID current_station_id; ///< ID of the last station examined while creating components
+
+	friend const SaveLoad *GetLinkGraphDesc();
+
+	void CreateComponent(Station *first);
+};
+
+extern LinkGraph _link_graphs[NUM_CARGO];
+
+#endif /* LINKGRAPH_H_ */
diff --git a/src/linkgraph/linkgraph_type.h b/src/linkgraph/linkgraph_type.h
new file mode 100644
index 0000000..cd73b1c
--- /dev/null
+++ b/src/linkgraph/linkgraph_type.h
@@ -0,0 +1,36 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_type.h Declaration of link graph types used for cargo distribution. */
+
+#ifndef LINKGRAPH_TYPE_H_
+#define LINKGRAPH_TYPE_H_
+
+typedef uint16 LinkGraphComponentID;
+static const LinkGraphComponentID INVALID_LINKGRAPH_COMPONENT = UINT16_MAX;
+
+typedef uint NodeID;
+static const NodeID INVALID_NODE = UINT_MAX;
+
+enum DistributionType {
+	DT_BEGIN = 0,
+	DT_SYMMETRIC = 0, ///< symmetric distribution. The same amount of cargo travels in each direction between each pair of nodes.
+	DT_ASYMMETRIC,    ///< asymmetric distribution. Usually cargo will only travel in one direction.
+	DT_MANUAL,        ///< manual distribution. No link graph calculations are run.
+	DT_NUM = 3,
+	DT_END = 3
+};
+
+/* It needs to be 8bits, because we save and load it as such
+ * Define basic enum properties
+ */
+template <> struct EnumPropsT<DistributionType> : MakeEnumPropsT<DistributionType, byte, DT_BEGIN, DT_END, DT_NUM> {};
+typedef TinyEnumT<DistributionType> DistributionTypeByte; // typedefing-enumification of DistributionType
+
+#endif /* LINKGRAPH_TYPE_H_ */
diff --git a/src/misc.cpp b/src/misc.cpp
index 2d8c6b0..2ea9efd 100644
--- a/src/misc.cpp
+++ b/src/misc.cpp
@@ -54,6 +54,7 @@ void InitializeCompanies();
 void InitializeCheats();
 void InitializeNPF();
 void InitializeOldNames();
+void InitializeLinkGraphs();
 
 void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settings)
 {
@@ -116,6 +117,7 @@ void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settin
 #endif /* ENABLE_NETWORK */
 	InitializeAnimatedTiles();
 
+	InitializeLinkGraphs();
 	InitializeEconomy();
 
 	ResetObjectToPlace();
diff --git a/src/moving_average.cpp b/src/moving_average.cpp
new file mode 100644
index 0000000..d164025
--- /dev/null
+++ b/src/moving_average.cpp
@@ -0,0 +1,27 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.cpp Implementation of moving average functions */
+
+
+#include "moving_average.h"
+#include "variables.h"
+#include "station_base.h"
+
+template <class Titem> void RunAverages()
+{
+	for(uint id = _tick_counter % DAY_TICKS; id < Titem::GetPoolSize(); id += DAY_TICKS) {
+		Titem *item = Titem::GetIfValid(id);
+		if (item != NULL) {
+			item->RunAverages();
+		}
+	}
+}
+
+template void RunAverages<Station>();
diff --git a/src/moving_average.h b/src/moving_average.h
new file mode 100644
index 0000000..7beca5e
--- /dev/null
+++ b/src/moving_average.h
@@ -0,0 +1,45 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.h Utility class for moving averages. */
+
+#ifndef MOVING_AVERAGE_H_
+#define MOVING_AVERAGE_H_
+
+#include "stdafx.h"
+#include "settings_type.h"
+#include "core/math_func.hpp"
+
+template<class Tvalue>
+class MovingAverage {
+protected:
+	uint length;
+
+public:
+	FORCEINLINE MovingAverage(uint length) : length(length)
+		{assert(this->length > 0);}
+
+	FORCEINLINE uint Length() const
+		{return this->length;}
+
+	FORCEINLINE Tvalue Monthly(const Tvalue &value) const
+		{return value * 30 / (this->length);}
+
+	FORCEINLINE Tvalue &Decrease(Tvalue &value) const
+	{
+		value *= this->length;
+		value /= (this->length + 1);
+		return value;
+	}
+};
+
+template<class Titem> void RunAverages();
+
+#endif /* MOVING_AVERAGE_H_ */
+
diff --git a/src/openttd.cpp b/src/openttd.cpp
index 0c04838..5e54270 100644
--- a/src/openttd.cpp
+++ b/src/openttd.cpp
@@ -1076,6 +1076,16 @@ void SwitchToMode(SwitchMode new_mode)
 		default: NOT_REACHED();
 	}
 
+	LinkGraphSettings &lg = _settings_game.linkgraph;
+	if (!_settings_client.gui.new_nonstop) {
+		if ((lg.distribution_armoured | lg.distribution_default |
+				lg.distribution_express | lg.distribution_mail |
+				lg.distribution_pax) != DT_MANUAL) {
+			ShowErrorMessage(STR_WARNING_NONSTOP_CARGODIST, INVALID_STRING_ID,
+					WL_WARNING, 0, true);
+		}
+	}
+
 	if (_switch_mode_errorstr != INVALID_STRING_ID) {
 		ShowErrorMessage(_switch_mode_errorstr, INVALID_STRING_ID, WL_CRITICAL);
 	}
diff --git a/src/order_base.h b/src/order_base.h
index 3e74f4c..71783e1 100644
--- a/src/order_base.h
+++ b/src/order_base.h
@@ -261,6 +261,8 @@ struct OrderList : OrderListPool::PoolItem<&_orderlist_pool> {
 private:
 	friend void AfterLoadVehicles(bool part_of_load); ///< For instantiating the shared vehicle chain
 	friend const struct SaveLoad *GetOrderListDescription(); ///< Saving and loading of order lists.
+	const Order * GetNext(const Order * curr) const;
+	const Order * GetNextStoppingOrder(const Order * next, uint hops, bool check_nonstop) const;
 
 	Order *first;                   ///< First order of the order list
 	VehicleOrderID num_orders;      ///< NOSAVE: How many orders there are in the list
@@ -310,6 +312,8 @@ public:
 	 */
 	inline Order *GetLastOrder() const { return this->GetOrderAt(this->num_orders - 1); }
 
+	StationID GetNextStoppingStation(VehicleOrderID curr, bool check_nonstop) const;
+
 	/**
 	 * Get number of orders in the order list.
 	 * @return number of orders in the chain. */
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
index 25b9162..23c0c5a 100644
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -258,6 +258,67 @@ Order *OrderList::GetOrderAt(int index) const
 	return order;
 }
 
+const Order * OrderList::GetNext(const Order * curr) const
+{
+	const Order * next = curr->next;
+	if (next == NULL) {
+		next = GetFirstOrder();
+	}
+	return next;
+}
+
+const Order * OrderList::GetNextStoppingOrder(const Order * next, uint hops, bool check_nonstop) const
+{
+	if (next == NULL || hops > GetNumOrders()) {
+		return NULL;
+	}
+
+	if (next->GetType() == OT_CONDITIONAL) {
+		const Order * skip_to = GetNextStoppingOrder(GetOrderAt(next->GetConditionSkipToOrder()), hops + 1, check_nonstop);
+		const Order * advance = GetNextStoppingOrder(next, hops + 1, check_nonstop);
+		if (skip_to == advance) {
+			return skip_to; // skipping over non-stopping orders
+		} else {
+			return NULL; // nondeterministic
+		}
+	}
+
+	bool is_station = (next->GetType() == OT_GOTO_STATION);
+
+	if (check_nonstop) {
+		switch(next->GetNonStopType()) {
+		case ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS:
+			if (is_station) return next; // else fall through
+		case ONSF_NO_STOP_AT_ANY_STATION:
+			return GetNextStoppingOrder(GetNext(next), hops + 1, check_nonstop);
+		default: // nondeterministic
+			return NULL;
+		}
+	} else {
+		if (is_station) {
+			return next;
+		} else {
+			return GetNextStoppingOrder(GetNext(next), hops + 1, check_nonstop);
+		}
+	}
+}
+
+StationID OrderList::GetNextStoppingStation(VehicleOrderID curr_id, bool check_nonstop) const {
+	const Order * curr = GetOrderAt(curr_id);
+	if (curr == NULL) {
+		curr = GetFirstOrder();
+		if (curr == NULL) {
+			return INVALID_STATION;
+		}
+	}
+	const Order * next = GetNextStoppingOrder(GetNext(curr), 1, check_nonstop);
+	if (next == NULL) {
+		return INVALID_STATION;
+	} else {
+		return next->GetDestination();
+	}
+}
+
 void OrderList::InsertOrderAt(Order *new_order, int index)
 {
 	if (this->first == NULL) {
@@ -691,6 +752,8 @@ CommandCost CmdInsertOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 			}
 			/* Update any possible open window of the vehicle */
 			InvalidateVehicleOrder(u, INVALID_VEH_ORDER_ID | (sel_ord << 8));
+
+			RecalcFrozenIfLoading(u);
 		}
 
 		/* As we insert an order, the order to skip to will be 'wrong'. */
@@ -725,6 +788,9 @@ static CommandCost DecloneOrder(Vehicle *dst, DoCommandFlag flags)
 	if (flags & DC_EXEC) {
 		DeleteVehicleOrders(dst);
 		InvalidateVehicleOrder(dst, -1);
+
+		RecalcFrozenIfLoading(dst);
+
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(dst->type), 0);
 	}
 	return CommandCost();
@@ -777,6 +843,8 @@ CommandCost CmdDeleteOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 
 			/* Update any possible open window of the vehicle */
 			InvalidateVehicleOrder(u, sel_ord | (INVALID_VEH_ORDER_ID << 8));
+
+			RecalcFrozenIfLoading(u);
 		}
 
 		/* As we delete an order, the order to skip to will be 'wrong'. */
@@ -821,10 +889,10 @@ CommandCost CmdSkipToOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 	if (ret.Failed()) return ret;
 
 	if (flags & DC_EXEC) {
-		v->cur_order_index = sel_ord;
-
 		if (v->current_order.IsType(OT_LOADING)) v->LeaveStation();
 
+		v->cur_order_index = sel_ord;
+
 		InvalidateVehicleOrder(v, -2);
 	}
 
@@ -889,6 +957,8 @@ CommandCost CmdMoveOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 			assert(v->orders.list == u->orders.list);
 			/* Update any possible open window of the vehicle */
 			InvalidateVehicleOrder(u, moving_order | (target_order << 8));
+
+			RecalcFrozenIfLoading(u);
 		}
 
 		/* As we move an order, the order to skip to will be 'wrong'. */
@@ -1142,6 +1212,8 @@ CommandCost CmdModifyOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 				u->current_order.SetLoadType(order->GetLoadType());
 			}
 			InvalidateVehicleOrder(u, -2);
+
+			RecalcFrozenIfLoading(u);
 		}
 	}
 
@@ -1271,6 +1343,8 @@ CommandCost CmdCloneOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 		default: return CMD_ERROR;
 	}
 
+	RecalcFrozenIfLoading(dst);
+
 	return CommandCost();
 }
 
@@ -1577,6 +1651,8 @@ void RemoveOrderFromAllVehicles(OrderType type, DestinationID destination)
 					/* In GUI, simulate by removing the order and adding it back */
 					InvalidateVehicleOrder(w, id | (INVALID_VEH_ORDER_ID << 8));
 					InvalidateVehicleOrder(w, (INVALID_VEH_ORDER_ID << 8) | id);
+
+					RecalcFrozenIfLoading(w);
 				}
 			}
 		}
@@ -1620,6 +1696,8 @@ void DeleteVehicleOrders(Vehicle *v, bool keep_orderlist)
 		v->orders.list->FreeChain(keep_orderlist);
 		if (!keep_orderlist) v->orders.list = NULL;
 	}
+
+	RecalcFrozenIfLoading(v);
 }
 
 uint16 GetServiceIntervalClamped(uint interval, CompanyID company_id)
@@ -1820,7 +1898,7 @@ bool ProcessOrders(Vehicle *v)
 	if (((v->current_order.IsType(OT_GOTO_STATION) && (v->current_order.GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION)) || v->current_order.IsType(OT_GOTO_WAYPOINT)) &&
 			IsTileType(v->tile, MP_STATION) &&
 			v->current_order.GetDestination() == GetStationIndex(v->tile)) {
-		if (v->current_order.IsType(OT_GOTO_STATION)) v->last_station_visited = v->current_order.GetDestination();
+		/* treat it like a waypoint and don't set last_station_visited */
 		UpdateVehicleTimetable(v, true);
 		v->IncrementOrderIndex();
 	}
diff --git a/src/roadveh_cmd.cpp b/src/roadveh_cmd.cpp
index f207efa..4a2f98b 100644
--- a/src/roadveh_cmd.cpp
+++ b/src/roadveh_cmd.cpp
@@ -1459,9 +1459,10 @@ again:
 					v->owner == GetTileOwner(v->tile) && !v->current_order.IsType(OT_LEAVESTATION) &&
 					GetRoadStopType(v->tile) == (v->IsBus() ? ROADSTOP_BUS : ROADSTOP_TRUCK)) {
 				Station *st = Station::GetByTile(v->tile);
+				StationID previous_station = v->last_station_visited;
 				v->last_station_visited = st->index;
 				RoadVehArrivesAt(v, st);
-				v->BeginLoading();
+				v->BeginLoading(previous_station);
 			}
 			return false;
 		}
@@ -1517,12 +1518,12 @@ again:
 			}
 
 			rs->SetEntranceBusy(false);
-
+			StationID previous_station = v->last_station_visited;
 			v->last_station_visited = st->index;
 
 			if (IsDriveThroughStopTile(v->tile) || (v->current_order.IsType(OT_GOTO_STATION) && v->current_order.GetDestination() == st->index)) {
 				RoadVehArrivesAt(v, st);
-				v->BeginLoading();
+				v->BeginLoading(previous_station);
 				return false;
 			}
 		} else {
diff --git a/src/saveload/afterload.cpp b/src/saveload/afterload.cpp
index 4ff9157..7e12df8 100644
--- a/src/saveload/afterload.cpp
+++ b/src/saveload/afterload.cpp
@@ -2117,6 +2117,8 @@ bool AfterLoadGame()
 	InitializeWindowsAndCaches();
 	/* Restore the signals */
 	ResetSignalHandlers();
+
+	AfterLoadLinkGraphs();
 	return true;
 }
 
diff --git a/src/saveload/linkgraph_sl.cpp b/src/saveload/linkgraph_sl.cpp
new file mode 100644
index 0000000..6608ae4
--- /dev/null
+++ b/src/saveload/linkgraph_sl.cpp
@@ -0,0 +1,149 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_sl.cpp Code handling saving and loading of link graphs */
+
+#include "../linkgraph/linkgraph.h"
+#include "../linkgraph/demands.h"
+#include "../settings_internal.h"
+#include "saveload.h"
+#include <vector>
+
+const SettingDesc *GetSettingDescription(uint index);
+
+/**
+ * Get a SaveLoad array for a link graph. The settings struct is derived from
+ * the global settings saveload array. The exact entries are calculated when the function
+ * is called the first time.
+ * @return an array of SaveLoad structs
+ */
+const SaveLoad *GetLinkGraphDesc() {
+
+	static std::vector<SaveLoad> saveloads;
+	static const char *prefix = "linkgraph.";
+
+	/* Build the SaveLoad array on first call and don't touch it later on */
+	if (saveloads.empty()) {
+		size_t offset_gamesettings = cpp_offsetof(GameSettings, linkgraph);
+		size_t offset_component = cpp_offsetof(LinkGraph, settings);
+
+		size_t prefixlen = strlen(prefix);
+
+		int setting = 0;
+		const SettingDesc *desc = GetSettingDescription(setting);
+		while (desc->save.cmd != SL_END) {
+			if (desc->desc.name != NULL && strncmp(desc->desc.name, prefix, prefixlen) == 0) {
+				SaveLoad sl = desc->save;
+				char *&address = reinterpret_cast<char *&>(sl.address);
+				address -= offset_gamesettings;
+				address += offset_component;
+				saveloads.push_back(sl);
+			}
+			desc = GetSettingDescription(++setting);
+		}
+
+		const SaveLoad component_desc[] = {
+			SLE_CONDVAR(LinkGraph, num_nodes,          SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, index,              SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, current_station_id, SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, cargo,              SLE_UINT8,  SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_END()
+		};
+
+		int i = 0;
+		do {
+			saveloads.push_back(component_desc[i++]);
+		} while (saveloads.back().cmd != SL_END);
+	}
+
+	return &saveloads[0];
+}
+
+/* Edges and nodes are saved in the correct order, so we don't need to save their ids. */
+
+/**
+ * SaveLoad desc for a link graph node.
+ */
+static const SaveLoad _node_desc[] = {
+	 SLE_CONDVAR(Node, supply,    SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Node, demand,    SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Node, station,   SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_END()
+};
+
+/**
+ * SaveLoad desc for a link graph edge.
+ */
+static const SaveLoad _edge_desc[] = {
+	 SLE_CONDVAR(Edge, distance,  SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Edge, capacity,  SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_END()
+};
+
+/**
+ * Save/load a component of a link graph
+ * @param comp the component to be saved or loaded
+ */
+static void SaveLoad_LinkGraphComponent(LinkGraphComponent &comp) {
+	uint size = comp.GetSize();
+	for (NodeID from = 0; from < size; ++from) {
+		Node *node = &comp.GetNode(from);
+		SlObject(node, _node_desc);
+		node->undelivered_supply = node->supply;
+		for (NodeID to = 0; to < size; ++to) {
+			SlObject(&comp.GetEdge(from, to), _edge_desc);
+		}
+	}
+}
+
+/**
+ * Save all link graphs.
+ */
+static void DoSave_LGRP(void *)
+{
+	for(CargoID cargo = CT_BEGIN; cargo != CT_END; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		SlObject(&graph, GetLinkGraphDesc());
+		SaveLoad_LinkGraphComponent(graph);
+	}
+}
+
+/**
+ * Load all link graphs.
+ */
+static void Load_LGRP()
+{
+	for(CargoID cargo = CT_BEGIN; cargo != CT_END; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		assert(graph.GetSize() == 0);
+		SlObject(&graph, GetLinkGraphDesc());
+		graph.SetSize();
+		SaveLoad_LinkGraphComponent(graph);
+	}
+}
+
+/**
+ * Spawn the threads for running link graph calculations.
+ * Has to be done after loading as the cargo classes might have changed.
+ */
+void AfterLoadLinkGraphs()
+{
+	for(CargoID cargo = CT_BEGIN; cargo != CT_END; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		if (graph.GetSize() > 0) graph.SpawnThread();
+	}
+}
+
+static void Save_LGRP() {
+	SlAutolength((AutolengthProc*)DoSave_LGRP, NULL);
+}
+
+extern const ChunkHandler _linkgraph_chunk_handlers[] = {
+	{ 'LGRP', Save_LGRP,      Load_LGRP,	NULL,      CH_LAST},
+};
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
index 329ca2a..f089fde 100644
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -46,7 +46,7 @@
 
 #include "saveload_internal.h"
 
-extern const uint16 SAVEGAME_VERSION = 140;
+extern const uint16 SAVEGAME_VERSION = SL_DEMANDS;
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
@@ -128,6 +128,7 @@ extern const ChunkHandler _group_chunk_handlers[];
 extern const ChunkHandler _cargopacket_chunk_handlers[];
 extern const ChunkHandler _autoreplace_chunk_handlers[];
 extern const ChunkHandler _labelmaps_chunk_handlers[];
+extern const ChunkHandler _linkgraph_chunk_handlers[];
 extern const ChunkHandler _airport_chunk_handlers[];
 
 static const ChunkHandler * const _chunk_handlers[] = {
@@ -156,6 +157,7 @@ static const ChunkHandler * const _chunk_handlers[] = {
 	_cargopacket_chunk_handlers,
 	_autoreplace_chunk_handlers,
 	_labelmaps_chunk_handlers,
+	_linkgraph_chunk_handlers,
 	_airport_chunk_handlers,
 	NULL,
 };
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
index 0914a50..c96cd3f 100644
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -79,8 +79,6 @@ enum SLRefType {
 	REF_ORDERLIST     = 8,
 };
 
-#define SL_MAX_VERSION 255
-
 enum {
 	INC_VEHICLE_COMMON = 0,
 };
@@ -338,4 +336,16 @@ bool SaveloadCrashWithMissingNewGRFs();
 
 extern char _savegame_format[8];
 
+/**
+ * save/load versions used for the various branches
+ * SL_TRUNK is always the current trunk version.
+ */
+enum SaveLoadVersions {
+	SL_TRUNK = 140,
+	SL_CAPACITIES = SL_TRUNK + 20,
+	SL_COMPONENTS,
+	SL_DEMANDS = SL_COMPONENTS + 20,
+	SL_MAX_VERSION = 255
+};
+
 #endif /* SAVELOAD_H */
diff --git a/src/saveload/saveload_internal.h b/src/saveload/saveload_internal.h
index b400861..4bf5646 100644
--- a/src/saveload/saveload_internal.h
+++ b/src/saveload/saveload_internal.h
@@ -30,6 +30,7 @@ void AfterLoadVehicles(bool part_of_load);
 void AfterLoadStations();
 void AfterLoadRoadStops();
 void AfterLoadLabelMaps();
+void AfterLoadLinkGraphs();
 void UpdateHousesAndTowns();
 
 void UpdateOldAircraft();
diff --git a/src/saveload/station_sl.cpp b/src/saveload/station_sl.cpp
index a1f12ab..f20a4c1 100644
--- a/src/saveload/station_sl.cpp
+++ b/src/saveload/station_sl.cpp
@@ -205,6 +205,7 @@ static const SaveLoad _old_station_desc[] = {
 };
 
 static uint16 _waiting_acceptance;
+static uint16 _num_links;
 static uint16 _cargo_source;
 static uint32 _cargo_source_xy;
 static uint16 _cargo_days;
@@ -217,6 +218,21 @@ static const SaveLoad _station_speclist_desc[] = {
 	SLE_END()
 };
 
+static StationID _station_id;
+
+const SaveLoad *GetLinkStatDesc() {
+	static const SaveLoad linkstat_desc[] = {
+		SLEG_CONDVAR(             _station_id,         SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    length,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    capacity,            SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    frozen,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(LinkStat,    usage,               SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_END()
+	};
+	
+	return linkstat_desc;
+}
+
 /**
  * Wrapper function to get the GoodsEntry's internal structure while
  * some of the variables itself are private.
@@ -239,7 +255,10 @@ const SaveLoad *GetGoodsDesc()
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_FILE_U32 | SLE_VAR_I64, 14, 64),
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_INT64,                  65, 67),
 		 SLE_CONDLST(GoodsEntry, cargo.packets,       REF_CARGO_PACKET,           68, SL_MAX_VERSION),
-
+		 SLE_CONDVAR(GoodsEntry, supply,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, supply_new,          SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, last_component,      SLE_UINT16,      SL_COMPONENTS, SL_MAX_VERSION),
 		SLE_END()
 	};
 
@@ -379,7 +398,14 @@ static void RealSave_STNN(BaseStation *bst)
 	if (!waypoint) {
 		Station *st = Station::From(bst);
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
-			SlObject(&st->goods[i], GetGoodsDesc());
+			GoodsEntry *ge = &st->goods[i];
+			LinkStatMap &stats = ge->link_stats;
+			_num_links = (uint16)stats.size();
+			SlObject(ge, GetGoodsDesc());
+			for (LinkStatMap::iterator i = stats.begin(); i != stats.end(); ++i) {
+				_station_id = i->first;
+				SlObject(&(i->second), GetLinkStatDesc());
+			}
 		}
 	}
 
@@ -411,7 +437,15 @@ static void Load_STNN()
 		if (!waypoint) {
 			Station *st = Station::From(bst);
 			for (CargoID i = 0; i < NUM_CARGO; i++) {
-				SlObject(&st->goods[i], GetGoodsDesc());
+				GoodsEntry *ge = &st->goods[i];
+				LinkStatMap &stats = ge->link_stats;
+				SlObject(ge, GetGoodsDesc());
+				LinkStat ls;
+				for (uint16 i = 0; i < _num_links; ++i) {
+					SlObject(&ls, GetLinkStatDesc());
+					assert(!ls.IsNull());
+					stats[_station_id] = ls;
+				}
 			}
 		}
 
@@ -435,6 +469,7 @@ static void Ptrs_STNN()
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
 			GoodsEntry *ge = &st->goods[i];
 			SlObject(ge, GetGoodsDesc());
+			// as there are no pointers in the link stats we don't have to consider them
 		}
 		SlObject(st, _station_desc);
 	}
diff --git a/src/settings.cpp b/src/settings.cpp
index ae3e13c..1cf51c1 100644
--- a/src/settings.cpp
+++ b/src/settings.cpp
@@ -1513,7 +1513,7 @@ void DeleteGRFPresetFromConfig(const char *config_name)
 	delete ini;
 }
 
-static const SettingDesc *GetSettingDescription(uint index)
+const SettingDesc *GetSettingDescription(uint index)
 {
 	if (index >= lengthof(_settings)) return NULL;
 	return &_settings[index];
diff --git a/src/settings_gui.cpp b/src/settings_gui.cpp
index 77f1481..6800f72 100644
--- a/src/settings_gui.cpp
+++ b/src/settings_gui.cpp
@@ -1384,6 +1384,20 @@ static SettingEntry _settings_economy[] = {
 /** Economy sub-page */
 static SettingsPage _settings_economy_page = {_settings_economy, lengthof(_settings_economy)};
 
+static SettingEntry _settings_linkgraph[] = {
+	SettingEntry("linkgraph.recalc_interval"),
+	SettingEntry("linkgraph.distribution_pax"),
+	SettingEntry("linkgraph.distribution_mail"),
+	SettingEntry("linkgraph.distribution_express"),
+	SettingEntry("linkgraph.distribution_armoured"),
+	SettingEntry("linkgraph.distribution_default"),
+	SettingEntry("linkgraph.accuracy"),
+	SettingEntry("linkgraph.demand_distance"),
+	SettingEntry("linkgraph.demand_size"),
+};
+/** Linkgraph sub-page */
+static SettingsPage _settings_linkgraph_page = {_settings_linkgraph, lengthof(_settings_linkgraph)};
+
 static SettingEntry _settings_ai_npc[] = {
 	SettingEntry("ai.ai_in_multiplayer"),
 	SettingEntry("ai.ai_disable_veh_train"),
@@ -1476,6 +1490,7 @@ static SettingEntry _settings_main[] = {
 	SettingEntry(&_settings_vehicles_page,     STR_CONFIG_SETTING_VEHICLES),
 	SettingEntry(&_settings_stations_page,     STR_CONFIG_SETTING_STATIONS),
 	SettingEntry(&_settings_economy_page,      STR_CONFIG_SETTING_ECONOMY),
+	SettingEntry(&_settings_linkgraph_page,    STR_CONFIG_SETTING_LINKGRAPH),
 	SettingEntry(&_settings_ai_page,           STR_CONFIG_SETTING_AI),
 };
 
diff --git a/src/settings_type.h b/src/settings_type.h
index 0caca95..9b31836 100644
--- a/src/settings_type.h
+++ b/src/settings_type.h
@@ -17,6 +17,8 @@
 #include "transport_type.h"
 #include "network/core/config.h"
 #include "company_type.h"
+#include "cargotype.h"
+#include "linkgraph/linkgraph_type.h"
 
 /** Settings related to the difficulty of the game */
 struct DifficultySettings {
@@ -352,6 +354,32 @@ struct EconomySettings {
 	uint16 town_noise_population[3];         ///< population to base decision on noise evaluation (@see town_council_tolerance)
 };
 
+struct LinkGraphSettings {
+	uint16 recalc_interval;                     ///< minimum interval (in days) between subsequent calculations of components in the same link graph
+	DistributionTypeByte distribution_pax;      ///< distribution type for passengers
+	DistributionTypeByte distribution_mail;     ///< distribution type for mail
+	DistributionTypeByte distribution_express;  ///< distribution type for express cargo class
+	DistributionTypeByte distribution_armoured; ///< distribution type for armoured cargo class
+	DistributionTypeByte distribution_default;  ///< distribution type for all other goods
+	uint8 accuracy;                             ///< accuracy when calculating things on the link graph. low accuracy => low running time
+	uint8 demand_size;                          ///< influence of supply ("station size") on the demand function
+	uint8 demand_distance;                      ///< influence of distance between stations on the demand function
+
+	FORCEINLINE DistributionType GetDistributionType(CargoID cargo) const {
+		if (IsCargoInClass(cargo, CC_PASSENGERS)) {
+			return this->distribution_pax;
+		} else if (IsCargoInClass(cargo, CC_MAIL)) {
+			return this->distribution_mail;
+		} else if (IsCargoInClass(cargo, CC_EXPRESS)) {
+			return this->distribution_express;
+		} else if (IsCargoInClass(cargo, CC_ARMOURED)) {
+			return this->distribution_armoured;
+		} else {
+			return this->distribution_default;
+		}
+	}
+};
+
 /** Settings related to stations. */
 struct StationSettings {
 	bool   modified_catchment;               ///< different-size catchment areas
@@ -392,6 +420,7 @@ struct GameSettings {
 	OrderSettings        order;              ///< settings related to orders
 	VehicleSettings      vehicle;            ///< options for vehicles
 	EconomySettings      economy;            ///< settings to change the economy
+	LinkGraphSettings    linkgraph;          ///< settings for link graph calculations
 	StationSettings      station;            ///< settings related to station management
 	LocaleSettings       locale;             ///< settings related to used currency/unit system in the current game
 };
diff --git a/src/ship_cmd.cpp b/src/ship_cmd.cpp
index 8e12a9f..090491c 100644
--- a/src/ship_cmd.cpp
+++ b/src/ship_cmd.cpp
@@ -517,13 +517,14 @@ static void ShipController(Ship *v)
 									return;
 								}
 							} else if (v->current_order.IsType(OT_GOTO_STATION)) {
+								StationID previous_station = v->last_station_visited;
 								v->last_station_visited = v->current_order.GetDestination();
 
 								/* Process station in the orderlist. */
 								Station *st = Station::Get(v->current_order.GetDestination());
 								if (st->facilities & FACIL_DOCK) { // ugly, ugly workaround for problem with ships able to drop off cargo at wrong stations
 									ShipArrivesAt(v, st);
-									v->BeginLoading();
+									v->BeginLoading(previous_station);
 								} else { // leave stations without docks right aways
 									v->current_order.MakeLeaveStation();
 									v->IncrementOrderIndex();
diff --git a/src/station.cpp b/src/station.cpp
index 0dcc6da..59d012f 100644
--- a/src/station.cpp
+++ b/src/station.cpp
@@ -69,6 +69,14 @@ Station::~Station()
 		if (a->targetairport == this->index) a->targetairport = INVALID_STATION;
 	}
 
+	Station * st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID c = CT_BEGIN; c != CT_END; ++c) {
+			GoodsEntry & ge = st->goods[c];
+			ge.link_stats.erase(this->index);
+		}
+	}
+
 	Vehicle *v;
 	FOR_ALL_VEHICLES(v) {
 		/* Forget about this station if this station is removed */
diff --git a/src/station_base.h b/src/station_base.h
index 83ef418..937f2b5 100644
--- a/src/station_base.h
+++ b/src/station_base.h
@@ -17,12 +17,102 @@
 #include "newgrf_airport.h"
 #include "cargopacket.h"
 #include "industry_type.h"
+#include "linkgraph/linkgraph_type.h"
+#include "moving_average.h"
+#include <map>
 
 typedef Pool<BaseStation, StationID, 32, 64000> StationPool;
 extern StationPool _station_pool;
 
 static const byte INITIAL_STATION_RATING = 175;
 
+class LinkStat : private MovingAverage<uint> {
+private:
+	/**
+	 * capacity of the link.
+	 * This is a moving average use MovingAverage::Monthly() to get a meaningful value 
+	 */
+	uint capacity;
+	
+	/**
+	 * capacity of currently loading vehicles
+	 */
+	uint frozen;
+	
+	/**
+	 * usage of the link.
+	 * This is a moving average use MovingAverage::Monthly() to get a meaningful value 
+	 */
+	uint usage;
+
+public:
+	static const uint MIN_AVERAGE_LENGTH = 64;
+
+	friend const SaveLoad *GetLinkStatDesc();
+
+	FORCEINLINE LinkStat(uint distance = 1, uint capacity = 0, uint frozen = 0, uint usage = 0) :
+		MovingAverage<uint>(distance), capacity(capacity), frozen(frozen), usage(usage) {}
+
+	FORCEINLINE void Clear()
+	{
+		this->capacity = 0;
+		this->usage = 0;
+		this->frozen = 0;
+	}
+
+	FORCEINLINE void Decrease()
+	{
+		this->MovingAverage<uint>::Decrease(this->usage);
+		this->capacity = max(this->MovingAverage<uint>::Decrease(this->capacity), this->frozen);
+	}
+
+	FORCEINLINE uint Capacity() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->capacity);
+	}
+
+	FORCEINLINE uint Usage() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->usage);
+	}
+
+	FORCEINLINE uint Frozen() const
+	{
+		return this->frozen;
+	}
+
+	FORCEINLINE void Increase(uint capacity, uint usage)
+	{
+		this->capacity += capacity;
+		this->usage += usage;
+	}
+
+	FORCEINLINE void Freeze(uint capacity)
+	{
+		this->frozen += capacity;
+		this->capacity = max(this->frozen, this->capacity);
+	}
+
+	FORCEINLINE void Unfreeze(uint capacity)
+	{
+		this->frozen -= capacity;
+	}
+
+	FORCEINLINE void Unfreeze()
+	{
+		this->frozen = 0;
+	}
+
+	FORCEINLINE bool IsNull() const
+	{
+		return this->capacity == 0;
+	}
+};
+
+typedef std::map<StationID, LinkStat> LinkStatMap;
+
+uint GetMovingAverageLength(const Station *from, const Station *to);
+
 struct GoodsEntry {
 	enum AcceptancePickup {
 		ACCEPTANCE,
@@ -34,7 +124,10 @@ struct GoodsEntry {
 		days_since_pickup(255),
 		rating(INITIAL_STATION_RATING),
 		last_speed(0),
-		last_age(255)
+		last_age(255),
+		supply(0),
+		supply_new(0),
+		last_component(INVALID_LINKGRAPH_COMPONENT)
 	{}
 
 	byte acceptance_pickup;
@@ -42,7 +135,11 @@ struct GoodsEntry {
 	byte rating;
 	byte last_speed;
 	byte last_age;
-	StationCargoList cargo; ///< The cargo packets of cargo waiting in this station
+	StationCargoList cargo;              ///< The cargo packets of cargo waiting in this station
+	uint supply;                         ///< Cargo supplied last month
+	uint supply_new;                     ///< Cargo supplied so far this month
+	LinkStatMap link_stats;              ///< capacities and usage statistics for outgoing links
+	LinkGraphComponentID last_component; ///< the component this station was last part of in this cargo's link graph
 };
 
 /** All airport-related information. Only valid if tile != INVALID_TILE. */
@@ -174,6 +271,8 @@ public:
 	/* virtual */ uint32 GetNewGRFVariable(const ResolverObject *object, byte variable, byte parameter, bool *available) const;
 
 	/* virtual */ void GetTileArea(TileArea *ta, StationType type) const;
+
+	void RunAverages();
 };
 
 #define FOR_ALL_STATIONS(var) FOR_ALL_BASE_STATIONS_OF_TYPE(Station, var)
diff --git a/src/station_cmd.cpp b/src/station_cmd.cpp
index 0b928cf..9df2334 100644
--- a/src/station_cmd.cpp
+++ b/src/station_cmd.cpp
@@ -48,6 +48,7 @@
 #include "core/random_func.hpp"
 #include "company_base.h"
 #include "newgrf.h"
+#include "moving_average.h"
 #include "table/airporttile_ids.h"
 #include "newgrf_airporttiles.h"
 
@@ -3102,6 +3103,120 @@ static void UpdateStationRating(Station *st)
 	}
 }
 
+uint GetMovingAverageLength(const Station *from, const Station *to)
+{
+	return LinkStat::MIN_AVERAGE_LENGTH + (DistanceManhattan(from->xy, to->xy) >> 2);
+}
+
+void Station::RunAverages() {
+	for(int goods_index = CT_BEGIN; goods_index != CT_END; ++goods_index) {
+		GoodsEntry & good = this->goods[goods_index];
+		LinkStatMap & links = good.link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end();) {
+			StationID id = i->first;
+			Station *other = Station::GetIfValid(id);
+			if (other == NULL) {
+				links.erase(i++);
+			} else {
+				LinkStat & ls = i->second;
+				ls.Decrease();
+				if (ls.IsNull()) {
+					links.erase(i++);
+				} else {
+					++i;
+				}
+			}
+		}
+	}
+}
+
+void RecalcFrozenIfLoading(const Vehicle * v) {
+	if (v->current_order.IsType(OT_LOADING)) {
+		RecalcFrozen(Station::Get(v->last_station_visited));
+	}
+}
+
+void RecalcFrozen(Station * st) {
+	if (st->loading_vehicles.empty()) {
+		/* if no vehicles are there the frozen values are always correct */
+		return;
+	}
+
+	for(int goods_index = CT_BEGIN; goods_index != CT_END; ++goods_index) {
+		GoodsEntry & good = st->goods[goods_index];
+		LinkStatMap & links = good.link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end(); ++i) {
+			i->second.Unfreeze();
+		}
+	}
+
+	std::list<Vehicle *>::iterator v_it = st->loading_vehicles.begin();
+	while(v_it != st->loading_vehicles.end()) {
+		const Vehicle * front = *v_it;
+		OrderList * orders = front->orders.list;
+		if (orders != NULL) {
+			StationID next_station_id = orders->GetNextStoppingStation(front->cur_order_index, front->type == VEH_ROAD || front->type == VEH_TRAIN);
+			if (next_station_id != INVALID_STATION && next_station_id != st->index) {
+				IncreaseStats(st, front, next_station_id, true);
+			}
+		}
+		++v_it;
+	}
+}
+
+void DecreaseFrozen(Station *st, const Vehicle *front, StationID next_station_id) {
+	assert(st->index != next_station_id && next_station_id != INVALID_STATION);
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			LinkStatMap & link_stats = st->goods[v->cargo_type].link_stats;
+			LinkStatMap::iterator lstat_it = link_stats.find(next_station_id);
+			if (lstat_it == link_stats.end()) {
+				DEBUG(misc, 1, "frozen not in linkstat list.");
+				RecalcFrozen(st);
+				return;
+			} else {
+				LinkStat & link_stat = lstat_it->second;
+				if (link_stat.Frozen() < v->cargo_cap) {
+					DEBUG(misc, 1, "frozen is smaller than cargo cap.");
+					RecalcFrozen(st);
+					return;
+				} else {
+					link_stat.Unfreeze(v->cargo_cap);
+				}
+				assert(!link_stat.IsNull());
+			}
+		}
+	}
+}
+
+void IncreaseStats(Station *st, const Vehicle *front, StationID next_station_id, bool freeze) {
+	Station *next = Station::GetIfValid(next_station_id);
+	assert(st->index != next_station_id && next != NULL);
+	uint average_length = GetMovingAverageLength(st, next);
+
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->cargo_cap > 0) {
+			LinkStatMap &stats = st->goods[v->cargo_type].link_stats;
+			LinkStatMap::iterator i = stats.find(next_station_id);
+			if (i == stats.end()) {
+				stats.insert(std::make_pair(next_station_id, LinkStat(
+					average_length, v->cargo_cap,
+					freeze ? v->cargo_cap : 0,
+					freeze ? 0 : v->cargo.Count()
+				)));
+			} else {
+				LinkStat & link_stat = i->second;
+				if (freeze) {
+					link_stat.Freeze(v->cargo_cap);
+				} else {
+					link_stat.Increase(v->cargo_cap, v->cargo.Count());
+				}
+				assert(!link_stat.IsNull());
+			}
+		}
+	}
+}
+
 /* called for every station each tick */
 static void StationHandleSmallTick(BaseStation *st)
 {
@@ -3118,10 +3233,12 @@ void OnTick_Station()
 {
 	if (_game_mode == GM_EDITOR) return;
 
+	RunAverages<Station>();
+
 	BaseStation *st;
 	FOR_ALL_BASE_STATIONS(st) {
 		StationHandleSmallTick(st);
-
+		
 		/* Run 250 tick interval trigger for station animation.
 		 * Station index is included so that triggers are not all done
 		 * at the same time. */
@@ -3136,7 +3253,14 @@ void OnTick_Station()
 
 void StationMonthlyLoop()
 {
-	/* not used */
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for(int goods_index = CT_BEGIN; goods_index != CT_END; ++goods_index) {
+			GoodsEntry &good = st->goods[goods_index];
+			good.supply = good.supply_new;
+			good.supply_new = 0;
+		}
+	}
 }
 
 
@@ -3160,8 +3284,10 @@ void ModifyStationRatingAround(TileIndex tile, Owner owner, int amount, uint rad
 
 static void UpdateStationWaiting(Station *st, CargoID type, uint amount, SourceType source_type, SourceID source_id)
 {
-	st->goods[type].cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id));
-	SetBit(st->goods[type].acceptance_pickup, GoodsEntry::PICKUP);
+	GoodsEntry & good = st->goods[type];
+	good.cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id));
+	SetBit(good.acceptance_pickup, GoodsEntry::PICKUP);
+	good.supply_new += amount;
 
 	StationAnimationTrigger(st, st->xy, STAT_ANIM_NEW_CARGO, type);
 	AirportAnimationTrigger(st, AAT_STATION_NEW_CARGO, type);
diff --git a/src/station_func.h b/src/station_func.h
index 2a2d831..1ec2f5f 100644
--- a/src/station_func.h
+++ b/src/station_func.h
@@ -18,6 +18,7 @@
 #include "road_type.h"
 #include "cargo_type.h"
 #include "company_type.h"
+#include "vehicle_base.h"
 
 void ModifyStationRatingAround(TileIndex tile, Owner owner, int amount, uint radius);
 
@@ -49,4 +50,12 @@ bool IsStationTileElectrifiable(TileIndex tile);
 
 void UpdateAirportsNoise();
 
+void DecreaseFrozen(Station *st, const Vehicle *v, StationID next_station_id);
+
+void RecalcFrozen(Station * st);
+
+void RecalcFrozenIfLoading(const Vehicle * v);
+
+void IncreaseStats(Station *st, const Vehicle *v, StationID next_station_id, bool freeze);
+
 #endif /* STATION_FUNC_H */
diff --git a/src/table/settings.h b/src/table/settings.h
index e50cff0..001e68c 100644
--- a/src/table/settings.h
+++ b/src/table/settings.h
@@ -462,6 +462,16 @@ const SettingDesc _settings[] = {
 	 SDT_CONDVAR(GameSettings, economy.town_noise_population[1],    SLE_UINT16, 96, SL_MAX_VERSION, 0, 0,  2000,   400,   65535, 0, STR_NULL,                                  NULL),
 	 SDT_CONDVAR(GameSettings, economy.town_noise_population[2],    SLE_UINT16, 96, SL_MAX_VERSION, 0, 0,  4000,   800,   65535, 0, STR_NULL,                                  NULL),
 
+	 SDT_CONDVAR(GameSettings, linkgraph.recalc_interval,           SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION, 0, 0,16, 1, 4096, 1, STR_CONFIG_SETTING_LINKGRAPH_INTERVAL,     NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.distribution_pax,  SLE_UINT8,SL_COMPONENTS, SL_MAX_VERSION,0,MS,DT_SYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DISTRIBUTION_PAX, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.distribution_mail, SLE_UINT8,SL_COMPONENTS,SL_MAX_VERSION,0,MS,DT_SYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DISTRIBUTION_MAIL, NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.distribution_express,SLE_UINT8,SL_COMPONENTS,SL_MAX_VERSION,0,MS,DT_ASYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DISTRIBUTION_EXPRESS,NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.distribution_armoured,SLE_UINT8,SL_COMPONENTS,SL_MAX_VERSION,0,MS,DT_SYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED,NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.distribution_default,SLE_UINT8,SL_COMPONENTS,SL_MAX_VERSION,0,MS,DT_ASYMMETRIC,DT_BEGIN,DT_NUM-1,1,STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT,NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.accuracy,                   SLE_UINT8,SL_DEMANDS, SL_MAX_VERSION, 0, 0,16,  2,      64, 1, STR_CONFIG_SETTING_LINKGRAPH_ACCURACY,     NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_distance,            SLE_UINT8,SL_DEMANDS, SL_MAX_VERSION, 0, 0,100, 0,     255, 5, STR_CONFIG_SETTING_DEMAND_DISTANCE,        NULL),
+	 SDT_CONDVAR(GameSettings, linkgraph.demand_size,                SLE_UINT8,SL_DEMANDS, SL_MAX_VERSION, 0, 0,100, 0,     100, 5, STR_CONFIG_SETTING_DEMAND_SIZE,            NULL),
+
 	 SDT_CONDVAR(GameSettings, pf.wait_for_pbs_path,                 SLE_UINT8,100, SL_MAX_VERSION, 0, 0,    30,     2,     255, 0, STR_NULL,                                  NULL),
 	SDT_CONDBOOL(GameSettings, pf.reserve_paths,                               100, SL_MAX_VERSION, 0, 0, false,                    STR_NULL,                                  NULL),
 	 SDT_CONDVAR(GameSettings, pf.path_backoff_interval,             SLE_UINT8,100, SL_MAX_VERSION, 0, 0,    20,     1,     255, 0, STR_NULL,                                  NULL),
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
index f1260f7..b522ff2 100644
--- a/src/train_cmd.cpp
+++ b/src/train_cmd.cpp
@@ -2869,6 +2869,7 @@ int Train::UpdateSpeed()
 
 static void TrainEnterStation(Train *v, StationID station)
 {
+	StationID previous_station = v->last_station_visited;
 	v->last_station_visited = station;
 
 	/* check if a train ever visited this station before */
@@ -2885,7 +2886,7 @@ static void TrainEnterStation(Train *v, StationID station)
 		AI::NewEvent(v->owner, new AIEventStationFirstVehicle(st->index, v->index));
 	}
 
-	v->BeginLoading();
+	v->BeginLoading(previous_station);
 
 	StationAnimationTrigger(st, v->tile, STAT_ANIM_TRAIN_ARRIVES);
 }
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index e14d497..6e41e7b 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -1574,7 +1574,7 @@ uint GetVehicleCapacity(const Vehicle *v, uint16 *mail_capacity)
 }
 
 
-void Vehicle::BeginLoading()
+void Vehicle::BeginLoading(StationID last_station_id)
 {
 	assert(IsTileType(tile, MP_STATION) || type == VEH_SHIP);
 
@@ -1594,7 +1594,23 @@ void Vehicle::BeginLoading()
 		current_order.MakeLoading(false);
 	}
 
-	Station::Get(this->last_station_visited)->loading_vehicles.push_back(this);
+	StationID curr_station_id = this->last_station_visited;
+	Station * curr_station = Station::Get(curr_station_id);
+	curr_station->loading_vehicles.push_back(this);
+
+	StationID next_station_id = INVALID_STATION;
+	OrderList * orders = this->orders.list;
+	if (orders != NULL) {
+		next_station_id = orders->GetNextStoppingStation(this->cur_order_index, this->type == VEH_ROAD || this->type == VEH_TRAIN);
+	}
+
+	if (last_station_id != INVALID_STATION && last_station_id != curr_station_id) {
+		IncreaseStats(Station::Get(last_station_id), this, curr_station_id, false);
+	}
+
+	if (next_station_id != INVALID_STATION && next_station_id != curr_station_id) {
+		IncreaseStats(curr_station, this, next_station_id, true);
+	}
 
 	PrepareUnload(this);
 
@@ -1621,6 +1637,17 @@ void Vehicle::LeaveStation()
 	Station *st = Station::Get(this->last_station_visited);
 	st->loading_vehicles.remove(this);
 
+	OrderList * orders = this->orders.list;
+	if (orders != NULL) {
+		StationID next_station_id = orders->GetNextStoppingStation(this->cur_order_index, this->type == VEH_ROAD || this->type == VEH_TRAIN);
+		if (next_station_id != INVALID_STATION && next_station_id != this->last_station_visited) {
+			DecreaseFrozen(st, this, next_station_id);
+		}
+	} else {
+		DEBUG(misc, 1, "orders are NULL");
+		RecalcFrozen(st);
+	}
+
 	HideFillingPercent(&this->fill_percent_te_id);
 
 	if (this->type == VEH_TRAIN && !(this->vehstatus & VS_CRASHED)) {
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index ea626a4..15bf17c 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -193,7 +193,7 @@ public:
 	/** We want to 'destruct' the right class. */
 	virtual ~Vehicle();
 
-	void BeginLoading();
+	void BeginLoading(StationID last_station_id);
 	void LeaveStation();
 
 	/**
