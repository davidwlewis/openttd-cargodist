diff --git a/src/lang/english.txt b/src/lang/english.txt
index 2a3175c..1a82f11 100644
--- a/src/lang/english.txt
+++ b/src/lang/english.txt
@@ -1065,6 +1065,7 @@ STR_CONFIG_SETTING_LOADING_INDICATORS_OWN                       :Own company
 STR_CONFIG_SETTING_LOADING_INDICATORS_ALL                       :All companies
 STR_CONFIG_SETTING_TIMETABLE_ALLOW                              :{LTBLUE}Enable timetabling for vehicles: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_TIMETABLE_IN_TICKS                           :{LTBLUE}Show timetable in ticks rather than days: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_TIMETABLE_SEPARATION                         :{LTBLUE}Use timetable to ensure vehicles separation: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_QUICKGOTO                                    :{LTBLUE}Quick creation of vehicle orders: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_DEFAULT_RAIL_TYPE                            :{LTBLUE}Default rail type (after new game/game load): {ORANGE}{STRING1}
 STR_CONFIG_SETTING_DEFAULT_RAIL_TYPE_RAIL                       :Normal Rail
diff --git a/src/settings_gui.cpp b/src/settings_gui.cpp
index 08ba50b..eb76894 100644
--- a/src/settings_gui.cpp
+++ b/src/settings_gui.cpp
@@ -1355,6 +1355,7 @@ static SettingEntry _settings_vehicles[] = {
 	SettingEntry("vehicle.max_ships"),
 	SettingEntry("vehicle.plane_speed"),
 	SettingEntry("order.timetabling"),
+	SettingEntry("order.timetable_separation"),
 	SettingEntry("vehicle.dynamic_engines"),
 };
 /** Vehicles sub-page */
diff --git a/src/settings_type.h b/src/settings_type.h
index 7e9f3a2..9a59902 100644
--- a/src/settings_type.h
+++ b/src/settings_type.h
@@ -285,6 +285,7 @@ struct OrderSettings {
 	bool   gotodepot;                        ///< allow goto depot in orders
 	bool   no_servicing_if_no_breakdowns;    ///< dont send vehicles to depot when breakdowns are disabled
 	bool   timetabling;                      ///< whether to allow timetabling
+	bool   timetable_separation;             ///< whether to perform automatic separation based on timetable.
 	bool   serviceathelipad;                 ///< service helicopters at helipads automatically (no need to send to depot)
 };
 
diff --git a/src/table/settings.h b/src/table/settings.h
index 5c0756f..b255165 100644
--- a/src/table/settings.h
+++ b/src/table/settings.h
@@ -388,6 +388,7 @@ const SettingDesc _settings[] = {
 	SDT_CONDBOOL(GameSettings, vehicle.disable_elrails,                         38, SL_MAX_VERSION, 0,NN, false,                    STR_CONFIG_SETTING_DISABLE_ELRAILS,        SettingsDisableElrail),
 	 SDT_CONDVAR(GameSettings, vehicle.freight_trains,               SLE_UINT8, 39, SL_MAX_VERSION, 0,NN,     1,     1,     255, 1, STR_CONFIG_SETTING_FREIGHT_TRAINS,         NULL),
 	SDT_CONDBOOL(GameSettings, order.timetabling,                               67, SL_MAX_VERSION, 0, 0,  true,                    STR_CONFIG_SETTING_TIMETABLE_ALLOW,        NULL),
+	SDT_CONDBOOL(GameSettings, order.timetable_separation,                      67, SL_MAX_VERSION, 0, 0,  true,                    STR_CONFIG_SETTING_TIMETABLE_SEPARATION,   NULL),
 	 SDT_CONDVAR(GameSettings, vehicle.plane_speed,                  SLE_UINT8, 90, SL_MAX_VERSION, 0, 0,     4,     1,       4, 0, STR_CONFIG_SETTING_PLANE_SPEED,            NULL),
 	SDT_CONDBOOL(GameSettings, vehicle.dynamic_engines,                         95, SL_MAX_VERSION, 0,NN, false,                    STR_CONFIG_SETTING_DYNAMIC_ENGINES,        ChangeDynamicEngines),
 
diff --git a/src/timetable_cmd.cpp b/src/timetable_cmd.cpp
index 4e12743..55fe921 100644
--- a/src/timetable_cmd.cpp
+++ b/src/timetable_cmd.cpp
@@ -10,6 +10,7 @@
 #include "settings_type.h"
 
 #include "table/strings.h"
+#include "station_map.h"
 
 static void ChangeTimetable(Vehicle *v, VehicleOrderID order_number, uint16 time, bool is_journey)
 {
@@ -161,7 +162,7 @@ CommandCost CmdAutofillTimetable(TileIndex tile, DoCommandFlag flags, uint32 p1,
 			ClrBit(v->vehicle_flags, VF_AUTOFILL_TIMETABLE);
 			ClrBit(v->vehicle_flags, VF_AUTOFILL_PRES_WAIT_TIME);
 		}
-	}
+  }
 
 	for (Vehicle *v2 = v->FirstShared(); v2 != NULL; v2 = v2->NextShared()) {
 		if (v2 != v) {
@@ -222,6 +223,12 @@ void UpdateVehicleTimetable(Vehicle *v, bool travelling)
 			ClrBit(v->vehicle_flags, VF_AUTOFILL_PRES_WAIT_TIME);
 		}
 		return;
+	} else if (travelling && _settings_game.order.timetable_separation && v->PreviousShared() == NULL && timetabled != 0) {
+		/* With separation patch, the first vehicle will continuously updated it's travel times
+		 * in order to smooth changes in the journey */
+		time_taken = (uint)(((timetabled + (int32)(time_taken - timetabled) / 5) / DAY_TICKS)) * DAY_TICKS;
+
+		ChangeTimetable(v, v->cur_order_index, time_taken, travelling);
 	}
 
 	if (just_started) return;
@@ -233,6 +240,12 @@ void UpdateVehicleTimetable(Vehicle *v, bool travelling)
 
 	v->lateness_counter -= (timetabled - time_taken);
 
+  if (travelling && _settings_game.order.timetable_separation && v->PreviousShared() == NULL && v->cur_order_index == 0) {
+      /* With separation patch, the first vehicle will reduce automatically its lateness counter
+       * in order to smooth the one-time problems */
+      v->lateness_counter = (((v->lateness_counter / 2) / DAY_TICKS)) * DAY_TICKS;
+  }
+
 	for (v = v->FirstShared(); v != NULL; v = v->NextShared()) {
 		InvalidateWindow(WC_VEHICLE_TIMETABLE, v->index);
 	}
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index d3bc2eb..68f387d 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -1428,6 +1428,12 @@ void Vehicle::BeginLoading(StationID last_station_id)
 {
 	assert(IsTileType(tile, MP_STATION) || type == VEH_SHIP);
 
+  const bool timetable_separation = _settings_game.order.timetabling &&
+                                    _settings_game.order.timetable_separation &&
+                                    this->IsOrderListShared() &&
+                                    this->PreviousShared() != NULL &&
+                                    this->FirstStopStationOrderID() == this->cur_order_index;
+
 	if (this->current_order.IsType(OT_GOTO_STATION) &&
 			this->current_order.GetDestination() == this->last_station_visited) {
 		current_order.MakeLoading(true);
@@ -1440,16 +1446,68 @@ void Vehicle::BeginLoading(StationID last_station_id)
 		 * that arrives at random stations is bad. */
 		this->current_order.SetNonStopType(ONSF_NO_STOP_AT_ANY_STATION);
 
+		/* We ensure the vehicle is well positionned in the shared order list
+		 * This means the last vehicle from this shared order list that visited the
+		 * station must be its ->prev_shared */
+		if (timetable_separation) {
+			/* Find the previous vehicle of the shared order that visited the station */
+			int min_separation = -1;
+			int tmp_separation = 0;
+			Vehicle *previous = NULL;
+			/* Check for previous vehicles */
+			for (Vehicle *v = this->PreviousShared(); v != NULL; v = v->PreviousShared()) {
+				tmp_separation = this->GetVehicleSeparation(v, false, true);
+				if (min_separation > 0 && tmp_separation < min_separation || min_separation == -1) {
+					min_separation = tmp_separation;
+					previous = v;
+				}
+			}
+			/* Check for next vehicles */
+			for (Vehicle *v = this->NextShared(); v != NULL; v = v->NextShared()) {
+				tmp_separation = this->GetVehicleSeparation(v, false, true);
+				if (min_separation > 0 && tmp_separation < min_separation || min_separation == -1) {
+					min_separation = tmp_separation;
+					previous = v;
+				}
+			}
+
+			/* Check if prev_shared vehicle is really the previous one and reorder the chain if needed */
+			if (this->PreviousShared() != previous && previous != NULL) {
+				/* Remove this vehicle from the list */
+				this->previous_shared->next_shared = this->next_shared;
+				if (this->next_shared != NULL) this->next_shared->previous_shared = this->previous_shared;
+				/* Insert in the list */
+				this->previous_shared = previous;
+				this->next_shared = previous->next_shared;
+				/* Update previous and next */
+				if (previous->next_shared != NULL) previous->next_shared->previous_shared = this;
+				previous->next_shared = this;
+			}
+		}
+
 	} else {
 		current_order.MakeLoading(false);
 	}
 
+	OrderList * orders = this->orders.list;
+	/* For shared orders vehicles other than the first in chain arriving to the
+	 * first order station, we have to recompute the separation */
+	if (timetable_separation) {
+		/* This vehicle have to ensure separation
+		 * Compute wait_time for auto-separation system
+     * The vehicle can leave the station. Fill the lateness counter with
+     * separation informations, and override the actual waiting time. 
+     */
+		this->lateness_counter = -((orders->GetTimetableDurationIncomplete() / orders->GetNumVehicles())
+                           - GetVehicleSeparation(this->PreviousShared(), false, true)
+                           - this->PreviousShared()->lateness_counter);
+	}
+
 	StationID curr_station_id = this->last_station_visited;
 	Station * curr_station = Station::Get(curr_station_id);
 	curr_station->loading_vehicles.push_back(this);
 
 	StationID next_station_id = INVALID_STATION;
-	OrderList * orders = this->orders.list;
 	if (orders != NULL) {
 		next_station_id = orders->GetNextStoppingStation(this->cur_order_index, this->type == VEH_ROAD || this->type == VEH_TRAIN);
 	}
@@ -1517,8 +1575,8 @@ void Vehicle::HandleLoading(bool mode)
 {
 	switch (this->current_order.GetType()) {
 		case OT_LOADING: {
+			/* Uses standard timetable system (no timetable, no shared orders, first vehicle, etc.) */
 			uint wait_time = max(this->current_order.wait_time - this->lateness_counter, 0);
-
 			/* Not the first call for this tick, or still loading */
 			if (mode || !HasBit(this->vehicle_flags, VF_LOADING_FINISHED) ||
 					(_settings_game.order.timetabling && this->current_order_time < wait_time)) return;
@@ -1677,6 +1735,73 @@ void Vehicle::RemoveFromShared()
 	this->previous_shared = NULL;
 }
 
+
+int Vehicle::GetFirstSharedSeparation()
+{
+  /* If this is the first vehicle in the shared orders chain then separation is 0 */
+	Vehicle *first = this->PreviousShared();
+	if (first == NULL)
+    return 0;
+
+	/* Else gets the first vehicle in chain... */
+	for (; first->PreviousShared() != NULL; first = first->PreviousShared());
+    /* ... then returns the separation between this vehicle and first vehicle, plus the first vehicle lateness counter */
+	return this->GetVehicleSeparation(first, false, true) + first->lateness_counter;
+}
+
+
+int Vehicle::GetVehicleSeparation(Vehicle *v, bool add_this_current_order_time, bool add_other_current_order_time)
+{
+    /* If the compared vehicle is this vehicle, then the separation is 0, whatever the current order time */
+	if (this == v) return 0;
+
+	int this_position = this->GetTimetablePosition(add_this_current_order_time);
+	int other_position = v->GetTimetablePosition(add_other_current_order_time);
+
+	if (this_position <= other_position) {
+		/* The other vehicle is in front of this one. It's really easy to compute. */
+		return other_position - this_position;
+	} else {
+		/* The other vehicle is behind this one. We must add the total timetable duration minus the current order wait_time as we may start immediately. */
+		int total_timetable = this->orders.list->GetTimetableDurationIncomplete();
+		return total_timetable + other_position - this_position;
+	}
+}
+
+int Vehicle::GetTimetablePosition(bool add_current_order_time)
+{
+	int total = 0;
+
+	/* Add current order time */
+	if (add_current_order_time) total += current_order_time;
+
+  OrderList *orders = this->orders.list;
+	Order *o = orders->GetFirstOrder();
+	for (int i = 0; i < cur_order_index%orders->GetNumOrders(); i++) {
+		total += o->travel_time + o->wait_time;
+		o = o->next;
+	}
+
+	if (last_station_visited == o->GetDestination())
+	{
+		total += o->travel_time;
+	}
+
+	return total;
+}
+
+VehicleOrderID Vehicle::FirstStopStationOrderID()
+{
+	VehicleOrderID index = 0;
+	for (Order *first = this->GetFirstOrder(); first != NULL; first = first->next) {
+		if (first->GetType() == OT_GOTO_STATION && first->wait_time > 0) {
+			return index;
+		}
+		index++;
+	}
+	return INVALID_VEH_ORDER_ID;
+}
+
 void StopAllVehicles()
 {
 	Vehicle *v;
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index 77bf93b..e52a7bf 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -511,6 +511,54 @@ public:
 	{
 		return (this->orders.list == NULL) ? NULL : this->orders.list->GetLastOrder();
 	}
+
+
+//bool IsVehicleInSharedOrdersList(Vehicle *v);
+// OrderList->IsVehicleInSharedOrdersList
+
+// OrderList->GetNumVehicles
+//int CountSharedOrderdList();
+
+// OrderList->GetPositionInSharedOrderList
+//int GetPositionInSharedOrderList();
+
+// OrderList->GetTimetableDurationIncomplete() probably
+//int GetTimetableTotalDuration();
+
+  /**
+   * Get the current theorical separation with the first shared order vehicle.
+   * This includes its lateness_counter.
+   * The vehicle must be in the first order station for this function to work.
+   * @return The actual separation (in ticks) with the first vehicle
+   */
+  int GetFirstSharedSeparation();
+
+  /**
+   * Get the current separation with the given vehicle.
+   * @param *v The vehicle to compare
+   * @param add_this_current_order_time Indicates if we have to take into account
+   *              this vehicle current order time
+   * @param add_other_current_order_time Indicates if we have to take into
+   *              account the compared vehicle current order time
+   * @return Separation duration (in ticks) between both vehicles
+   */
+  int GetVehicleSeparation(Vehicle *v, bool add_this_current_order_time, bool add_other_current_order_time);
+
+  /**
+   * Get the theorical current vehicle position in the timetable. This position
+   * is not the position in the shared orders chain, but actually the theorical
+   * duration since the vehicle started the timetabled orders list based on the
+   * current order.
+   * @param add_current_order_time Indicates if we get the current order time into account.
+   * @return numbers of ticks from the begining of the timetable without lateness_counter.
+   */
+  int GetTimetablePosition(bool add_current_order_time);
+
+  /**
+   * Gets the first order index where the vehicle stops at a station
+   * @return First order index vhere the vehicle stops at a station
+   */
+  VehicleOrderID FirstStopStationOrderID();
 };
 
 #define FOR_ALL_VEHICLES_FROM(var, start) FOR_ALL_ITEMS_FROM(Vehicle, vehicle_index, var, start)
