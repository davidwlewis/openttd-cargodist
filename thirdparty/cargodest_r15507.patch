diff -r cefcfd943f94 config.lib
--- a/config.lib	Tue Feb 17 00:30:59 2009 +0000
+++ b/config.lib	Tue Feb 17 03:31:08 2009 +0100
@@ -1094,6 +1094,8 @@
 			if [ $enable_assert -eq 0 ]; then
 				CFLAGS="$CFLAGS -Wno-unused"
 			fi
+
+			CFLAGS="$CFLAGS -ftemplate-depth-40"
 		fi
 
 		if [ $cc_version -ge 30 ]; then
diff -r cefcfd943f94 projects/openttd_vs80.vcproj
--- a/projects/openttd_vs80.vcproj	Tue Feb 17 00:30:59 2009 +0000
+++ b/projects/openttd_vs80.vcproj	Tue Feb 17 03:31:08 2009 +0100
@@ -684,6 +684,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\routing.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\screenshot.cpp"
 				>
 			</File>
@@ -1332,6 +1336,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\routing.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\screenshot.h"
 				>
 			</File>
diff -r cefcfd943f94 projects/openttd_vs90.vcproj
--- a/projects/openttd_vs90.vcproj	Tue Feb 17 00:30:59 2009 +0000
+++ b/projects/openttd_vs90.vcproj	Tue Feb 17 03:31:08 2009 +0100
@@ -681,6 +681,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\routing.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\screenshot.cpp"
 				>
 			</File>
@@ -1329,6 +1333,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\routing.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\screenshot.h"
 				>
 			</File>
diff -r cefcfd943f94 source.list
--- a/source.list	Tue Feb 17 00:30:59 2009 +0000
+++ b/source.list	Tue Feb 17 03:31:08 2009 +0100
@@ -63,6 +63,7 @@
 rail.cpp
 rev.cpp
 road.cpp
+routing.cpp
 screenshot.cpp
 #if SDL
 	sdl.cpp
@@ -263,6 +264,7 @@
 road_internal.h
 road_type.h
 roadveh.h
+routing.h
 screenshot.h
 sdl.h
 sound/sdl_s.h
diff -r cefcfd943f94 src/aircraft_cmd.cpp
--- a/src/aircraft_cmd.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/aircraft_cmd.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -28,6 +28,7 @@
 #include "company_func.h"
 #include "effectvehicle_func.h"
 #include "settings_type.h"
+#include "routing.h"
 
 #include "table/strings.h"
 #include "table/sprites.h"
@@ -576,6 +577,7 @@
 
 	if (flags & DC_EXEC) {
 		v->cargo_cap = pass;
+		uint32 old_mask = v->GetCargoForSharedVehicles();
 
 		Vehicle *u = v->Next();
 		uint mail = IsCargoInClass(new_cid, CC_PASSENGERS) ? avi->mail_capacity : 0;
@@ -588,6 +590,12 @@
 		InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
 		InvalidateWindow(WC_VEHICLE_DEPOT, v->tile);
 		InvalidateWindowClassesData(WC_AIRCRAFT_LIST, 0);
+
+		uint32 new_mask     = v->GetCargoForSharedVehicles();
+		uint32 changed_mask = new_mask ^ old_mask;
+
+		RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListRemoval,   v->GetFirstOrder(), v->type, old_mask & changed_mask);
+		RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListInsertion, v->GetFirstOrder(), v->type, new_mask & changed_mask);
 	}
 
 	return cost;
diff -r cefcfd943f94 src/aircraft_gui.cpp
--- a/src/aircraft_gui.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/aircraft_gui.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -10,10 +10,30 @@
 #include "vehicle_func.h"
 #include "gfx_func.h"
 #include "window_gui.h"
+#include "routing.h"
 
 #include "table/sprites.h"
 #include "table/strings.h"
 
+#include <vector>
+#include <map>
+
+/**
+ * Returns the number of entries we need for the vehicle detail window
+ * so that we can set the scrollbar accordingly. The list can be long since
+ * we list all destinations for every cargo type carried
+ * @see    GetNumberOfDestinationsAndCargoTypes
+ * @param  veh_id The ID of the vehicle we're looking at
+ * @return The total number of entries in the list
+ */
+int GetAircraftDetailsWndVScroll(VehicleID veh_id)
+{
+	int num = 1; // We need one additional line for the vehicle type
+
+	for (const Vehicle *v = GetVehicle(veh_id); v != NULL; v = v->Next()) if (v->cargo_cap > 0) num++;
+	return num + RoutingBase::GetNumberOfDestinationsAndCargoTypes(GetVehicle(veh_id));
+}
+
 /**
 * Draw the details for the given vehicle at the position (x,y)
 *
@@ -21,43 +41,58 @@
 * @param x The x coordinate
 * @param y The y coordinate
 */
-void DrawAircraftDetails(const Vehicle *v, int x, int y)
+void DrawAircraftDetails(const Vehicle *v, int x, int y, int vscroll_pos, uint16 vscroll_cap)
 {
-	int y_offset = (v->Next()->cargo_cap != 0) ? -11 : 0;
+	int y_offset = 1;
 	Money feeder_share = 0;
+	RoutingBase::CargoTypesByStationMap cargo_by_destination;
+	RoutingBase::GetDestinationsForCargos(v, cargo_by_destination);
 
 	for (const Vehicle *u = v ; u != NULL ; u = u->Next()) {
 		if (IsNormalAircraft(u)) {
 			SetDParam(0, u->engine_type);
 			SetDParam(1, u->build_year);
 			SetDParam(2, u->value);
-			DrawString(x, y, STR_A011_BUILT_VALUE, TC_FROMSTRING);
+			DrawString(x, y + y_offset, STR_A011_BUILT_VALUE, TC_FROMSTRING);
 
 			SetDParam(0, u->cargo_type);
 			SetDParam(1, u->cargo_cap);
 			SetDParam(2, u->Next()->cargo_type);
 			SetDParam(3, u->Next()->cargo_cap);
 			SetDParam(4, GetCargoSubtypeText(u));
-			DrawString(x, y + 10, (u->Next()->cargo_cap != 0) ? STR_A019_CAPACITY : STR_A01A_CAPACITY, TC_FROMSTRING);
+			y_offset += 14;
+			DrawString(x, y + y_offset, (u->Next()->cargo_cap != 0) ? STR_A019_CAPACITY : STR_A01A_CAPACITY, TC_FROMSTRING);
 		}
 
 		if (u->cargo_cap != 0) {
 			uint cargo_count = u->cargo.Count();
 
-			y_offset += 11;
-			if (cargo_count != 0) {
-				/* Cargo names (fix pluralness) */
+			if (--vscroll_pos < 0 && vscroll_pos > -vscroll_cap + 2) {
+				if (cargo_count != 0) {
+					/* Cargo names (fix pluralness) */
+					SetDParam(0, u->cargo_type);
+					SetDParam(1, cargo_count);
+					SetDParam(2, u->cargo.Source());
+					y_offset += 14;
+					DrawString(x, y + y_offset, STR_8813_FROM, TC_FROMSTRING);
+				}
+			}
+			feeder_share += u->cargo.FeederShare();
+		}
+		for (RoutingBase::CargoByStationMap::const_iterator it = cargo_by_destination[u->cargo_type].begin(); it != cargo_by_destination[u->cargo_type].end(); ++it) {
+			if (--vscroll_pos < 0 && vscroll_pos > -vscroll_cap + 2) {
 				SetDParam(0, u->cargo_type);
-				SetDParam(1, cargo_count);
-				SetDParam(2, u->cargo.Source());
-				DrawString(x, y + 21 + y_offset, STR_8813_FROM, TC_FROMSTRING);
-				feeder_share += u->cargo.FeederShare();
+				SetDParam(1, it->second);
+				SetDParam(2, it->first);
+				y_offset += 14;
+				DrawString(x, y + y_offset, STR_ORIGIN_TO, TC_FROMSTRING);
 			}
 		}
 	}
 
 	SetDParam(0, feeder_share);
-	DrawString(x, y + 33 + y_offset, STR_FEEDER_CARGO_VALUE, TC_FROMSTRING);
+	y_offset += 14;
+	DrawString(x, y + y_offset, STR_FEEDER_CARGO_VALUE, TC_FROMSTRING);
 }
 
 
diff -r cefcfd943f94 src/autoreplace_cmd.cpp
--- a/src/autoreplace_cmd.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/autoreplace_cmd.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -111,7 +111,7 @@
 			uint amount = min(src->cargo.Count(), dest->cargo_cap - dest->cargo.Count());
 			if (amount <= 0) continue;
 
-			src->cargo.MoveTo(&dest->cargo, amount);
+			src->cargo.MoveTo(&dest->cargo, amount, dest->cargo_type);
 		}
 	}
 
diff -r cefcfd943f94 src/cargo_type.h
--- a/src/cargo_type.h	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/cargo_type.h	Tue Feb 17 03:31:08 2009 +0100
@@ -9,6 +9,7 @@
 
 /** Available types of cargo */
 enum CargoTypes {
+	CT_BEGIN        =  0,
 	/* Temperate */
 	CT_PASSENGERS   =  0,
 	CT_COAL         =  1,
diff -r cefcfd943f94 src/cargopacket.cpp
--- a/src/cargopacket.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/cargopacket.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -5,6 +5,7 @@
 #include "stdafx.h"
 #include "station_base.h"
 #include "oldpool_func.h"
+#include "routing.h"
 
 /* Initialize the cargopacket-pool */
 DEFINE_OLD_POOL_GENERIC(CargoPacket, CargoPacket)
@@ -16,13 +17,14 @@
 	_CargoPacket_pool.AddBlockToPool();
 }
 
-CargoPacket::CargoPacket(StationID source, uint16 count)
+CargoPacket::CargoPacket(StationID source, StationID target, uint16 count)
 {
 	if (source != INVALID_STATION) assert(count != 0);
 
 	this->source          = source;
 	this->source_xy       = (source != INVALID_STATION) ? GetStation(source)->xy : 0;
 	this->loaded_at_xy    = this->source_xy;
+	this->target          = target;
 
 	this->count           = count;
 	this->days_in_transit = 0;
@@ -35,9 +37,9 @@
 	this->count = 0;
 }
 
-bool CargoPacket::SameSource(const CargoPacket *cp) const
+bool CargoPacket::SameRoute(const CargoPacket *cp) const
 {
-	return this->source_xy == cp->source_xy && this->days_in_transit == cp->days_in_transit && this->paid_for == cp->paid_for;
+	return this->target == cp->target && this->source_xy == cp->source_xy && this->days_in_transit == cp->days_in_transit && this->paid_for == cp->paid_for;
 }
 
 /*
@@ -48,6 +50,7 @@
 
 CargoList::~CargoList()
 {
+	delete cargo_list;
 	while (!packets.empty()) {
 		delete packets.front();
 		packets.pop_front();
@@ -106,10 +109,14 @@
 	assert(cp != NULL);
 	assert(cp->IsValid());
 
+	this->RecomputeCargoLeftCache();
+
 	for (List::iterator it = packets.begin(); it != packets.end(); it++) {
-		if ((*it)->SameSource(cp) && (*it)->count + cp->count <= 65535) {
+		if ((*it)->SameRoute(cp) && (*it)->count + cp->count <= 65535) {
 			(*it)->count        += cp->count;
 			(*it)->feeder_share += cp->feeder_share;
+
+			if (this->CargoLeft() != NULL) this->CargoLeft()->ModifyDestinationList(cp->target, cp->count);
 			delete cp;
 
 			InvalidateCache();
@@ -119,13 +126,15 @@
 
 	/* The packet could not be merged with another one */
 	packets.push_back(cp);
+	if (this->CargoLeft() != NULL) this->CargoLeft()->ModifyDestinationList(cp->target, cp->count);
 	InvalidateCache();
 }
 
 
 void CargoList::Truncate(uint count)
 {
-	for (List::iterator it = packets.begin(); it != packets.end(); it++) {
+	if (this->CargoLeft() != NULL) this->CargoLeft()->SetCacheDirty();
+	for (List::reverse_iterator it = packets.rbegin(); it != packets.rend(); it++) {
 		uint local_count = (*it)->count;
 		if (local_count <= count) {
 			count -= local_count;
@@ -137,47 +146,101 @@
 	}
 
 	while (!packets.empty()) {
-		CargoPacket *cp = packets.back();
+		CargoPacket *cp = packets.front();
 		if (cp->count != 0) break;
 		delete cp;
-		packets.pop_back();
+		packets.pop_front();
 	}
 
-	InvalidateCache();
+	this->InvalidateCache();
+	this->RecomputeCargoLeftCache();
 }
 
-bool CargoList::MoveTo(CargoList *dest, uint count, CargoList::MoveToAction mta, uint data)
+void CargoList::SetNewDestination(StationID from, StationID target)
 {
-	assert(mta == MTA_FINAL_DELIVERY || dest != NULL);
-	CargoList tmp;
+	if (this->CargoLeft() != NULL) this->CargoLeft()->SetCacheDirty();
+	for (List::iterator it = packets.begin(); it != packets.end(); ++it) {
+		if ((*it)->target == from) (*it)->target = target;
+	}
+	this->RecomputeCargoLeftCache();
+}
 
-	while (!packets.empty() && count > 0) {
-		CargoPacket *cp = *packets.begin();
+bool CargoList::MoveTo(CargoList *dest, uint count, CargoID type, CargoList::MoveToAction mta, uint data, const Vehicle *v)
+{
+	assert(dest != NULL || (mta == MTA_FINAL_DELIVERY && !RoutingBase::Routing(type)->HasDestinations()));
+	assert(mta != MTA_CARGO_LOAD || v != NULL);
+	bool remaining = false;
+	bool dest_cache_safe = false;
+	bool this_cache_safe = false;
+	bool this_paid_cache_safe = true;
+
+	this->RecomputeCargoLeftCache();
+
+	/* We don't have the ++it here since we have an .erase(it) call inside the loop */
+	for (List::iterator it = packets.begin(); it != packets.end();) {
+		CargoPacket *cp = *it;
+
+		/* Skip loading if it doesn't want to use this vehicle */
+		if (mta == MTA_CARGO_LOAD && !RoutingBase::Routing(type)->UseVehicle(v, cp->target, false)) {
+			++it;
+			continue;
+		}
+
+		/* Skip unloading if it doesn't want to leave this vehicle */
+		if (mta == MTA_FINAL_DELIVERY && RoutingBase::Routing(type)->UseVehicle(v, cp->target, true)) {
+			++it;
+			continue;
+		}
+
+		if (count == 0) {
+			/* There are more packets to move, but we can't yet. */
+			remaining = true;
+			break;
+		}
+
 		if (cp->count <= count) {
 			/* Can move the complete packet */
-			packets.remove(cp);
+			count -= cp->count;
+			it = packets.erase(it);
+
 			switch (mta) {
 				case MTA_FINAL_DELIVERY:
-					if (cp->source == data) {
-						tmp.Append(cp);
+					/* Cargo did not start here */
+					if (cp->target == data || cp->target == INVALID_STATION || dest == NULL) {
+						/* Cargo actually wants to go here, or anywhere */
+						GetStation(data)->goods[type].destination_this_month += cp->count;
+						delete cp;
 					} else {
-						count -= cp->count;
-						delete cp;
+						/* Cargo wants to go somewhere else on another vehicle, so don't destroy them but move them onto the station */
+						dest->packets.push_back(cp);
+						GetStation(data)->goods[type].transfer_this_month += cp->count;
+						assert(dest->CargoLeft() != NULL);
+						dest->CargoLeft()->ModifyDestinationList(cp->target, cp->count);
+
+						dest->ModifyCache(cp, true);
+						dest_cache_safe = true;
 					}
 					break;
 				case MTA_CARGO_LOAD:
 					cp->loaded_at_xy = data;
 					/* When cargo is moved into another vehicle you have *always* paid for it */
 					cp->paid_for     = false;
+
+					assert(this->CargoLeft() != NULL);
+					this->CargoLeft()->ModifyDestinationList(cp->target, -static_cast<int>(cp->count));
+
+					this_paid_cache_safe = this->ModifyCache(cp, false);
+					this_cache_safe = true;
 					/* FALL THROUGH */
 				case MTA_OTHER:
-					count -= cp->count;
+					/* We are transferring stuff to a station, by a manual transfer order */
+					if (dest->CargoLeft() != NULL) dest->CargoLeft()->ModifyDestinationList(cp->target, cp->count);
 					dest->packets.push_back(cp);
 					break;
 			}
 		} else {
 			/* Can move only part of the packet, so split it into two pieces */
-			if (mta != MTA_FINAL_DELIVERY) {
+			if (mta != MTA_FINAL_DELIVERY || (cp->target != data && cp->target != INVALID_STATION && dest != NULL)) {
 				CargoPacket *cp_new = new CargoPacket();
 
 				Money fs = cp->feeder_share * count / static_cast<uint>(cp->count);
@@ -186,6 +249,7 @@
 				cp_new->source          = cp->source;
 				cp_new->source_xy       = cp->source_xy;
 				cp_new->loaded_at_xy    = (mta == MTA_CARGO_LOAD) ? data : cp->loaded_at_xy;
+				cp_new->target          = cp->target;
 
 				cp_new->days_in_transit = cp->days_in_transit;
 				cp_new->feeder_share    = fs;
@@ -194,25 +258,72 @@
 
 				cp_new->count = count;
 				dest->packets.push_back(cp_new);
+
+				switch (mta) {
+					case MTA_FINAL_DELIVERY:
+						assert(dest->CargoLeft() != NULL);
+						dest->CargoLeft()->ModifyDestinationList(cp->target, count);
+
+						dest->ModifyCache(cp_new, true);
+						dest_cache_safe = true;
+						break;
+					case MTA_CARGO_LOAD:
+						assert(this->CargoLeft() != NULL);
+						this->CargoLeft()->ModifyDestinationList(cp->target, -static_cast<int>(count));
+						/* No handling of cp_new->paid_for as we didn't remove any cargopacket from the chain */
+						this->ModifyCache(cp_new, false);
+						this_cache_safe = true;
+						break;
+					case MTA_OTHER:
+						if (dest->CargoLeft() != NULL) dest->CargoLeft()->ModifyDestinationList(cp->target, count);
+						break;
+				}
 			}
 			cp->count -= count;
 
 			count = 0;
+			remaining = true;
+
+			++it;
 		}
 	}
 
-	bool remaining = !packets.empty();
-
-	if (mta == MTA_FINAL_DELIVERY && !tmp.Empty()) {
-		/* There are some packets that could not be delivered at the station, put them back */
-		tmp.MoveTo(this, UINT_MAX);
-		tmp.packets.clear();
+	if (dest != NULL && !dest_cache_safe) dest->InvalidateCache();
+	if (!this_cache_safe) {
+		InvalidateCache();
+	} else if (!this_paid_cache_safe) {
+		this->unpaid_cargo = false;
+		for (CargoList::List::const_iterator it = packets.begin(); it != packets.end(); it++) {
+			if (!(*it)->paid_for) {
+				this->unpaid_cargo = true;
+				break;
+			}
+		}
 	}
 
-	if (dest != NULL) dest->InvalidateCache();
-	InvalidateCache();
+	return remaining;
+}
 
-	return remaining;
+bool CargoList::ModifyCache(const CargoPacket *cp, bool insert)
+{
+	uint dit = this->count * this->days_in_transit;
+	int multi = (insert) ? +1 : -1;
+
+	this->count        += multi * cp->count;
+	this->feeder_share += multi * cp->feeder_share;
+	dit                += multi * cp->count * cp->days_in_transit;
+	this->empty        =  this->packets.empty();
+
+	this->days_in_transit = 0;
+	if (this->count != 0) this->days_in_transit = dit / this->count;
+
+	if (insert) {
+		if (!this->unpaid_cargo && !cp->paid_for) this->unpaid_cargo = true;
+	} else {
+		if (!cp->paid_for) return false;
+	}
+
+	return true;
 }
 
 void CargoList::InvalidateCache()
@@ -237,3 +348,65 @@
 	source = (*packets.begin())->source;
 }
 
+void DestinationList::ModifyDestinationList(StationID target, int count)
+{
+	assert(!this->dirty);
+
+	StationID next = RoutingBase::Routing(this->type)->FindNextHop(this->index, target);
+	NextHopMap::iterator pos = this->map.find(next);
+
+	if (pos == this->map.end()) {
+		assert(count > 0);
+		this->map.insert(std::pair<StationID, int>(next, count));
+	} else {
+		assert(pos->second + count >= 0);
+		pos->second += count;
+
+		if (pos->second == 0) this->map.erase(next);
+	}
+}
+
+void DestinationList::RecomputeCache(CargoList::List *packets)
+{
+	if (!this->dirty) return;
+
+	this->map.clear();
+
+	/* Cache for the nexthops. We could store this in the station struct itself if we
+	 * get performance issues with this one
+	 */
+	std::map<StationID, StationID>            nexthops;
+	std::map<StationID, StationID>::iterator  nexthop_pos;
+
+	for (CargoList::List::const_iterator it = packets->begin(); it != packets->end(); ++it) {
+		const CargoPacket  *cp = *it;
+		StationID           next;
+
+		/* Where do we need to go */
+		nexthop_pos = nexthops.find(cp->target);
+
+		if (nexthop_pos == nexthops.end()) {
+			/* Find the next hop for the current destination, and
+			 * store it in the cache
+			 */
+			next = RoutingBase::Routing(this->type)->FindNextHop(this->index, cp->target);
+			nexthops.insert(std::pair<StationID, StationID>(cp->target, next));
+		} else {
+			next = nexthop_pos->second;
+		}
+
+		/* Find the item in the map that corresponds to the current nexthop */
+		NextHopMap::iterator pos = this->map.find(next);
+
+		if (pos == this->map.end()) {
+			/* This nexthop is not yet known, add it to the map */
+			this->map.insert(std::pair<StationID, int>(next, cp->count));
+		} else {
+			/* Next hop is know, just add the amount of cargo to the list */
+			pos->second += cp->count;
+		}
+	}
+
+	this->dirty = false;
+}
+
diff -r cefcfd943f94 src/cargopacket.h
--- a/src/cargopacket.h	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/cargopacket.h	Tue Feb 17 03:31:08 2009 +0100
@@ -9,10 +9,13 @@
 #include "economy_type.h"
 #include "tile_type.h"
 #include "station_type.h"
+
 #include <list>
+#include <map>
 
 typedef uint32 CargoPacketID;
 struct CargoPacket;
+struct Vehicle;
 
 /** We want to use a pool */
 DECLARE_OLD_POOL(CargoPacket, CargoPacket, 10, 1000)
@@ -26,6 +29,7 @@
 	TileIndex source_xy;    ///< The origin of the cargo (first station in feeder chain)
 	TileIndex loaded_at_xy; ///< Location where this cargo has been loaded into the vehicle
 	StationID source;       ///< The station where the cargo came from first
+	StationID target;       ///< The station where the cargo should go to
 
 	uint16 count;           ///< The amount of cargo in this packet
 	byte days_in_transit;   ///< Amount of days this packet has been in transit
@@ -37,7 +41,7 @@
 	 * @param count  the number of cargo entities to put in this packet
 	 * @pre count != 0 || source == INVALID_STATION
 	 */
-	CargoPacket(StationID source = INVALID_STATION, uint16 count = 0);
+	CargoPacket(StationID source = INVALID_STATION, StationID target = INVALID_STATION, uint16 count = 0);
 
 	/** Destroy the packet */
 	virtual ~CargoPacket();
@@ -51,11 +55,11 @@
 
 	/**
 	 * Checks whether the cargo packet is from (exactly) the same source
-	 * in time and location.
+	 * in time and location, and to the same target.
 	 * @param cp the cargo packet to compare to
 	 * @return true if and only if days_in_transit and source_xy are equal
 	 */
-	bool SameSource(const CargoPacket *cp) const;
+	bool SameRoute(const CargoPacket *cp) const;
 };
 
 /**
@@ -73,14 +77,70 @@
 
 extern void SaveLoad_STNS(Station *st);
 
+/** Basic class containing types for cargo lists */
+struct CargoListType {
+	/** List of cargo packets */
+	typedef std::list<CargoPacket *> List;
+};
+
+/**
+ * Class which handles the destination cache of a goodsentry.
+ */
+class DestinationList : private CargoListType {
+public:
+	/** Maps an amount of cargo onto a NextHop */
+	typedef std::map<StationID, int> NextHopMap;
+
+private:
+	bool             dirty;  ///< Flag the determine whether the cache is dirty
+	const CargoID    type;   ///< The cargo type we're handling. This is needed because the GoodsEntry doesn't know anything about it
+	const StationID  index;  ///< The station to which we belong
+	NextHopMap       map;    ///< Maps the number of cargounits onto all the active NextHops of a station
+
+public:
+	/**
+	 * Constructor for the destination cache.
+	 * @param type   The cargo type we are supposed to work on
+	 * @param index  The station we're at
+	 */
+	DestinationList(CargoID type, StationID index) : dirty(true), type(type), index(index) { this->map.clear(); }
+
+	/** Destructor */
+	~DestinationList() { this->map.clear(); }
+
+	/** Invalidates the destination cache */
+	void SetCacheDirty() { this->dirty = true; }
+
+	/** Finds whether the cache is dirty */
+	bool IsCacheDirty() const { return this->dirty; }
+
+	/**
+	 * Obtains the destination cache
+	 * @pre The cache must not be dirty
+	 */
+	NextHopMap *Map() { assert(!this->dirty); return &this->map; }
+
+	/**
+	 * Adds/subtracts an amount of cargo to/from the map
+	 * @param target The target station of the cargopacket
+	 * @param count  The amount of cargo
+	 */
+	void ModifyDestinationList(StationID target, int count);
+
+private:
+	friend class CargoList;
+	/**
+	 * Recomputes the destination cache for a given CargoList if needed
+	 * @param packets The cargolist to process
+	 */
+	void RecomputeCache(List *packets);
+};
+
 /**
  * Simple collection class for a list of cargo packets
  */
-class CargoList {
+class CargoList : public CargoListType {
 public:
-	/** List of cargo packets */
-	typedef std::list<CargoPacket *> List;
-
 	/** Kind of actions that could be done with packets on move */
 	enum MoveToAction {
 		MTA_FINAL_DELIVERY, ///< "Deliver" the packet to the final destination, i.e. destroy the packet
@@ -98,15 +158,37 @@
 	StationID source;     ///< Cache for the source of the packet
 	uint days_in_transit; ///< Cache for the number of days in transit
 
+	/** The destination cache */
+	DestinationList *cargo_list;
+
 public:
 	friend void SaveLoad_STNS(Station *st);
 
 	/** Create the cargo list */
-	CargoList() { this->InvalidateCache(); }
+	CargoList() { this->InvalidateCache(); this->cargo_list = NULL; }
 	/** And destroy it ("frees" all cargo packets) */
 	~CargoList();
 
 	/**
+	 * Creates a new destination cache. We don't have this in the constructor because
+	 * it is only needed for Station-based cargo lists, not for vehicle-based ones
+	 * @param type  The cargo type we're going to handle
+	 * @param index The station index we associated to
+	 */
+	void CreateCargoListEntry(CargoID type, StationID index) { assert(this->cargo_list == NULL); this->cargo_list = new DestinationList(type, index); }
+
+	/**
+	 * Removes the destination cache
+	 */
+	void DeleteCargoListEntry() { delete this->cargo_list; this->cargo_list = NULL; }
+
+	/** Returns the destination list */
+	DestinationList *CargoLeft() { return cargo_list; }
+
+	/** Recomputes our own destination cache */
+	void RecomputeCargoLeftCache() { if (cargo_list != NULL) cargo_list->RecomputeCache(&packets); }
+
+	/**
 	 * Returns a pointer to the cargo packet list (so you can iterate over it etc).
 	 * @return pointer to the packet list
 	 */
@@ -186,7 +268,29 @@
 	 * @param mta == MTA_FINAL_DELIVERY || dest != NULL
 	 * @return true if there are still packets that might be moved from this cargo list
 	 */
-	bool MoveTo(CargoList *dest, uint count, CargoList::MoveToAction mta = MTA_OTHER, uint data = 0);
+	bool MoveTo(CargoList *dest, uint count, CargoID type, CargoList::MoveToAction mta = MTA_OTHER, uint data = 0, const Vehicle *v = NULL);
+
+	/**
+	 * Sets a new destination for cargopackets
+	 * @param from   The destination to overwrite
+	 * @param to     The new destination
+	 */
+	void SetNewDestination(StationID from, StationID target);
+
+	/**
+	 * Modified the contents of the cache. This is faster than
+	 * to just invalidate the whole cache of the cargolist, especially
+	 * when the cargolist is really long (stations with lots of cargo
+	 * for example)
+	 * @param cp     The cargopacket that has been added or removed
+	 * @param insert true if the cargopacket was added to the list
+	 * @return       Status of the unpaid_cargo member
+	 * @retval true  unpaid_cargo is clean
+	 * @retval false unpaid_cargo is dirty, we need to recompute it manually
+	 * @pre          The cargo packet needs to have been removed/added into the List already
+	 * @see          InvalidateCache
+	 */
+	bool ModifyCache(const CargoPacket *cp, bool insert);
 
 	/** Invalidates the cached data and rebuild it */
 	void InvalidateCache();
diff -r cefcfd943f94 src/console_cmds.cpp
--- a/src/console_cmds.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/console_cmds.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -32,6 +32,11 @@
 #include "gamelog.h"
 #include "ai/ai.hpp"
 #include "ai/ai_config.hpp"
+#include "station_base.h"
+#include "cargotype.h"
+#include "routing.h"
+#include "cargopacket.h"
+
 
 #ifdef ENABLE_NETWORK
 	#include "table/strings.h"
@@ -1387,6 +1392,266 @@
 	return true;
 }
 
+DEF_CONSOLE_CMD(ConRouteNetwork)
+{
+	if (argc <= 1) {
+		IConsoleHelp("Interface tool for the routing network");
+		IConsoleHelp("Usage: rn <command>");
+		IConsoleHelp("<command>:");
+		IConsoleHelp("   lv [filter]:");
+		IConsoleHelp("      list vertices (i.e. stations in the routing network) and their indices");
+		IConsoleHelp("");
+		IConsoleHelp("   lc:");
+		IConsoleHelp("      list cargo types and their indices");
+		IConsoleHelp("");
+		IConsoleHelp("   le <type> <index>:");
+		IConsoleHelp("      list outgoing routes for cargo of type <type> from a station with index <index>");
+		IConsoleHelp("");
+		IConsoleHelp("   fr <type> <to> <from>:");
+		IConsoleHelp("      find a route from a station <from> to a station <to> for cargo of type <type>");
+		IConsoleHelp("");
+		IConsoleHelp("   rr:");
+		IConsoleHelp("      resets the routing system and the destination caches. USE WITH CARE!");
+		IConsoleHelp("");
+		IConsoleHelp("   dl <type> <index>:");
+		IConsoleHelp("      lists the destination cache for cargo of type <type> at the station with index <index>. For debugging purposes");
+		IConsoleHelp("");
+		IConsoleHelp("   cd:");
+		IConsoleHelp("      Cache Debugger, implies a full reset of the routing system. This is slow, since it includes a rebuild of all cache levels");
+		return true;
+	}
+
+	if (strcmp(argv[1], "lv") == 0) {
+		char            buffer[256];
+		const Station  *st;
+
+		FOR_ALL_STATIONS(st) {
+			size_t l;
+			SetDParam(0, st->index);
+			GetString(buffer, STR_STATION, lastof(buffer));
+			if (argv[2] != NULL) l = strlen(argv[2]);
+			if (argv[2] == NULL || strncmp(buffer, argv[2], l) == 0) IConsolePrintF(CC_INFO, "%d: %s", st->index, buffer);
+		}
+
+		return true;
+	}
+
+	if (strcmp(argv[1], "lc") == 0) {
+		uint8 count = 0;
+
+		for (CargoID c = CT_BEGIN; c < NUM_CARGO; c++) {
+			if (_cargo[c].IsValid() && RoutingBase::Routing(c)->HasDestinations()) count++;
+		}
+
+		if (count == 0) {
+			IConsolePrintF(CC_INFO, "No cargo type with routing system found");
+			return true;
+		}
+
+		IConsolePrintF(CC_INFO, "Cargo types with routing systems");
+
+		char buffer[256];
+		for (CargoID c = CT_BEGIN; c < NUM_CARGO; c++) {
+			if (_cargo[c].IsValid() && RoutingBase::Routing(c)->HasDestinations()) {
+				SetDParam(0, _cargo[c].name);
+				GetString(buffer, STR_CARGO, lastof(buffer));
+				IConsolePrintF(CC_INFO, "%d: %s", c, buffer);
+			}
+		}
+
+		return true;
+	}
+
+	if (strcmp(argv[1], "le") == 0) {
+		char  buffer[256];
+		char  cargotype[256];
+		bool  routes_listed = false;
+
+		if (argv[3] == NULL) {
+			IConsoleError("No station index and/or cargotype given");
+			IConsoleError("Usage: rn le <cargotype> <index>");
+			return false;
+		}
+
+		CargoID   type  = atoi(argv[2]);
+		StationID index = atoi(argv[3]);
+
+		if ((strcmp(argv[2], "0") != 0 && type == 0) || type >= NUM_CARGO || !_cargo[type].IsValid()) {
+			IConsoleError("Invalid Input for Cargo ID");
+			return false;
+		}
+
+		if (strcmp(argv[3], "0") != 0 && index == 0) {
+			IConsoleError("Invalid Input for Station ID");
+			return false;
+		}
+
+		SetDParam(0, _cargo[type].name);
+		GetString(cargotype, STR_CARGO, lastof(cargotype));
+
+		if (!RoutingBase::Routing(type)->HasDestinations()) {
+			IConsolePrintF(CC_WARNING, "No routing system established for [%s]", cargotype);
+			return true;
+		}
+
+		RoutingVectorList list;
+
+		if (!IsValidStationID(index)) {
+			IConsoleError("Invalid Station ID");
+			return false;
+		}
+
+		SetDParam(0, index);
+		GetString(buffer, STR_STATION, lastof(buffer));
+		IConsolePrintF(CC_INFO, "Outgoing routes of <%s> for [%s]", buffer, cargotype);
+
+		RoutingBase::Routing(type)->ListAdjacencies(list);
+		for (uint i = 0; i < list.Length(); i++) {
+			if (list[i].a == index) {
+				SetDParam(0, list[i].b);
+				GetString(buffer, STR_STATION, lastof(buffer));
+				IConsolePrintF(CC_INFO, "    %s", buffer);
+				routes_listed = true;
+			}
+		}
+
+		if (!routes_listed) IConsolePrintF(CC_INFO, "No outgoing routes for [%s]", cargotype);
+		return true;
+	}
+
+	if (strcmp(argv[1], "fr") == 0 ) {
+		char      buffer[3][256];
+		char      cargotype[256];
+
+		if (argv[4] == NULL) {
+			IConsoleError("Missing: station indices");
+			IConsoleError("Usage: rn fr <cargotype> <to> <from>");
+			return false;
+		}
+
+		CargoID   type = atoi(argv[2]);
+		StationID from = atoi(argv[3]);
+		StationID to   = atoi(argv[4]);
+
+		if ((strcmp(argv[2], "0") != 0 && type == 0) || type >= NUM_CARGO || !_cargo[type].IsValid()) {
+			IConsoleError("Invalid Input for Cargo ID");
+			return false;
+		}
+
+		if (strcmp(argv[3], "0") != 0 && from == 0) {
+			IConsoleError("Invalid Input for Station ID");
+			return false;
+		}
+
+		if (strcmp(argv[4], "0") != 0 && to == 0) {
+			IConsoleError("Invalid Input for Station ID");
+			return false;
+		}
+
+		SetDParam(0, _cargo[type].name);
+		GetString(cargotype, STR_CARGO, lastof(cargotype));
+
+		if (!RoutingBase::Routing(type)->HasDestinations()) {
+			IConsolePrintF(CC_WARNING, "No routing system established for [%s]", cargotype);
+			return true;
+		}
+
+		if (to == from) {
+			IConsoleError("Start and endpoint are identical");
+			return true;
+		}
+
+		if (!IsValidStationID(to) || !IsValidStationID(from)) {
+			IConsoleError("Invalid Station ID");
+			return true;
+		}
+
+		SetDParam(0, from);
+		GetString(buffer[0], STR_STATION, lastof(buffer[0]));
+
+		SetDParam(0, to);
+		GetString(buffer[1], STR_STATION, lastof(buffer[1]));
+
+		if (!RoutingBase::Routing(type)->CanReachStationFrom(from, to)) {
+			IConsolePrintF(CC_INFO, "No route found from <%s> to <%s> for [%s]", buffer[0], buffer[1], cargotype);
+			return true;
+		}
+
+		IConsolePrintF(CC_INFO, "Route from <%s> to <%s> for [%s]", buffer[0], buffer[1], cargotype);
+		IConsolePrintF(CC_INFO, "    <%s>", buffer[0]);
+
+		for (StationID hop = RoutingBase::Routing(type)->FindNextHop(from, to); hop != to; hop = RoutingBase::Routing(type)->FindNextHop(hop, to)) {
+			SetDParam(0, hop);
+			GetString(buffer[2], STR_STATION, lastof(buffer[2]));
+			IConsolePrintF(CC_INFO, "    -> <%s>", buffer[2]);
+		}
+
+		IConsolePrintF(CC_INFO, "    -> <%s> (END)", buffer[1]);
+
+		return true;
+	}
+
+	if (strcmp(argv[1], "rr") == 0 ) {
+		RoutingBase::InitializeRoutingSystems(true);
+		return true;
+	}
+
+	if (strcmp(argv[1], "cd") == 0 ) {
+		for (CargoID c = CT_BEGIN; c < NUM_CARGO; c++) {
+			RoutingBase::Routing(c)->CheckRoutingCaches();
+		}
+		return true;
+	}
+
+	if (strcmp(argv[1], "dl") == 0) {
+		char  buffer[256];
+		char  cargotype[256];
+
+		if (argv[3] == NULL) {
+			IConsoleError("No station index and/or cargotype given");
+			IConsoleError("Usage: rn le <cargotype> <index>");
+			return false;
+		}
+
+		CargoID   type  = atoi(argv[2]);
+		StationID index = atoi(argv[3]);
+
+		if ((strcmp(argv[2], "0") != 0 && type == 0) || type >= NUM_CARGO || !_cargo[type].IsValid()) {
+			IConsoleError("Invalid Input for Cargo ID");
+			return false;
+		}
+
+		if ((strcmp(argv[3], "0") != 0 && index == 0) || !IsValidStationID(index)) {
+			IConsoleError("Invalid Input for Station ID");
+			return false;
+		}
+
+		SetDParam(0, _cargo[type].name);
+		GetString(cargotype, STR_CARGO, lastof(cargotype));
+
+		SetDParam(0, index);
+		GetString(buffer, STR_STATION, lastof(buffer));
+
+		IConsolePrintF(CC_INFO, "Destination Cache at <%s> for [%s]", buffer, cargotype);
+
+		GetStation(index)->goods[type].cargo.RecomputeCargoLeftCache();
+
+		DestinationList::NextHopMap *nexthop_map = GetStation(index)->goods[type].cargo.CargoLeft()->Map();
+
+		for (DestinationList::NextHopMap::iterator it = nexthop_map->begin(); it != nexthop_map->end(); ++it) {
+			SetDParam(0, it->first);
+			GetString(buffer, STR_STATION, lastof(buffer));
+			IConsolePrintF(CC_INFO, "  %d going via <%s>", it->second, buffer);
+		}
+
+		return true;
+	}
+
+	IConsolePrintF(CC_INFO, "Unknown command: %s", argv[1]);
+
+	return true;
+}
+
 #ifdef ENABLE_NETWORK
 
 DEF_CONSOLE_CMD(ConSay)
@@ -1726,6 +1991,7 @@
 	IConsoleCmdRegister("list_cmds",    ConListCommands);
 	IConsoleCmdRegister("list_vars",    ConListVariables);
 	IConsoleCmdRegister("list_aliases", ConListAliases);
+	IConsoleCmdRegister("rn",           ConRouteNetwork);
 	IConsoleCmdRegister("newgame",      ConNewGame);
 	IConsoleCmdRegister("restart",      ConRestart);
 	IConsoleCmdRegister("getseed",      ConGetSeed);
diff -r cefcfd943f94 src/debug.cpp
--- a/src/debug.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/debug.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -32,6 +32,8 @@
 int _debug_station_level;
 int _debug_gamelog_level;
 int _debug_desync_level;
+int _debug_routing_level;
+int _debug_cargopacket_level;
 
 
 struct DebugLevel {
@@ -58,6 +60,8 @@
 	DEBUG_LEVEL(station),
 	DEBUG_LEVEL(gamelog),
 	DEBUG_LEVEL(desync),
+	DEBUG_LEVEL(routing),
+	DEBUG_LEVEL(cargopacket)
 	};
 #undef DEBUG_LEVEL
 
diff -r cefcfd943f94 src/debug.h
--- a/src/debug.h	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/debug.h	Tue Feb 17 03:31:08 2009 +0100
@@ -49,6 +49,8 @@
 	extern int _debug_station_level;
 	extern int _debug_gamelog_level;
 	extern int _debug_desync_level;
+	extern int _debug_routing_level;
+	extern int _debug_cargopacket_level;
 
 	void CDECL debug(const char *dbg, ...);
 #endif /* NO_DEBUG_MESSAGES */
diff -r cefcfd943f94 src/economy.cpp
--- a/src/economy.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/economy.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -32,10 +32,13 @@
 #include "autoreplace_func.h"
 #include "company_gui.h"
 #include "signs_base.h"
+#include "routing.h"
 
 #include "table/strings.h"
 #include "table/sprites.h"
 
+#include <map>
+
 /**
  * Multiply two integer values and shift the results to right.
  *
@@ -826,6 +829,9 @@
 	StartupEconomy();
 	InitializeLandscapeVariables(false);
 
+	/* Restart the routing system and re-read the station list */
+	RoutingBase::InitializeRoutingSystems(true);
+
 	/* Reapply inflation, ignoring the year */
 	while (old_value > _economy.max_loan_unround) {
 		AddInflation(false);
@@ -1419,8 +1425,6 @@
  */
 void VehiclePayment(Vehicle *front_v)
 {
-	int result = 0;
-
 	Money vehicle_profit = 0; // Money paid to the train
 	Money route_profit   = 0; // The grand total amount for the route. A-D of transfer chain A-B-C-D
 	Money virtual_profit = 0; // The virtual profit for entire vehicle chain
@@ -1452,44 +1456,49 @@
 			continue;
 		}
 
-		GoodsEntry *ge = &st->goods[v->cargo_type];
 		const CargoList::List *cargos = v->cargo.Packets();
 
 		for (CargoList::List::const_iterator it = cargos->begin(); it != cargos->end(); it++) {
 			CargoPacket *cp = *it;
-			if (!cp->paid_for &&
-					cp->source != last_visited &&
-					HasBit(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE) &&
-					(front_v->current_order.GetUnloadType() & OUFB_TRANSFER) == 0) {
-				/* Deliver goods to the station */
-				st->time_since_unload = 0;
+			Money profit;
 
-				/* handle end of route payment */
-				Money profit = DeliverGoods(cp->count, v->cargo_type, cp->source, last_visited, cp->source_xy, cp->days_in_transit, &industry_set);
-				cp->paid_for = true;
-				route_profit   += profit; // display amount paid for final route delivery, A-D of a chain A-B-C-D
-				vehicle_profit += profit - cp->feeder_share;                    // whole vehicle is not payed for transfers picked up earlier
+			switch (RoutingBase::Routing(v->cargo_type)->ProcessPayment(cp, st, front_v)) {
+				case RoutingBase::PPR_ARRIVE:
+					st->time_since_unload = 0;
 
-				result |= 1;
+					/* handle end of route payment */
+					profit = DeliverGoods(cp->count, v->cargo_type, cp->source, last_visited, cp->source_xy, cp->days_in_transit, &industry_set);
+					cp->paid_for = true;
+					/* display amount paid for final route delivery, A-D of a chain A-B-C-D */
+					route_profit   += profit;
+					/* whole vehicle is not payed for transfers picked up earlier */
+					vehicle_profit += profit - cp->feeder_share;
 
-				SetBit(v->vehicle_flags, VF_CARGO_UNLOADING);
-			} else if (front_v->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) {
-				if (!cp->paid_for && (front_v->current_order.GetUnloadType() & OUFB_TRANSFER) != 0) {
-					Money profit = GetTransportedGoodsIncome(
+					SetBit(v->vehicle_flags, VF_CARGO_UNLOADING);
+					break;
+
+				case RoutingBase::PPR_TRANSFER:
+					profit = GetTransportedGoodsIncome(
 						cp->count,
 						/* pay transfer vehicle for only the part of transfer it has done: ie. cargo_loaded_at_xy to here */
 						DistanceManhattan(cp->loaded_at_xy, GetStation(last_visited)->xy),
 						cp->days_in_transit,
 						v->cargo_type);
 
-					front_v->profit_this_year += profit << 8;
-					virtual_profit   += profit; // accumulate transfer profits for whole vehicle
-					cp->feeder_share += profit; // account for the (virtual) profit already made for the cargo packet
-					cp->paid_for      = true;   // record that the cargo has been paid for to eliminate double counting
-				}
-				result |= 2;
+					front_v->profit_this_year += profit * 256;
+					virtual_profit            += profit; // accumulate transfer profits for whole vehicle
+					cp->feeder_share          += profit; // account for the (virtual) profit already made for the cargo packet
+					cp->paid_for              =  true;   // record that the cargo has been paid for to eliminate double counting
+					SetBit(v->vehicle_flags, VF_CARGO_UNLOADING);
+					break;
 
-				SetBit(v->vehicle_flags, VF_CARGO_UNLOADING);
+				case RoutingBase::PPR_NOPAY:
+					SetBit(v->vehicle_flags, VF_CARGO_UNLOADING);
+					break;
+
+				case RoutingBase::PPR_NONE:
+					break;
+
 			}
 		}
 		v->cargo.InvalidateCache();
@@ -1501,8 +1510,11 @@
 		TriggerIndustryProduction(*iid);
 	}
 
+	bool show_both = false;
+
 	if (virtual_profit > 0) {
-		ShowFeederIncomeAnimation(front_v->x_pos, front_v->y_pos, front_v->z_pos, virtual_profit);
+		if (route_profit != 0) show_both = true;
+		ShowFeederIncomeAnimation(front_v->x_pos, front_v->y_pos, front_v->z_pos, virtual_profit, -vehicle_profit);
 	}
 
 	if (route_profit != 0) {
@@ -1513,7 +1525,7 @@
 			SndPlayVehicleFx(SND_14_CASHTILL, front_v);
 		}
 
-		ShowCostOrIncomeAnimation(front_v->x_pos, front_v->y_pos, front_v->z_pos, -vehicle_profit);
+		if (!show_both) ShowCostOrIncomeAnimation(front_v->x_pos, front_v->y_pos, front_v->z_pos, -vehicle_profit);
 	}
 
 	_current_company = old_company;
@@ -1527,16 +1539,25 @@
  *                   picked up by another vehicle when all
  *                   previous vehicles have loaded.
  */
-static void LoadUnloadVehicle(Vehicle *v, int *cargo_left)
+static void LoadUnloadVehicle(Vehicle *v, RoutingBase::CargoTypesByStationMap& cargo_left)
 {
 	assert(v->current_order.IsType(OT_LOADING));
+	Vehicle *u = v;
 
 	/* We have not waited enough time till the next round of loading/unloading */
 	if (--v->load_unload_time_rem != 0) {
 		if (_settings_game.order.improved_load && (v->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
 			/* 'Reserve' this cargo for this vehicle, because we were first. */
 			for (; v != NULL; v = v->Next()) {
-				if (v->cargo_cap != 0) cargo_left[v->cargo_type] -= v->cargo_cap - v->cargo.Count();
+				RoutingBase::CargoByStationMap::iterator it;
+
+				/* Loop through all the possible nexthops in the cargo list of the station */
+				for (it = cargo_left[v->cargo_type].begin(); it != cargo_left[v->cargo_type].end(); ++it) {
+					/* We can board, so actually reserve the cargo. We can cache this as well */
+					if (RoutingBase::Routing(v->cargo_type)->UseVehicle(u, it->first, false) && v->cargo_cap != 0) {
+						it->second -= v->cargo_cap - v->cargo.Count();
+					}
+				}
 			}
 		}
 		return;
@@ -1553,18 +1574,23 @@
 	}
 
 	int unloading_time = 0;
-	Vehicle *u = v;
-	int result = 0;
+	bool refresh = false;
 	uint cap;
+	uint count = 0;
 
 	bool completely_emptied = true;
 	bool anything_unloaded = false;
 	bool anything_loaded   = false;
 	uint32 cargo_not_full  = 0;
 	uint32 cargo_full      = 0;
+	uint32 cargo_moved     = 0;
+	CargoID prev_type      = CT_INVALID;
 
 	v->cur_speed = 0;
 
+	/* Count cargo that can be loaded */
+	RoutingBase::HandledStationFlagMap loadmap;
+
 	for (; v != NULL; v = v->Next()) {
 		if (v->cargo_cap == 0) continue;
 
@@ -1583,31 +1609,26 @@
 		if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING) && (u->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
 			uint cargo_count = v->cargo.Count();
 			uint amount_unloaded = _settings_game.order.gradual_loading ? min(cargo_count, load_amount) : cargo_count;
-			bool remaining; // Are there cargo entities in this vehicle that can still be unloaded here?
 
-			if (HasBit(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE) && !(u->current_order.GetUnloadType() & OUFB_TRANSFER)) {
-				/* The cargo has reached it's final destination, the packets may now be destroyed */
-				remaining = v->cargo.MoveTo(NULL, amount_unloaded, CargoList::MTA_FINAL_DELIVERY, last_visited);
+			uint8 result = RoutingBase::Routing(v->cargo_type)->ProcessUnload(ge, amount_unloaded, last_visited, v, u);
 
-				result |= 1;
-			} else if (u->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) {
-				remaining = v->cargo.MoveTo(&ge->cargo, amount_unloaded);
-				SetBit(ge->acceptance_pickup, GoodsEntry::PICKUP);
+			if (result == 2) continue;
 
-				result |= 2;
-			} else {
-				/* The order changed while unloading (unset unload/transfer) or the
-				 * station does not accept goods anymore. */
-				ClrBit(v->vehicle_flags, VF_CARGO_UNLOADING);
-				continue;
-			}
+			bool remaining = !!result; // Are there cargo entities in this vehicle that can still be unloaded here?
 
 			/* Deliver goods to the station */
 			st->time_since_unload = 0;
 
-			unloading_time += amount_unloaded;
+			/* The amount unloaded may not necessarily be what we expected */
+			amount_unloaded = cargo_count - v->cargo.Count();
 
-			anything_unloaded = true;
+			if (amount_unloaded > 0) {
+				unloading_time += amount_unloaded;
+				anything_unloaded = true;
+				refresh = true;
+				SetBit(cargo_moved, v->cargo_type);
+			}
+
 			if (_settings_game.order.gradual_loading && remaining) {
 				completely_emptied = false;
 			} else {
@@ -1636,24 +1657,55 @@
 
 		/* If there's goods waiting at the station, and the vehicle
 		 * has capacity for it, load it on the vehicle. */
-		if (!ge->cargo.Empty() &&
+		uint waiting = ge->cargo.Count();
+
+		if (v->cargo_type != prev_type) {
+			loadmap.clear();
+			count = 0;
+
+			for (CargoList::List::const_iterator it = ge->cargo.Packets()->begin(); it != ge->cargo.Packets()->end(); ++it) {
+				const CargoPacket *cp = *it;
+
+				/* Let's see if our current target is in the cache */
+				RoutingBase::HandledStationFlagMap::iterator pos = loadmap.find(cp->target);
+
+				/* A failed find sets the iterator to end() */
+				if (pos == loadmap.end()) {
+					if (RoutingBase::Routing(v->cargo_type)->UseVehicle(u, cp->target, false)) {
+						/* We've found our route once, store it in the map so that we don't
+						 * need to recompute again
+						 */
+						loadmap.insert(RoutingBase::HandledStationFlag(cp->target, true));
+						count += cp->count;
+					} else {
+						/* We can't use this vehicle, store this answer in the map as well */
+						loadmap.insert(RoutingBase::HandledStationFlag(cp->target, false));
+					}
+				} else if (pos->second == true) count += cp->count;
+			}
+		}
+
+		prev_type = v->cargo_type;
+
+		if (count > 0 &&
 				(cap = v->cargo_cap - v->cargo.Count()) != 0) {
-			uint count = ge->cargo.Count();
+
+			/* Locate the position in the map for 1) the correct cargo type, and 2) going to the right destination */
+			RoutingBase::CargoByStationMap::iterator cargo_left_pos = cargo_left[v->cargo_type].find(RoutingBase::Routing(v->cargo_type)->NextUnloadStationForVehicle(u));
+			bool                                       reserve_cargo  = (_settings_game.order.improved_load && cargo_left_pos != cargo_left[v->cargo_type].end());
 
 			/* Skip loading this vehicle if another train/vehicle is already handling
-			 * the same cargo type at this station */
-			if (_settings_game.order.improved_load && cargo_left[v->cargo_type] <= 0) {
+			 * the same cargo type at this station and there's nothing left for us */
+			if (reserve_cargo && cargo_left_pos->second <= 0) {
 				SetBit(cargo_not_full, v->cargo_type);
 				continue;
 			}
 
 			if (cap > count) cap = count;
 			if (_settings_game.order.gradual_loading) cap = min(cap, load_amount);
-			if (_settings_game.order.improved_load) {
-				/* Don't load stuff that is already 'reserved' for other vehicles */
-				cap = min((uint)cargo_left[v->cargo_type], cap);
-				cargo_left[v->cargo_type] -= cap;
-			}
+
+			/* Don't load stuff that is already 'reserved' for other vehicles */
+			if (reserve_cargo) cap = min((uint)cargo_left_pos->second, cap);
 
 			if (v->cargo.Empty()) TriggerVehicle(v, VEHICLE_TRIGGER_NEW_CARGO);
 
@@ -1665,18 +1717,27 @@
 			 * completely_emptied assignment can then be safely
 			 * removed; that's how TTDPatch behaves too. --pasky */
 			completely_emptied = false;
-			anything_loaded = true;
 
-			ge->cargo.MoveTo(&v->cargo, cap, CargoList::MTA_CARGO_LOAD, st->xy);
+			ge->cargo.MoveTo(&v->cargo, cap, v->cargo_type, CargoList::MTA_CARGO_LOAD, st->xy, u);
+
+			/* The amount loaded may not necessarily be what we expected */
+			cap = waiting - ge->cargo.Count();
+			count -= cap;
+
+			if (cap > 0) {
+				anything_loaded = true;
+				unloading_time += cap;
+				refresh = true;
+				SetBit(cargo_moved, v->cargo_type);
+
+				/* Reserve stuff for us */
+				if (reserve_cargo) cargo_left_pos->second -= cap;
+			}
 
 			st->time_since_load = 0;
 			st->last_vehicle_type = v->type;
 
 			StationAnimationTrigger(st, st->xy, STAT_ANIM_CARGO_TAKEN, v->cargo_type);
-
-			unloading_time += cap;
-
-			result |= 2;
 		}
 
 		if (v->cargo.Count() == v->cargo_cap) {
@@ -1696,7 +1757,15 @@
 	if (_settings_game.order.improved_load && (u->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
 		/* Update left cargo */
 		for (v = u; v != NULL; v = v->Next()) {
-			if (v->cargo_cap != 0) cargo_left[v->cargo_type] -= v->cargo_cap - v->cargo.Count();
+			RoutingBase::CargoByStationMap::iterator it;
+
+			/* Loop through all the possible nexthops in the cargo list of the station */
+			for (it = cargo_left[v->cargo_type].begin(); it != cargo_left[v->cargo_type].end(); ++it) {
+				/* We can board, so actually reserve the cargo. More cache options here */
+				if (RoutingBase::Routing(v->cargo_type)->UseVehicle(u, it->first, false) && v->cargo_cap != 0) {
+					it->second -= v->cargo_cap - v->cargo.Count();
+				}
+			}
 		}
 	}
 
@@ -1760,14 +1829,14 @@
 		TriggerVehicle(v, VEHICLE_TRIGGER_EMPTY);
 	}
 
-	if (result != 0) {
+	if (refresh) {
 		InvalidateWindow(GetWindowClassForVehicleType(v->type), v->owner);
 		InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
 
 		st->MarkTilesDirty(true);
 		v->MarkDirty();
 
-		if (result & 2) InvalidateWindow(WC_STATION_VIEW, last_visited);
+		InvalidateWindowData(WC_STATION_VIEW, last_visited, cargo_moved);
 	}
 }
 
@@ -1778,9 +1847,25 @@
  */
 void LoadUnloadStation(Station *st)
 {
-	int cargo_left[NUM_CARGO];
+	if (st->loading_vehicles.empty()) return;
 
-	for (uint i = 0; i < NUM_CARGO; i++) cargo_left[i] = st->goods[i].cargo.Count();
+	/*
+	 * A vector of maps. The vector is basically
+	 * the "array" of all cargo-types, the map
+	 * contains the mapping from a the StationID of
+	 * the nexthop to the amount of cargo
+	 */
+	RoutingBase::CargoTypesByStationMap cargo_left;
+
+	/* Make a local copy of the cargo left maps
+	 * this is because the reservation system for fifo
+	 * loading reserves in cargo_left but the amount
+	 * of cargo doesn't actually change
+	 */
+	for (CargoID c = CT_BEGIN; c != NUM_CARGO; c++) {
+		st->goods[c].cargo.RecomputeCargoLeftCache();
+		cargo_left.push_back(*(st->goods[c].cargo.CargoLeft()->Map()));
+	}
 
 	std::list<Vehicle *>::iterator iter;
 	for (iter = st->loading_vehicles.begin(); iter != st->loading_vehicles.end(); ++iter) {
diff -r cefcfd943f94 src/functions.h
--- a/src/functions.h	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/functions.h	Tue Feb 17 03:31:08 2009 +0100
@@ -46,7 +46,7 @@
  */
 void MarkAllViewportsDirty(int left, int top, int right, int bottom);
 void ShowCostOrIncomeAnimation(int x, int y, int z, Money cost);
-void ShowFeederIncomeAnimation(int x, int y, int z, Money cost);
+void ShowFeederIncomeAnimation(int x, int y, int z, Money transfer, Money cost);
 
 void AskExitGame();
 void AskExitToGameMenu();
diff -r cefcfd943f94 src/lang/english.txt
--- a/src/lang/english.txt	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/lang/english.txt	Tue Feb 17 03:31:08 2009 +0100
@@ -17,6 +17,11 @@
 STR_0008_WAITING                                                :{BLACK}Waiting: {WHITE}{STRING}
 STR_0009                                                        :{WHITE}{CARGO}
 STR_EN_ROUTE_FROM                                               :{YELLOW}({SHORTCARGO} en-route from {STATION})
+STR_EN_ROUTE_FROM_TO                                            :{YELLOW}({SHORTCARGO} en-route from {STATION} to {STATION})
+STR_ORIGIN_TO                                                   :{BLACK}({SHORTCARGO} to {STATION})
+STR_ORIGIN_TO_AND_VIA                                           :{BLACK}({SHORTCARGO} to {STATION}, {YELLOW}{SHORTCARGO} continuing, {GREEN}{SHORTCARGO} arriving)
+STR_ORIGIN_NO_ROUTE                                             :{RED}({SHORTCARGO} to {SKIP}{STATION}, no route found!)
+STR_GOING_VIA                                                   :{BLACK}({SHORTCARGO} going via {STATION})
 STR_000C_ACCEPTS                                                :{BLACK}Accepts: {WHITE}
 STR_000D_ACCEPTS                                                :{BLACK}Accepts: {GOLD}
 STR_SUPPLIES                                                    :{BLACK}Supplies: {GOLD}
@@ -198,6 +203,7 @@
 STR_00E5_CONTOURS                                               :Contours
 STR_00E6_VEHICLES                                               :Vehicles
 STR_00E7_INDUSTRIES                                             :Industries
+STR_SMALLMAP_ROUTEMAP                                           :Route Network
 STR_00E8_ROUTES                                                 :Routes
 STR_00E9_VEGETATION                                             :Vegetation
 STR_00EA_OWNERS                                                 :Owners
@@ -341,6 +347,8 @@
 STR_SORT_BY_FACILITY                                            :Station type
 STR_SORT_BY_WAITING                                             :Waiting cargo value
 STR_SORT_BY_RATING_MAX                                          :Cargo rating
+STR_SORT_BY_CARGO_TARGET                                        :Destination station
+STR_SORT_BY_CARGO_COUNT                                         :Cargo waiting
 STR_ENGINE_SORT_ENGINE_ID                                       :EngineID (classic sort)
 STR_ENGINE_SORT_COST                                            :Cost
 STR_ENGINE_SORT_POWER                                           :Power
@@ -365,6 +373,13 @@
 STR_SEND_AIRCRAFT_TO_HANGAR                                     :Send to Hangar
 STR_SEND_FOR_SERVICING                                          :Send for Servicing
 
+STR_VIEW_MODE                                                   :View Mode
+STR_VIEW_MODE_FULL                                              :Full View
+STR_VIEW_MODE_DESTINATION                                       :Destination View
+STR_VIEW_MODE_NEXTHOP                                           :NextHop View
+STR_VIEW_MODE_TREE                                              :Tree View
+STR_VIEW_MODE_SOURCE                                            :Source View
+
 ############ range for months starts
 STR_0162_JAN                                                    :Jan
 STR_0163_FEB                                                    :Feb
@@ -1037,6 +1052,12 @@
 STR_CONFIG_SETTING_SHOW_TRACK_RESERVATION                       :{LTBLUE}Show reserved tracks: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_PERSISTENT_BUILDINGTOOLS                     :{LTBLUE}Keep building tools active after usage: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_EXPENSES_LAYOUT                              :{LTBLUE}Group expenses in company finance window: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEFAULT_STATION_CARGO_VIEW                   :{LTBLUE}Default station cargo view: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEFAULT_STATION_CARGO_VIEW_FULL              :All sources and destinations
+STR_CONFIG_SETTING_DEFAULT_STATION_CARGO_VIEW_DESTINATIONS      :Destinations only
+STR_CONFIG_SETTING_DEFAULT_STATION_CARGO_VIEW_NEXTHOP           :Next hop only
+STR_CONFIG_SETTING_DEFAULT_STATION_CARGO_VIEW_TREE              :Tree
+STR_CONFIG_SETTING_DEFAULT_STATION_CARGO_VIEW_SOURCE            :Source
 
 STR_CONFIG_SETTING_ALWAYS_BUILD_INFRASTRUCTURE                  :{LTBLUE}Show building tools when no suitable vehicles are available: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_MAX_TRAINS                                   :{LTBLUE}Max trains per player: {ORANGE}{STRING1}
@@ -1127,6 +1148,25 @@
 STR_CONFIG_SETTING_ECONOMY_TOWNS                                :{ORANGE}Towns
 STR_CONFIG_SETTING_ECONOMY_INDUSTRIES                           :{ORANGE}Industries
 
+STR_CONFIG_SETTING_PAXDEST                                      :{LTBLUE}Passengers can be delivered to {ORANGE}{STRING1}
+STR_CONFIG_SETTING_PAXDEST_ANYWHERE                             :anywhere
+STR_CONFIG_SETTING_PAXDEST_MAXACCEPTANCE                        :anywhere, but with a maximum monthly acceptance
+STR_CONFIG_SETTING_PAXDEST_DESTINATIONS                         :chosen destinations
+STR_CONFIG_SETTING_MAILDEST                                     :{LTBLUE}Mail can be delivered to {ORANGE}{STRING1}
+STR_CONFIG_SETTING_MAILDEST_ANYWHERE                            :anywhere
+STR_CONFIG_SETTING_MAILDEST_MAXACCEPTANCE                       :anywhere, but with a maximum monthly acceptance
+STR_CONFIG_SETTING_MAILDEST_DESTINATIONS                        :chosen destinations
+STR_CONFIG_SETTING_GOLDDEST                                     :{LTBLUE}Valuables etc. can be delivered to {ORANGE}{STRING1}
+STR_CONFIG_SETTING_GOLDDEST_ANYWHERE                            :anywhere
+STR_CONFIG_SETTING_GOLDDEST_MAXACCEPTANCE                       :anywhere, but with a maximum monthly acceptance
+STR_CONFIG_SETTING_GOLDDEST_DESTINATIONS                        :chosen destinations
+STR_CONFIG_SETTING_OTHERDEST                                    :{LTBLUE}Other cargo can be delivered to {ORANGE}{STRING1}
+STR_CONFIG_SETTING_OTHERDEST_ANYWHERE                           :anywhere
+STR_CONFIG_SETTING_OTHERDEST_MAXACCEPTANCE                      :anywhere, but with a maximum monthly acceptance
+STR_CONFIG_SETTING_OTHERDEST_DESTINATIONS                       :chosen destinations
+
+
+
 STR_CONFIG_SETTING_PATHFINDER_FOR_TRAINS                        :{LTBLUE}Pathfinder for trains: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_PATHFINDER_FOR_TRAINS_NTP                    :NTP {RED}(Not recommended)
 STR_CONFIG_SETTING_PATHFINDER_FOR_TRAINS_NPF                    :NPF
@@ -1532,6 +1572,10 @@
 STR_0803_INCOME                                                 :{GREEN}Income: {CURRENCY}
 STR_FEEDER_TINY                                                 :{TINYFONT}{YELLOW}Transfer: {CURRENCY}
 STR_FEEDER                                                      :{YELLOW}Transfer: {CURRENCY}
+STR_FEEDER_INCOME_TINY                                          :{TINYFONT}{YELLOW}Transfer: {CURRENCY}{GREEN} Income: {CURRENCY}
+STR_FEEDER_INCOME                                               :{YELLOW}Transfer: {CURRENCY}{GREEN} Income: {CURRENCY}
+STR_FEEDER_COST_TINY                                            :{TINYFONT}{YELLOW}Transfer: {CURRENCY}{RED} Cost: {CURRENCY}
+STR_FEEDER_COST                                                 :{YELLOW}Transfer: {CURRENCY}{RED} Cost: {CURRENCY}
 STR_0805_ESTIMATED_COST                                         :{WHITE}Estimated Cost: {CURRENCY}
 STR_0807_ESTIMATED_INCOME                                       :{WHITE}Estimated Income: {CURRENCY}
 STR_0808_CAN_T_RAISE_LAND_HERE                                  :{WHITE}Can't raise land here...
@@ -1766,6 +1810,7 @@
 STR_TOWN                                                        :{TOWN}
 STR_INDUSTRY_FORMAT                                             :{TOWN} {STRING}
 STR_STATION                                                     :{STATION}
+STR_CARGO                                                       :{STRING}
 
 ##id 0x2800
 STR_LANDSCAPING                                                 :Landscaping
@@ -2693,6 +2738,7 @@
 
 STR_INVALID_ORDER                                               :{RED} (Invalid Order)
 
+STR_ANY_DESTINATION                                             :anywhere
 STR_UNKNOWN_STATION                                             :unknown station
 STR_8812_EMPTY                                                  :{LTBLUE}Empty
 STR_8813_FROM                                                   :{LTBLUE}{CARGO} from {STATION}
@@ -3346,6 +3392,7 @@
 
 STR_SMALLMAP_CENTER                                             :{BLACK}Center the smallmap on the current position
 STR_SMALLMAP_INDUSTRY                                           :{TINYFONT}{STRING} ({NUM})
+STR_SMALLMAP_ROUTEMAP_LEGEND                                    :{TINYFONT}{STRING}
 
 # Strings for map borders at game generation
 STR_BORDER_TYPE                                                 :{BLACK}Map edges:
diff -r cefcfd943f94 src/misc.cpp
--- a/src/misc.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/misc.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -24,6 +24,7 @@
 #include "tilehighlight_func.h"
 #include "network/network_func.h"
 #include "window_func.h"
+#include "routing.h"
 
 #include "table/sprites.h"
 
@@ -81,6 +82,7 @@
 	InitializeDepots();
 	InitializeOrders();
 	InitializeGroup();
+	RoutingBase::InitializeRoutingSystems();
 
 	InitNewsItemStructs();
 	InitializeLandscape();
diff -r cefcfd943f94 src/misc_gui.cpp
--- a/src/misc_gui.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/misc_gui.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -572,12 +572,22 @@
 	AddTextEffect(msg, pt.x, pt.y, 0x250, TE_RISING);
 }
 
-void ShowFeederIncomeAnimation(int x, int y, int z, Money cost)
+void ShowFeederIncomeAnimation(int x, int y, int z, Money transfer, Money cost)
 {
 	Point pt = RemapCoords(x, y, z);
 
-	SetDParam(0, cost);
-	AddTextEffect(STR_FEEDER, pt.x, pt.y, 0x250, TE_RISING);
+	SetDParam(0, transfer);
+	if (cost != 0) {
+		StringID msg = STR_FEEDER_COST;
+		if (cost < 0) {
+			cost = -cost;
+			msg  = STR_FEEDER_INCOME;
+		}
+		SetDParam(1, cost);
+		AddTextEffect(msg, pt.x, pt.y, 0x250, TE_RISING);
+	} else {
+		AddTextEffect(STR_FEEDER, pt.x, pt.y, 0x250, TE_RISING);
+	}
 }
 
 TextEffectID ShowFillingPercent(int x, int y, int z, uint8 percent, StringID string)
diff -r cefcfd943f94 src/openttd.cpp
--- a/src/openttd.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/openttd.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -50,6 +50,7 @@
 #include "elrail_func.h"
 #include "rev.h"
 #include "highscore.h"
+#include "routing.h"
 
 #include "newgrf_commons.h"
 
@@ -311,11 +312,14 @@
 	/* Uninitialize airport state machines */
 	UnInitializeAirports();
 
+	RoutingBase::UnInitializeRoutingSystems();
+
 	/* Uninitialize variables that are allocated dynamically */
 	GamelogReset();
 	_Town_pool.CleanPool();
 	_Industry_pool.CleanPool();
 	_Station_pool.CleanPool();
+	RoutingBase::UnInitializeRoutingSystems();
 	_Vehicle_pool.CleanPool();
 	_Sign_pool.CleanPool();
 	_Order_pool.CleanPool();
diff -r cefcfd943f94 src/order_base.h
--- a/src/order_base.h	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/order_base.h	Tue Feb 17 03:31:08 2009 +0100
@@ -37,11 +37,12 @@
 
 public:
 	Order *next;          ///< Pointer to next order. If NULL, end of list
+	Order *prev;          ///< NOSAVE: Pointer to previous order.
 
 	uint16 wait_time;    ///< How long in ticks to wait at the destination.
 	uint16 travel_time;  ///< How long in ticks the journey to this destination should take.
 
-	Order() : refit_cargo(CT_NO_REFIT) {}
+	Order() : refit_cargo(CT_NO_REFIT), next(NULL), prev(NULL) {}
 	~Order() { this->type = OT_NOTHING; }
 
 	/**
@@ -236,6 +237,71 @@
 	 * it moves all bits to the new location.
 	 */
 	void ConvertFromOldSavegame();
+
+	/**
+	 * Returns the next order in a cyclic manner, i. e. it jumps from
+	 * the last to the first order
+	 */
+	const Order *GetNextOrderCyclic() const;
+
+	/**
+	 * Returns the previous order in a cyclic manner, i. e. it jumps from
+	 * the first to the last order
+	 */
+	const Order *GetPreviousOrderCyclic() const;
+
+	/**
+	 * Finds out whether a train does actually stop at a station on
+	 * its order list.
+	 * @param order  The order to analyse
+	 * @returns      true if the train will stop
+	 */
+	bool IsStoppingOrder() const;
+
+	/**
+	 * Finds out whether cargo can be unloaded at this station
+	 * @param   order The order to analyse
+	 * @returns       Whether cargo can be unloaded
+	 */
+	bool IsUnloadingOrder() const;
+
+	/**
+	 * Obtains the next order where cargo can be unloaded
+	 * @param   start The order to which the next order should be obtained for
+	 * @returns       The order that succeeds the order in question and unloads cargo
+	 * @retval  NULL  No such order has been found
+	 */
+	const Order *GetNextUnloadingOrder() const;
+
+	/**
+	 * Finds out whether cargo can be loaded at this station
+	 * @param   order The order to analyse
+	 * @returns       Whether cargo can be loaded
+	 */
+	bool IsLoadingOrder() const;
+
+	/**
+	 * Obtains the previous order where cargo can be loaded
+	 * @param   start The order to which the previous order should be obtained for
+	 * @returns       The order that precedes the order in question and loads cargo
+	 * @retval  NULL  No such order has been found
+	 */
+	const Order *GetPreviousLoadingOrder() const;
+
+	/**
+	 * Obtains the next order where cargo can be loaded
+	 * @param   start The order to which the previous order should be obtained for
+	 * @returns       The next order that loads cargo
+	 * @retval  NULL  No such order has been found
+	 */
+	const Order *GetNextLoadingOrder() const;
+
+	/**
+	 * Finds out whether a train does stop at a station on its order list
+	 * @param flags The flags of the order to analyse
+	 * @returns     true if the train will stop
+	 */
+	static bool IsStoppingOrder(OrderNonStopFlags flags);
 };
 
 static inline VehicleOrderID GetMaxOrderIndex()
@@ -277,8 +343,10 @@
 	/** Create an order list with the given order chain for the given vehicle.
 	 *  @param chain is the pointer to the first order of the order chain
 	 *  @param v is any vehicle of the shared order vehicle chain (does not need to be the first)
+	 *  @param no_cargodest If set to true the cargodest routing network is not updated (used during
+	 *    loading of games where the routing network is not yet initialized).
 	 */
-	OrderList(Order *chain, Vehicle *v);
+	OrderList(Order *chain, Vehicle *v, bool no_cargodest = false);
 
 	/** Destructor. Invalidates OrderList for re-usage by the pool. */
 	~OrderList() { this->num_orders = INVALID_VEH_ORDER_ID; }
diff -r cefcfd943f94 src/order_cmd.cpp
--- a/src/order_cmd.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/order_cmd.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -20,6 +20,8 @@
 #include "oldpool_func.h"
 #include "depot_base.h"
 #include "settings_type.h"
+#include "debug.h"
+#include "routing.h"
 
 #include "table/strings.h"
 
@@ -42,6 +44,7 @@
 	this->flags = 0;
 	this->dest  = 0;
 	this->next  = NULL;
+	this->prev  = NULL;
 }
 
 void Order::MakeGoToStation(StationID destination)
@@ -133,6 +136,7 @@
 	this->flags   = GB(packed,  8,  8);
 	this->dest    = GB(packed, 16, 16);
 	this->next    = NULL;
+	this->prev    = NULL;
 	this->refit_cargo   = CT_NO_REFIT;
 	this->refit_subtype = 0;
 	this->wait_time     = 0;
@@ -178,14 +182,110 @@
 	this->travel_time = other.travel_time;
 }
 
+const Order *Order::GetNextOrderCyclic() const
+{
+	const Order *order = this;
+	if (order == NULL) return NULL;
 
-OrderList::OrderList(Order *chain, Vehicle *v) :
+	if (order->next == NULL) {
+		if (order->prev == NULL) return NULL;
+		do order = order->prev; while (order->prev != NULL);
+		return order;
+	}
+
+	return order->next;
+}
+
+
+const Order *Order::GetPreviousOrderCyclic() const
+{
+	const Order *order = this;
+	if (order == NULL) return NULL;
+
+	if (order->prev == NULL) {
+		if (order->next == NULL) return NULL;
+		do order = order->next; while (order->next != NULL);
+		return order;
+	}
+
+	return order->prev;
+}
+
+bool Order::IsStoppingOrder() const
+{
+	return (this->GetNonStopType() == ONSF_STOP_EVERYWHERE || this->GetNonStopType() == ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS);
+}
+
+/* static */
+bool Order::IsStoppingOrder(OrderNonStopFlags flags)
+{
+	return (flags == ONSF_STOP_EVERYWHERE || flags == ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS);
+}
+
+bool Order::IsUnloadingOrder() const
+{
+	if (this->GetType() != OT_GOTO_STATION) return false;
+	if (GetStation(this->GetDestination())->IsBuoy()) return false;
+
+	return (this->IsStoppingOrder() && this->GetUnloadType() != OUFB_NO_UNLOAD);
+}
+
+const Order *Order::GetNextUnloadingOrder() const
+{
+	const Order *order = this;
+
+	for (order = order->GetNextOrderCyclic(); order != this; order = order->GetNextOrderCyclic()) {
+		if (order == NULL) return NULL;
+		if (order->IsUnloadingOrder()) return order;
+	}
+
+	return NULL;
+}
+
+bool Order::IsLoadingOrder() const
+{
+	if (this->GetType() != OT_GOTO_STATION) return false;
+	if (GetStation(this->GetDestination())->IsBuoy()) return false;
+
+	return (this->IsStoppingOrder() && this->GetLoadType() != OLFB_NO_LOAD);
+}
+
+const Order *Order::GetPreviousLoadingOrder() const
+{
+	const Order *order = this;
+
+	for (order = order->GetPreviousOrderCyclic(); order != this; order = order->GetPreviousOrderCyclic()) {
+		if (order == NULL) return NULL;
+		if (order->IsLoadingOrder()) return order;
+	}
+
+	return NULL;
+}
+
+const Order *Order::GetNextLoadingOrder() const
+{
+	const Order *order = this;
+	for (order = order->GetNextOrderCyclic(); order != this; order = order->GetNextOrderCyclic()) {
+		if (order == NULL) return NULL;
+		if (order->IsLoadingOrder()) return order;
+	}
+
+	return NULL;
+}
+
+OrderList::OrderList(Order *chain, Vehicle *v, bool no_cargodest) :
 		first(chain), num_orders(0), num_vehicles(1), first_shared(v),
 		timetable_duration(0)
 {
+	/* If chain is not the first order we'll get problems */
+	assert(first == NULL || first->prev == NULL);
+
+	Order *prev = NULL;
 	for (Order *o = this->first; o != NULL; o = o->next) {
 		++this->num_orders;
 		this->timetable_duration += o->wait_time + o->travel_time;
+		o->prev = prev;
+		prev = o;
 	}
 
 	for (Vehicle *u = v->PreviousShared(); u != NULL; u = u->PreviousShared()) {
@@ -194,10 +294,20 @@
 	}
 
 	for (const Vehicle *u = v->NextShared(); u != NULL; u = u->NextShared()) ++this->num_vehicles;
+
+	/* During game loading we usually don't have initialized all data structures, yet */
+	if (!no_cargodest) {
+		uint32 mask = v->GetCargoForSharedVehicles();
+		RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListInsertion, first, v->type, mask);
+	}
 }
 
 void OrderList::FreeChain(bool keep_orderlist)
 {
+	Vehicle *v = this->first_shared;
+	uint32 mask = v->GetCargoForSharedVehicles();
+	RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListRemoval, first, v->type, mask);
+
 	Order *next;
 	for(Order *o = this->first; o != NULL; o = next) {
 		next = o->next;
@@ -234,18 +344,27 @@
 			/* Insert as first or only order */
 			new_order->next = this->first;
 			this->first = new_order;
+			if (new_order->next != NULL) new_order->next->prev = new_order;
 		} else if (index >= this->num_orders) {
 			/* index is after the last order, add it to the end */
-			this->GetLastOrder()->next = new_order;
+			Order *before = this->GetLastOrder();
+			before->next = new_order;
+			new_order->prev = before;
 		} else {
 			/* Put the new order in between */
 			Order *order = this->GetOrderAt(index - 1);
+			new_order->prev = order;
 			new_order->next = order->next;
 			order->next = new_order;
+			new_order->next->prev = new_order;
 		}
 	}
 	++this->num_orders;
 	this->timetable_duration += new_order->wait_time + new_order->travel_time;
+
+	Vehicle *v = this->first_shared;
+	uint32 mask = v->GetCargoForSharedVehicles();
+	RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderInsertion, new_order, v->type, mask);
 }
 
 
@@ -253,18 +372,30 @@
 {
 	if (index >= this->num_orders) return;
 
+	Order *prev;
 	Order *to_remove;
 
 	if (index == 0) {
 		to_remove = this->first;
+	} else {
+		prev = GetOrderAt(index - 1);
+		to_remove = prev->next;
+	}
+
+	Vehicle *v = this->first_shared;
+	uint32 mask = v->GetCargoForSharedVehicles();
+	RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderRemoval, to_remove, v->type, mask);
+
+	if (index == 0) {
 		this->first = to_remove->next;
+		if (this->first != NULL) this->first->prev = NULL;
 	} else {
-		Order *prev = GetOrderAt(index - 1);
-		to_remove = prev->next;
 		prev->next = to_remove->next;
+		if (prev->next != NULL) prev->next->prev = prev;
 	}
 	--this->num_orders;
 	this->timetable_duration -= (to_remove->wait_time + to_remove->travel_time);
+
 	delete to_remove;
 }
 
@@ -272,27 +403,36 @@
 {
 	if (from >= this->num_orders || to >= this->num_orders || from == to) return;
 
-	Order *moving_one;
+	Order *moving_one = GetOrderAt(from);
+	Vehicle *v = this->first_shared;
+	uint32 mask = v->GetCargoForSharedVehicles();
+	RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderRemoval, moving_one, v->type, mask);
 
 	/* Take the moving order out of the pointer-chain */
 	if (from == 0) {
-		moving_one = this->first;
 		this->first = moving_one->next;
+		this->first->prev = NULL;
 	} else {
 		Order *one_before = GetOrderAt(from - 1);
-		moving_one = one_before->next;
 		one_before->next = moving_one->next;
+		if (one_before->next != NULL) one_before->next->prev = one_before;
 	}
 
 	/* Insert the moving_order again in the pointer-chain */
 	if (to == 0) {
+		this->first->prev = moving_one;
+		moving_one->prev = NULL;
 		moving_one->next = this->first;
 		this->first = moving_one;
 	} else {
 		Order *one_before = GetOrderAt(to - 1);
+		moving_one->prev = one_before;
 		moving_one->next = one_before->next;
 		one_before->next = moving_one;
+		if (moving_one->next != NULL) moving_one->next->prev = moving_one;
 	}
+
+	RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderInsertion, moving_one, v->type, mask);
 }
 
 void OrderList::RemoveVehicle(Vehicle *v)
@@ -934,6 +1074,12 @@
 	}
 
 	if (flags & DC_EXEC) {
+		uint32 mask = v->GetCargoForSharedVehicles();
+
+		for (uint c = 0; c < NUM_CARGO; c++) {
+			if (HasBit(mask, c)) RoutingBase::Routing(c)->ProcessOrderListRemoval(v->GetFirstOrder(), v->type);
+		}
+
 		switch (mof) {
 			case MOF_NON_STOP:
 				order->SetNonStopType((OrderNonStopFlags)data);
@@ -1015,6 +1161,10 @@
 			default: NOT_REACHED();
 		}
 
+		for (uint c = 0; c < NUM_CARGO; c++) {
+			if (HasBit(mask, c)) RoutingBase::Routing(c)->ProcessOrderListInsertion(v->GetFirstOrder(), v->type);
+		}
+
 		/* Update the windows and full load flags, also for vehicles that share the same order list */
 		Vehicle *u = v->FirstShared();
 		DeleteOrderWarnings(u);
@@ -1155,6 +1305,12 @@
 					new (dst->orders.list) OrderList(first, dst);
 				}
 
+				Order *neworder;
+
+				FOR_VEHICLE_ORDERS(dst, neworder) {
+					if (neworder->next != NULL) neworder->next->prev = neworder;
+				}
+
 				InvalidateVehicleOrder(dst, -1);
 
 				InvalidateWindowClassesData(GetWindowClassForVehicleType(dst->type), 0);
@@ -1483,6 +1639,10 @@
 			if (order->IsType(OT_GOTO_DEPOT) && (order->GetDepotActionType() & ODATFB_NEAREST_DEPOT) != 0) continue;
 			if ((v->type == VEH_AIRCRAFT && order->IsType(OT_GOTO_DEPOT) ? OT_GOTO_STATION : order->GetType()) == type &&
 					order->GetDestination() == destination) {
+				uint32 mask = v->GetCargoForSharedVehicles();
+
+				RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderRemoval, order, v->type, mask);
+
 				order->MakeDummy();
 				for (const Vehicle *w = v->FirstShared(); w != NULL; w = w->NextShared()) {
 					/* In GUI, simulate by removing the order and adding it back */
@@ -1527,6 +1687,10 @@
 		v->RemoveFromShared();
 		v->orders.list = NULL;
 	} else if (v->orders.list != NULL) {
+		uint32 mask = v->GetCargoForSharedVehicles();
+
+		RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListRemoval, v->GetFirstOrder(), v->type, mask);
+
 		/* Remove the orders */
 		v->orders.list->FreeChain(keep_orderlist);
 		if (!keep_orderlist) v->orders.list = NULL;
diff -r cefcfd943f94 src/roadveh_cmd.cpp
--- a/src/roadveh_cmd.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/roadveh_cmd.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -30,6 +30,7 @@
 #include "depot_base.h"
 #include "effectvehicle_func.h"
 #include "settings_type.h"
+#include "routing.h"
 
 #include "table/strings.h"
 #include "table/sprites.h"
@@ -2004,6 +2005,11 @@
 
 	if (new_cid >= NUM_CARGO) return CMD_ERROR;
 
+	uint32 old_mask = 0;
+	if (flags & DC_EXEC) {
+		old_mask = v->GetCargoForSharedVehicles();
+	}
+
 	for (; v != NULL; v = v->Next()) {
 		/* XXX: We refit all the attached wagons en-masse if they can be
 		 * refitted. This is how TTDPatch does it.  TODO: Have some nice
@@ -2074,5 +2080,14 @@
 
 	_returned_refit_capacity = total_capacity;
 
+	if (flags & DC_EXEC) {
+		v = GetVehicle(p1);
+		uint32 new_mask     = v->GetCargoForSharedVehicles();
+		uint32 changed_mask = new_mask ^ old_mask;
+
+		RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListRemoval,   v->GetFirstOrder(), v->type, old_mask & changed_mask);
+		RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListInsertion, v->GetFirstOrder(), v->type, new_mask & changed_mask);
+	}
+
 	return cost;
 }
diff -r cefcfd943f94 src/roadveh_gui.cpp
--- a/src/roadveh_gui.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/roadveh_gui.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -10,13 +10,33 @@
 #include "strings_func.h"
 #include "vehicle_func.h"
 #include "string_func.h"
+#include "routing.h"
 
 #include "table/sprites.h"
 #include "table/strings.h"
 
-void DrawRoadVehDetails(const Vehicle *v, int x, int y)
+#include <vector>
+#include <map>
+
+/**
+ * Returns the number of entries we need for the vehicle detail window
+ * so that we can set the scrollbar accordingly. The list can be long since
+ * we list all destinations for every cargo type carried
+ * @see    GetNumberOfDestinationsAndCargoTypes
+ * @param  veh_id The ID of the vehicle we're looking at
+ * @return The total number of entries in the list
+ */
+int GetRoadVehDetailsWndVScroll(VehicleID veh_id)
 {
-	uint y_offset = RoadVehHasArticPart(v) ? 15 : 0;
+	int num = 2; // Two additional lines: Vehicle Type, Capacity
+
+	for (const Vehicle *v = GetVehicle(veh_id); v != NULL; v = v->Next()) if (v->cargo_cap > 0) num++;
+	return num + RoutingBase::GetNumberOfDestinationsAndCargoTypes(GetVehicle(veh_id));
+}
+
+void DrawRoadVehDetails(const Vehicle *v, int x, int y, int vscroll_pos, uint16 vscroll_cap)
+{
+	uint y_offset = 1;
 	StringID str;
 	Money feeder_share = 0;
 
@@ -24,6 +44,8 @@
 	SetDParam(1, v->build_year);
 	SetDParam(2, v->value);
 	DrawString(x, y + y_offset, STR_9011_BUILT_VALUE, TC_FROMSTRING);
+	RoutingBase::CargoTypesByStationMap cargo_by_destination;
+	RoutingBase::GetDestinationsForCargos(v, cargo_by_destination);
 
 	if (RoadVehHasArticPart(v)) {
 		AcceptedCargo max_cargo;
@@ -65,45 +87,69 @@
 		}
 
 		SetDParamStr(0, capacity);
-		DrawStringTruncated(x, y + 10 + y_offset, STR_JUST_RAW_STRING, TC_BLUE, 380 - x);
+		y_offset += 14;
+		DrawStringTruncated(x, y + y_offset, STR_JUST_RAW_STRING, TC_BLUE, 380 - x);
 
 		for (const Vehicle *u = v; u != NULL; u = u->Next()) {
 			if (u->cargo_cap == 0) continue;
 
-			str = STR_8812_EMPTY;
-			if (!u->cargo.Empty()) {
-				SetDParam(0, u->cargo_type);
-				SetDParam(1, u->cargo.Count());
-				SetDParam(2, u->cargo.Source());
-				str = STR_8813_FROM;
-				feeder_share += u->cargo.FeederShare();
+			if (--vscroll_pos < 0 && vscroll_pos > -vscroll_cap + 2) {
+				str = STR_8812_EMPTY;
+				if (!u->cargo.Empty()) {
+					SetDParam(0, u->cargo_type);
+					SetDParam(1, u->cargo.Count());
+					SetDParam(2, u->cargo.Source());
+					str = STR_8813_FROM;
+				}
+				y_offset += 14;
+				DrawString(x, y + y_offset, str, TC_FROMSTRING);
 			}
-			DrawString(x, y + 21 + y_offset, str, TC_FROMSTRING);
-
-			y_offset += 11;
+			feeder_share += u->cargo.FeederShare();
 		}
 
-		y_offset -= 11;
+		for (RoutingBase::CargoByStationMap::const_iterator it = cargo_by_destination[v->cargo_type].begin(); it != cargo_by_destination[v->cargo_type].end(); ++it) {
+			if (--vscroll_pos < 0 && vscroll_pos > -vscroll_cap + 2) {
+				SetDParam(0, v->cargo_type);
+				SetDParam(1, it->second);
+				SetDParam(2, it->first);
+				y_offset += 14;
+				DrawString(x, y + y_offset, STR_ORIGIN_TO, TC_FROMSTRING);
+			}
+		}
 	} else {
 		SetDParam(0, v->cargo_type);
 		SetDParam(1, v->cargo_cap);
 		SetDParam(2, GetCargoSubtypeText(v));
-		DrawString(x, y + 10 + y_offset, STR_9012_CAPACITY, TC_FROMSTRING);
+		y_offset += 14;
+		DrawString(x, y + y_offset, STR_9012_CAPACITY, TC_FROMSTRING);
 
-		str = STR_8812_EMPTY;
-		if (!v->cargo.Empty()) {
-			SetDParam(0, v->cargo_type);
-			SetDParam(1, v->cargo.Count());
-			SetDParam(2, v->cargo.Source());
-			str = STR_8813_FROM;
-			feeder_share += v->cargo.FeederShare();
+		if (--vscroll_pos < 0 && vscroll_pos > -vscroll_cap + 2) {
+			str = STR_8812_EMPTY;
+			if (!v->cargo.Empty()) {
+				SetDParam(0, v->cargo_type);
+				SetDParam(1, v->cargo.Count());
+				SetDParam(2, v->cargo.Source());
+				str = STR_8813_FROM;
+			}
+			y_offset += 14;
+			DrawString(x, y + y_offset, str, TC_FROMSTRING);
 		}
-		DrawString(x, y + 21 + y_offset, str, TC_FROMSTRING);
+		feeder_share += v->cargo.FeederShare();
+		for (RoutingBase::CargoByStationMap::const_iterator it = cargo_by_destination[v->cargo_type].begin(); it != cargo_by_destination[v->cargo_type].end(); ++it) {
+			if (--vscroll_pos < 0 && vscroll_pos > -vscroll_cap + 2) {
+				SetDParam(0, v->cargo_type);
+				SetDParam(1, it->second);
+				SetDParam(2, it->first);
+				y_offset += 14;
+				DrawString(x, y + y_offset, STR_ORIGIN_TO, TC_FROMSTRING);
+			}
+		}
 	}
 
 	/* Draw Transfer credits text */
 	SetDParam(0, feeder_share);
-	DrawString(x, y + 33 + y_offset, STR_FEEDER_CARGO_VALUE, TC_FROMSTRING);
+	y_offset += 14;
+	DrawString(x, y + y_offset, STR_FEEDER_CARGO_VALUE, TC_FROMSTRING);
 }
 
 
diff -r cefcfd943f94 src/routing.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/routing.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -0,0 +1,919 @@
+/* $Id$ */
+
+/**
+ * @file routing.cpp Implementation of the routing network. For method documentation, please consult the header file.
+ * This file also contains a number of helper functions, classes and such
+ */
+
+
+#include "stdafx.h"
+#include "openttd.h"
+#include "routing_classes.h"
+#include "station_base.h"
+#include "map_func.h"
+#include "cargo_type.h"
+#include "cargotype.h"
+#include "settings_type.h"
+#include "newgrf_cargo.h"
+#include "core/random_func.hpp"
+
+#include "table/strings.h"
+
+#include <stdarg.h>
+#include <vector>
+#include <boost/graph/dijkstra_shortest_paths.hpp>
+
+/**********************************************************************************************
+ * METHOD IMPLEMENTATION OF BASE CLASS OF THE ROUTING SYSTEM                                  *
+ **********************************************************************************************/
+
+std::vector<RoutingBase *> RoutingBase::routingnetworks;
+
+/* static */
+void RoutingBase::InitializeRoutingSystems(bool reread)
+{
+	UnInitializeRoutingSystems();
+	RoutingBase::routingnetworks.resize(NUM_CARGO);
+
+	for (CargoID c = CT_BEGIN; c != RoutingBase::routingnetworks.size(); ++c) {
+		int type;
+
+		if (IsCargoInClass(c, CC_PASSENGERS)) {
+			type = _settings_game.economy.pax_dest_type;
+		} else if (IsCargoInClass(c, CC_MAIL)) {
+			type = _settings_game.economy.mail_dest_type;
+		} else if (IsCargoInClass(c, CC_ARMOURED) && !IsCargoInClass(c, CC_MAIL)) {
+			type = _settings_game.economy.gold_dest_type;
+		} else {
+			type = _settings_game.economy.other_dest_type;
+		}
+
+		if (reread) {
+			Station *st;
+			FOR_ALL_STATIONS(st) st->goods[c].cargo.CreateCargoListEntry(c, st->index);
+		}
+
+		if (type == DESTINATIONS) {
+			RoutingBase::routingnetworks[c] = new RoutingSystem(c, reread);
+		} else {
+			RoutingBase::routingnetworks[c] = new NoRoutingSystem(c);
+		}
+	}
+}
+
+/* static */
+void RoutingBase::ProcessOrder(Process proc, const Order *order, VehicleType type, uint32 mask)
+{
+	for (CargoID c = CT_BEGIN; c < NUM_CARGO; c++) {
+		if (HasBit(mask, c)) (Routing(c)->*proc)(order, type);
+	}
+}
+
+/* static */
+void RoutingBase::UnInitializeRoutingSystems()
+{
+	for (CargoID c = CT_BEGIN; c != RoutingBase::routingnetworks.size(); c++) {
+		Station *st;
+		FOR_ALL_STATIONS(st) st->goods[c].cargo.DeleteCargoListEntry();
+		delete Routing(c);
+	}
+
+	RoutingBase::routingnetworks.clear();
+}
+
+/* static */
+void RoutingBase::ModifyRoutingSystem(CargoID c, int32 type)
+{
+	delete Routing(c);
+	switch (type) {
+		/* Not using the ternary operator due to a) expansion and b) non-compliance with polymorphic pointers */
+		case DESTINATIONS:
+			RoutingBase::routingnetworks[c] = new RoutingSystem(c, true);
+			break;
+		default:
+			RoutingBase::routingnetworks[c] = new NoRoutingSystem(c);
+			break;
+	}
+	Station *st;
+	FOR_ALL_STATIONS(st) st->goods[c].cargo.CargoLeft()->SetCacheDirty();
+}
+
+/* static */
+bool RoutingBase::ModifyPaxRoutingSystem(int32 p1)
+{
+	for (CargoID c = CT_BEGIN; c != NUM_CARGO; c++) {
+		if (IsCargoInClass(c, CC_PASSENGERS)) {
+			ModifyRoutingSystem(c, p1);
+		}
+	}
+
+	return true;
+}
+
+/* static */
+bool RoutingBase::ModifyMailRoutingSystem(int32 p1)
+{
+	for (CargoID c = CT_BEGIN; c != NUM_CARGO; c++) {
+		if (IsCargoInClass(c, CC_MAIL)) {
+			ModifyRoutingSystem(c, p1);
+		}
+	}
+
+	return true;
+}
+
+/* static */
+bool RoutingBase::ModifyGoldRoutingSystem(int32 p1)
+{
+	for (CargoID c = CT_BEGIN; c != NUM_CARGO; c++) {
+		if (IsCargoInClass(c, CC_ARMOURED) && !IsCargoInClass(c, CC_MAIL)) {
+			ModifyRoutingSystem(c, p1);
+		}
+	}
+
+	return true;
+}
+
+/* static */
+bool RoutingBase::ModifyOtherRoutingSystem(int32 p1)
+{
+	for (CargoID c = CT_BEGIN; c != NUM_CARGO; c++) {
+		if (IsCargoInClass(c, CC_PASSENGERS | CC_MAIL | CC_ARMOURED)) continue;
+
+		ModifyRoutingSystem(c, p1);
+	}
+
+	return true;
+}
+
+void CDECL RoutingBase::Debug(int system, int level, ...) const
+{
+#ifdef NO_DEBUG_MESSAGES
+	return;
+#else
+	if (system == routing && _debug_routing_level < level) return;
+	if (system == cargopacket && _debug_cargopacket_level < level) return;
+
+	if (system != routing && system != cargopacket) return;
+
+	va_list va;
+	va_start(va, level);
+
+	static const uint MESSAGEBUFFER_SIZE = 1024;
+	static const uint CARGOBUFFER_SIZE   =   50;
+	static const uint CARGO_TAB_SKIP     =   16;
+
+	char        messagebuffer[MESSAGEBUFFER_SIZE];
+	const char *s = va_arg(va, const char*);
+
+	vsnprintf(messagebuffer, lengthof(messagebuffer), s, va);
+	va_end(va);
+
+	if (!_cargo[this->cargo_type].IsValid()) return;
+
+	char cargobuffer[CARGOBUFFER_SIZE];
+	SetDParam(0, _cargo[this->cargo_type].name);
+	cargobuffer[0] = '[';
+	GetString(&(cargobuffer[1]), STR_CARGO, lastof(cargobuffer));
+
+	strcat(cargobuffer, "]");
+
+	/* Make sure the output is aligned after the cargo type name */
+	while (strlen(cargobuffer) < CARGO_TAB_SKIP) strcat(cargobuffer, " ");
+
+	strcat(cargobuffer, ":");
+
+	char *buffer = AllocaM(char, strlen(messagebuffer) + strlen(cargobuffer) + 1);
+
+	strcpy(buffer, cargobuffer);
+	strcat(buffer, messagebuffer);
+
+	switch (system) {
+		case routing:     DEBUG(routing, level, buffer);     break;
+		case cargopacket: DEBUG(cargopacket, level, buffer); break;
+	}
+#endif
+}
+
+/* static */
+int RoutingBase::GetNumberOfDestinationsAndCargoTypes(const Vehicle *v)
+{
+	typedef std::map <CargoID, bool> HandledCargoFlagMap;
+	typedef std::pair<CargoID, bool> HandledCargoFlag;
+
+	HandledStationFlagMaps          dest_handled;
+	HandledCargoFlagMap             cargo_handled;
+	HandledStationFlagMap::iterator handled_pos;
+	int                             num = 0;
+
+	dest_handled.resize(NUM_CARGO);
+
+	assert(v == v->First());
+
+	for (const Vehicle *u = v; u != NULL; u = u->Next()) {
+		const CargoList::List *packets = u->cargo.Packets();
+
+		/* Unhandled cargotype, add it to our list */
+		if (u->cargo_cap > 0) {
+			HandledCargoFlagMap::iterator cargo_pos = cargo_handled.find(u->cargo_type);
+			if (cargo_pos == cargo_handled.end()) {
+				cargo_handled.insert(HandledCargoFlag(u->cargo_type, true));
+				num++;
+			}
+		}
+
+		/* Cycle through all our packets and see if we have any new
+		 * destination we haven't handled yet */
+		for (CargoList::List::const_iterator it = packets->begin(); it != packets->end(); ++it) {
+			handled_pos = dest_handled[u->cargo_type].find((*it)->target);
+
+			if (handled_pos == dest_handled[u->cargo_type].end()) {
+				dest_handled[u->cargo_type].insert(HandledStationFlag((*it)->target, true));
+				num++;
+			}
+		}
+	}
+
+	return num;
+}
+
+/* static */
+void RoutingBase::GetDestinationsForCargos(const Vehicle *v, CargoTypesByStationMap& cargo_by_dest)
+{
+	CargoByStationMap::iterator dest_pos;
+	cargo_by_dest.resize(NUM_CARGO);
+
+	assert(v == v->First());
+
+	for (const Vehicle *u = v; u != NULL ; u = u->Next()) {
+		const CargoList::List *packets = u->cargo.Packets();
+
+		for (CargoList::List::const_iterator it = packets->begin(); it != packets->end(); ++it) {
+			dest_pos = cargo_by_dest[u->cargo_type].find((*it)->target);
+
+			if (dest_pos == cargo_by_dest[u->cargo_type].end()) {
+				cargo_by_dest[u->cargo_type].insert(std::pair<StationID, uint>((*it)->target, (*it)->count));
+			} else {
+				dest_pos->second += (*it)->count;
+			}
+		}
+	}
+}
+
+/**********************************************************************************************
+ * METHOD IMPLEMENTATION OF ROUTING SYSTEM                                                    *
+ **********************************************************************************************/
+
+RoutingSystem::RoutingSystem(CargoID type, bool reread) : RoutingBase(type), route_network(0) {
+	Debug(routing, 2, "Constructing routing network");
+
+	memset(this->vehicle_factor, 0, sizeof(this->vehicle_factor));
+	this->vehicle_factor[VEH_AIRCRAFT] = _settings_game.rn.aircraft_penalty_factor;
+	this->vehicle_factor[VEH_TRAIN]    = _settings_game.rn.train_penalty_factor;
+	this->vehicle_factor[VEH_ROAD]     = _settings_game.rn.road_penalty_factor;
+	this->vehicle_factor[VEH_SHIP]     = _settings_game.rn.ship_penalty_factor;
+	this->stopover_penalty             = _settings_game.rn.stopover_penalty;
+
+	Debug(routing, 2, "Initializing routing cache");
+	this->dirty.clear();
+	this->hopcache.clear();
+	this->reachcache.clear();
+
+	/* We're initializing a new game, so we don't have a station pool yet */
+	if (!reread) return;
+
+	const Station *st;
+
+	Debug(routing, 2, "Running game detected.");
+	Debug(routing, 3, "Parsing station list");
+
+	FOR_ALL_STATIONS(st) {
+		this->AddStationToVertexList(st->index);
+	}
+
+	Debug(routing, 3, "Parsing order list");
+
+	const Vehicle *v;
+
+	FOR_ALL_VEHICLES(v) {
+		if (v != v->FirstShared()) continue;
+
+		uint32 mask = v->GetCargoForSharedVehicles();
+
+		if (HasBit(mask, this->cargo_type)) this->ProcessOrderListInsertion(v->GetFirstOrder(), v->type);
+	}
+}
+
+RoutingSystem::~RoutingSystem()
+{
+	Debug(routing, 2, "Destructing routing network");
+	this->dirty.clear();
+	this->hopcache.clear();
+	this->reachcache.clear();
+	this->route_network.clear();
+}
+
+void RoutingSystem::SetCacheDirty()
+{
+	Debug(routing, 2, "Setting cache dirty");
+
+	for (DirtyVec::iterator it = this->dirty.begin(); it < this->dirty.end(); ++it) *it = true;
+
+	Station *st;
+	FOR_ALL_STATIONS(st) st->goods[this->cargo_type].cargo.CargoLeft()->SetCacheDirty();
+}
+
+void RoutingSystem::AddStationToVertexList(StationID index)
+{
+	/* Recycle existing indices */
+	if (index < num_vertices(route_network)) {
+		this->hopcache[index].clear();
+		this->reachcache[index].clear();
+		this->dirty[index] = true;
+		Debug(routing, 3, "Reusing old vertex for %d", index);
+	} else {
+		VertexDescriptor vtx;
+
+		do {
+			/* Add as many vertices needed to reach the station index */
+			vtx = add_vertex(route_network);
+			this->hopcache.push_back(HopVec());
+			this->reachcache.push_back(ReachVec());
+			this->dirty.push_back(true);
+		} while (vtx != index);
+
+		Debug(routing, 3, "Vertex and cache %d added to routing network for %d", vtx, index);
+
+		assert(hopcache.size() == num_vertices(route_network));
+	}
+	this->SetCacheDirty();
+}
+
+void RoutingSystem::RemoveStationFromVertexList(StationID index)
+{
+	if (index < num_vertices(route_network)) {
+		Debug(routing, 3, "Clearing vertex for station %d", index);
+		clear_vertex(index, route_network);
+		this->hopcache[index].clear();
+		this->reachcache[index].clear();
+	}
+}
+
+void RoutingSystem::AddRoute(const Order *from, const Order *to, VehicleType type)
+{
+
+	/* Safeguards against crappy input */
+	if (from == NULL || to == NULL) {
+		Debug(routing, 4, "Incomplete route for adding. Ignoring");
+	} else if ( from == to || from->GetDestination() == to->GetDestination() ) {
+		Debug(routing, 4, "Loop routing for adding. Ignoring");
+	} else {
+		/* We can finally perform the actual edge insertion */
+		assert(from->GetDestination() < num_vertices(route_network));
+		assert(to->GetDestination()   < num_vertices(route_network));
+
+		VertexDescriptor fromvtx = vertex(from->GetDestination(), route_network);
+		VertexDescriptor tovtx   = vertex(to->GetDestination(),   route_network);
+		std::pair<EdgeDescriptor, bool> success = add_edge(fromvtx, tovtx, route_network);
+
+		this->SetCacheDirty();
+
+		if (success.second) {
+			EdgeOrderIDMap IDMap     = get(boost::edge_index,   route_network);
+			EdgeLengthMap  LengthMap = get(boost::edge_weight,  route_network);
+
+			boost::put(IDMap,     success.first, from->index);
+			boost::put(LengthMap, success.first, DistanceManhattan(GetStation(from->GetDestination())->xy, GetStation(to->GetDestination())->xy) * this->vehicle_factor[type] + this->stopover_penalty);
+
+			Debug(routing, 3, "Added route from <%d> to <%d>. Index %d, Vehicle Type %d, length %d", from->GetDestination(), to->GetDestination(), from->index, type,
+					DistanceManhattan(GetStation(from->GetDestination())->xy, GetStation(to->GetDestination())->xy) * this->vehicle_factor[type] + this->stopover_penalty);
+		} else {
+			Debug(routing, 0, "ERROR: Adding a route from <%d> to <%d> failed!", from->GetDestination(), to->GetDestination());
+		}
+	}
+}
+
+void RoutingSystem::RemoveRoute(const Order *from, const Order *to)
+{
+	if (from == NULL || to == NULL) {
+		Debug(routing, 4, "Incomplete route for removal. Ignoring");
+	} else if ( from == to || from->GetDestination() == to->GetDestination() ) {
+		Debug(routing, 4, "Loop routing for removal. Ignoring");
+	} else {
+		VertexDescriptor   startvtx   = vertex(from->GetDestination(), route_network);
+		EdgeOrderIDMap     IDMap      = get(boost::edge_index,   route_network);
+		OutEdgeIterator    edge;
+		OutEdgeIterator    endedge;
+
+		assert(from->GetDestination() < num_vertices(route_network));
+		assert(to->GetDestination()   < num_vertices(route_network));
+
+		Debug(routing, 3, "Removing route from <%d> to <%d>. Index %d", from->GetDestination(), to->GetDestination(), from->index);
+
+		for (boost::tie(edge, endedge) = boost::out_edges(startvtx, route_network); edge != endedge; ++edge) {
+			if (IDMap[*edge] == from->index) {
+				Debug(routing, 4, "Found edge with index %d. Removing now", IDMap[*edge]);
+				this->SetCacheDirty();
+				remove_edge(edge, route_network);
+				/* There ought to be only one edge with said index, so jump out, since
+				   the iterator is crapped anyway */
+				return;
+			} else {
+				Debug(routing, 4, "Found edge with index %d. Skipping", IDMap[*edge]);
+			}
+		}
+
+		Debug(routing, 1, "WARNING: Didn't find any edge to remove");
+	}
+}
+
+void RoutingSystem::ProcessOrderInsertion(const Order *order, VehicleType type)
+{
+	if (order->GetType() != OT_GOTO_STATION) return;
+	if (!order->IsStoppingOrder()) return;
+
+	/* We're not going to add buoys */
+	if (GetStation(order->GetDestination())->IsBuoy()) return;
+
+	/* We're inserting an order "C" between "A" and "B". so that we get
+	 * A->C->B from A->B. */
+	if (order->GetUnloadType() != OUFB_NO_UNLOAD) {
+		const Order *prev = order->GetPreviousLoadingOrder();
+		this->RemoveRoute(prev, order->GetNextUnloadingOrder());
+		this->AddRoute(prev, order, type);
+	}
+	if (order->GetLoadType() != OLFB_NO_LOAD) {
+		this->AddRoute(order, order->GetNextUnloadingOrder(), type);
+	}
+}
+
+void RoutingSystem::ProcessOrderRemoval(const Order *order, VehicleType type)
+{
+	if (order->GetType() != OT_GOTO_STATION) return;
+	if (!order->IsStoppingOrder()) return;
+
+	/* We're removing an order "C" between "A" and "B". so that we get
+	 * A->B from A->C->B. */
+	const Order *prev = order->GetPreviousLoadingOrder();
+	const Order *next = order->GetNextUnloadingOrder();
+
+	if (order->GetUnloadType() != OUFB_NO_UNLOAD) {
+		this->RemoveRoute(prev, order);
+		this->RemoveRoute(order, next);
+	}
+	if (order->GetLoadType() != OLFB_NO_LOAD) {
+		this->AddRoute(prev, next, type);
+	}
+}
+
+void RoutingSystem::ProcessOrderListInsertion(const Order *order, VehicleType type)
+{
+	/* Don't do anything for vehicle order lists that are empty */
+	if (order == NULL) return;
+
+	/* if this is not the first order of the list, this will result in a mess */
+	assert(order->prev == NULL);
+
+	/* We're not loading any cargo at this station anyway, so move on to the
+	 * next one */
+	if (!order->IsLoadingOrder()) order = order->GetNextLoadingOrder();
+
+	/* We might not (yet) have a loading order */
+	if (order == NULL) return;
+
+	const Order *firstloadingorder = NULL; //infinite-loop protector
+
+	for (; order != NULL; order = order->GetNextLoadingOrder()) {
+		/* We've been here already, bail out */
+		if (firstloadingorder == order) return;
+		/* Set up loop protector */
+		if (firstloadingorder == NULL) firstloadingorder = order;
+
+		this->AddRoute(order, order->GetNextUnloadingOrder(), type);
+	}
+}
+
+void RoutingSystem::ProcessOrderListRemoval(const Order *order, VehicleType type)
+{
+	if (order == NULL) return;
+
+	assert(order->prev == NULL);
+
+	for (; order != NULL; order = order->next) {
+		if (order->IsLoadingOrder()) {
+			this->RemoveRoute(order, order->GetNextUnloadingOrder());
+		}
+	}
+}
+
+void RoutingSystem::ListAdjacencies(RoutingVectorList &t) const
+{
+	EdgeIterator edge    = boost::edges(route_network).first;
+	EdgeIterator endedge = boost::edges(route_network).second;
+
+	for (; edge != endedge; ++edge) {
+		VertexDescriptor v1 = boost::source(*edge, route_network);
+		VertexDescriptor v2 = boost::target(*edge, route_network);
+		RoutingVector *r = t.Append();
+		r->a = v1;
+		r->b = v2;
+	}
+}
+
+bool RoutingSystem::UseVehicle(const Vehicle *v, StationID to, bool is_on_board) const
+{
+	assert(v != NULL);
+	/* We're not at a station, so we shouldn't even be here */
+	assert(v->last_station_visited != INVALID_STATION);
+
+	/* Do not use v->current_order because it might not be
+	 * part of the scheduled orders at all */
+	const Order *curr = GetVehicleOrder(v, v->cur_order_index);
+	const Order *next = curr->GetNextUnloadingOrder();
+
+	/* This is the only chance to get off the vehicle */
+	if (next == NULL) return false;
+
+	if (curr->GetDestination() == to) {
+		Debug(routing, 5, "We have arrived anyway. Unloading");
+		return false;
+	}
+
+	if (is_on_board) {
+		if (curr->GetUnloadType() == OUFB_UNLOAD) {
+			Debug(routing, 1, "INFO: Vehicle at <%d> has a force unload order, this is not recommended with destinations", v->last_station_visited);
+			return false;
+		}
+	} else {
+		if (curr->GetLoadType() == OLFB_NO_LOAD) {
+			Debug(routing, 1, "INFO: Vehicle at <%d> has a noload order, this is not recommended with destinations", v->last_station_visited);
+			return false;
+		}
+	}
+
+	/* If the cargo has no destination, it can board or leave. */
+	if (to == INVALID_STATION) {
+		if (is_on_board) {
+			Debug(routing, 5, "Cargo with no destination leaving vehicle at <%d>", v->last_station_visited);
+			return false;
+		} else {
+			Debug(routing, 5, "Cargo with no destination boarding vehicle at <%d>", v->last_station_visited);
+			return true;
+		}
+	}
+
+	/* Handle intermediate stops */
+	if (is_on_board && v->last_station_visited != curr->GetDestination()) {
+		Debug(routing, 1, "INFO: Vehicle arrived at <%d> without order", v->last_station_visited);
+		/* Correct station, get off */
+		if (v->last_station_visited == to) return false;
+
+		/* Keep going */
+		return true;
+	}
+
+	/* The vehicle is going exactly where our cargo wants to go as well, so stay put
+	 * or board */
+	if (this->FindNextHop(curr->GetDestination(), to) == next->GetDestination() ) {
+		Debug(routing, 5, "Found vehicle at <%d> to use", v->last_station_visited);
+		return true;
+	}
+
+	/* Move off */
+	return false;
+}
+
+StationID RoutingSystem::NextUnloadStationForVehicle(const Vehicle *v) const
+{
+	if (GetVehicleOrder(v, v->cur_order_index) != NULL && GetVehicleOrder(v, v->cur_order_index)->GetNextUnloadingOrder() != NULL) {
+		return GetVehicleOrder(v, v->cur_order_index)->GetNextUnloadingOrder()->GetDestination();
+	}
+
+	return INVALID_STATION;
+}
+
+StationID RoutingSystem::GetDestination(StationID from) const
+{
+	StationID target;
+	Debug(cargopacket, 3, "Attempting to obtain a destination at <%d>", from);
+
+	this->RecomputeCache(from);
+
+	for (;;) {
+		target       = this->reachcache[from][RandomRange(this->reachcache[from].size())];
+		uint dist    = DistanceManhattan(GetStation(from)->xy, GetStation(target)->xy);
+		uint maxdist = MapSizeX() + MapSizeY();
+		uint sector  = dist * 5 / maxdist;
+
+		/* Station is too far away */
+		if (RandomRange(5) < sector) continue;
+
+		const uint maxnumskip = 40;
+		uint       numskip    = maxnumskip - (min(GetStation(target)->goods[this->cargo_type].origin_last_month, 2000) / 50);
+
+		/* Penalize passenger stations which are served with RVs/ships only */
+		if ( GetCargo(this->cargo_type)->town_effect == TE_PASSENGERS &&
+		    (GetStation(target)->facilities & (FACIL_TRAIN | FACIL_AIRPORT)) == 0) {
+			numskip = min(maxnumskip, numskip + 10) - 1;
+		}
+
+		/* Station is 'too small' */
+		if (RandomRange(maxnumskip + 1) < numskip) continue;
+
+		break;
+	}
+
+	Debug(cargopacket, 3, "selected <%d> as target", target);
+
+	return target;
+}
+
+bool RoutingSystem::CanReachAnyStation(StationID from) const
+{
+	this->RecomputeCache(from);
+
+	if (this->reachcache[from].size() == 0) {
+		Debug(cargopacket, 1, "INFO: Cannot reach any station from <%d>", from);
+		return false;
+	}
+
+	return true;
+}
+
+void RoutingSystem::ComputeReachList(StationID from, ReachVec& list) const
+{
+	const Station *st;
+
+	Debug(cargopacket, 2, "Reach cache dirty, recomputing");
+
+	list.clear();
+	FOR_ALL_STATIONS(st) {
+		if (st->index != from && this->CanReachStationFrom(from, st->index) && HasBit(st->goods[this->cargo_type].acceptance_pickup, GoodsEntry::ACCEPTANCE)) {
+			Debug(cargopacket, 5, "Can reach <%d> from <%d>", st->index, from);
+			list.push_back(st->index);
+		}
+	}
+}
+
+
+RoutingSystem::UnloadProcessResult RoutingSystem::ProcessUnload(GoodsEntry *ge, uint amount, StationID st_index, Vehicle *v, const Vehicle *u) const
+{
+	if (v->current_order.GetUnloadType() & OUFB_TRANSFER) {
+		Debug(routing, 1, "INFO: RoutingSystem system active, manual Transfer flag overriden");
+	}
+
+	if (!HasBit(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE)) {
+
+		if (this->CanReachAnyStation(st_index)) {
+			/* GetDestination assumes that we can reach a station */
+			StationID target = this->GetDestination(st_index);
+
+			assert(st_index != target);
+
+			Debug(cargopacket, 3, "Cargo is no longer accepted at <%d>, rerouting to <%d>", st_index, target);
+
+			v->cargo.SetNewDestination(st_index, target);
+		} else {
+			/* Packages will be removed by CargoList::MoveTo, we don't get payment
+			 * for them anyway */
+			Debug(cargopacket, 1, "WARNING: cannot reach any station from <%d>. Dunno what to do", st_index);
+		}
+	}
+
+	return (v->cargo.MoveTo(&ge->cargo, amount, this->cargo_type, CargoList::MTA_FINAL_DELIVERY, st_index, u)) ? UP_UNLOAD_PARTIAL : UP_UNLOAD_COMPLETE;
+}
+
+RoutingSystem::PaymentProcessResult RoutingSystem::ProcessPayment(const CargoPacket *cp, const Station * st, const Vehicle *v) const
+{
+	if (cp->paid_for) {
+		/* We deboard */
+		if (!this->UseVehicle(v, cp->target, true)) return PPR_NOPAY;
+
+		return PPR_NONE;
+	}
+
+	if (HasBit(st->goods[this->cargo_type].acceptance_pickup, GoodsEntry::ACCEPTANCE) &&
+	        (cp->target == INVALID_STATION || cp->target == st->index))
+	    return PPR_ARRIVE;
+
+	/* We should transfer */
+	if (!this->UseVehicle(v, cp->target, true)) return PPR_TRANSFER;
+
+	/* We stay onboard */
+	return PPR_NONE;
+}
+
+bool RoutingSystem::CanReachStationFrom(StationID from, StationID to) const
+{
+	return IsValidStationID(this->FindNextHop(from, to));
+}
+
+StationID RoutingSystem::FindNextHop(StationID from, StationID to) const
+{
+	/* We got crappy parameters, bail out */
+	if (from == INVALID_STATION) return INVALID_STATION;
+	if (to   == INVALID_STATION) return INVALID_STATION;
+
+	/* This will not work if we're trying to get from A to A, so
+	 * don't try it in the first place */
+	assert(from != to);
+
+	assert(from < num_vertices(route_network));
+	assert(to   < num_vertices(route_network));
+
+	this->RecomputeCache(from);
+
+	/* See if we have found any path at all */
+	if (this->hopcache[from][to] == to) {
+		Debug(routing, 6, "No route found from <%d> to <%d>", from, to);
+		return INVALID_STATION;
+	}
+
+	if (this->hopcache[from][to] == from) {
+		Debug(routing, 6, "Direct route found from <%d> to <%d>", from, to);
+		return to;
+	}
+
+	for (int curr_vertex = this->hopcache[from][to]; ; curr_vertex = this->hopcache[from][curr_vertex]) {
+		if (this->hopcache[from][curr_vertex] == from) {
+
+			Debug(routing, 6, "The next hop going from <%d> to <%d> is via <%d>", from, to, curr_vertex);
+			return curr_vertex;
+		}
+	}
+
+	Debug(routing, 0, "ERROR: We shouldn't be here, RoutingSystem::FindNextHop");
+	return INVALID_STATION;
+}
+
+void RoutingSystem::ComputeRoutes(StationID from, HopVec& p) const
+{
+	VertexDescriptor v = vertex(from, route_network);
+	std::vector<int> d(num_vertices(route_network));
+
+	Debug(routing, 5, "Recomputing Routes for <%d>", from);
+
+	dijkstra_shortest_paths(route_network, v, boost::predecessor_map(&p[0]).distance_map(&d[0]));
+
+	/* Only debug stuff below this line */
+	Debug(routing, 5, "Done recomputing the routes");
+	Debug(routing, 6, "=========================================================");
+	Debug(routing, 6, "DETAILED ROUTING INFORMATION FOLLOWS!");
+	Debug(routing, 7, "VERY DETAILED ROUTING INFORMATION FOLLOWS! You've been warned");
+	Debug(routing, 6, "   Source: <%d>", from);
+
+	for (uint i = 0; i < num_vertices(route_network); ++i) {
+		uint distance = 0;
+
+		if (i == v) continue; // Can't find a way to myself
+
+		if (p[i] == i) {
+			Debug(routing, 6, "<%d> cannot be reached from <%d> at all", i, from);
+			continue;
+		}
+
+		Debug(routing, 6, "Predecessor of <%d> is <%d>", i, p[i]);
+		Debug(routing, 7, "---------");
+		Debug(routing, 7, "Backtracing route from <%d> to <%d>", i, from);
+
+		/* Walk through our network from the destination to the source
+		 * until we're there */
+		for (uint curr = p[i]; curr != v; curr = p[curr]) {
+			distance += d[curr];
+			Debug(routing, 7, "    <%d> (distance %d)", curr, d[curr]);
+		}
+
+		Debug(routing, 7, "End of tracing");
+		Debug(routing, 7, "---------");
+
+		Debug(routing, 6, "Total distance %d", distance);
+	}
+	Debug(routing, 7, "END OF VERY DETAILED ROUTING INFORMATION");
+	Debug(routing, 6, "END OF DETAILED ROUTING INFORMATION");
+	Debug(routing, 6, "=========================================================");
+}
+
+void RoutingSystem::RecomputeCache(StationID from) const
+{
+	if (!this->dirty[from]) return;
+
+	HopVec   p(num_vertices(route_network));
+	ReachVec list;
+
+	Debug(routing, 2, "The route network cache for <%d> is dirty. Recomputing", from);
+
+	this->ComputeRoutes(from, p);
+	this->dirty[from] = false; // put this here to prevent infinite recusion by ComputeReachList
+	this->hopcache[from].clear();
+	this->hopcache[from] = p;
+	this->ComputeReachList(from, list);
+	this->reachcache[from] = list;
+}
+
+void RoutingSystem::ProcessAcceptanceModification(StationID index)
+{
+	Debug(routing, 2, "Invalidating cache due to modified acceptance at <%d>", index);
+	/* Can we do this in a nicer way?
+	 * Maybe we just need to invalidate the caches for those
+	 * stations which are reachable by the changed cargotype? */
+	this->SetCacheDirty();
+}
+
+void RoutingSystem::CheckRoutingCaches()
+{
+	/* Back up existing data */
+	DirtyVec   dirty_old      = this->dirty;
+	HopCache   hopcache_old   = this->hopcache;
+	ReachCache reachcache_old = this->reachcache;
+
+	/* Set the cache dirty, were not using SetCacheDirty because it will invalidate
+	 * the L3 cache and we need that later on */
+	for (DirtyVec::iterator it = this->dirty.begin(); it < this->dirty.end(); ++it) *it = true;
+	StationID st_ind = 0;
+
+	/* Compare the new and old caches */
+	for (DirtyVec::iterator it = dirty_old.begin(); it < dirty_old.end(); ++it, ++st_ind) {
+
+		/* Bail out if the stored cache wasn't valid */
+		if (*it) continue;
+		this->RecomputeCache(st_ind);
+
+		if (this->hopcache[st_ind] != hopcache_old[st_ind]) {
+			Debug(routing, 0, "ERROR in L1 cache for station index %d", st_ind);
+		}
+
+		if (this->reachcache[st_ind] != reachcache_old[st_ind]) {
+			Debug(routing, 0, "ERROR in L2 cache for station index %d", st_ind);
+		}
+	}
+
+	dirty_old.clear();
+	hopcache_old.clear();
+	reachcache_old.clear();
+
+	Station *st;
+
+	FOR_ALL_STATIONS(st) {
+		DestinationList *List = st->goods[this->cargo_type].cargo.CargoLeft();
+
+		if (List->IsCacheDirty()) continue;
+
+		DestinationList::NextHopMap *map_old = List->Map();
+
+		st->goods[this->cargo_type].cargo.CargoLeft()->SetCacheDirty();
+		st->goods[this->cargo_type].cargo.RecomputeCargoLeftCache();
+
+		if (*map_old != *(List->Map())) {
+			Debug(routing, 0, "ERROR in L3 cache for station index %d", st->index);
+		}
+	}
+}
+
+/**********************************************************************************************
+ * METHOD IMPLEMENTATION OF NOROUTING SYSTEM                                                    *
+ **********************************************************************************************/
+
+NoRoutingSystem::UnloadProcessResult NoRoutingSystem::ProcessUnload(GoodsEntry *ge, uint amount, StationID st_index, Vehicle *v, const Vehicle *u) const
+{
+	/* The goods are accepted, and we don't force then to transfer, so we deliver to the station */
+	if (HasBit(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE) && !(u->current_order.GetUnloadType() & OUFB_TRANSFER)) {
+		return (v->cargo.MoveTo(NULL, amount, this->cargo_type, CargoList::MTA_FINAL_DELIVERY, st_index, u)) ? UP_UNLOAD_PARTIAL : UP_UNLOAD_COMPLETE;
+	}
+
+	/* We couldn't deliver, but we force them to go to the platform anyways */
+	if (u->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) {
+		return (v->cargo.MoveTo(&ge->cargo, amount, this->cargo_type)) ? UP_UNLOAD_PARTIAL : UP_UNLOAD_COMPLETE;
+	}
+
+	/* We couldn't unload anything, maybe the unload/transfer flags or the acceptance has been modified */
+	ClrBit(v->vehicle_flags, VF_CARGO_UNLOADING);
+	return UP_UNLOAD_FAILED;
+}
+
+
+NoRoutingSystem::PaymentProcessResult NoRoutingSystem::ProcessPayment(const CargoPacket *cp, const Station * st, const Vehicle *v) const
+{
+	const GoodsEntry *ge = &st->goods[this->cargo_type];
+
+	if (cp->paid_for) {
+		/* We already got money for this one, just find out whether it needs to be unloaded for a transfer */
+		if (v->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) return PPR_NOPAY;
+
+		/* We don't even need to unload */
+		return PPR_NONE;
+	}
+
+	/* We can deliver our stuff here */
+	if (HasBit(ge->acceptance_pickup, GoodsEntry::ACCEPTANCE) && !(v->current_order.GetUnloadType() & OUFB_TRANSFER)) return PPR_ARRIVE;
+
+	/* We should transfer */
+	if (v->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) {
+		/* Per definition, we only pay for a transfer if the transfer flag is explicitly set */
+		if ( (v->current_order.GetUnloadType() & OUFB_TRANSFER) != 0) return PPR_TRANSFER;
+
+		return PPR_NONE;
+	}
+
+	/* Nothing to do */
+	return PPR_NONE;
+}
diff -r cefcfd943f94 src/routing.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/routing.h	Tue Feb 17 03:31:08 2009 +0100
@@ -0,0 +1,393 @@
+/* $Id$ */
+
+/**
+ * @file routing.h Interface for the handling the routing of cargopackets.
+ *
+ * This file only contains the ABC for the RoutingSystem system (and some helpers).
+ * Implementation is in routing_classes.h
+ */
+
+#ifndef ROUTING_H
+#define ROUTING_H
+
+/* Local includes */
+#include "vehicle_type.h"
+#include "station_base.h"
+#include "station_type.h"
+#include "order_type.h"
+#include "cargopacket.h"
+#include "core/smallvec_type.hpp"
+
+/* System includes */
+#include <vector>
+#include <map>
+
+/**
+ * A Vector, consiting of two point indices
+ */
+struct RoutingVector {
+	int a;  ///< starting point of the vector
+	int b;  ///< ending   point of the vector
+};
+
+/**
+ * A container that stores a list of vectors. We use this
+ * for the smallmap GUI so that we can display the routes
+ * on the map
+ */
+typedef SmallVector<RoutingVector, 8> RoutingVectorList;
+
+/**
+ * ABC for the routing system. This class predefines all the methods that any RoutingSystem system
+ * must define.
+ */
+class RoutingBase {
+protected:
+	/* Note: The two following constants are lowercase in order to be
+	 * consistent with other debug subsystems, which are lowercase as well
+	 */
+
+	/** Debug subsystem routing */
+	static const int routing     = 0;
+
+	/** Debug subsystem cargopacket */
+	static const int cargopacket = 1;
+
+	/** Patch setting value when RoutingSystem should be enabled */
+	static const char DESTINATIONS = 2;
+
+	/**
+	 * The routing systems for all the cargo types
+	 */
+	static std::vector<RoutingBase *> routingnetworks;
+
+	/**
+	 * Our cargo type
+	 */
+	const CargoID cargo_type;
+
+public:
+	/**
+	 * Pointer to member-function. Used for calling the Functions that process any
+	 * alterations of orders
+	 */
+	typedef void (RoutingBase::*Process) (const Order *order, VehicleType type);
+
+	/**
+	 * Maps units of cargo to a station
+	 */
+	typedef std::map<StationID, int> CargoByStationMap;
+
+	/**
+	 * Maps units of all cargo types to a station
+	 */
+	typedef std::vector<CargoByStationMap> CargoTypesByStationMap;
+
+	/**
+	 * A flag that indicated that a certain station been handled
+	 * during some process
+	 */
+	typedef std::pair<StationID, bool> HandledStationFlag;
+
+	/**
+	 * A map of flags that determines which stations have already
+	 * been handled in a process
+	 * @see HandledStationFlag
+	 */
+	typedef std::map<StationID, bool> HandledStationFlagMap;
+
+	/**
+	 * A HandledStationFlagMap for all existing cargo types
+	 */
+	typedef std::vector<HandledStationFlagMap> HandledStationFlagMaps;
+
+	/**
+	 * Result of a process that unloads a vehicle
+	 */
+	enum UnloadProcessResult {
+		UP_UNLOAD_COMPLETE, ///< We completely unloaded all cargo
+		UP_UNLOAD_PARTIAL,  ///< We could only partially unload the cargo
+		UP_UNLOAD_FAILED    ///< We failed to unload the cargo
+	};
+
+	/**
+	 * Result of a process the detemines how to pay a vehicle
+	 */
+	enum PaymentProcessResult {
+		PPR_ARRIVE,   ///< Cargo has arrived at its destination, get full payment
+		PPR_TRANSFER, ///< Cargo has arrived at an intermediate destination
+		PPR_NOPAY,    ///< Cargo has arrived, but we don't pay for it
+		PPR_NONE      ///< No cargo has arrived
+	};
+
+	/**
+	 * Adds a vertex for a station, in case it doesn't exist yet
+	 * @param index The index of the station to be added
+	 */
+	virtual void AddStationToVertexList(StationID index)                      = 0;
+
+	/**
+	 * Removes or invalidates a vertex for a station
+	 * @param index The index of the station to be removed
+	 */
+	virtual void RemoveStationFromVertexList(StationID index)                 = 0;
+
+	/**
+	 * Update the route network after an order has been inserted
+	 * @param order The order that has been inserted
+	 * @param type  The type of the vehicle we're adding
+	 * @pre         All the prev and next pointer in the orders must already have been updated
+	 */
+	virtual void ProcessOrderInsertion(const Order *order, VehicleType type)  = 0;
+
+	/**
+	 * Update the route network with information of an entire order-list.
+	 * This should only be used when the order list does not contain any edges
+	 * yet, like when a vehicle is cloned (not shared) or the game is loaded (we do
+	 * not store the graph in the savegame).
+	 * @param order The first order of the chain that is to be inserted
+	 * @param type  The type of the vehicle
+	 */
+	virtual void ProcessOrderListInsertion(const Order *order, VehicleType type)    = 0;
+
+	/**
+	 * Update the route network with the removal of an entire order-list.
+	 * @param order The first order of the chain that will be removed
+	 */
+	virtual void ProcessOrderListRemoval(const Order *order, VehicleType type)= 0;
+
+	/**
+	 * Update the route network after an order has been removed
+	 * @param order The order that has been removed
+	 * @param type  The type of the vehicle on which we operate. We need
+	 *              this for the adding of routes that happens during
+	 *              removal of other routes
+	 * @pre         The order itself must not yet have been freed or deleted,
+	 *              nor may the prev and next pointers have been modified
+	 */
+	virtual void ProcessOrderRemoval(const Order *order, VehicleType type)    = 0;
+
+	/**
+	 * Populates a RoutingVectorList with all the routes that
+	 * exist in the routing network
+	 * @param t [out] The vector where to put the list
+	 */
+	virtual void ListAdjacencies(RoutingVectorList &t) const                  = 0;
+
+	/**
+	 * Finds the next station that we have to go to if we want
+	 * to go from A to B
+	 * @param from  The station we're at
+	 * @param to    The station we wanna go to
+	 * @return      The station we need to go to
+	 */
+	virtual StationID FindNextHop(StationID from, StationID to) const         = 0;
+
+	/**
+	 * Determines whether we can reach a certain station from another
+	 * station
+	 * @param from The origin station
+	 * @param to   the destination station
+	 * @return     true if there's a route between those two
+	 */
+	virtual bool CanReachStationFrom(StationID from, StationID to) const      = 0;
+
+	/**
+	 * Determines whether a cargo packet should use a certain vehicle
+	 * to travel to its destination. This can be used in two ways:<p>
+	 * @li        To determine whether a cargopacket on a station to board a vehicle
+	 * @li        To determine whether a cargopacket on a vehicle to stay on board
+	 *
+	 * @param v             The vehicle we're currently on
+	 * @param to            The ultimate destination of the cargopacket
+	 * @param is_on_board   Set to true if the cargopacket is already boarded
+	 * @return              true if we should end up on the vehicle (or remain there)
+	 * @pre                 v is the vehicle containing the orders (i. e. no wagon or similar)
+	 */
+	virtual bool UseVehicle(const Vehicle *v, StationID to,
+			bool is_on_board) const                                           = 0;
+
+	/**
+	 * Determines the next station a vehicle goes to
+	 * @param v                The vehicle having the orders
+	 * @return                 The index of the station where the vehicle will next
+	 *                         unload stuff
+	 * @retval INVALID_STATION The next station is non exsiting or irrelevant
+	 */
+	virtual StationID NextUnloadStationForVehicle(const Vehicle *v) const     = 0;
+
+	/** Determines whether this routing type has distinct destinations */
+	virtual bool HasDestinations() const                                      = 0;
+
+	/**
+	 * Obtains a random destination station
+	 * @param from    The origin station we're at
+	 * @return        The destination we're supposed to go to
+	 * retval         INVALID_STATION We can go to any station we wish to
+	 */
+	virtual StationID GetDestination(StationID from) const                    = 0;
+
+	/**
+	 * Determines whether we can reach any station at all
+	 * @param from The station we're at
+	 * @return     True if any station can be reached
+	 */
+	virtual bool CanReachAnyStation(StationID from) const                     = 0;
+
+	/**
+	 * Method called when the acceptance at a station changes
+	 * @param index The index of the station which changed
+	 */
+	virtual void ProcessAcceptanceModification(StationID index)               = 0;
+
+	/**
+	 * Processs the unload of a vehicle at a station
+	 * @param   ge        The GoodsEntry of where the cargo is to be delivered. NULL if the packets need to be destroyed
+	 * @param   amount    The units of cargo that have been delivered
+	 * @param   st_index  The index of the station we're at
+	 * @param   v         The vehicle whose cargo is being moved
+	 * @param   u         The vehicle that contains the orders
+	 * @return            The status
+	 */
+	virtual UnloadProcessResult ProcessUnload(GoodsEntry *ge,
+			uint amount, StationID st_index,
+			Vehicle *v, const Vehicle *u) const                               = 0;
+
+	/**
+	 * Determines how and whether a vehicle should be payed when arriving
+	 * at a station
+	 * @param  cp           The cargopacket we're handling
+	 * @param  st           The station we're at
+	 * @param  v            The vehicle that contains the orders
+	 * @return              What to do with the vehicle
+	 */
+	virtual PaymentProcessResult ProcessPayment(const CargoPacket *cp,
+			const Station *st, const Vehicle *v) const                        = 0;
+
+	/**
+	 * Constructor for the routing system. This must be called from any
+	 * routing system that needs the cargo type. Can be set only here.<p>
+	 * @code YourRoutingSystem() : RoutingBase(cargotype) {} @endcode
+	 */
+	RoutingBase(CargoID type) : cargo_type(type) {}
+
+	/**
+	 * virtual destructor of the RoutingSystem classes. Recommended because we
+	 * use polymorphism (plus it silences some warnings)
+	 */
+	virtual ~RoutingBase() { }
+
+	/**
+	 * Performs a cache debug operation on the routing system
+	 */
+	virtual void CheckRoutingCaches() {};
+
+	/**
+	 * Print a debug message for routing and or cargopackets.
+	 * Compared to the normal DEBUG macro, this automagically adds
+	 * the cargotype to the debug message.
+	 * @param system  what subsystem re write the debug message for
+	 * @param level   The debug level to print to
+	 * @param ...     The message are arguments to print, compare with fprintf
+	 */
+	void CDECL Debug(int system, int level, ...) const;
+
+	/**
+	 * Update the route network because something has happend to the order system
+	 * in general.
+	 * @param proc   The process to use.
+	 * @param order  The order which has been inserted, deleted or moved.
+	 * @param type   The type of the vehicle
+	 * @param mask   A mask of cargotypes for which to do the selected process.
+	 * @see ProcessOrderListInsertion, ProcessOrderInsertion, ProcessOrderRemoval, ProcessOrderListRemoval
+	 */
+	static void ProcessOrder(Process proc, const Order *order, VehicleType type, uint32 mask);
+
+	/**
+	 * Obtains the number of different cargo destinations and types
+	 * in a consist
+	 * @param v The front vehicle we're handling
+	 * @return  The sum of all individual destinations (over all cargo types)
+	 */
+	static int GetNumberOfDestinationsAndCargoTypes(const Vehicle *v);
+
+	/**
+	 * Obtains the cargo destinations per cargo type in a consist
+	 * @param v              The front vehicle we're handling
+	 * @param cargo_by_dest  [out] A vector of maps containing the different destinations
+	 */
+	static void GetDestinationsForCargos(const Vehicle *v, CargoTypesByStationMap& cargo_by_dest);
+
+	/**
+	 * Initialize the routing system for cargos
+	 * @param reread If this is set, the constructor will parse the station
+	 *               and order list and populate the graph
+	 */
+	static void InitializeRoutingSystems(bool reread = false);
+
+	/**
+	 * Uninitialize the whole routing system
+	 * @warning After calling this, the cargo handling will no longer work
+	 */
+	static void UnInitializeRoutingSystems();
+
+	/**
+	 * Change the setting how to handle the destination of
+	 * passsengers. We we change to/from the routing system, we
+	 * need to allocate/deallocate the class
+	 * @param p1 the new setting value
+	 * @return   always true, this function should never fail
+	 */
+	static bool ModifyPaxRoutingSystem(int32 p1);
+
+	/**
+	 * Change the setting how to handle the destination of
+	 * mail. We we change to/from the routing system, we
+	 * need to allocate/deallocate the class
+	 * @param p1 the new setting value
+	 * @return   always true, this function should never fail
+	 */
+	static bool ModifyMailRoutingSystem(int32 p1);
+
+	/**
+	 * Change the setting how to handle the destination of
+	 * valuables, gold and diamonds. We we change to/from the routing system, we
+	 * need to allocate/deallocate the class
+	 * @param p1 the new setting value
+	 * @return   always true, this function should never fail
+	 */
+	static bool ModifyGoldRoutingSystem(int32 p1);
+
+	/**
+	 * Change the setting how to handle the destination of
+	 * other types of cargo. We we change to/from the routing system, we
+	 * need to allocate/deallocate the class
+	 * @param p1 the new setting value
+	 * @return   always true, this function should never fail
+	 */
+	static bool ModifyOtherRoutingSystem(int32 p1);
+
+	/**
+	 * Change the low-level parameters of the routing system
+	 * @param p1  unused
+	 * @return    always true, this function should never fail
+	 */
+	static bool ModifyParameter(int32 p1) { InitializeRoutingSystems(true); return true; }
+
+	/**
+	 * Returns the routing system of a cargotype
+	 * @param type The cargo type to return the routing system for
+	 */
+	static RoutingBase *Routing(CargoID type) { return RoutingBase::routingnetworks[type]; }
+
+private:
+	/**
+	 * Switches a certain cargo type to another routing system
+	 * @param c      The cargotype to switch
+	 * @param type   The type of routing system to use
+	 */
+	static void ModifyRoutingSystem(CargoID c, int32 type);
+};
+
+
+#endif /* ROUTING_H */
diff -r cefcfd943f94 src/routing_classes.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/routing_classes.h	Tue Feb 17 03:31:08 2009 +0100
@@ -0,0 +1,308 @@
+/* $Id$ */
+
+/**
+ * @file routing_classes.h Handles the routing of cargopackets, interface of the derived classes
+ * <h3>Concept</h3>
+ * All the routing of cargopackets is happening in these classes. RoutingBase is the
+ * abtract base class which serves as the basis for all the different routing systems.
+ * If we want to create a new routing system, use RoutingBase and then implement the routing
+ * system as such.<br>
+ * Currently there are only two systems:
+ * - NoRoutingSystem is the old cargohandling as we know it
+ * - RoutingSystem   is the new routing system where each cargopacket gets a randomly assigned destination
+ */
+
+#ifndef ROUTING_CLASSES_H
+#define ROUTING_CLASSES_H
+
+/* Local includes */
+#include "debug.h"
+#include "station_type.h"
+#include "order_type.h"
+#include "strings_func.h"
+#include "vehicle_base.h"
+#include "routing.h"
+#include "cargo_type.h"
+
+/* System includes */
+#include <boost/graph/adjacency_list.hpp>
+
+/**
+ * Base Class containing the types used for Routing_t
+ */
+class Routing_types {
+protected:
+	/**
+	 * Property of the edge which stores the length of the edge by
+	 * Manhattan distance, used for finding the optimal route between two
+	 * stations. The edge weight also takes the vehicle type into
+	 * account
+	 * @see DistanceManhattan
+	 */
+	typedef boost::property<boost::edge_weight_t, int>                  EdgeLength;
+
+	/**
+	 * Property of the edge which stores the index of the order to which the edge
+	 * is associated. As we have a multigraph, this is needed to identify edges
+	 * during removal processes. EdgeLength is the recursive inclusion of
+	 * previously defined edge property
+	 */
+	typedef boost::property<boost::edge_index_t, int, EdgeLength>       EdgeOrderID;
+
+	/**
+	 * Storate type of the route network.
+	 * The graph itself is stored as an adjacency_list, i. e. each vertex stores
+	 * its out-edges to the adjacent nodes. This is a decent compromise between
+	 * execution speed (worse than adjacency maxtrices) and space (worse than
+	 * edge lists).<p>
+	 * Edges are stored are a multisetS for speed, vertices are stored as a vector, to reduce
+	 * storage space and ease debugging compared to list.
+	 * We're assinging each edge a propery with the name of "EdgeOrderID" so that each
+	 * edge can be perfectly identified by this ID
+	 * @warning Be careful about deleting vertices in a loop, since the iterators
+	 * can be invalidated during the loop while using vector. Consult the BGL's documentation
+	 * for more information
+	 */
+	typedef boost::adjacency_list<
+		boost::multisetS,   // Storage type of edges
+		boost::vecS,        // Storage type of vertices
+		boost::directedS,   // Directional behaviour of edges
+		boost::no_property, // Properties of vertices
+		EdgeOrderID         // Properties of edges
+	>                                                                       RouteNetwork;
+	typedef boost::graph_traits<RouteNetwork>::vertex_descriptor            VertexDescriptor;  ///< Vertex descriptor of the graph
+	typedef boost::graph_traits<RouteNetwork>::vertex_iterator              VertexIterator;    ///< Vertex iterator of the graph
+	typedef boost::graph_traits<RouteNetwork>::edge_descriptor              EdgeDescriptor;    ///< edge descriptor of the graph
+	typedef boost::graph_traits<RouteNetwork>::edge_iterator                EdgeIterator;      ///< edge iterator of the graph
+	typedef boost::graph_traits<RouteNetwork>::out_edge_iterator            OutEdgeIterator;   ///< out edge iterator of the graph
+
+	/* --------------------------------------------------------------------------- */
+	/* Property mapping. Needed for obtaining or setting properties from the graph */
+	/* --------------------------------------------------------------------------- */
+
+	/**
+	 * Type for mapping the OrderID onto the edge
+	 */
+	typedef boost::property_map<RouteNetwork, boost::edge_index_t>::type    EdgeOrderIDMap;
+
+	/**
+	 * Type for storing the edge length so that we don't need to compute it during
+	 * routing finding runs
+	 */
+	typedef boost::property_map<RouteNetwork, boost::edge_weight_t>::type   EdgeLengthMap;
+};
+
+/**
+ * Class for cargos that do not have a route network but can deliver an arbitrary number
+ * of cargo units to an arbitrary station, as by original TTD. We don't need to do anything
+ * for most of these methods as we're not constructing a routing network anyway
+ */
+class NoRoutingSystem : public RoutingBase {
+public:
+	/**
+	 * Constructor of the system
+	 * @param type The cargotype we're handling
+	 */
+	NoRoutingSystem(CargoID type) : RoutingBase(type)
+	{
+		Debug(routing, 3, "Constructing empty routing system");
+	}
+
+	~NoRoutingSystem()
+	{
+		Debug(routing, 3, "Removing empty routing system");
+	}
+
+	void AddStationToVertexList(StationID index) { return; }
+	void RemoveStationFromVertexList(StationID index) { return; }
+	void ProcessOrderInsertion(const Order *order, VehicleType type) { return; }
+	void ProcessOrderListInsertion(const Order *order, VehicleType type) { return; }
+	void ProcessOrderListRemoval(const Order *order, VehicleType type) { return; }
+	void ProcessOrderRemoval(const Order *order, VehicleType type) { return; }
+	void ListAdjacencies(RoutingVectorList &t) const { return; }
+	StationID FindNextHop(StationID from, StationID to) const { return INVALID_STATION; }
+	bool CanReachStationFrom(StationID from, StationID to) const { return true; }
+	bool UseVehicle(const Vehicle *v, StationID to, bool is_on_board) const { return is_on_board ? false : true; }
+	StationID NextUnloadStationForVehicle(const Vehicle *v) const { return INVALID_STATION; }
+	bool HasDestinations() const { return false; }
+	UnloadProcessResult ProcessUnload(GoodsEntry *ge, uint amount, StationID st_index, Vehicle *v, const Vehicle *u) const;
+	PaymentProcessResult ProcessPayment(const CargoPacket *cp, const Station *st, const Vehicle *v) const;
+	StationID GetDestination(StationID from) const
+	{
+		Debug(cargopacket, 5, "No RoutingSystem system found. allowing cargo to go to any destination");
+		return INVALID_STATION;
+	}
+	bool CanReachAnyStation(StationID from) const { return true; }
+	void ProcessAcceptanceModification(StationID index) { return; }
+	void CheckRoutingCaches() { return; }
+};
+
+/**
+ * Class for handling the route network
+ *   <h3>Synopsis</h3>
+ *    Basically, we're storing the entire route network in a graph (in the mathemetical
+ *    sense), where the stations represent the <b>vertices</b> (i.e. 'points') of the
+ *    graph, while the orders that connect the stations represent the <b>edge</b> (i.e. lines
+ *    between the points. Specifically, we are using a directed multigraph:
+ *    - \e Directed means that an edge is only traversed in one direction.
+ *    - \e Multigraph means that two vertices can be connected by multiple
+ *    (parallel) edges. We do this because we can have multiple (non-shared)
+ *    Vehicles that run between two stations A and B. When one vehicle (or its
+ *    orders) is deleted, only one of the edges is removed. To do so, we need
+ *    to associate the edge with the order. This is done by storing the OrderID
+ *    as a property of the edges.<br>
+ *   <h3>Debug levels</h3>
+ *    -# Print warnings (Errors are always printed)
+ *    -# Constructor, destructor and operations on the routing cache
+ *    -# Vertex and edge modification, terse output
+ *    -# Vertex and edge modification, verbose output
+ *    -# RoutingSystem usage and computation
+ *    -# RoutingSystem pathfinding results, terse output
+ *    -# RoutingSystem pathfinding results, verbose output
+ *    @note Only routes from one station to the next are stored. It is the responsibility
+ *    of the vehicle (or its cargopackets) to determine whether they should stay on board
+ *    if their route continues on the same vehicle, there are methods to determine that.
+ */
+class RoutingSystem : private Routing_types, public RoutingBase {
+private:
+	/** Graph of the route network. uses the BGL (boost graph library). */
+	RouteNetwork                   route_network;
+	/** Penalty factors of the different vehicle types */
+	uint                           vehicle_factor[VEH_END];
+	/** Penalty of a stopover */
+	uint                           stopover_penalty;
+
+	/**
+	 * Typedef for a hop-list
+	 */
+	typedef std::vector<VertexDescriptor> HopVec;
+
+	/**
+	 * Typedef for the hopcache
+	 */
+	typedef std::vector<HopVec>           HopCache;
+
+	/**
+	 * Typedef for a reach-list
+	 */
+	typedef std::vector<StationID>        ReachVec;
+
+	/**
+	 * Typedef for the reachcache
+	 */
+	typedef std::vector<ReachVec>         ReachCache;
+
+	/**
+	 * Typedef for the dirty flag
+	 */
+	typedef std::vector<bool>             DirtyVec;
+
+	/**
+	 * The cache of the network, storing the pathfinding results for all
+	 * the possible routes out of all vertices.
+	 * This one stores the so-called predecessor lists for each vertex, i. e.
+	 * hopcache[A][B]
+	 * contains the vertex called C predecing B in a route A->...->C->B. We can then
+	 * iteratively read
+	 * hopcache[A][C] until this value is A itself (i. e. we're at the origin).<p>
+	 * Should hopcache[A][B] have a value of B itself, there is no route going
+	 * from A to B.
+	 * @note We've made this mutable because the modifing the cache of the routing
+	 * network does not (logically) change the contents of the object
+	 * @warning this->dirty[A] should not be set when hopcache is read, call
+	 * RecomputeCache before reading it
+	 */
+	mutable HopCache hopcache;
+
+	/**
+	 * The cache of reachable stations.
+	 * reachcache[A] contains a vector of all stations that can be reached from
+	 * A. If reachcache[A] is empty(), no stations can be reached.
+	 *
+	 * @note We've made this mutable because the modifing the cache of the routing
+	 * network does not (logically) change the contents of the object
+	 * @warning this->dirty[A] should not be set when reachcache is read, call
+	 * RecomputeCache before reading it
+	 */
+	mutable ReachCache reachcache;
+
+	/**
+	 * Flag that indicates whether the network has been modified since
+	 * the the cache updates
+	 * @note We've made this mutable because the modifing the cache of the routing
+	 * network does not (logically) change the contents of the object
+	 */
+	mutable DirtyVec dirty;
+
+public:
+	/**
+	 * Constructor of the Route Network.
+	 * @param type             The Cargo ID of the route network. Used for debugging purposes
+	 * @param reread           If true, the constructor will attempt to re-read the station and order list
+	 */
+	RoutingSystem(CargoID type, bool reread = false);
+
+	~RoutingSystem();
+	void AddStationToVertexList(StationID index);
+	void RemoveStationFromVertexList(StationID index);
+	void ProcessOrderInsertion(const Order *order, VehicleType type);
+	void ProcessOrderListInsertion(const Order *order, VehicleType type);
+	void ProcessOrderListRemoval(const Order *order, VehicleType type);
+	void ProcessOrderRemoval(const Order *order, VehicleType type);
+	void ListAdjacencies(RoutingVectorList &t) const;
+	StationID FindNextHop(StationID from, StationID to) const;
+	bool CanReachStationFrom(StationID from, StationID to) const;
+	bool UseVehicle(const Vehicle *v, StationID to, bool is_on_board) const;
+	StationID NextUnloadStationForVehicle(const Vehicle *v) const;
+	bool HasDestinations() const { return true; }
+	StationID GetDestination(StationID from) const;
+	bool CanReachAnyStation(StationID from) const;
+	UnloadProcessResult ProcessUnload(GoodsEntry *ge, uint amount, StationID st_index, Vehicle *v, const Vehicle *u) const;
+	PaymentProcessResult ProcessPayment(const CargoPacket *cp, const Station *st, const Vehicle *v) const;
+	void ProcessAcceptanceModification(StationID index);
+	void CheckRoutingCaches();
+
+private:
+	/**
+	 * Atomic process for adding a route
+	 * @param from  The start order of the route
+	 * @param to    The end order of the route
+	 * @param type  The type of the vehicle we're adding
+	 */
+	void AddRoute(const Order *from, const Order *to, VehicleType type);
+
+	/**
+	 * Atomic process for removing a route
+	 * @param from        The start order of the route
+	 * @param to          The end order of the route
+	 * @todo              Can we use remove_edge_if, and if so, how?
+	 */
+	void RemoveRoute(const Order *from, const Order *to);
+
+	/**
+	 * Computes all the possible routes from a station
+	 * @param from The station from which the routes to compute
+	 * @param p    [out] A vector that contains the predecessors of all the vertices
+	 */
+	void ComputeRoutes(StationID from, HopVec& p) const;
+
+	/**
+	 * Computes all possible stations that can be reached.
+	 * @param from  The station we're at and for which we want to know where we can go
+	 * @param list  [out] A vector that contains the StationIDs of the candidates
+	 */
+	void ComputeReachList(StationID from, ReachVec& list) const;
+
+	/**
+	 * Invalidate the cache
+	 */
+	void SetCacheDirty();
+
+	/**
+	 * Recompute the cache for a given station
+	 * @param from the Station to compute the cache for
+	 */
+	void RecomputeCache(StationID from) const;
+};
+
+#endif /* ROUTING_CLASSES_H */
diff -r cefcfd943f94 src/saveload/afterload.cpp
--- a/src/saveload/afterload.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/saveload/afterload.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -27,6 +27,7 @@
 #include "../company_func.h"
 #include "../road_cmd.h"
 #include "../ai/ai.hpp"
+#include "../routing.h"
 
 #include "table/strings.h"
 
@@ -1722,6 +1723,9 @@
 		}
 	}
 
+	/* Restart the routing system and re-read the station list */
+	RoutingBase::InitializeRoutingSystems(true);
+
 	GamelogPrintDebug(1);
 
 	bool ret = InitializeWindowsAndCaches();
diff -r cefcfd943f94 src/saveload/cargopacket_sl.cpp
--- a/src/saveload/cargopacket_sl.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/saveload/cargopacket_sl.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -15,6 +15,7 @@
 	SLE_VAR(CargoPacket, days_in_transit, SLE_UINT8),
 	SLE_VAR(CargoPacket, feeder_share,    SLE_INT64),
 	SLE_VAR(CargoPacket, paid_for,        SLE_BOOL),
+	SLE_CONDVAR(CargoPacket, target,      SLE_UINT16, 114, SL_MAX_VERSION),
 
 	SLE_END()
 };
diff -r cefcfd943f94 src/saveload/saveload.cpp
--- a/src/saveload/saveload.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/saveload/saveload.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -38,7 +38,7 @@
 
 #include "saveload_internal.h"
 
-extern const uint16 SAVEGAME_VERSION = 113;
+extern const uint16 SAVEGAME_VERSION = 114;
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
diff -r cefcfd943f94 src/saveload/station_sl.cpp
--- a/src/saveload/station_sl.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/saveload/station_sl.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -135,6 +135,12 @@
 		     SLE_VAR(GoodsEntry, last_age,            SLE_UINT8),
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_FILE_U32 | SLE_VAR_I64, 14, 64),
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_INT64,                  65, 67),
+		 SLE_CONDVAR(GoodsEntry, origin_last_month,      SLE_UINT32,             114, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, destination_last_month, SLE_UINT32,             114, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, transfer_last_month,    SLE_UINT32,             114, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, origin_this_month,      SLE_UINT32,             114, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, destination_this_month, SLE_UINT32,             114, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, transfer_this_month,    SLE_UINT32,             114, SL_MAX_VERSION),
 		 SLE_CONDLST(GoodsEntry, cargo.packets,       REF_CARGO_PACKET,           68, SL_MAX_VERSION),
 
 		SLE_END()
diff -r cefcfd943f94 src/saveload/vehicle_sl.cpp
--- a/src/saveload/vehicle_sl.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/saveload/vehicle_sl.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -277,12 +277,12 @@
 						v->orders.list = mapping[v->orders.old];
 						/* For old games (case a) we must create the shared vehicle chain */
 						if (CheckSavegameVersionOldStyle(5, 2)) {
-							v->AddToShared(v->orders.list->GetFirstSharedVehicle());
+							v->AddToShared(v->orders.list->GetFirstSharedVehicle(), true);
 						}
 					}
 				} else { // OrderList was saved as such, only recalculate not saved values
 					if (v->PreviousShared() == NULL) {
-						new (v->orders.list) OrderList(v->orders.list->GetFirstOrder(), v);
+						new (v->orders.list) OrderList(v->orders.list->GetFirstOrder(), v, true);
 					}
 				}
 			}
@@ -301,6 +301,17 @@
 	CheckValidVehicles();
 
 	FOR_ALL_VEHICLES(v) {
+		if (v != NULL) {
+			Order *o = v->GetFirstOrder();
+			if (o != NULL) o->prev = NULL;
+
+			FOR_VEHICLE_ORDERS(v, o) {
+				if (o->next != NULL) o->next->prev = o;
+			}
+		}
+	}
+
+	FOR_ALL_VEHICLES(v) {
 		assert(v->first != NULL);
 
 		if (v->type == VEH_TRAIN && (IsFrontEngine(v) || IsFreeWagon(v))) {
diff -r cefcfd943f94 src/settings.cpp
--- a/src/settings.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/settings.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -56,6 +56,7 @@
 #include "gamelog.h"
 #include "station_func.h"
 #include "settings_func.h"
+#include "routing.h"
 #include "ini_type.h"
 #include "ai/ai_config.hpp"
 
@@ -1379,6 +1380,10 @@
 	 SDT_CONDVAR(GameSettings, economy.larger_towns,                 SLE_UINT8, 54, SL_MAX_VERSION, 0, D0,    4,     0,     255, 1, STR_CONFIG_SETTING_LARGER_TOWNS,           NULL),
 	 SDT_CONDVAR(GameSettings, economy.initial_city_size,            SLE_UINT8, 56, SL_MAX_VERSION, 0, 0,     2,     1,      10, 1, STR_CONFIG_SETTING_CITY_SIZE_MULTIPLIER,   NULL),
 	SDT_CONDBOOL(GameSettings, economy.mod_road_rebuild,                        77, SL_MAX_VERSION, 0, 0, false,                    STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD,  NULL),
+	 SDT_CONDVAR(GameSettings, economy.pax_dest_type,                SLE_UINT8,114, SL_MAX_VERSION, 0,MS,     0,     0,       2, 2, STR_CONFIG_SETTING_PAXDEST,                RoutingBase::ModifyPaxRoutingSystem),
+	 SDT_CONDVAR(GameSettings, economy.mail_dest_type,               SLE_UINT8,114, SL_MAX_VERSION, 0,MS,     0,     0,       2, 2, STR_CONFIG_SETTING_MAILDEST,               RoutingBase::ModifyMailRoutingSystem),
+	 SDT_CONDVAR(GameSettings, economy.gold_dest_type,               SLE_UINT8,114, SL_MAX_VERSION, 0,MS,     0,     0,       2, 2, STR_CONFIG_SETTING_GOLDDEST,               RoutingBase::ModifyGoldRoutingSystem),
+	 SDT_CONDVAR(GameSettings, economy.other_dest_type,              SLE_UINT8,114, SL_MAX_VERSION, 0,MS,     0,     0,       2, 2, STR_CONFIG_SETTING_OTHERDEST,              RoutingBase::ModifyOtherRoutingSystem),
 
 	SDT_CONDNULL(1, 0, 106), // previously ai-new setting.
 	    SDT_BOOL(GameSettings, ai.ai_in_multiplayer,                                                0, 0, true,                     STR_CONFIG_SETTING_AI_IN_MULTIPLAYER,      NULL),
@@ -1417,6 +1422,13 @@
 	     SDT_VAR(GameSettings, pf.npf.npf_crossing_penalty,                    SLE_UINT,                     0, 0, (  3 * NPF_TILE_LENGTH),   0,  100000, 0, STR_NULL,         NULL),
 	 SDT_CONDVAR(GameSettings, pf.npf.npf_road_drive_through_penalty,          SLE_UINT, 47, SL_MAX_VERSION, 0, 0, (  8 * NPF_TILE_LENGTH),   0,  100000, 0, STR_NULL,         NULL),
 
+	 SDT_CONDVAR(GameSettings, rn.aircraft_penalty_factor,                    SLE_UINT8,114, SL_MAX_VERSION, 0, 0,                       1,   1,      10, 0, STR_NULL,         RoutingBase::ModifyParameter),
+	 SDT_CONDVAR(GameSettings, rn.train_penalty_factor,                       SLE_UINT8,114, SL_MAX_VERSION, 0, 0,                       2,   1,      10, 0, STR_NULL,         RoutingBase::ModifyParameter),
+	 SDT_CONDVAR(GameSettings, rn.road_penalty_factor,                        SLE_UINT8,114, SL_MAX_VERSION, 0, 0,                       3,   1,      10, 0, STR_NULL,         RoutingBase::ModifyParameter),
+	 SDT_CONDVAR(GameSettings, rn.ship_penalty_factor,                        SLE_UINT8,114, SL_MAX_VERSION, 0, 0,                       4,   1,      10, 0, STR_NULL,         RoutingBase::ModifyParameter),
+	 SDT_CONDVAR(GameSettings, rn.stopover_penalty,                           SLE_UINT8,114, SL_MAX_VERSION, 0, 0,                      25,   1,    1000, 0, STR_NULL,         RoutingBase::ModifyParameter),
+
+
 
 	SDT_CONDBOOL(GameSettings, pf.yapf.disable_node_optimization,                        28, SL_MAX_VERSION, 0, 0, false,                                    STR_NULL,         NULL),
 	 SDT_CONDVAR(GameSettings, pf.yapf.max_search_nodes,                       SLE_UINT, 28, SL_MAX_VERSION, 0, 0, 10000,                   500, 1000000, 0, STR_NULL,         NULL),
@@ -1518,6 +1530,7 @@
 	 SDTC_BOOL(gui.station_show_coverage,                S,  0, false,                        STR_NULL,                                       NULL),
 	 SDTC_BOOL(gui.persistent_buildingtools,             S,  0, false,                        STR_CONFIG_SETTING_PERSISTENT_BUILDINGTOOLS,    NULL),
 	 SDTC_BOOL(gui.expenses_layout,                      S,  0, false,                        STR_CONFIG_SETTING_EXPENSES_LAYOUT,             RedrawScreen),
+	  SDTC_VAR(gui.default_cargo_view,        SLE_UINT8, S, MS,     3,        0,        4, 0, STR_CONFIG_SETTING_DEFAULT_STATION_CARGO_VIEW,  NULL),
 
 	  SDTC_VAR(gui.console_backlog_timeout,  SLE_UINT16, S,  0,   100,       10,    65500, 0, STR_NULL,                                       NULL),
 	  SDTC_VAR(gui.console_backlog_length,   SLE_UINT16, S,  0,   100,       10,    65500, 0, STR_NULL,                                       NULL),
diff -r cefcfd943f94 src/settings_gui.cpp
--- a/src/settings_gui.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/settings_gui.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -1048,6 +1048,7 @@
 	SettingEntry("gui.always_build_infrastructure"),
 	SettingEntry("gui.persistent_buildingtools"),
 	SettingEntry("gui.coloured_news_year"),
+	SettingEntry("gui.default_cargo_view"),
 };
 /** Interface subpage */
 static SettingsPage _settings_ui_page = {_settings_ui, lengthof(_settings_ui)};
@@ -1124,6 +1125,10 @@
 	SettingEntry(&_settings_economy_industries_page, STR_CONFIG_SETTING_ECONOMY_INDUSTRIES),
 	SettingEntry("economy.inflation"),
 	SettingEntry("economy.smooth_economy"),
+	SettingEntry("economy.pax_dest_type"),
+	SettingEntry("economy.mail_dest_type"),
+	SettingEntry("economy.gold_dest_type"),
+	SettingEntry("economy.other_dest_type"),
 };
 /** Economy sub-page */
 static SettingsPage _settings_economy_page = {_settings_economy, lengthof(_settings_economy)};
diff -r cefcfd943f94 src/settings_type.h
--- a/src/settings_type.h	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/settings_type.h	Tue Feb 17 03:31:08 2009 +0100
@@ -90,6 +90,7 @@
 	bool   station_show_coverage;            ///< whether to highlight coverage area
 	bool   persistent_buildingtools;         ///< keep the building tools active after usage
 	uint8  expenses_layout;                  ///< layout of expenses window
+	byte   default_cargo_view;               ///< default view for cargo list
 
 	uint16 console_backlog_timeout;          ///< the minimum amount of time items should be in the console backlog before they will be removed in ~3 seconds granularity.
 	uint16 console_backlog_length;           ///< the minimum amount of items in the console backlog before items will be removed.
@@ -323,6 +324,10 @@
 	bool   allow_town_roads;                 ///< towns are allowed to build roads (always allowed when generating world / in SE)
 	bool   station_noise_level;              ///< build new airports when the town noise level is still within accepted limits
 	uint16 town_noise_population[3];         ///< population to base decision on noise evaluation (@see town_council_tolerance)
+	byte   pax_dest_type;                    ///< whether the passengers carry destinations or maximum acceptance
+	byte   mail_dest_type;                   ///< whether the mail carries destinations or maximum acceptance
+	byte   gold_dest_type;                   ///< whether the valuables etc carry destinations or maximum acceptance
+	byte   other_dest_type;                  ///< whether the other cargo types carry destinations or maximum acceptance
 };
 
 /** Settings related to stations. */
@@ -336,6 +341,15 @@
 	byte   station_spread;                   ///< amount a station may spread
 };
 
+/** Settings related to the routing network */
+struct RoutingSettings {
+	uint8  aircraft_penalty_factor;          ///< penalty factor of an aircraft
+	uint8  train_penalty_factor;             ///< penalty factor of a train
+	uint8  road_penalty_factor;              ///< penalty factor of a road vehicle
+	uint8  ship_penalty_factor;              ///< penalty factor of a ship
+	uint8  stopover_penalty;                 ///< base cost for a route of length 0 (in order to make stopovers less attractive)
+};
+
 /** All settings together for the game. */
 struct GameSettings {
 	DifficultySettings   difficulty;         ///< settings related to the difficulty
@@ -349,6 +363,7 @@
 	EconomySettings      economy;            ///< settings to change the economy
 	StationSettings      station;            ///< settings related to station management
 	LocaleSettings       locale;             ///< settings related to used currency/unit system in the current game
+	RoutingSettings      rn;                 ///< settings related to the routing network
 };
 
 /** All settings that are only important for the local client. */
diff -r cefcfd943f94 src/ship_cmd.cpp
--- a/src/ship_cmd.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/ship_cmd.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -30,6 +30,7 @@
 #include "effectvehicle_func.h"
 #include "settings_type.h"
 #include "ai/ai.hpp"
+#include "routing.h"
 
 #include "table/strings.h"
 #include "table/sprites.h"
@@ -938,6 +939,7 @@
 	}
 
 	if (flags & DC_EXEC) {
+		uint32 old_mask = v->GetCargoForSharedVehicles();
 		v->cargo_cap = capacity;
 		v->cargo.Truncate((v->cargo_type == new_cid) ? capacity : 0);
 		v->cargo_type = new_cid;
@@ -946,6 +948,12 @@
 		InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
 		InvalidateWindow(WC_VEHICLE_DEPOT, v->tile);
 		InvalidateWindowClassesData(WC_SHIPS_LIST, 0);
+
+		uint32 new_mask     = v->GetCargoForSharedVehicles();
+		uint32 changed_mask = new_mask ^ old_mask;
+
+		RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListRemoval,   v->GetFirstOrder(), v->type, old_mask & changed_mask);
+		RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListInsertion, v->GetFirstOrder(), v->type, new_mask & changed_mask);
 	}
 
 	return cost;
diff -r cefcfd943f94 src/ship_gui.cpp
--- a/src/ship_gui.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/ship_gui.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -9,9 +9,13 @@
 #include "vehicle_gui.h"
 #include "strings_func.h"
 #include "vehicle_func.h"
+#include "routing.h"
 
 #include "table/strings.h"
 
+#include <vector>
+#include <map>
+
 void DrawShipImage(const Vehicle *v, int x, int y, VehicleID selection)
 {
 	DrawSprite(v->GetImage(DIR_W), GetVehiclePalette(v), x + 32, y + 10);
@@ -35,34 +39,68 @@
 }
 
 /**
+ * Returns the number of entries we need for the vehicle detail window
+ * so that we can set the scrollbar accordingly. The list can be long since
+ * we list all destinations for every cargo type carried
+ * @see    GetNumberOfDestinationsAndCargoTypes
+ * @param  veh_id The ID of the vehicle we're looking at
+ * @return The total number of entries in the list
+ */
+int GetShipDetailsWndVScroll(VehicleID veh_id)
+{
+	int num = 2; // Two additional lines 1) Type 2) Capacity & total amount
+
+	return num + RoutingBase::GetNumberOfDestinationsAndCargoTypes(GetVehicle(veh_id));
+}
+
+/**
 * Draw the details for the given vehicle at the position (x,y)
 *
 * @param v current vehicle
 * @param x The x coordinate
 * @param y The y coordinate
 */
-void DrawShipDetails(const Vehicle *v, int x, int y)
+void DrawShipDetails(const Vehicle *v, int x, int y, int vscroll_pos, uint16 vscroll_cap)
 {
+	int y_offset = 1;
+	RoutingBase::CargoTypesByStationMap cargo_by_destination;
+	RoutingBase::GetDestinationsForCargos(v, cargo_by_destination);
+
 	SetDParam(0, v->engine_type);
 	SetDParam(1, v->build_year);
 	SetDParam(2, v->value);
-	DrawString(x, y, STR_9816_BUILT_VALUE, TC_FROMSTRING);
+	DrawString(x, y + y_offset, STR_9816_BUILT_VALUE, TC_FROMSTRING);
 
 	SetDParam(0, v->cargo_type);
 	SetDParam(1, v->cargo_cap);
 	SetDParam(2, GetCargoSubtypeText(v));
-	DrawString(x, y + 10, STR_9817_CAPACITY, TC_FROMSTRING);
+	y_offset += 14;
+	DrawString(x, y + y_offset, STR_9817_CAPACITY, TC_FROMSTRING);
 
-	StringID str = STR_8812_EMPTY;
-	if (!v->cargo.Empty()) {
-		SetDParam(0, v->cargo_type);
-		SetDParam(1, v->cargo.Count());
-		SetDParam(2, v->cargo.Source());
-		str = STR_8813_FROM;
+	if (--vscroll_pos < 0 && vscroll_pos > -vscroll_cap + 2) {
+		StringID str = STR_8812_EMPTY;
+		if (!v->cargo.Empty()) {
+			SetDParam(0, v->cargo_type);
+			SetDParam(1, v->cargo.Count());
+			SetDParam(2, v->cargo.Source());
+			str = STR_8813_FROM;
+		}
+		y_offset += 14;
+		DrawString(x, y + y_offset, str, TC_FROMSTRING);
 	}
-	DrawString(x, y + 21, str, TC_FROMSTRING);
+
+	for (RoutingBase::CargoByStationMap::const_iterator it = cargo_by_destination[v->cargo_type].begin(); it != cargo_by_destination[v->cargo_type].end(); ++it) {
+		if (--vscroll_pos < 0 && vscroll_pos > -vscroll_cap + 2) {
+			SetDParam(0, v->cargo_type);
+			SetDParam(1, it->second);
+			SetDParam(2, it->first);
+			y_offset += 14;
+			DrawString(x, y + y_offset, STR_ORIGIN_TO, TC_FROMSTRING);
+		}
+	}
 
 	/* Draw Transfer credits text */
 	SetDParam(0, v->cargo.FeederShare());
-	DrawString(x, y + 33, STR_FEEDER_CARGO_VALUE, TC_FROMSTRING);
+	y_offset += 14;
+	DrawString(x, y + y_offset, STR_FEEDER_CARGO_VALUE, TC_FROMSTRING);
 }
diff -r cefcfd943f94 src/smallmap_gui.cpp
--- a/src/smallmap_gui.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/smallmap_gui.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -20,6 +20,10 @@
 #include "vehicle_base.h"
 #include "sound_func.h"
 #include "window_func.h"
+#include "routing.h"
+#include "company_func.h"
+#include "cargotype.h"
+#include "openttd.h"
 
 #include "table/strings.h"
 #include "table/sprites.h"
@@ -30,16 +34,18 @@
 { WWT_STICKYBOX,     RESIZE_LR,  COLOUR_BROWN,   338,   349,     0,    13, 0x0,                     STR_STICKY_BUTTON},
 {     WWT_PANEL,     RESIZE_RB,  COLOUR_BROWN,     0,   349,    14,   157, 0x0,                     STR_NULL},
 {     WWT_INSET,     RESIZE_RB,  COLOUR_BROWN,     2,   347,    16,   155, 0x0,                     STR_NULL},
-{     WWT_PANEL,    RESIZE_RTB,  COLOUR_BROWN,     0,   261,   158,   201, 0x0,                     STR_NULL},
-{     WWT_PANEL,   RESIZE_LRTB,  COLOUR_BROWN,   262,   349,   158,   158, 0x0,                     STR_NULL},
+{     WWT_PANEL,    RESIZE_RTB,  COLOUR_BROWN,     0,   239,   158,   201, 0x0,                     STR_NULL},
+{     WWT_PANEL,   RESIZE_LRTB,  COLOUR_BROWN,   240,   349,   158,   158, 0x0,                     STR_NULL},
+{     WWT_PANEL,   RESIZE_LRTB,  COLOUR_BROWN,   262,   283,   158,   179, 0x0,                     STR_NULL},
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   284,   305,   158,   179, SPR_IMG_SHOW_COUNTOURS,  STR_0191_SHOW_LAND_CONTOURS_ON_MAP},
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   306,   327,   158,   179, SPR_IMG_SHOW_VEHICLES,   STR_0192_SHOW_VEHICLES_ON_MAP},
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   328,   349,   158,   179, SPR_IMG_INDUSTRY,        STR_0193_SHOW_INDUSTRIES_ON_MAP},
+{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   262,   283,   180,   201, SPR_IMG_SHOW_ROUTES,     STR_0194_SHOW_TRANSPORT_ROUTES_ON},
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   284,   305,   180,   201, SPR_IMG_SHOW_ROUTES,     STR_0194_SHOW_TRANSPORT_ROUTES_ON},
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   306,   327,   180,   201, SPR_IMG_PLANTTREES,      STR_0195_SHOW_VEGETATION_ON_MAP},
 {    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   328,   349,   180,   201, SPR_IMG_COMPANY_GENERAL, STR_0196_SHOW_LAND_OWNERS_ON_MAP},
-{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   262,   283,   158,   179, SPR_IMG_SMALLMAP,        STR_SMALLMAP_CENTER},
-{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   262,   283,   180,   201, SPR_IMG_TOWN,            STR_0197_TOGGLE_TOWN_NAMES_ON_OFF},
+{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   240,   261,   158,   179, SPR_IMG_SMALLMAP,        STR_SMALLMAP_CENTER},
+{    WWT_IMGBTN,   RESIZE_LRTB,  COLOUR_BROWN,   240,   261,   180,   201, SPR_IMG_TOWN,            STR_0197_TOGGLE_TOWN_NAMES_ON_OFF},
 {     WWT_PANEL,    RESIZE_RTB,  COLOUR_BROWN,     0,   337,   202,   213, 0x0,                     STR_NULL},
 {   WWT_TEXTBTN,     RESIZE_TB,  COLOUR_BROWN,     0,    99,   202,   213, STR_MESSAGES_ENABLE_ALL, STR_NULL},
 {   WWT_TEXTBTN,     RESIZE_TB,  COLOUR_BROWN,   100,   201,   202,   213, STR_MESSAGES_DISABLE_ALL,STR_NULL},
@@ -171,10 +177,13 @@
 	_smallmap_industry_count = j;
 }
 
+static LegendAndColour _legend_routemap[NUM_CARGO + 1];
+
 static const LegendAndColour * const _legend_table[] = {
 	_legend_land_contours,
 	_legend_vehicles,
 	_legend_from_industries,
+	_legend_routemap,
 	_legend_routes,
 	_legend_vegetation,
 	_legend_land_owners,
@@ -495,6 +504,7 @@
 	GetSmallMapVehiclesPixels,
 	GetSmallMapIndustriesPixels,
 	GetSmallMapRoutesPixels,
+	GetSmallMapRoutesPixels,
 	GetSmallMapVegetationPixels,
 	GetSmallMapOwnerPixels,
 };
@@ -521,26 +531,47 @@
 	SM_WIDGET_MAP,
 	SM_WIDGET_LEGEND,
 	SM_WIDGET_BUTTONSPANEL,
+	SM_WIDGET_BLANK,
 	SM_WIDGET_CONTOUR,
 	SM_WIDGET_VEHICLES,
 	SM_WIDGET_INDUSTRIES,
+	SM_WIDGET_ROUTEMAP,
 	SM_WIDGET_ROUTES,
 	SM_WIDGET_VEGETATION,
 	SM_WIDGET_OWNERS,
 	SM_WIDGET_CENTERMAP,
 	SM_WIDGET_TOGGLETOWNNAME,
 	SM_WIDGET_BOTTOMPANEL,
-	SM_WIDGET_ENABLEINDUSTRIES,
-	SM_WIDGET_DISABLEINDUSTRIES,
+	SM_WIDGET_ENABLE_ALL,
+	SM_WIDGET_DISABLE_ALL,
 	SM_WIDGET_RESIZEBOX,
 };
 
+void DrawVertex(int x, int y, int size, int color)
+{
+	size--;
+	int w1 = size / 2;
+	int w2 = size / 2 + size % 2;
+
+	for (int i = y - w1; i <= y + w2; ++i) {
+		GfxDrawLine(x - w1, i, x + w2, i, color);
+	}
+
+	w1++;
+	w2++;
+	GfxDrawLine(x - w1, y - w1, x + w2, y - w1, 0x0);
+	GfxDrawLine(x - w1, y + w2, x + w2, y + w2, 0x0);
+	GfxDrawLine(x - w1, y - w1, x - w1, y + w2, 0x0);
+	GfxDrawLine(x + w2, y - w1, x + w2, y + w2, 0x0);
+}
+
 class SmallMapWindow : public Window
 {
 	enum SmallMapType {
 		SMT_CONTOUR,
 		SMT_VEHICLES,
 		SMT_INDUSTRY,
+		SMT_ROUTEMAP,
 		SMT_ROUTES,
 		SMT_VEGETATION,
 		SMT_OWNER,
@@ -548,6 +579,7 @@
 
 	static SmallMapType map_type;
 	static bool show_towns;
+	static uint32 cargo_types;
 
 	int32 scroll_x;
 	int32 scroll_y;
@@ -557,6 +589,46 @@
 	static const int COLUMN_WIDTH = 119;
 	static const int MIN_LEGEND_HEIGHT = 6 * 7;
 
+	int routemap_count;
+
+	/**
+	 * Populate legend table for the route map view.
+	 */
+	void BuildRouteMapLegend()
+	{
+		/* Clear the legend */
+		memset(_legend_routemap, 0, sizeof(_legend_routemap));
+
+		uint i = 0;
+
+		for (CargoID c = CT_BEGIN; c != NUM_CARGO; ++c) {
+			const CargoSpec *cs = GetCargo(c);
+			if (!cs->IsValid()) continue;
+			if (!RoutingBase::Routing(c)->HasDestinations()) continue;
+
+			_legend_routemap[i].legend = cs->name;
+			_legend_routemap[i].colour = cs->legend_colour;
+			_legend_routemap[i].type = c;
+			_legend_routemap[i].show_on_map = HasBit(this->cargo_types, c);
+
+			i++;
+		}
+
+		this->routemap_count = i;
+
+		_legend_routemap[i].end = true;
+
+		this->SetWidgetDisabledState(SM_WIDGET_ROUTEMAP, this->routemap_count == 0);
+		if (this->routemap_count == 0 && this->map_type == SMT_ROUTEMAP) {
+			this->map_type = SMT_CONTOUR;
+		}
+	}
+
+	bool HasButtons()
+	{
+		return this->map_type == SMT_INDUSTRY || this->map_type == SMT_ROUTEMAP;
+	}
+
 public:
 	/**
 	 * Draws the small map.
@@ -719,6 +791,80 @@
 			}
 		}
 
+		if (this->map_type == SMT_ROUTEMAP && _game_mode == GM_NORMAL) {
+			for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
+				if (!tbl->show_on_map) continue;
+
+				CargoID c = tbl->type;
+
+				RoutingVectorList t;
+				RoutingBase::Routing(c)->ListAdjacencies(t);
+
+				for (uint i = 0; i < t.Length(); i++) {
+					const Station *sta = GetStation(t[i].a);
+					const Station *stb = GetStation(t[i].b);
+
+					if (sta->owner != _local_company && IsValidCompanyID(sta->owner)) continue;
+					if (stb->owner != _local_company && IsValidCompanyID(stb->owner)) continue;
+
+					TileIndex ta = sta->xy;
+					TileIndex tb = stb->xy;
+
+					Point pta = RemapCoords(
+						(int)(TileX(ta) * TILE_SIZE - this->scroll_x) / TILE_SIZE,
+						(int)(TileY(ta) * TILE_SIZE - this->scroll_y) / TILE_SIZE,
+						0);
+					pta.x -= this->subscroll + 3;
+
+					Point ptb = RemapCoords(
+						(int)(TileX(tb) * TILE_SIZE - this->scroll_x) / TILE_SIZE,
+						(int)(TileY(tb) * TILE_SIZE - this->scroll_y) / TILE_SIZE,
+						0);
+					ptb.x -= this->subscroll + 3;
+
+					GfxDrawLine(pta.x - 1, pta.y, ptb.x - 1, ptb.y, _colour_gradient[COLOUR_GREY][1]);
+					GfxDrawLine(pta.x + 1, pta.y, ptb.x + 1, ptb.y, _colour_gradient[COLOUR_GREY][1]);
+					GfxDrawLine(pta.x, pta.y - 1, ptb.x, ptb.y - 1, _colour_gradient[COLOUR_GREY][1]);
+					GfxDrawLine(pta.x, pta.y + 1, ptb.x, ptb.y + 1, _colour_gradient[COLOUR_GREY][1]);
+					GfxDrawLine(pta.x, pta.y, ptb.x, ptb.y, tbl->colour);
+				}
+			}
+
+			/* Colour for player owned stations */
+			int p_colour = _colour_gradient[GetCompany(_local_company)->colour][6];
+			/* Colour for non-player owned stations */
+			int o_colour = _colour_gradient[COLOUR_GREY][4];
+
+			const Station *st;
+			FOR_ALL_STATIONS(st) {
+				if (st->owner != _local_company && IsValidCompanyID(st->owner)) continue;
+
+				TileIndex t = st->xy;
+
+				Point pt = RemapCoords(
+					(int)(TileX(t) * TILE_SIZE - this->scroll_x) / TILE_SIZE,
+					(int)(TileY(t) * TILE_SIZE - this->scroll_y) / TILE_SIZE,
+					0);
+				pt.x -= this->subscroll + 3;
+
+				/* Add up cargo waiting for each selected cargo type */
+				uint q = 0;
+				for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
+					if (!tbl->show_on_map) continue;
+					CargoID c = tbl->type;
+					q += st->goods[c].cargo.Count();
+				}
+
+				uint r = 2;
+				if (q >= 100) r++;
+				if (q >= 200) r++;
+				if (q >= 400) r++;
+				if (q >= 800) r++;
+				if (q >= 1600) r++;
+				DrawVertex(pt.x, pt.y, r, IsValidCompanyID(st->owner) ? p_colour : o_colour);
+			}
+		}
+
 		if (this->show_towns) {
 			const Town *t;
 
@@ -789,7 +935,13 @@
 		Widget *legend = &this->widget[SM_WIDGET_LEGEND];
 		int rows = (legend->bottom - legend->top) - 1;
 		int columns = (legend->right - legend->left) / COLUMN_WIDTH;
-		int new_rows = (this->map_type == SMT_INDUSTRY) ? ((_smallmap_industry_count + columns - 1) / columns) * 6 : MIN_LEGEND_HEIGHT;
+		int new_rows = 0;
+
+		if (this->map_type == SMT_INDUSTRY) {
+			new_rows = ((_smallmap_industry_count + columns - 1) / columns) * 6;
+		} else if (this->map_type == SMT_ROUTEMAP) {
+			new_rows = ((this->routemap_count + columns - 1) / columns) * 6;
+		}
 
 		new_rows = max(new_rows, MIN_LEGEND_HEIGHT);
 
@@ -815,6 +967,8 @@
 
 	SmallMapWindow(const WindowDesc *desc, int window_number) : Window(desc, window_number)
 	{
+		this->BuildRouteMapLegend();
+
 		this->LowerWidget(this->map_type + SM_WIDGET_CONTOUR);
 		this->SetWidgetLoweredState(SM_WIDGET_TOGGLETOWNNAME, this->show_towns);
 
@@ -827,8 +981,8 @@
 		DrawPixelInfo new_dpi;
 
 		/* Hide Enable all/Disable all buttons if is not industry type small map*/
-		this->SetWidgetHiddenState(SM_WIDGET_ENABLEINDUSTRIES, this->map_type != SMT_INDUSTRY);
-		this->SetWidgetHiddenState(SM_WIDGET_DISABLEINDUSTRIES, this->map_type != SMT_INDUSTRY);
+		this->SetWidgetHiddenState(SM_WIDGET_ENABLE_ALL, !this->HasButtons());
+		this->SetWidgetHiddenState(SM_WIDGET_DISABLE_ALL, !this->HasButtons());
 
 		/* draw the window */
 		SetDParam(0, STR_00E5_CONTOURS + this->map_type);
@@ -862,6 +1016,16 @@
 					DrawString(x + 11, y, STR_SMALLMAP_INDUSTRY, TC_BLACK);
 					GfxFillRect(x, y + 1, x + 8, y + 5, 0); // outer border of the legend colour
 				}
+			} else if (this->map_type == SMT_ROUTEMAP) {
+				SetDParam(0, tbl->legend);
+				if (!tbl->show_on_map) {
+					/* Simply draw the string, not the black border of the legend color.
+					 * This will enforce the idea of the disabled item */
+					DrawString(x + 11, y, STR_SMALLMAP_ROUTEMAP_LEGEND, TC_GREY);
+				} else {
+					DrawString(x + 11, y, STR_SMALLMAP_ROUTEMAP_LEGEND, TC_BLACK);
+					GfxFillRect(x, y + 1, x + 8, y + 5, 0); // outer border of the legend color
+				}
 			} else {
 				/* Anything that is not an industry is using normal process */
 				GfxFillRect(x, y + 1, x + 8, y + 5, 0);
@@ -904,6 +1068,7 @@
 			case SM_WIDGET_CONTOUR:    // Show land contours
 			case SM_WIDGET_VEHICLES:   // Show vehicles
 			case SM_WIDGET_INDUSTRIES: // Show industries
+			case SM_WIDGET_ROUTEMAP:   // Show route map
 			case SM_WIDGET_ROUTES:     // Show transport routes
 			case SM_WIDGET_VEGETATION: // Show vegetation
 			case SM_WIDGET_OWNERS:     // Show land owners
@@ -934,7 +1099,7 @@
 
 			case SM_WIDGET_LEGEND: // Legend
 				/* if industry type small map*/
-				if (this->map_type == SMT_INDUSTRY) {
+				if (this->map_type == SMT_INDUSTRY || this->map_type == SMT_ROUTEMAP) {
 					/* if click on industries label, find right industry type and enable/disable it */
 					Widget *wi = &this->widget[SM_WIDGET_LEGEND]; // label panel
 					uint column = (pt.x - 4) / COLUMN_WIDTH;
@@ -942,37 +1107,50 @@
 					int rows_per_column = (wi->bottom - wi->top) / 6;
 
 					/* check if click is on industry label*/
-					int industry_pos = (column * rows_per_column) + line;
-					if (industry_pos < _smallmap_industry_count) {
-						_legend_from_industries[industry_pos].show_on_map = !_legend_from_industries[industry_pos].show_on_map;
+					int click_pos = (column * rows_per_column) + line;
+					if (this->map_type == SMT_INDUSTRY) {
+						if (click_pos < _smallmap_industry_count) {
+							_legend_from_industries[click_pos].show_on_map = !_legend_from_industries[click_pos].show_on_map;
+						}
+					} else if (this->map_type == SMT_ROUTEMAP) {
+						if (click_pos < this->routemap_count) {
+							_legend_routemap[click_pos].show_on_map = !_legend_routemap[click_pos].show_on_map;
+							ToggleBit(this->cargo_types, click_pos);
+						}
 					}
 
 					/* Raise the two buttons "all", as we have done a specific choice */
-					this->RaiseWidget(SM_WIDGET_ENABLEINDUSTRIES);
-					this->RaiseWidget(SM_WIDGET_DISABLEINDUSTRIES);
+					this->RaiseWidget(SM_WIDGET_ENABLE_ALL);
+					this->RaiseWidget(SM_WIDGET_DISABLE_ALL);
 					this->SetDirty();
 				}
 				break;
 
-			case SM_WIDGET_ENABLEINDUSTRIES: // Enable all industries
-				for (int i = 0; i != _smallmap_industry_count; i++) {
-					_legend_from_industries[i].show_on_map = true;
+			case SM_WIDGET_ENABLE_ALL: { // Enable all items
+				LegendAndColour *tbl = (this->map_type == SMT_INDUSTRY) ? _legend_from_industries : _legend_routemap;
+				for (; !tbl->end; ++tbl) {
+					tbl->show_on_map = true;
 				}
+				this->cargo_types = UINT_MAX;
 				/* toggle appeareance indicating the choice */
-				this->LowerWidget(SM_WIDGET_ENABLEINDUSTRIES);
-				this->RaiseWidget(SM_WIDGET_DISABLEINDUSTRIES);
+				this->LowerWidget(SM_WIDGET_ENABLE_ALL);
+				this->RaiseWidget(SM_WIDGET_DISABLE_ALL);
 				this->SetDirty();
 				break;
+			}
 
-			case SM_WIDGET_DISABLEINDUSTRIES: // disable all industries
-				for (int i = 0; i != _smallmap_industry_count; i++) {
-					_legend_from_industries[i].show_on_map = false;
+			case SM_WIDGET_DISABLE_ALL: { // Disable all items
+				LegendAndColour *tbl = (this->map_type == SMT_INDUSTRY) ? _legend_from_industries : _legend_routemap;
+				for (; !tbl->end; ++tbl) {
+					tbl->show_on_map = false;
 				}
+				this->cargo_types = 0;
 				/* toggle appeareance indicating the choice */
-				this->RaiseWidget(SM_WIDGET_ENABLEINDUSTRIES);
-				this->LowerWidget(SM_WIDGET_DISABLEINDUSTRIES);
+				this->RaiseWidget(SM_WIDGET_ENABLE_ALL);
+				this->LowerWidget(SM_WIDGET_DISABLE_ALL);
 				this->SetDirty();
 				break;
+			}
 		}
 	}
 
@@ -1048,15 +1226,16 @@
 
 	virtual void OnResize(Point new_size, Point delta)
 	{
-		if (delta.x != 0 && this->map_type == SMT_INDUSTRY) this->ResizeLegend();
+		if (delta.x != 0 && (this->map_type == SMT_INDUSTRY || this->map_type == SMT_ROUTEMAP)) this->ResizeLegend();
 	}
 };
 
 SmallMapWindow::SmallMapType SmallMapWindow::map_type = SMT_CONTOUR;
 bool SmallMapWindow::show_towns = true;
+uint32 SmallMapWindow::cargo_types = UINT_MAX;
 
 static const WindowDesc _smallmap_desc = {
-	WDP_AUTO, WDP_AUTO, 350, 214, 446, 314,
+	WDP_AUTO, WDP_AUTO, 350, 214, 468, 314,
 	WC_SMALLMAP, WC_NONE,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_STICKY_BUTTON | WDF_RESIZABLE,
 	_smallmap_widgets,
diff -r cefcfd943f94 src/station.cpp
--- a/src/station.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/station.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -20,6 +20,7 @@
 #include "aircraft.h"
 #include "vehicle_gui.h"
 #include "settings_type.h"
+#include "routing.h"
 
 #include "table/strings.h"
 
@@ -41,6 +42,13 @@
 
 	random_bits = 0; // Random() must be called when station is really built (DC_EXEC)
 	waiting_triggers = 0;
+
+	if (tile != INVALID_TILE) {
+		for (CargoID c = CT_BEGIN; c != NUM_CARGO; c++) {
+			this->goods[c].cargo.CreateCargoListEntry(c, this->index);
+			RoutingBase::Routing(c)->AddStationToVertexList(index);
+		}
+	}
 }
 
 /**
@@ -79,9 +87,29 @@
 	DeleteWindowById(WC_SHIPS_LIST, wno | (VEH_SHIP << 11));
 	DeleteWindowById(WC_AIRCRAFT_LIST, wno | (VEH_AIRCRAFT << 11));
 
+	/* Reroute cargopackets that go here.
+	 * We do this to eliminate any problems when another station is
+	 * rebuilt and our index is recycled (especially when said station is not
+	 * connected at all or has a different acceptance */
+	Station *st;
+
+	FOR_ALL_STATIONS(st) {
+		for (CargoID c = 0; c < NUM_CARGO; c++) {
+			StationID target = INVALID_STATION;
+
+			if (RoutingBase::Routing(c)->CanReachAnyStation(st->index)) target = RoutingBase::Routing(c)->GetDestination(st->index);
+
+			st->goods[c].cargo.SetNewDestination(this->index, target);
+		}
+	}
+
 	/* Now delete all orders that go to the station */
 	RemoveOrderFromAllVehicles(OT_GOTO_STATION, index);
 
+	for (CargoID c = CT_BEGIN; c != NUM_CARGO; c++) {
+		RoutingBase::Routing(c)->RemoveStationFromVertexList(index);
+	}
+
 	/* Subsidies need removal as well */
 	DeleteSubsidyWithStation(index);
 
diff -r cefcfd943f94 src/station_base.h
--- a/src/station_base.h	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/station_base.h	Tue Feb 17 03:31:08 2009 +0100
@@ -36,7 +36,13 @@
 		days_since_pickup(255),
 		rating(INITIAL_STATION_RATING),
 		last_speed(0),
-		last_age(255)
+		last_age(255),
+		origin_last_month(0),
+		destination_last_month(0),
+		transfer_last_month(0),
+		origin_this_month(0),
+		destination_this_month(0),
+		transfer_this_month(0)
 	{}
 
 	byte acceptance_pickup;
@@ -44,6 +50,12 @@
 	byte rating;
 	byte last_speed;
 	byte last_age;
+	uint32 origin_last_month;
+	uint32 destination_last_month;
+	uint32 transfer_last_month;
+	uint32 origin_this_month;
+	uint32 destination_this_month;
+	uint transfer_this_month;
 	CargoList cargo; ///< The cargo packets of cargo waiting in this station
 };
 
diff -r cefcfd943f94 src/station_cmd.cpp
--- a/src/station_cmd.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/station_cmd.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -32,6 +32,7 @@
 #include "oldpool_func.h"
 #include "animated_tile_func.h"
 #include "elrail_func.h"
+#include "routing.h"
 
 #include "table/strings.h"
 
@@ -627,6 +628,10 @@
 	uint new_acc = GetAcceptanceMask(st);
 	if (old_acc == new_acc) return;
 
+	for (CargoID c = 0; c < NUM_CARGO; c++) {
+		if (HasBit(new_acc ^ old_acc, c)) RoutingBase::Routing(c)->ProcessAcceptanceModification(st->index);
+	}
+
 	/* show a message to report that the acceptance was changed? */
 	if (show_msg && st->owner == _local_company && st->facilities) {
 		/* List of accept and reject strings for different number of
@@ -677,7 +682,16 @@
 	if (r->IsEmpty()) return; /* no tiles belong to this station */
 
 	/* clamp sign coord to be inside the station rect */
+	TileIndex oldxy = st->xy;
 	st->xy = TileXY(ClampU(TileX(st->xy), r->left, r->right), ClampU(TileY(st->xy), r->top, r->bottom));
+
+	/**
+	 * @todo I wonder whether this is the best way to do it.
+	 * Then again, parsing the order list manually and finding the ones
+	 * that need modification isn't going to save us a lot of
+	 * hassle .. or CPU cycles
+	 */
+	if (oldxy != st->xy) RoutingBase::InitializeRoutingSystems(true);
 	UpdateStationVirtCoordDirty(st);
 }
 
@@ -2724,13 +2738,14 @@
 
 static void UpdateStationRating(Station *st)
 {
-	bool waiting_changed = false;
+	StationID index = st->index;
 
 	byte_inc_sat(&st->time_since_load);
 	byte_inc_sat(&st->time_since_unload);
 
-	GoodsEntry *ge = st->goods;
-	do {
+	for (CargoID c = CT_BEGIN; c != NUM_CARGO; ++c) {
+		GoodsEntry *ge = &st->goods[c];
+
 		/* Slowly increase the rating back to his original level in the case we
 		 *  didn't deliver cargo yet to this station. This happens when a bribe
 		 *  failed while you didn't moved that cargo yet to a station. */
@@ -2779,6 +2794,7 @@
 			(rating += 10, true);
 
 			{
+				bool waiting_changed = false;
 				int or_ = ge->rating; // old rating
 
 				/* only modify rating in steps of -2, -1, 0, 1 or 2 */
@@ -2818,17 +2834,15 @@
 					waiting_changed = true;
 				}
 
-				if (waiting_changed) ge->cargo.Truncate(waiting);
+				if (waiting_changed) {
+					ge->cargo.Truncate(waiting);
+					InvalidateWindowData(WC_STATION_VIEW, index, 1 << c);
+				}
 			}
 		}
-	} while (++ge != endof(st->goods));
+	}
 
-	StationID index = st->index;
-	if (waiting_changed) {
-		InvalidateWindow(WC_STATION_VIEW, index); // update whole window
-	} else {
-		InvalidateWindowWidget(WC_STATION_VIEW, index, SVW_RATINGLIST); // update only ratings list
-	}
+	InvalidateWindowWidget(WC_STATION_VIEW, index, SVW_RATINGLIST); // update ratings list
 }
 
 /* called for every station each tick */
@@ -2867,7 +2881,20 @@
 
 void StationMonthlyLoop()
 {
-	/* not used */
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID i = 0; i < NUM_CARGO; i++) {
+			GoodsEntry *ge = &st->goods[i];
+
+			ge->origin_last_month = ge->origin_this_month;
+			ge->destination_last_month = ge->destination_this_month;
+			ge->transfer_last_month = ge->transfer_this_month;
+
+			ge->origin_this_month = 0;
+			ge->destination_this_month = 0;
+			ge->transfer_this_month = 0;
+		}
+	}
 }
 
 
@@ -2891,12 +2918,16 @@
 
 static void UpdateStationWaiting(Station *st, CargoID type, uint amount)
 {
-	st->goods[type].cargo.Append(new CargoPacket(st->index, amount));
+	StationID target = RoutingBase::Routing(type)->GetDestination(st->index);
+
+	assert(target != st->index);
+
+	st->goods[type].cargo.Append(new CargoPacket(st->index, target, amount));
 	SetBit(st->goods[type].acceptance_pickup, GoodsEntry::PICKUP);
 
 	StationAnimationTrigger(st, st->xy, STAT_ANIM_NEW_CARGO, type);
 
-	InvalidateWindow(WC_STATION_VIEW, st->index);
+	InvalidateWindowData(WC_STATION_VIEW, st->index, 1 << type);
 	st->MarkTilesDirty(true);
 }
 
@@ -3043,7 +3074,9 @@
 	if (st2 == NULL) {
 		/* only one station around */
 		uint moved = amount * best_rating1 / 256 + 1;
+		if (!RoutingBase::Routing(type)->CanReachAnyStation(st1->index)) return 0;
 		UpdateStationWaiting(st1, type, moved);
+		st1->goods[type].origin_this_month += moved;
 		return moved;
 	}
 
@@ -3059,16 +3092,18 @@
 	uint t = (best_rating1 * (amount + 1)) / (best_rating1 + best_rating2);
 
 	uint moved = 0;
-	if (t != 0) {
+	if (t != 0 && RoutingBase::Routing(type)->CanReachAnyStation(st1->index)) {
 		moved = t * best_rating1 / 256 + 1;
 		amount -= t;
 		UpdateStationWaiting(st1, type, moved);
+		st1->goods[type].origin_this_month += moved;
 	}
 
-	if (amount != 0) {
+	if (amount != 0 && RoutingBase::Routing(type)->CanReachAnyStation(st2->index)) {
 		amount = amount * best_rating2 / 256 + 1;
 		moved += amount;
 		UpdateStationWaiting(st2, type, amount);
+		st2->goods[type].origin_this_month += amount;
 	}
 
 	return moved;
diff -r cefcfd943f94 src/station_gui.cpp
--- a/src/station_gui.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/station_gui.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -25,6 +25,7 @@
 #include "company_base.h"
 #include "sortlist_type.h"
 #include "settings_type.h"
+#include "routing.h"
 
 #include "table/strings.h"
 #include "table/sprites.h"
@@ -633,19 +634,23 @@
 
 static const Widget _station_view_widgets[] = {
 {   WWT_CLOSEBOX,   RESIZE_NONE,  COLOUR_GREY,     0,    10,     0,    13, STR_00C5,          STR_018B_CLOSE_WINDOW},                // SVW_CLOSEBOX
-{    WWT_CAPTION,  RESIZE_RIGHT,  COLOUR_GREY,    11,   236,     0,    13, STR_300A_0,        STR_018C_WINDOW_TITLE_DRAG_THIS},
-{  WWT_STICKYBOX,     RESIZE_LR,  COLOUR_GREY,   237,   248,     0,    13, 0x0,               STR_STICKY_BUTTON},
-{      WWT_PANEL,     RESIZE_RB,  COLOUR_GREY,     0,   236,    14,    65, 0x0,               STR_NULL},                             // SVW_WAITING
-{  WWT_SCROLLBAR,    RESIZE_LRB,  COLOUR_GREY,   237,   248,    14,    65, 0x0,               STR_0190_SCROLL_BAR_SCROLLS_LIST},
-{      WWT_PANEL,    RESIZE_RTB,  COLOUR_GREY,     0,   248,    66,    97, 0x0,               STR_NULL},                             // SVW_ACCEPTLIST / SVW_RATINGLIST
-{ WWT_PUSHTXTBTN,     RESIZE_TB,  COLOUR_GREY,     0,    59,    98,   109, STR_00E4_LOCATION, STR_3053_CENTER_MAIN_VIEW_ON_STATION}, // SVW_LOCATION
-{ WWT_PUSHTXTBTN,     RESIZE_TB,  COLOUR_GREY,    60,   120,    98,   109, STR_3032_RATINGS,  STR_3054_SHOW_STATION_RATINGS},        // SVW_RATINGS / SVW_ACCEPTS
-{ WWT_PUSHTXTBTN,    RESIZE_RTB,  COLOUR_GREY,   121,   180,    98,   109, STR_0130_RENAME,   STR_3055_CHANGE_NAME_OF_STATION},      // SVW_RENAME
-{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   181,   194,    98,   109, STR_TRAIN,         STR_SCHEDULED_TRAINS_TIP },            // SVW_TRAINS
-{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   195,   208,    98,   109, STR_LORRY,         STR_SCHEDULED_ROAD_VEHICLES_TIP },     // SVW_ROADVEHS
-{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   209,   222,    98,   109, STR_PLANE,         STR_SCHEDULED_AIRCRAFT_TIP },          // SVW_PLANES
-{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   223,   236,    98,   109, STR_SHIP,          STR_SCHEDULED_SHIPS_TIP },             // SVW_SHIPS
-{  WWT_RESIZEBOX,   RESIZE_LRTB,  COLOUR_GREY,   237,   248,    98,   109, 0x0,               STR_RESIZE_BUTTON},
+{    WWT_CAPTION,  RESIZE_RIGHT,  COLOUR_GREY,    11,   336,     0,    13, STR_300A_0,        STR_018C_WINDOW_TITLE_DRAG_THIS},
+{  WWT_STICKYBOX,     RESIZE_LR,  COLOUR_GREY,   337,   348,     0,    13, 0x0,               STR_STICKY_BUTTON},
+{    WWT_TEXTBTN,   RESIZE_NONE,  COLOUR_GREY,     0,    80,    14,    25, STR_SORT_BY,       STR_SORT_ORDER_TIP},                   // SVW_SORTBY
+{   WWT_DROPDOWN,   RESIZE_NONE,  COLOUR_GREY,    81,   243,    14,    25, 0x0,               STR_SORT_CRITERIA_TIP},                // SVW_SORTDROPBTN
+{   WWT_DROPDOWN,   RESIZE_NONE,  COLOUR_GREY,   244,   348,    14,    25, 0x0,               STR_VIEW_MODE},                        // SVW_VIEW_MODE
+{      WWT_PANEL,  RESIZE_RIGHT,  COLOUR_GREY,   349,   349,    14,    25, 0x0,               STR_NULL},                             // SVW_PAN_SORT_RIGHT
+{      WWT_PANEL,     RESIZE_RB,  COLOUR_GREY,     0,   336,    26,    77, 0x0,               STR_NULL},                             // SVW_WAITING
+{  WWT_SCROLLBAR,    RESIZE_LRB,  COLOUR_GREY,   337,   348,    26,    77, 0x0,               STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WWT_PANEL,    RESIZE_RTB,  COLOUR_GREY,     0,   348,    78,   109, 0x0,               STR_NULL},                             // SVW_ACCEPTLIST / SVW_RATINGLIST
+{ WWT_PUSHTXTBTN,     RESIZE_TB,  COLOUR_GREY,     0,    89,   110,   121, STR_00E4_LOCATION, STR_3053_CENTER_MAIN_VIEW_ON_STATION}, // SVW_LOCATION
+{ WWT_PUSHTXTBTN,     RESIZE_TB,  COLOUR_GREY,    90,   180,   110,   121, STR_3032_RATINGS,  STR_3054_SHOW_STATION_RATINGS},        // SVW_RATINGS / SVW_ACCEPTS
+{ WWT_PUSHTXTBTN,    RESIZE_RTB,  COLOUR_GREY,   181,   280,   110,   121, STR_0130_RENAME,   STR_3055_CHANGE_NAME_OF_STATION},      // SVW_RENAME
+{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   281,   294,   110,   121, STR_TRAIN,         STR_SCHEDULED_TRAINS_TIP },            // SVW_TRAINS
+{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   295,   308,   110,   121, STR_LORRY,         STR_SCHEDULED_ROAD_VEHICLES_TIP },     // SVW_ROADVEHS
+{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   309,   322,   110,   121, STR_PLANE,         STR_SCHEDULED_AIRCRAFT_TIP },          // SVW_PLANES
+{ WWT_PUSHTXTBTN,   RESIZE_LRTB,  COLOUR_GREY,   323,   336,   110,   121, STR_SHIP,          STR_SCHEDULED_SHIPS_TIP },             // SVW_SHIPS
+{  WWT_RESIZEBOX,   RESIZE_LRTB,  COLOUR_GREY,   337,   348,   110,   121, 0x0,               STR_RESIZE_BUTTON},
 {   WIDGETS_END},
 };
 
@@ -687,26 +692,208 @@
 	} while (--num);
 }
 
-struct CargoData {
-	CargoID cargo;
-	StationID source;
-	uint count;
-
-	CargoData(CargoID cargo, StationID source, uint count) :
-		cargo(cargo),
-		source(source),
-		count(count)
-	{ }
-};
-
-typedef std::list<CargoData> CargoDataList;
-
 /**
  * The StationView window
  */
 struct StationViewWindow : public Window {
-	uint32 cargo;                 ///< Bitmask of cargo types to expand
-	uint16 cargo_rows[NUM_CARGO]; ///< Header row for each cargo type
+	enum StationViewMode {
+		SVM_ALL,
+		SVM_DESTINATION,
+		SVM_NEXT_HOP,
+		SVM_TREE,
+		SVM_SOURCE
+	};
+
+	struct CargoData {
+		StationID source;
+		StationID target;
+		StationID final_target;
+		uint count;
+		uint level;
+		uint arrivecount;
+
+		CargoData(StationID source, StationID target, uint count, uint level = 0, uint arrivecount = 0, StationID final = INVALID_STATION) :
+			source(source),
+			target(target),
+			final_target(final),
+			count(count),
+			level(level),
+			arrivecount(arrivecount)
+		{ }
+	};
+
+	typedef std::list<CargoData> CargoDataList;
+
+	uint32 cargo_total[NUM_CARGO];       ///< Total cargo waiting for each cargo type
+	CargoDataList cargo_list[NUM_CARGO]; ///< Sorted cargo list for each cargo type
+	uint32 cargo_dirty;                  ///< Bitmask of cargo types that need updating
+	uint32 cargo_can_expand;             ///< Bitmask of cargo types that can expand
+	uint32 cargo_expand;                 ///< Bitmask of cargo types to expand
+	bool cargo_resort;
+	StationViewMode view;                ///< How to show cargo
+
+	static Listing last_sorting;
+
+	/* Constants for sorting cargo */
+	typedef bool SorterFunc(const CargoData &, const CargoData &);
+	static const StringID sorter_names[];
+	static const StringID view_names[];
+	static SorterFunc *const sorter_funcs[];
+
+	/**
+	 * Build the cargo list for the given cargo type
+	 */
+	void BuildCargoList(CargoID type)
+	{
+		StationID station_id = this->window_number;
+		const Station *st = GetStation(station_id);
+		const GoodsEntry *ge = &st->goods[type];
+
+		ClrBit(this->cargo_dirty, type);
+
+		this->cargo_total[type] = 0;
+		this->cargo_list[type].clear();
+
+		if (ge->cargo.Empty()) return;
+
+		this->cargo_total[type] = ge->cargo.Count();
+
+		/* Add an entry for each distinct cargo source. */
+		const CargoList::List *packets = ge->cargo.Packets();
+		for (CargoList::List::const_iterator it = packets->begin(); it != packets->end(); ++it) {
+			const CargoPacket *cp = *it;
+			if (cp->source != station_id || cp->target != INVALID_STATION) {
+				SetBit(this->cargo_can_expand, type);
+
+				/* Don't go further through the cargo packets if it will not be shown */
+				if (!HasBit(this->cargo_expand, type)) break;
+
+				if (this->view == SVM_TREE) {
+					StationID target   = cp->target;
+					StationID curr     = station_id;
+					StationID prev_hop = INVALID_STATION;
+					uint level = 0;
+					CargoDataList::iterator inspos = this->cargo_list[type].begin();
+
+					do {
+						bool added = false;
+						prev_hop   = curr;
+						curr       = RoutingBase::Routing(type)->FindNextHop(curr, target);
+
+						if (curr == INVALID_STATION) {
+							for (CargoDataList::iterator jt = this->cargo_list[type].begin(); jt != this->cargo_list[type].end(); ++jt) {
+								CargoData *cd = &(*jt);
+
+								if (cd->final_target == cp->target) {
+									cd->count += cp->count;
+									cd->arrivecount += cp->count;
+									added = true;
+									break;
+								}
+							}
+
+							if (!added) this->cargo_list[type].push_front(CargoData(station_id, curr, cp->count, level, cp->count, cp->target));
+						} else {
+							for (CargoDataList::iterator jt = this->cargo_list[type].begin(); jt != this->cargo_list[type].end(); ++jt) {
+								CargoData *cd = &(*jt);
+
+								if (cd->target == curr) {
+									cd->count += cp->count;
+									if (cd->target == cp->target) cd->arrivecount += cp->count;
+									added = true;
+									inspos = jt;
+									break;
+								}
+							}
+
+							if (!added) {
+								uint arrivecount = (curr == target) ? cp->count : 0;
+								if (level == 0 || inspos == this->cargo_list[type].end()) {
+									/* We have a new 'trunk' leaving the station, or happen to be at the end of the list, so
+									 * we use push_back(), because insert() can't append to the list */
+									assert(level == 0 || prev_hop == this->cargo_list[type].back().target);
+
+									this->cargo_list[type].push_back(CargoData(station_id, curr, cp->count, level, arrivecount));
+									inspos = this->cargo_list[type].end(); // Adjust the insertion position for new elements
+								} else {
+									/* Adding a new branch to an existing trunk. Plus we can use insert() since we're not
+									 * at the end of the list */
+									assert(prev_hop == inspos->target);
+									inspos++;
+									inspos = this->cargo_list[type].insert(inspos, CargoData(station_id, curr, cp->count, level, arrivecount));
+								}
+							}
+
+							level++;
+						}
+					} while (curr != target && curr != INVALID_STATION);
+
+				} else {
+					bool added = false;
+
+					StationID target = (this->view == SVM_NEXT_HOP) ? RoutingBase::Routing(type)->FindNextHop(station_id, cp->target) : cp->target;
+
+					/* Check if we already have this source in the list */
+					for (CargoDataList::iterator jt = this->cargo_list[type].begin(); jt != this->cargo_list[type].end(); ++jt) {
+						CargoData *cd = &(*jt);
+						if ((cd->source == cp->source || (this->view != SVM_ALL && this->view != SVM_SOURCE)) && (cd->target == target || this->view == SVM_SOURCE)) {
+							cd->count += cp->count;
+							added = true;
+							break;
+						}
+					}
+
+					if (!added) {
+						this->cargo_list[type].push_back(CargoData( (this->view == SVM_ALL || this->view == SVM_SOURCE) ? cp->source : station_id, target, cp->count));
+					}
+				}
+			}
+		}
+
+		SortCargoList(type);
+	}
+
+	/** Sort cargo by target name */
+	static bool CargoListTargetSorter(const CargoData &a, const CargoData &b)
+	{
+		char buf_a[MAX_LENGTH_STATION_NAME_BYTES];
+		char buf_b[MAX_LENGTH_STATION_NAME_BYTES];
+
+		SetDParam(0, a.target);
+		GetString(buf_a, STR_STATION, lastof(buf_a));
+
+		SetDParam(0, b.target);
+		GetString(buf_b, STR_STATION, lastof(buf_b));
+
+		return strcmp(buf_a, buf_b) < 0;
+	}
+
+	/** Sort cargo by quantity */
+	static bool CargoListCountSorter(const CargoData &a, const CargoData &b)
+	{
+		return a.count < b.count;
+	}
+
+	void SortCargoList(CargoID type)
+	{
+		if (this->view == SVM_TREE) return; // Override any sorting in the tree view
+		this->cargo_list[type].sort(this->sorter_funcs[this->last_sorting.criteria]);
+
+		if (this->last_sorting.order) this->cargo_list[type].reverse();
+	}
+
+	int GetCargoListLines()
+	{
+		int lines = 0;
+
+		for (CargoID c = CT_BEGIN; c != NUM_CARGO; ++c) {
+			if (this->cargo_total[c] != 0) {
+				lines += this->cargo_list[c].size() + 1;
+			}
+		}
+
+		return lines;
+	}
 
 	StationViewWindow(const WindowDesc *desc, WindowNumber window_number) : Window(desc, window_number)
 	{
@@ -714,6 +901,11 @@
 		if (owner != OWNER_NONE) this->owner = owner;
 		this->vscroll.cap = 5;
 		this->resize.step_height = 10;
+		this->view = (StationViewMode)_settings_client.gui.default_cargo_view;
+		this->cargo_dirty = UINT_MAX;
+
+		this->widget[SVW_SORTDROPBTN].data = this->sorter_names[this->last_sorting.criteria];
+		this->widget[SVW_VIEW_MODE].data   = this->view_names[this->view];
 
 		this->FindWindowPlacementAndResize(desc);
 	}
@@ -733,49 +925,19 @@
 	{
 		StationID station_id = this->window_number;
 		const Station *st = GetStation(station_id);
-		CargoDataList cargolist;
-		uint32 transfers = 0;
 
-		/* count types of cargos waiting in station */
-		for (CargoID i = 0; i < NUM_CARGO; i++) {
-			if (st->goods[i].cargo.Empty()) {
-				this->cargo_rows[i] = 0;
-			} else {
-				/* Add an entry for total amount of cargo of this type waiting. */
-				cargolist.push_back(CargoData(i, INVALID_STATION, st->goods[i].cargo.Count()));
+		if (this->cargo_dirty != 0) {
+			for (CargoID c = CT_BEGIN; c != NUM_CARGO; ++c) {
+				if (HasBit(this->cargo_dirty, c)) BuildCargoList(c);
+			}
+		} else if (this->cargo_resort) {
+			for (CargoID c = CT_BEGIN; c != NUM_CARGO; ++c) {
+				SortCargoList(c);
+			}
+			this->cargo_resort = false;
+		}
 
-				/* Set the row for this cargo entry for the expand/hide button */
-				this->cargo_rows[i] = (uint16)cargolist.size();
-
-				/* Add an entry for each distinct cargo source. */
-				const CargoList::List *packets = st->goods[i].cargo.Packets();
-				for (CargoList::List::const_iterator it = packets->begin(); it != packets->end(); it++) {
-					const CargoPacket *cp = *it;
-					if (cp->source != station_id) {
-						bool added = false;
-
-						/* Enable the expand/hide button for this cargo type */
-						SetBit(transfers, i);
-
-						/* Don't add cargo lines if not expanded */
-						if (!HasBit(this->cargo, i)) break;
-
-						/* Check if we already have this source in the list */
-						for (CargoDataList::iterator jt = cargolist.begin(); jt != cargolist.end(); jt++) {
-							CargoData *cd = &(*jt);
-							if (cd->cargo == i && cd->source == cp->source) {
-								cd->count += cp->count;
-								added = true;
-								break;
-							}
-						}
-
-						if (!added) cargolist.push_back(CargoData(i, cp->source, cp->count));
-					}
-				}
-			}
-		}
-		SetVScrollCount(this, (int)cargolist.size() + 1); // update scrollbar
+		SetVScrollCount(this, this->GetCargoListLines() + 1); // update scrollbar
 
 		/* disable some buttons */
 		this->SetWidgetDisabledState(SVW_RENAME,   st->owner != _local_company);
@@ -788,8 +950,14 @@
 		SetDParam(1, st->facilities);
 		this->DrawWidgets();
 
+		/* draw arrow pointing up/down for ascending/descending sorting */
+		this->DrawSortButtonState(SVW_SORTBY, this->last_sorting.order ? SBS_DOWN : SBS_UP);
+
+		this->SetWidgetDisabledState(SVW_SORTBY,      this->view == SVM_TREE);
+		this->SetWidgetDisabledState(SVW_SORTDROPBTN, this->view == SVM_TREE);
+
 		int x = 2;  ///< coordinates used for printing waiting/accepted/rating of cargo
-		int y = 15;
+		int y = this->widget[SVW_WAITING].top + 1;
 		int pos = this->vscroll.pos; ///< = this->vscroll.pos
 
 		uint width = this->widget[SVW_WAITING].right - this->widget[SVW_WAITING].left - 4;
@@ -807,31 +975,65 @@
 			y += 10;
 		}
 
-		for (CargoDataList::const_iterator it = cargolist.begin(); it != cargolist.end() && pos > -maxrows; ++it) {
+		for (CargoID c = CT_BEGIN; c != NUM_CARGO && pos > -maxrows; ++c) {
+			if (this->cargo_total[c] == 0) continue;
+
 			if (--pos < 0) {
-				const CargoData *cd = &(*it);
-				if (cd->source == INVALID_STATION) {
-					/* Heading */
-					DrawCargoIcons(cd->cargo, cd->count, x, y, width);
-					SetDParam(0, cd->cargo);
-					SetDParam(1, cd->count);
-					if (HasBit(transfers, cd->cargo)) {
-						/* This cargo has transfers waiting so show the expand or shrink 'button' */
-						const char *sym = HasBit(this->cargo, cd->cargo) ? "-" : "+";
-						DrawStringRightAligned(x + width - 8, y, STR_0009, TC_FROMSTRING);
-						DoDrawString(sym, x + width - 6, y, TC_YELLOW);
-					} else {
-						DrawStringRightAligned(x + width, y, STR_0009, TC_FROMSTRING);
-					}
+				/* Heading */
+				DrawCargoIcons(c, this->cargo_total[c], x, y, width);
+				SetDParam(0, c);
+				SetDParam(1, this->cargo_total[c]);
+
+				if (HasBit(this->cargo_can_expand, c)) {
+					/* This cargo has transfers waiting so show the expand or shrink 'button' */
+					const char *sym = HasBit(this->cargo_expand, c) ? "-" : "+";
+					DrawStringRightAligned(x + width - 8, y, STR_0009, TC_FROMSTRING);
+					DoDrawString(sym, x + width - 6, y, TC_YELLOW);
 				} else {
-					SetDParam(0, cd->cargo);
-					SetDParam(1, cd->count);
-					SetDParam(2, cd->source);
-					DrawStringRightAlignedTruncated(x + width, y, STR_EN_ROUTE_FROM, TC_FROMSTRING, width);
+					DrawStringRightAligned(x + width, y, STR_0009, TC_FROMSTRING);
 				}
 
 				y += 10;
 			}
+
+			for (CargoDataList::const_iterator it = this->cargo_list[c].begin(); it != this->cargo_list[c].end() && pos > -maxrows; ++it) {
+				if (--pos < 0) {
+					const CargoData *cd = &(*it);
+
+					if (cd->source == station_id) {
+						if (this->view == SVM_SOURCE) continue;
+						SetDParam(0, c);
+						SetDParam(1, cd->count);
+						SetDParam(2, cd->target);
+						if (this->view == SVM_TREE) {
+							if (cd->target == INVALID_STATION) {
+								SetDParam(3, cd->final_target);
+								DrawStringTruncated(x, y, STR_ORIGIN_NO_ROUTE, TC_FROMSTRING, width - cd->level * 16);
+							} else if (cd->arrivecount == cd->count) {
+								DrawStringTruncated(x + cd->level * 16, y, STR_ORIGIN_TO, TC_FROMSTRING, width - cd->level * 16);
+							} else if (cd->arrivecount == 0) {
+								DrawStringTruncated(x + cd->level * 16, y, STR_GOING_VIA, TC_FROMSTRING, width - cd->level * 16);
+							} else {
+								SetDParam(3, c);
+								SetDParam(4, cd->count - cd->arrivecount);
+								SetDParam(5, c);
+								SetDParam(6, cd->arrivecount);
+								DrawStringTruncated(x + cd->level * 16, y, STR_ORIGIN_TO_AND_VIA, TC_FROMSTRING, width - cd->level * 16);
+							}
+						} else {
+							DrawStringRightAlignedTruncated(x + width, y, (this->view == SVM_NEXT_HOP) ? STR_GOING_VIA : STR_ORIGIN_TO, TC_FROMSTRING, width);
+						}
+					} else {
+						SetDParam(0, c);
+						SetDParam(1, cd->count);
+						SetDParam(2, cd->source);
+						SetDParam(3, cd->target);
+						DrawStringRightAlignedTruncated(x + width, y, (cd->target == INVALID_STATION || this->view == SVM_SOURCE) ? STR_EN_ROUTE_FROM : STR_EN_ROUTE_FROM_TO, TC_FROMSTRING, width);
+					}
+
+					y += 10;
+				}
+			}
 		}
 
 		if (this->widget[SVW_ACCEPTS].data == STR_3032_RATINGS) { // small window with list of accepted cargo
@@ -891,18 +1093,71 @@
 	{
 		if (row == 0) return;
 
-		for (CargoID c = 0; c < NUM_CARGO; c++) {
-			if (this->cargo_rows[c] == row) {
-				ToggleBit(this->cargo, c);
+		int line = 1;
+		bool scrollto = true;
+		int offset = 0;
+		CargoID type = CT_INVALID;
+		for (CargoID c = CT_BEGIN; c != NUM_CARGO; ++c) {
+			if (this->cargo_total[c] == 0) continue;
+
+			if (line == row) {
+				ToggleBit(this->cargo_expand, c);
+				SetBit(this->cargo_dirty, c);
 				this->InvalidateWidget(SVW_WAITING);
+				scrollto = false;
 				break;
 			}
+
+			if (row > line && static_cast<int>(this->cargo_list[c].size()) >= row - line) {
+				offset = row - line - 1;
+				type = c;
+			}
+
+			line += this->cargo_list[c].size() + 1;
 		}
+
+		if (type != CT_INVALID && scrollto) {
+			CargoDataList::iterator it = this->cargo_list[type].begin();
+			for (; offset > 0; --offset) it++;
+			CargoData *cd = &(*it);
+
+			if (this->view == SVM_SOURCE && IsValidStationID(cd->source)) {
+				if (_ctrl_pressed) {
+					ShowExtraViewPortWindow(GetStation(cd->source)->xy);
+				} else {
+					ScrollMainWindowToTile(GetStation(this->window_number)->xy);
+				}
+			} else if (IsValidStationID(cd->target)) {
+				if (_ctrl_pressed) {
+					ShowExtraViewPortWindow(GetStation(cd->target)->xy);
+				} else {
+					ScrollMainWindowToTile(GetStation(cd->target)->xy);
+				}
+			}
+			return;
+		}
+
 	}
 
 	virtual void OnClick(Point pt, int widget)
 	{
 		switch (widget) {
+			case SVW_SORTBY: // flip sorting method asc/desc
+				this->last_sorting.order = !this->last_sorting.order;
+				this->cargo_resort = true;
+				this->flags4 |= 5;
+				this->LowerWidget(SVW_SORTBY);
+				this->SetDirty();
+				break;
+
+			case SVW_SORTDROPBTN: // select sorting criteria dropdown menu
+				ShowDropDownMenu(this, this->sorter_names, this->last_sorting.criteria, SVW_SORTDROPBTN, 0, 0);
+				break;
+
+			case SVW_VIEW_MODE:
+				ShowDropDownMenu(this, this->view_names, this->view, SVW_VIEW_MODE, 0, 0);
+				break;
+
 			case SVW_WAITING:
 				this->HandleCargoWaitingClick((pt.y - this->widget[SVW_WAITING].top) / 10 + this->vscroll.pos);
 				break;
@@ -968,6 +1223,31 @@
 		}
 	}
 
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		switch (widget) {
+			case SVW_SORTDROPBTN:
+				if (this->last_sorting.criteria != index) {
+					this->last_sorting.criteria = index;
+
+					/* Display the current sort variant */
+					this->widget[SVW_SORTDROPBTN].data = this->sorter_names[this->last_sorting.criteria];
+
+					this->cargo_resort = true;
+					this->SetDirty();
+				} break;
+			case SVW_VIEW_MODE:
+				if (this->view != index) {
+					this->view = static_cast<StationViewMode>(index);
+					this->widget[SVW_VIEW_MODE].data = this->view_names[this->view];
+					this->cargo_dirty = UINT_MAX;
+					this->InvalidateWidget(SVW_SORTDROPBTN);
+					this->InvalidateWidget(SVW_SORTBY);
+					this->InvalidateWidget(SVW_WAITING);
+				} break;
+		}
+	}
+
 	virtual void OnQueryTextFinished(char *str)
 	{
 		if (str == NULL) return;
@@ -980,11 +1260,39 @@
 		if (delta.x != 0) ResizeButtons(this, SVW_LOCATION, SVW_RENAME);
 		this->vscroll.cap += delta.y / (int)this->resize.step_height;
 	}
+
+	virtual void OnInvalidateData(int data = 0)
+	{
+		this->cargo_dirty |= data;
+	}
 };
 
+Listing StationViewWindow::last_sorting = {false, 0};
+
+/* Availible station sorting functions */
+StationViewWindow::SorterFunc *const StationViewWindow::sorter_funcs[] = {
+	&CargoListTargetSorter,
+	&CargoListCountSorter,
+};
+
+/* Names of the sorting functions */
+const StringID StationViewWindow::sorter_names[] = {
+	STR_SORT_BY_CARGO_TARGET,
+	STR_SORT_BY_CARGO_COUNT,
+	INVALID_STRING_ID
+};
+
+const StringID StationViewWindow::view_names[] = {
+	STR_VIEW_MODE_FULL,
+	STR_VIEW_MODE_DESTINATION,
+	STR_VIEW_MODE_NEXTHOP,
+	STR_VIEW_MODE_TREE,
+	STR_VIEW_MODE_SOURCE,
+	INVALID_STRING_ID
+};
 
 static const WindowDesc _station_view_desc = {
-	WDP_AUTO, WDP_AUTO, 249, 110, 249, 110,
+	WDP_AUTO, WDP_AUTO, 349, 122, 349, 122,
 	WC_STATION_VIEW, WC_NONE,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_STICKY_BUTTON | WDF_RESIZABLE,
 	_station_view_widgets,
diff -r cefcfd943f94 src/station_gui.h
--- a/src/station_gui.h	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/station_gui.h	Tue Feb 17 03:31:08 2009 +0100
@@ -9,16 +9,22 @@
 
 /** Enum for StationView, referring to _station_view_widgets and _station_view_expanded_widgets */
 enum StationViewWidgets {
-	SVW_CLOSEBOX   =  0, ///< Close 'X' button
-	SVW_CAPTION    =  1, ///< Caption of the window
-	SVW_WAITING    =  3, ///< List of waiting cargo
-	SVW_ACCEPTLIST =  5, ///< List of accepted cargos
-	SVW_RATINGLIST =  5, ///< Ratings of cargos
-	SVW_LOCATION   =  6, ///< 'Location' button
-	SVW_RATINGS    =  7, ///< 'Ratings' button
-	SVW_ACCEPTS    =  7, ///< 'Accepts' button
-	SVW_RENAME     =  8, ///< 'Rename' button
-	SVW_TRAINS     =  9, ///< List of scheduled trains button
+	SVW_CLOSEBOX,        ///< Close 'X' button
+	SVW_CAPTION,         ///< Caption of the window
+	SVW_STICKY,          ///< Sticky box
+	SVW_SORTBY,          ///< 'Sort by' button - reverse sort direction
+	SVW_SORTDROPBTN,     ///< Dropdown button
+	SVW_VIEW_MODE,       ///< View mode switcher
+	SVW_PAN_SORT_RIGHT,  ///< Panel right of sorting options
+	SVW_WAITING,         ///< List of waiting cargo
+	SVW_WAITING_SCROLLBAR,
+	SVW_ACCEPTLIST,      ///< List of accepted cargos
+	SVW_RATINGLIST = SVW_ACCEPTLIST, ///< Ratings of cargos
+	SVW_LOCATION,        ///< 'Location' button
+	SVW_RATINGS,         ///< 'Ratings' button
+	SVW_ACCEPTS = SVW_RATINGS, ///< 'Accepts' button
+	SVW_RENAME,          ///< 'Rename' button
+	SVW_TRAINS,          ///< List of scheduled trains button
 	SVW_ROADVEHS,        ///< List of scheduled road vehs button
 	SVW_PLANES,          ///< List of scheduled planes button
 	SVW_SHIPS,           ///< List of scheduled ships button
diff -r cefcfd943f94 src/texteff.cpp
--- a/src/texteff.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/texteff.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -84,7 +84,7 @@
 	te->y = y - 5;
 	te->bottom = y + 5;
 	te->params_1 = GetDParam(0);
-	te->params_2 = GetDParam(4);
+	te->params_2 = GetDParam(1);
 	te->mode = mode;
 
 	GetString(buffer, msg, lastof(buffer));
@@ -106,7 +106,7 @@
 	te = &_text_effect_list[te_id];
 	te->string_id = msg;
 	te->params_1 = GetDParam(0);
-	te->params_2 = GetDParam(4);
+	te->params_2 = GetDParam(1);
 
 	/* Update width of text effect */
 	char buffer[100];
diff -r cefcfd943f94 src/train_cmd.cpp
--- a/src/train_cmd.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/train_cmd.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -33,6 +33,7 @@
 #include "effectvehicle_func.h"
 #include "gamelog.h"
 #include "network/network.h"
+#include "routing.h"
 
 #include "table/strings.h"
 #include "table/train_cmd.h"
@@ -1213,6 +1214,9 @@
 			}
 		}
 
+		uint mask_old_removal = 0;
+		if (src_head != NULL) mask_old_removal = src_head->GetCargoForSharedVehicles();
+
 		if (HasBit(p2, 0)) {
 			/* unlink ALL wagons */
 			if (src != src_head) {
@@ -1231,6 +1235,12 @@
 			GetLastEnginePart(src)->SetNext(NULL);
 		}
 
+		uint mask_new_removal = 0;
+		if (src_head != NULL) {
+			mask_new_removal = src_head->GetCargoForSharedVehicles() ^ mask_old_removal;
+			RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListRemoval, src_head->GetFirstOrder(), src->type, mask_new_removal);
+		}
+
 		if (dst == NULL) {
 			/* We make a new line in the depot, so we know already that we invalidate the window data */
 			InvalidateWindowData(WC_VEHICLE_DEPOT, src->tile);
@@ -1255,6 +1265,8 @@
 			}
 			dst_head = src;
 		} else {
+			uint32 mask_old = 0;
+			if (dst_head != NULL) mask_old = dst_head->GetCargoForSharedVehicles();
 			if (IsFrontEngine(src)) {
 				/* the vehicle was previously a loco. need to free the order list and delete vehicle windows etc. */
 				DeleteWindowById(WC_VEHICLE_VIEW, src->index);
@@ -1281,6 +1293,10 @@
 				GetLastEnginePart(v)->SetNext(dst->Next());
 			}
 			dst->SetNext(src);
+			uint32 mask_new = 0;
+			if (dst_head != NULL) mask_new = dst_head->GetCargoForSharedVehicles() ^ mask_old;
+
+			RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListInsertion, dst->First()->GetFirstOrder(), dst->type, mask_new);
 		}
 
 		if (src->u.rail.other_multiheaded_part != NULL) {
@@ -1391,8 +1407,14 @@
 			if (rear != NULL) {
 				cost.AddCost(-rear->value);
 				if (flags & DC_EXEC) {
+					uint32 old_mask = rear->First()->GetCargoForSharedVehicles();
+
 					UnlinkWagon(rear, first);
 					delete rear;
+
+					uint32 new_mask = first->GetCargoForSharedVehicles() ^ old_mask;
+
+					RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListRemoval, first->GetFirstOrder(), first->type, new_mask);
 				}
 			}
 
@@ -1438,7 +1460,18 @@
 			/* 3. Delete the requested wagon */
 			cost.AddCost(-v->value);
 			if (flags & DC_EXEC) {
+				uint32 old_mask = first->GetCargoForSharedVehicles();
+				Vehicle *old_first = first;
+
 				first = UnlinkWagon(v, first);
+
+				uint32 new_mask;
+				if (first != NULL) {
+					new_mask = first->GetCargoForSharedVehicles() ^ old_mask;
+
+					RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListRemoval, old_first->GetFirstOrder(), old_first->type, new_mask);
+				}
+
 				delete v;
 
 				/* 4 If the second wagon was an engine, update it to front_engine
@@ -1452,7 +1485,6 @@
 					UpdateTrainGroupID(first);
 					if (IsFrontEngine(first)) InvalidateWindow(WC_VEHICLE_REFIT, first->index);
 				}
-
 			}
 		} break;
 		case 1: { /* Delete wagon and all wagons after it given certain criteria */
@@ -1491,7 +1523,19 @@
 
 				cost.AddCost(-v->value);
 				if (flags & DC_EXEC) {
+					uint32 old_mask = 0;
+					if (first != NULL) old_mask = first->GetCargoForSharedVehicles();
+					Vehicle *old_first = first;
+
 					first = UnlinkWagon(v, first);
+
+					uint32 new_mask;
+					if (first != NULL && old_first != NULL) {
+						new_mask = first->GetCargoForSharedVehicles() ^ old_mask;
+
+						RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListRemoval, old_first->GetFirstOrder(), old_first->type, new_mask);
+					}
+
 					delete v;
 				}
 			}
@@ -2009,6 +2053,12 @@
 	CommandCost cost(EXPENSES_TRAIN_RUN);
 	uint num = 0;
 
+	uint32 old_mask = 0;
+
+	if (flags & DC_EXEC) {
+		old_mask = GetVehicle(p1)->First()->GetCargoForSharedVehicles();
+	}
+
 	do {
 		/* XXX: We also refit all the attached wagons en-masse if they
 		 * can be refitted. This is how TTDPatch does it.  TODO: Have
@@ -2073,7 +2123,15 @@
 	_returned_refit_capacity = num;
 
 	/* Update the train's cached variables */
-	if (flags & DC_EXEC) TrainConsistChanged(GetVehicle(p1)->First(), false);
+	if (flags & DC_EXEC) {
+		TrainConsistChanged(GetVehicle(p1)->First(), false);
+		uint32 new_mask     = GetVehicle(p1)->First()->GetCargoForSharedVehicles();
+		uint32 changed_mask = new_mask ^ old_mask;
+
+		RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListRemoval,   GetVehicle(p1)->First()->GetFirstOrder(), GetVehicle(p1)->First()->type, old_mask & changed_mask);
+		RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListInsertion, GetVehicle(p1)->First()->GetFirstOrder(), GetVehicle(p1)->First()->type, new_mask & changed_mask);
+	}
+
 
 	return cost;
 }
diff -r cefcfd943f94 src/train_gui.cpp
--- a/src/train_gui.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/train_gui.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -14,10 +14,14 @@
 #include "engine_base.h"
 #include "window_func.h"
 #include "settings_type.h"
+#include "routing.h"
 
 #include "table/sprites.h"
 #include "table/strings.h"
 
+#include <vector>
+#include <map>
+
 void CcBuildWagon(bool success, TileIndex tile, uint32 p1, uint32 p2)
 {
 	if (!success) return;
@@ -151,28 +155,21 @@
 	}
 }
 
+/**
+ * Returns the number of entries we need for the vehicle detail window
+ * so that we can set the scrollbar accordingly. The list can be long since
+ * we list all destinations for every cargo type carried
+ * @see    GetNumberOfDestinationsAndCargoTypes
+ * @param  veh_id The ID of the vehicle we're looking at
+ * @return The total number of entries in the list
+ */
 int GetTrainDetailsWndVScroll(VehicleID veh_id, byte det_tab)
 {
-	AcceptedCargo act_cargo;
-	AcceptedCargo max_cargo;
 	int num = 0;
 
-	if (det_tab == 3) { // Total cargo tab
-		memset(max_cargo, 0, sizeof(max_cargo));
-		memset(act_cargo, 0, sizeof(act_cargo));
-
-		for (const Vehicle *v = GetVehicle(veh_id) ; v != NULL ; v = v->Next()) {
-			act_cargo[v->cargo_type] += v->cargo.Count();
-			max_cargo[v->cargo_type] += v->cargo_cap;
-		}
-
-		/* Set scroll-amount seperately from counting, as to not compute num double
-		 * for more carriages of the same type
-		 */
-		for (CargoID i = 0; i < NUM_CARGO; i++) {
-			if (max_cargo[i] > 0) num++; // only count carriages that the train has
-		}
-		num++; // needs one more because first line is description string
+	if (det_tab == 3) { // Total cargo tab is selected
+		num += 2; // one line for the description, one line for the transfer credits
+		num += RoutingBase::GetNumberOfDestinationsAndCargoTypes(GetVehicle(veh_id));
 	} else {
 		for (const Vehicle *v = GetVehicle(veh_id) ; v != NULL ; v = v->Next()) {
 			if (!IsArticulatedPart(v) || v->cargo_cap != 0) num++;
@@ -228,6 +225,7 @@
 		AcceptedCargo act_cargo;
 		AcceptedCargo max_cargo;
 		Money         feeder_share = 0;
+		RoutingBase::CargoTypesByStationMap cargo_by_destination;
 
 		memset(max_cargo, 0, sizeof(max_cargo));
 		memset(act_cargo, 0, sizeof(act_cargo));
@@ -238,10 +236,14 @@
 			feeder_share             += u->cargo.FeederShare();
 		}
 
+		RoutingBase::GetDestinationsForCargos(v, cargo_by_destination);
+
 		/* draw total cargo tab */
 		DrawString(x, y + 2, STR_TOTAL_CAPACITY_TEXT, TC_FROMSTRING);
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
-			if (max_cargo[i] > 0 && --vscroll_pos < 0 && vscroll_pos > -vscroll_cap) {
+			if (max_cargo[i] == 0) continue;
+
+			if (--vscroll_pos < 0 && vscroll_pos > -vscroll_cap + 1) {
 				y += 14;
 				SetDParam(0, i);            // {CARGO} #1
 				SetDParam(1, act_cargo[i]); // {CARGO} #2
@@ -250,6 +252,16 @@
 				SetDParam(4, _settings_game.vehicle.freight_trains);
 				DrawString(x, y + 2, FreightWagonMult(i) > 1 ? STR_TOTAL_CAPACITY_MULT : STR_TOTAL_CAPACITY, TC_FROMSTRING);
 			}
+
+			for (RoutingBase::CargoByStationMap::const_iterator it = cargo_by_destination[i].begin(); it != cargo_by_destination[i].end(); ++it) {
+				if (--vscroll_pos < 0 && vscroll_pos > -vscroll_cap + 1) {
+					y += 14;
+					SetDParam(0, i);            // {CARGO} #1
+					SetDParam(1, it->second);
+					SetDParam(2, it->first);
+					DrawString(x + 16, y + 2, STR_ORIGIN_TO, TC_FROMSTRING);
+				}
+			}
 		}
 		SetDParam(0, feeder_share);
 		DrawString(x, y + 15, STR_FEEDER_CARGO_VALUE, TC_FROMSTRING);
diff -r cefcfd943f94 src/vehicle.cpp
--- a/src/vehicle.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/vehicle.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -41,6 +41,8 @@
 #include "depot_func.h"
 #include "settings_type.h"
 
+#include "routing.h"
+
 #include "table/sprites.h"
 #include "table/strings.h"
 
@@ -2111,6 +2113,22 @@
 
 }
 
+
+uint32 Vehicle::GetCargoForSharedVehicles() const
+{
+	const Vehicle *v = this->FirstShared();
+	uint32 mask = 0;
+
+	for (; v != NULL; v = v->next_shared) {
+		for (const Vehicle *u = v; u != NULL; u = u->Next()) {
+			if (u->cargo_cap > 0) SetBit(mask, u->cargo_type);
+		}
+	}
+
+	return mask;
+}
+
+
 void Vehicle::SetNext(Vehicle *next)
 {
 	if (this->next != NULL) {
@@ -2133,7 +2151,7 @@
 	}
 }
 
-void Vehicle::AddToShared(Vehicle *shared_chain)
+void Vehicle::AddToShared(Vehicle *shared_chain, bool no_cargodest)
 {
 	assert(this->previous_shared == NULL && this->next_shared == NULL);
 
@@ -2143,11 +2161,16 @@
 		this->orders.list = shared_chain->orders.list = new OrderList(NULL, shared_chain);
 	}
 
+	uint32 mask_old       = shared_chain->GetCargoForSharedVehicles();
 	this->next_shared     = shared_chain->next_shared;
 	this->previous_shared = shared_chain;
 
 	shared_chain->next_shared = this;
 
+	uint32 mask_new = shared_chain->GetCargoForSharedVehicles() ^ mask_old;
+
+	if (!no_cargodest) RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListInsertion, shared_chain->GetFirstOrder(), shared_chain->type, mask_new);
+
 	if (this->next_shared != NULL) this->next_shared->previous_shared = this;
 
 	shared_chain->orders.list->AddVehicle(this);
@@ -2155,6 +2178,8 @@
 
 void Vehicle::RemoveFromShared()
 {
+	uint32 mask_old = this->GetCargoForSharedVehicles();
+
 	/* Remember if we were first and the old window number before RemoveVehicle()
 	 * as this changes first if needed. */
 	bool were_first = (this->FirstShared() == this);
@@ -2180,6 +2205,12 @@
 		InvalidateWindowData(GetWindowClassForVehicleType(this->type), old_window_number, (this->FirstShared()->index << 16) | (1 << 15));
 	}
 
+	Vehicle *new_first = this->FirstShared();
+
+	uint32 mask_new = new_first->GetCargoForSharedVehicles() ^ mask_old;
+
+	RoutingBase::ProcessOrder(&RoutingBase::ProcessOrderListRemoval, new_first->GetFirstOrder(), new_first->type, mask_new);
+
 	this->next_shared     = NULL;
 	this->previous_shared = NULL;
 }
diff -r cefcfd943f94 src/vehicle_base.h
--- a/src/vehicle_base.h	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/vehicle_base.h	Tue Feb 17 03:31:08 2009 +0100
@@ -194,6 +194,7 @@
 /* Some declarations of functions, so we can make them friendly */
 struct SaveLoad;
 extern const SaveLoad *GetVehicleDescription(VehicleType vt);
+extern void AfterLoadVehicles(bool part_of_load);
 struct LoadgameState;
 extern bool LoadOldVehicle(LoadgameState *ls, int num);
 
@@ -490,9 +491,11 @@
 	/**
 	 * Adds this vehicle to a shared vehicle chain.
 	 * @param shared_chain a vehicle of the chain with shared vehicles.
+	 *  @param no_cargodest If set to true the cargodest routing network is not updated (used during
+	 *    loading of games where the routing network is not yet initialized).
 	 * @pre !this->IsOrderListShared()
 	 */
-	void AddToShared(Vehicle *shared_chain);
+	void AddToShared(Vehicle *shared_chain, bool no_cargodest = false);
 
 	/**
 	 * Removes the vehicle from the shared order list.
@@ -595,6 +598,13 @@
 	 * @return the cost of the depot action.
 	 */
 	CommandCost SendToDepot(DoCommandFlag flags, DepotCommand command);
+
+	/**
+	 * Finds what cargo is transported in a list of
+	 * shared vehicles
+	 * @return  A bit mask of transported cargo types
+	 */
+	uint32 GetCargoForSharedVehicles() const;
 };
 
 /**
diff -r cefcfd943f94 src/vehicle_gui.cpp
--- a/src/vehicle_gui.cpp	Tue Feb 17 00:30:59 2009 +0000
+++ b/src/vehicle_gui.cpp	Tue Feb 17 03:31:08 2009 +0100
@@ -1231,7 +1231,7 @@
 	{ WWT_PUSHTXTBTN,     RESIZE_TB,  COLOUR_GREY,  96, 194, 113, 124, STR_013D_INFORMATION, STR_8850_SHOW_DETAILS_OF_TRAIN_VEHICLES},// VLD_WIDGET_DETAILS_TRAIN_VEHICLES
 	{ WWT_PUSHTXTBTN,     RESIZE_TB,  COLOUR_GREY, 195, 293, 113, 124, STR_013E_CAPACITIES,  STR_8851_SHOW_CAPACITIES_OF_EACH},       // VLD_WIDGET_DETAILS_CAPACITY_OF_EACH
 	{ WWT_PUSHTXTBTN,    RESIZE_RTB,  COLOUR_GREY, 294, 392, 113, 124, STR_TOTAL_CARGO,      STR_SHOW_TOTAL_CARGO},                   // VLD_WIDGET_DETAILS_TOTAL_CARGO
-	{  WWT_RESIZEBOX,   RESIZE_LRTB,  COLOUR_GREY, 393, 404, 113, 124, 0x0,                  STR_RESIZE_BUTTON},                      // VLD_RESIZE
+	{  WWT_RESIZEBOX,   RESIZE_LRTB,  COLOUR_GREY, 393, 404, 113, 124, 0x0,                  STR_RESIZE_BUTTON},                      // VLD_WIDGET_RESIZE
 	{   WIDGETS_END},
 };
 
@@ -1274,10 +1274,13 @@
 
 
 extern int GetTrainDetailsWndVScroll(VehicleID veh_id, byte det_tab);
+extern int GetRoadVehDetailsWndVScroll(VehicleID veh_id);
+extern int GetAircraftDetailsWndVScroll(VehicleID veh_id);
+extern int GetShipDetailsWndVScroll(VehicleID veh_id);
 extern void DrawTrainDetails(const Vehicle *v, int x, int y, int vscroll_pos, uint16 vscroll_cap, byte det_tab);
-extern void DrawRoadVehDetails(const Vehicle *v, int x, int y);
-extern void DrawShipDetails(const Vehicle *v, int x, int y);
-extern void DrawAircraftDetails(const Vehicle *v, int x, int y);
+extern void DrawRoadVehDetails(const Vehicle *v, int x, int y, int vscroll_pos, uint16 vscroll_cap);
+extern void DrawShipDetails(const Vehicle *v, int x, int y, int vscroll_pos, uint16 vscroll_cap);
+extern void DrawAircraftDetails(const Vehicle *v, int x, int y, int vscroll_pos, uint16 vscroll_cap);
 
 struct VehicleDetailsWindow : Window {
 	int tab;
@@ -1304,38 +1307,63 @@
 				this->widget[VLD_WIDGET_CAPTION].data = STR_900C_DETAILS;
 				this->widget[VLD_WIDGET_RENAME_VEHICLE].tooltips = STR_902E_NAME_ROAD_VEHICLE;
 
+				/* Reposition the resize box */
+				this->widget[VLD_WIDGET_BOTTOM_RIGHT].right -= 12;
+				this->widget[VLD_WIDGET_RESIZE].top         -= 12;
+				this->widget[VLD_WIDGET_RESIZE].bottom      -= 12;
+
+				ResizeWindow(this, 0, 25);
+				this->vscroll.cap = 5;
+				this->resize.height = this->height - 14 * 2;
+				this->resize.step_height = 14;
+
 				if (!RoadVehHasArticPart(v)) break;
 
 				/* Draw the text under the vehicle instead of next to it, minus the
 				 * height already allocated for the cargo of the first vehicle. */
-				uint height_extension = 15 - 11;
+				uint height_extension = 0; //15 - 11;
 
 				/* Add space for the cargo amount for each part. */
 				for (const Vehicle *u = v; u != NULL; u = u->Next()) {
-					if (u->cargo_cap != 0) height_extension += 11;
+					if (u->cargo_cap != 0) height_extension += 14;
+					this->vscroll.cap++;
 				}
 
 				ResizeWindow(this, 0, height_extension);
 			} break;
 
 			case VEH_SHIP:
+				/* Reposition the resize box */
+				this->widget[VLD_WIDGET_BOTTOM_RIGHT].right -= 12;
+				this->widget[VLD_WIDGET_RESIZE].top         -= 12;
+				this->widget[VLD_WIDGET_RESIZE].bottom      -= 12;
+
+				ResizeWindow(this, 0, 25);
+				this->vscroll.cap = 5;
+				this->resize.height = this->height - 14 * 2;
+				this->resize.step_height = 14;
+
 				this->widget[VLD_WIDGET_RENAME_VEHICLE].tooltips = STR_982F_NAME_SHIP;
 				this->widget[VLD_WIDGET_CAPTION].data = STR_9811_DETAILS;
 				break;
 
 			case VEH_AIRCRAFT:
-				ResizeWindow(this, 0, 11);
+				/* Reposition the resize box */
+				this->widget[VLD_WIDGET_BOTTOM_RIGHT].right -= 12;
+				this->widget[VLD_WIDGET_RESIZE].top         -= 12;
+				this->widget[VLD_WIDGET_RESIZE].bottom      -= 12;
+
+				ResizeWindow(this, 0, 25);
+				this->vscroll.cap = 5;
+				this->resize.height = this->height - 14 * 2;
+				this->resize.step_height = 14;
+
 				this->widget[VLD_WIDGET_RENAME_VEHICLE].tooltips = STR_A032_NAME_AIRCRAFT;
 				this->widget[VLD_WIDGET_CAPTION].data = STR_A00C_DETAILS;
 				break;
 			default: NOT_REACHED();
 		}
 
-		if (v->type != VEH_TRAIN) {
-			this->vscroll.cap = 1;
-			this->widget[VLD_WIDGET_MIDDLE_DETAILS].right += 12;
-		}
-
 		this->widget[VLD_WIDGET_MIDDLE_DETAILS].data = (this->vscroll.cap << 8) + 1;
 		this->owner = v->owner;
 
@@ -1363,17 +1391,17 @@
 	 * @param v current vehicle
 	 * @param x The x coordinate
 	 * @param y The y coordinate
-	 * @param vscroll_pos (train only)
-	 * @param vscroll_cap (train only)
+	 * @param vscroll_pos Position of the scrollbar
+	 * @param vscroll_cap Number of "items" in the scrollbar
 	 * @param det_tab (train only)
 	 */
 	static void DrawVehicleDetails(const Vehicle *v, int x, int y, int vscroll_pos, uint vscroll_cap, byte det_tab)
 	{
 		switch (v->type) {
 			case VEH_TRAIN:    DrawTrainDetails(v, x, y, vscroll_pos, vscroll_cap, det_tab);  break;
-			case VEH_ROAD:     DrawRoadVehDetails(v, x, y);  break;
-			case VEH_SHIP:     DrawShipDetails(v, x, y);     break;
-			case VEH_AIRCRAFT: DrawAircraftDetails(v, x, y); break;
+			case VEH_ROAD:     DrawRoadVehDetails(v, x, y, vscroll_pos, vscroll_cap);         break;
+			case VEH_SHIP:     DrawShipDetails(v, x, y, vscroll_pos, vscroll_cap);            break;
+			case VEH_AIRCRAFT: DrawAircraftDetails(v, x, y, vscroll_pos, vscroll_cap);        break;
 			default: NOT_REACHED();
 		}
 	}
@@ -1391,13 +1419,15 @@
 			SetVScrollCount(this, GetTrainDetailsWndVScroll(v->index, det_tab));
 		}
 
+		if (v->type == VEH_ROAD)     SetVScrollCount(this, GetRoadVehDetailsWndVScroll(v->index));
+		if (v->type == VEH_AIRCRAFT) SetVScrollCount(this, GetAircraftDetailsWndVScroll(v->index));
+		if (v->type == VEH_SHIP)     SetVScrollCount(this, GetShipDetailsWndVScroll(v->index));
+
 		this->SetWidgetsHiddenState(v->type != VEH_TRAIN,
-			VLD_WIDGET_SCROLLBAR,
 			VLD_WIDGET_DETAILS_CARGO_CARRIED,
 			VLD_WIDGET_DETAILS_TRAIN_VEHICLES,
 			VLD_WIDGET_DETAILS_CAPACITY_OF_EACH,
 			VLD_WIDGET_DETAILS_TOTAL_CARGO,
-			VLD_WIDGET_RESIZE,
 			WIDGET_LIST_END);
 
 		/* Disable service-scroller when interval is set to disabled */
