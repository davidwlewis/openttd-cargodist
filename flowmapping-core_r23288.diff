diff --git a/docs/linkgraph.txt b/docs/linkgraph.txt
new file mode 100644
index 0000000..ddb125a
--- /dev/null
+++ b/docs/linkgraph.txt
@@ -0,0 +1,30 @@
+Some clarifications about the link graph
+----------------------------------------
+
+InitializeLinkGraphs joins all threads, so if the game is abendoned
+with some threads still running, they're joined as soon as the next game
+(possibly the title game) is started. see also InitializeGame.
+
+The MCF algorithm can be quite CPU-hungry as it's NP-hard and takes
+exponential time (though with a very small constant factor) in the number
+of nodes.
+This is why it is run in a separate thread where possible. However after
+some time the thread is joined and if it hasn't finished by then the game
+will hang. This problem gets worse if we are running on a platform without
+threads. However, as those are usually the ones with less CPU power I
+assume the contention for the CPU would make the game hard to play even
+with threads or even without cargodist (autosave ...). I might be wrong,
+but I won't put any work into this before someone shows me some problem.
+
+You can configure the link graph recalculation interval. A link graph
+recalculation interval of X days means that each link graph job has X days
+to run before it is joined. The downside is that the flow stats won't be
+updated before the job is finished and thus a long interval means less
+updates and longer times until changes in capacities are accounted for.
+If you play a very large map with a complicated link graph you may want to
+raise the interval to avoid lags. The same holds for systems with slow
+CPUs.
+
+Another option to avoid excessive lags is to reduce the accuracy of link
+graph calculations. Generally the accurace is inversely correlated to the
+CPU requirements of the MCF algorithm.
diff --git a/projects/openttd_vs100.vcxproj b/projects/openttd_vs100.vcxproj
index 8731a07..e3165a6 100644
--- a/projects/openttd_vs100.vcxproj
+++ b/projects/openttd_vs100.vcxproj
@@ -327,6 +327,10 @@
     <ClCompile Include="..\src\ini.cpp" />
     <ClCompile Include="..\src\ini_load.cpp" />
     <ClCompile Include="..\src\landscape.cpp" />
+    <ClCompile Include="..\src\linkgraph\demands.cpp" />
+    <ClCompile Include="..\src\linkgraph\flowmapper.cpp" />
+    <ClCompile Include="..\src\linkgraph\linkgraph.cpp" />
+    <ClCompile Include="..\src\linkgraph\mcf.cpp" />
     <ClCompile Include="..\src\map.cpp" />
     <ClCompile Include="..\src\misc.cpp" />
     <ClCompile Include="..\src\mixer.cpp" />
@@ -456,10 +460,17 @@
     <ClInclude Include="..\src\landscape.h" />
     <ClInclude Include="..\src\landscape_type.h" />
     <ClInclude Include="..\src\language.h" />
+    <ClInclude Include="..\src\linkgraph\demands.h" />
+    <ClInclude Include="..\src\linkgraph\flowmapper.h" />
+    <ClInclude Include="..\src\linkgraph\linkgraph.h" />
+    <ClInclude Include="..\src\linkgraph\linkgraph_type.h" />
+    <ClInclude Include="..\src\linkgraph\mcf.h" />
     <ClInclude Include="..\src\livery.h" />
     <ClInclude Include="..\src\map_func.h" />
     <ClInclude Include="..\src\map_type.h" />
     <ClInclude Include="..\src\mixer.h" />
+    <ClInclude Include="..\src\moving_average.h" />
+    <ClCompile Include="..\src\moving_average.cpp" />
     <ClInclude Include="..\src\network\network.h" />
     <ClInclude Include="..\src\network\network_admin.h" />
     <ClInclude Include="..\src\network\network_base.h" />
@@ -729,6 +740,7 @@
     <ClCompile Include="..\src\saveload\group_sl.cpp" />
     <ClCompile Include="..\src\saveload\industry_sl.cpp" />
     <ClCompile Include="..\src\saveload\labelmaps_sl.cpp" />
+    <ClCompile Include="..\src\saveload\linkgraph_sl.cpp" />
     <ClCompile Include="..\src\saveload\map_sl.cpp" />
     <ClCompile Include="..\src\saveload\misc_sl.cpp" />
     <ClCompile Include="..\src\saveload\newgrf_sl.cpp" />
diff --git a/projects/openttd_vs100.vcxproj.filters b/projects/openttd_vs100.vcxproj.filters
index 19200a0..62f017d 100644
--- a/projects/openttd_vs100.vcxproj.filters
+++ b/projects/openttd_vs100.vcxproj.filters
@@ -201,6 +201,18 @@
     <ClCompile Include="..\src\landscape.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\linkgraph\demands.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\linkgraph\flowmapper.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\linkgraph\linkgraph.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\linkgraph\mcf.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -588,6 +600,21 @@
     <ClInclude Include="..\src\language.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\linkgraph\demands.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\flowmapper.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\linkgraph.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\linkgraph_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\mcf.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\livery.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -600,6 +627,12 @@
     <ClInclude Include="..\src\mixer.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\moving_average.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClCompile Include="..\src\moving_average.cpp">
+      <Filter>Header Files</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\network\network.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -1407,6 +1440,9 @@
     <ClCompile Include="..\src\saveload\labelmaps_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\saveload\linkgraph_sl.cpp">
+      <Filter>Save/Load handlers</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\saveload\map_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
diff --git a/projects/openttd_vs80.vcproj b/projects/openttd_vs80.vcproj
index f12f562..58e2c50 100644
--- a/projects/openttd_vs80.vcproj
+++ b/projects/openttd_vs80.vcproj
@@ -579,6 +579,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1099,6 +1115,26 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -1115,6 +1151,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -2211,6 +2255,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
diff --git a/projects/openttd_vs90.vcproj b/projects/openttd_vs90.vcproj
index 082206a..1a40f7c 100644
--- a/projects/openttd_vs90.vcproj
+++ b/projects/openttd_vs90.vcproj
@@ -576,6 +576,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1096,6 +1112,26 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -1112,6 +1148,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -2208,6 +2252,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
diff --git a/source.list b/source.list
index 7c63b52..8ca3342 100644
--- a/source.list
+++ b/source.list
@@ -35,6 +35,10 @@ hotkeys.cpp
 ini.cpp
 ini_load.cpp
 landscape.cpp
+linkgraph/demands.cpp
+linkgraph/flowmapper.cpp
+linkgraph/linkgraph.cpp
+linkgraph/mcf.cpp
 map.cpp
 misc.cpp
 mixer.cpp
@@ -189,10 +193,17 @@ ini_type.h
 landscape.h
 landscape_type.h
 language.h
+linkgraph/demands.h
+linkgraph/flowmapper.h
+linkgraph/linkgraph.h
+linkgraph/linkgraph_type.h
+linkgraph/mcf.h
 livery.h
 map_func.h
 map_type.h
 mixer.h
+moving_average.h
+moving_average.cpp
 network/network.h
 network/network_admin.h
 network/network_base.h
@@ -487,6 +498,7 @@ saveload/gamelog_sl.cpp
 saveload/group_sl.cpp
 saveload/industry_sl.cpp
 saveload/labelmaps_sl.cpp
+saveload/linkgraph_sl.cpp
 saveload/map_sl.cpp
 saveload/misc_sl.cpp
 saveload/newgrf_sl.cpp
diff --git a/src/aircraft_cmd.cpp b/src/aircraft_cmd.cpp
index 861a88a..e0a2053 100644
--- a/src/aircraft_cmd.cpp
+++ b/src/aircraft_cmd.cpp
@@ -267,6 +267,7 @@ CommandCost CmdBuildAircraft(TileIndex tile, DoCommandFlag flags, const Engine *
 
 		v->name = NULL;
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 
 		v->acceleration = avi->acceleration;
 		v->engine_type = e->index;
diff --git a/src/core/math_func.cpp b/src/core/math_func.cpp
index 7f0630a..bcddbfa 100644
--- a/src/core/math_func.cpp
+++ b/src/core/math_func.cpp
@@ -46,3 +46,24 @@ int GreatestCommonDivisor(int a, int b)
 	return a;
 
 }
+
+/**
+ * Deterministic approximate division.
+ * Cancels out division errors stemming from the integer nature of the division over multiple runs.
+ * @param a Dividend.
+ * @param b Divisor.
+ * @return a/b or (a/b)+1.
+ */
+int DivideApprox(int a, int b)
+{
+	int random_like = ((a + b) * (a - b)) % b;
+
+	int remainder = a % b;
+
+	int ret = a / b;
+	if (abs(random_like) < abs(remainder)) {
+		ret += ((a < 0) ^ (b < 0)) ? -1 : 1;
+	}
+
+	return ret;
+}
diff --git a/src/core/math_func.hpp b/src/core/math_func.hpp
index 19f2f53..a824af3 100644
--- a/src/core/math_func.hpp
+++ b/src/core/math_func.hpp
@@ -317,6 +317,7 @@ static FORCEINLINE uint ToPercent16(uint i)
 
 int LeastCommonMultiple(int a, int b);
 int GreatestCommonDivisor(int a, int b);
+int DivideApprox(int a, int b);
 
 /**
  * Computes ceil(a / b) for non-negative a and b.
diff --git a/src/economy.cpp b/src/economy.cpp
index 9a6dea2..920f0d9 100644
--- a/src/economy.cpp
+++ b/src/economy.cpp
@@ -1474,6 +1474,9 @@ static void LoadUnloadVehicle(Vehicle *front, int *cargo_left)
 			} else if (cargo_not_full != 0) {
 				finished_loading = false;
 			}
+
+			/* Refresh next hop stats if we're full loading to avoid deadlocks. */
+			if (!finished_loading) front->RefreshNextHopsStats();
 		}
 		unloading_time = 20;
 
diff --git a/src/landscape.cpp b/src/landscape.cpp
index deff47b..a388d94 100644
--- a/src/landscape.cpp
+++ b/src/landscape.cpp
@@ -1285,6 +1285,7 @@ void OnTick_Station();
 void OnTick_Industry();
 
 void OnTick_Companies();
+void OnTick_LinkGraph();
 
 void CallLandscapeTick()
 {
@@ -1294,4 +1295,5 @@ void CallLandscapeTick()
 	OnTick_Industry();
 
 	OnTick_Companies();
+	OnTick_LinkGraph();
 }
diff --git a/src/lang/english.txt b/src/lang/english.txt
index 119535d..f1bd99b 100644
--- a/src/lang/english.txt
+++ b/src/lang/english.txt
@@ -1331,11 +1331,25 @@ STR_CONFIG_SETTING_LARGER_TOWNS_DISABLED                        :{LTBLUE}Proport
 STR_CONFIG_SETTING_CITY_SIZE_MULTIPLIER                         :{LTBLUE}Initial city size multiplier: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD                        :{LTBLUE}Remove absurd road-elements during the road construction: {ORANGE}{STRING1}
 
+STR_CONFIG_SETTING_LINKGRAPH_INTERVAL                           :{LTBLUE}Link graph recalculation interval: {ORANGE}{STRING1} days
+STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC                       :symmetric
+STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC                      :asymmetric
+STR_CONFIG_SETTING_DISTRIBUTION_MANUAL                          :manual
+STR_CONFIG_SETTING_DISTRIBUTION_PAX                             :{LTBLUE}Distribution for passengers: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_MAIL                            :{LTBLUE}Distribution for mail: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED                        :{LTBLUE}Distribution for the ARMOURED cargo class: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT                         :{LTBLUE}Distribution for other cargo classes: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_LINKGRAPH_ACCURACY                           :{LTBLUE}Accuracy when calculating things on the link graph: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_DISTANCE                              :{LTBLUE}Effect of distance on demands: {ORANGE}{STRING1}%
+STR_CONFIG_SETTING_DEMAND_SIZE                                  :{LTBLUE}Effect of remote station's popularity on symmetric demands: {ORANGE}{STRING1}%
+STR_CONFIG_SETTING_SHORT_PATH_SATURATION                        :{LTBLUE}Saturation of short paths before using capacious paths: {ORANGE}{STRING1}%
+
 STR_CONFIG_SETTING_GUI                                          :{ORANGE}Interface
 STR_CONFIG_SETTING_CONSTRUCTION                                 :{ORANGE}Construction
 STR_CONFIG_SETTING_VEHICLES                                     :{ORANGE}Vehicles
 STR_CONFIG_SETTING_STATIONS                                     :{ORANGE}Stations
 STR_CONFIG_SETTING_ECONOMY                                      :{ORANGE}Economy
+STR_CONFIG_SETTING_LINKGRAPH                                    :{ORANGE}Link graph
 STR_CONFIG_SETTING_AI                                           :{ORANGE}Competitors
 STR_CONFIG_SETTING_DISPLAY_OPTIONS                              :{ORANGE}Display options
 STR_CONFIG_SETTING_INTERACTION                                  :{ORANGE}Interaction
diff --git a/src/linkgraph/demands.cpp b/src/linkgraph/demands.cpp
new file mode 100644
index 0000000..93f6941
--- /dev/null
+++ b/src/linkgraph/demands.cpp
@@ -0,0 +1,184 @@
+/** @file demands.h Definition of demand calculating link graph handler. */
+
+#include "../stdafx.h"
+#include "../station_base.h"
+#include "../settings_type.h"
+#include "../newgrf_cargo.h"
+#include "../cargotype.h"
+#include "../core/math_func.hpp"
+#include "demands.h"
+#include <list>
+
+typedef std::list<NodeID> NodeList;
+
+/**
+ * Set the demands between two nodes using the given base demand. In symmetric mode
+ * this sets demands in both directions.
+ * @param graph The link graph.
+ * @param from_id The supplying node.
+ * @þaram to_id The receiving node.
+ * @param demand_forw Demand calculated for the "forward" direction.
+ */
+void SymmetricScaler::SetDemands(LinkGraphComponent *graph, NodeID from_id, NodeID to_id, uint demand_forw)
+{
+	if (graph->GetNode(from_id).demand > 0) {
+		uint demand_back = demand_forw * this->mod_size / 100;
+		uint undelivered = graph->GetNode(to_id).undelivered_supply;
+		if (demand_back > undelivered) {
+			demand_back = undelivered;
+			demand_forw = max(1U, demand_back * 100 / this->mod_size);
+		}
+		this->Scaler::SetDemands(graph, to_id, from_id, demand_back);
+	}
+
+	this->Scaler::SetDemands(graph, from_id, to_id, demand_forw);
+}
+
+/**
+ * Set the demands between two nodes using the given base demand. In asymmetric mode
+ * this only sets demand in the "forward" direction.
+ * @param graph The link graph.
+ * @param from_id The supplying node.
+ * @þaram to_id The receiving node.
+ * @param demand_forw Demand calculated for the "forward" direction.
+ */
+FORCEINLINE void Scaler::SetDemands(LinkGraphComponent *graph, NodeID from_id, NodeID to_id, uint demand_forw)
+{
+	Edge &forward = graph->GetEdge(from_id, to_id);
+	forward.demand += demand_forw;
+	forward.unsatisfied_demand += demand_forw;
+	graph->GetNode(from_id).undelivered_supply -= demand_forw;
+}
+
+/**
+ * Do the actual demand calculation, called from constructor.
+ * @param graph Component to calculate the demands for.
+ */
+template<class Tscaler>
+void DemandCalculator::CalcDemand(LinkGraphComponent *graph, Tscaler scaler)
+{
+	NodeList supplies;
+	NodeList demands;
+	uint num_supplies = 0;
+	uint num_demands = 0;
+
+	for (NodeID node = 0; node < graph->GetSize(); node++) {
+		Node &n = graph->GetNode(node);
+		scaler.AddNode(n);
+		if (n.supply > 0) {
+			supplies.push_back(node);
+			num_supplies++;
+		}
+		if (n.demand > 0) {
+			demands.push_back(node);
+			num_demands++;
+		}
+	}
+
+	if (num_supplies == 0 || num_demands == 0) return;
+
+	/* mean acceptance attributed to each node. If the distribution is
+	 * symmetric this is relative to remote supply, otherwise it is
+	 * relative to remote demand.
+	 */
+	scaler.SetDemandPerNode(num_demands);
+	uint chance = 0;
+
+	while (!supplies.empty() && !demands.empty()) {
+		NodeID node1 = supplies.front();
+		supplies.pop_front();
+
+		Node &from = graph->GetNode(node1);
+
+		for (uint i = 0; i < num_demands; ++i) {
+			assert(!demands.empty());
+			NodeID node2 = demands.front();
+			demands.pop_front();
+			if (node1 == node2) {
+				if (demands.empty() && supplies.empty()) {
+					/* only one node with supply and demand left */
+					return;
+				} else {
+					demands.push_back(node2);
+					continue;
+				}
+			}
+			Node &to = graph->GetNode(node2);
+
+			int32 supply = scaler.EffectiveSupply(from, to);
+			assert(supply > 0);
+
+			/* scale the distance by mod_dist around max_distance */
+			int32 distance = this->max_distance - (this->max_distance -
+					(int32)graph->GetEdge(node1, node2).distance) * this->mod_dist / 100;
+
+			/* scale the accuracy by distance around accuracy / 2 */
+			int32 divisor = this->accuracy * (this->mod_dist - 50) / 100 +
+					this->accuracy * distance / this->max_distance + 1;
+
+			assert(divisor > 0);
+
+			uint demand_forw = 0;
+			if (divisor <= supply) {
+				/* at first only distribute demand if
+				 * effective supply / accuracy divisor >= 1
+				 * Others are too small or too far away to be considered.
+				 */
+				demand_forw = supply / divisor;
+			} else if (++chance > this->accuracy * num_demands * num_supplies) {
+				/* After some trying, if there is still supply left, distribute
+				 * demand also to other nodes.
+				 */
+				demand_forw = 1;
+			}
+
+			demand_forw = min(demand_forw, from.undelivered_supply);
+
+			scaler.SetDemands(graph, node1, node2, demand_forw);
+
+			if (scaler.DemandLeft(to)) {
+				demands.push_back(node2);
+			} else {
+				num_demands--;
+			}
+
+			if (from.undelivered_supply == 0) break;
+
+		}
+		if (from.undelivered_supply != 0) {
+			supplies.push_back(node1);
+		} else {
+			num_supplies--;
+		}
+	}
+}
+
+/**
+ * Create the DemandCalculator and immediately do the calculation.
+ * @param graph Component to calculate the demands for.
+ */
+DemandCalculator::DemandCalculator(LinkGraphComponent *graph) :
+	max_distance(MapSizeX() + MapSizeY() + 1)
+{
+	CargoID cargo = graph->GetCargo();
+	const LinkGraphSettings &settings = graph->GetSettings();
+
+	this->accuracy = settings.accuracy;
+	this->mod_dist = settings.demand_distance;
+	if (this->mod_dist > 100) {
+		/* increase effect of mod_dist > 100 */
+		int over100 = this->mod_dist - 100;
+		this->mod_dist = 100 + over100 * over100;
+	}
+
+	switch (settings.GetDistributionType(cargo)) {
+		case DT_SYMMETRIC:
+			this->CalcDemand<SymmetricScaler>(graph, SymmetricScaler(settings.demand_size));
+			break;
+		case DT_ASYMMETRIC:
+			this->CalcDemand<AsymmetricScaler>(graph, AsymmetricScaler());
+			break;
+		default:
+			NOT_REACHED();
+	}
+}
diff --git a/src/linkgraph/demands.h b/src/linkgraph/demands.h
new file mode 100644
index 0000000..009019c
--- /dev/null
+++ b/src/linkgraph/demands.h
@@ -0,0 +1,159 @@
+/** @file demands.h Declaration of demand calculating link graph handler. */
+
+#ifndef DEMANDS_H_
+#define DEMANDS_H_
+
+#include "linkgraph.h"
+#include "../cargo_type.h"
+#include "../map_func.h"
+
+/**
+ * Scale various things according to symmetric/asymmetric distribution.
+ */
+class Scaler {
+public:
+	Scaler() : demand_per_node(0) {}
+
+	void SetDemands(LinkGraphComponent * graph, NodeID from, NodeID to, uint demand_forw);
+protected:
+	uint demand_per_node; ///< Mean demand associated with each node.
+};
+
+/**
+ * Scaler for symmetric distribution.
+ */
+class SymmetricScaler : public Scaler {
+public:
+	FORCEINLINE SymmetricScaler(uint mod_size) : mod_size(mod_size), supply_sum(0) {}
+
+	/**
+	 * Count a node's supply into the sum of supplies.
+	 * @param node Node.
+	 */
+	FORCEINLINE void AddNode(const Node &node)
+	{
+		this->supply_sum += node.supply;
+	}
+
+	/**
+	 * Calculate the mean demand per node using the sum of supplies.
+	 * @param num_demands Number of accepting nodes.
+	 */
+	FORCEINLINE void SetDemandPerNode(uint num_demands)
+	{
+		this->demand_per_node = max(this->supply_sum / num_demands, 1U);
+	}
+
+	/**
+	 * Get the effective supply of one node towards another one. In symmetric
+	 * distribution the supply of the other node is weighed in.
+	 * @param from The supplying node.
+	 * @param to The receiving node.
+	 * @return Effective supply.
+	 */
+	FORCEINLINE uint EffectiveSupply(const Node &from, const Node &to)
+	{
+		return max(from.supply * max(1U, to.supply) * this->mod_size / 100 / this->demand_per_node, 1U);
+	}
+
+	/**
+	 * Check if there is any acceptance left for this node. In symmetric distribution
+	 * nodes only accept anything if they also supply something. So if
+	 * undelivered_supply == 0 at the node there isn't any demand left either.
+	 * @param to The node to be checked.
+	 */
+	FORCEINLINE bool DemandLeft(Node &to)
+	{
+		return (to.supply == 0 || to.undelivered_supply > 0) && to.demand > 0;
+	}
+
+	void SetDemands(LinkGraphComponent *graph, NodeID from, NodeID to, uint demand_forw);
+
+private:
+	uint mod_size;   ///< Size modifier. Determines how much demands increase with the supply of the remote station
+	uint supply_sum; ///< Sum of all supplies in the component.
+};
+
+/**
+ * A scaler for asymmetric distribution.
+ */
+class AsymmetricScaler : public Scaler {
+public:
+	AsymmetricScaler() : demand_sum(0) {}
+
+	/**
+	 * Count a node's demand into the sum of demands.
+	 * @param node The node to be counted.
+	 */
+	FORCEINLINE void AddNode(const Node &node)
+	{
+		this->demand_sum += node.demand;
+	}
+
+	/**
+	 * Calculate the mean demand per node using the sum of demands.
+	 * @param num_demands Number of accepting nodes.
+	 */
+	FORCEINLINE void SetDemandPerNode(uint num_demands)
+	{
+		this->demand_per_node = max(this->demand_sum / num_demands, (uint)1);
+	}
+
+	/**
+	 * Get the effective supply of one node towards another one. In asymmetric
+	 * distribution the demand of the other node is weighed in.
+	 * @param from The supplying node.
+	 * @param to The receiving node.
+	 */
+	FORCEINLINE uint EffectiveSupply(const Node &from, const Node &to)
+	{
+		return max(from.supply * to.demand / this->demand_per_node, (uint)1);
+	}
+
+	/**
+	 * Check if there is any acceptance left for this node. In asymmetric distribution
+	 * nodes always accept as long as their demand > 0.
+	 * @param to The node to be checked.
+	 */
+	FORCEINLINE bool DemandLeft(Node &to) { return to.demand > 0; }
+
+private:
+	uint demand_sum; ///< Sum of all demands in the component.
+};
+
+/**
+ * Calculate the demands. This class has a state, but is recreated for each
+ * call to of DemandHandler::Run.
+ */
+class DemandCalculator {
+public:
+	DemandCalculator(LinkGraphComponent *graph);
+
+private:
+	int32 max_distance; ///< Maximum distance possible on the map.
+	int32 mod_dist;     ///< Distance modifier, determines how much demands decrease with distance.
+	int32 accuracy;     ///< Accuracy of the calculation.
+
+	template<class Tscaler>
+	void CalcDemand(LinkGraphComponent *graph, Tscaler scaler);
+};
+
+/**
+ * Stateless, thread safe demand hander. Doesn't do anything but call DemandCalculator.
+ */
+class DemandHandler : public ComponentHandler {
+public:
+
+	/**
+	 * Call the demand calculator on the given component.
+	 * @param graph Component to calculate the demands for.
+	 */
+	virtual void Run(LinkGraphComponent *graph) { DemandCalculator c(graph); }
+
+	/**
+	 * Virtual destructor has to be defined because of virtual Run().
+	 */
+	virtual ~DemandHandler() {}
+};
+
+#endif /* DEMANDS_H_ */
diff --git a/src/linkgraph/flowmapper.cpp b/src/linkgraph/flowmapper.cpp
new file mode 100644
index 0000000..8b45147
--- /dev/null
+++ b/src/linkgraph/flowmapper.cpp
@@ -0,0 +1,54 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file flowmapper.cpp Definition of flowmapper. */
+
+#include "../stdafx.h"
+#include "flowmapper.h"
+
+/**
+ * Map the paths generated by the MCF solver into flows associated with nodes.
+ * @param component the link graph component to be used.
+ */
+void FlowMapper::Run(LinkGraphComponent *component)
+{
+	for (NodeID node_id = 0; node_id < component->GetSize(); ++node_id) {
+		Node &prev_node = component->GetNode(node_id);
+		StationID prev = prev_node.station;
+		PathSet &paths = prev_node.paths;
+		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
+			Path *path = *i;
+			uint flow = path->GetFlow();
+			if (flow == 0) continue;
+			Node &node = component->GetNode(path->GetNode());
+			StationID via = node.station;
+			assert(prev != via);
+			StationID origin = component->GetNode(path->GetOrigin()).station;
+			assert(via != origin);
+			/* mark all of the flow for local consumption at "first" */
+			node.flows[origin][via] += flow;
+			/* pass some of the flow marked for local consumption at "prev" on
+			 * to this node
+			 */
+			prev_node.flows[origin][via] += flow;
+			/* find simple circular flows ... */
+			assert(node.flows[origin][prev] == 0);
+			if (prev != origin) {
+				prev_node.flows[origin][prev] -= flow;
+			}
+		}
+	}
+	for (NodeID node_id = 0; node_id < component->GetSize(); ++node_id) {
+		PathSet &paths = component->GetNode(node_id).paths;
+		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
+			delete *i;
+		}
+		paths.clear();
+	}
+}
diff --git a/src/linkgraph/flowmapper.h b/src/linkgraph/flowmapper.h
new file mode 100644
index 0000000..a2b6bc0
--- /dev/null
+++ b/src/linkgraph/flowmapper.h
@@ -0,0 +1,30 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file flowmapper.h Declaration of flow mapper; maps paths into flows at nodes. */
+
+#ifndef FLOWMAPPER_H_
+#define FLOWMAPPER_H_
+
+#include "linkgraph.h"
+
+/**
+ * Map the path trees generated by the MCF solver into flows. The path tree is
+ * useful to cache capacities and distances and allow quick disconnecting and
+ * reconnecting to other paths. The flows show how much cargo from which nodes
+ * is to be routed in which direction at a given node. This is what we need in
+ * the end.
+ */
+class FlowMapper : public ComponentHandler {
+public:
+	virtual ~FlowMapper() {}
+	virtual void Run(LinkGraphComponent *component);
+};
+
+#endif /* FLOWMAPPER_H_ */
diff --git a/src/linkgraph/linkgraph.cpp b/src/linkgraph/linkgraph.cpp
new file mode 100644
index 0000000..3195b2e
--- /dev/null
+++ b/src/linkgraph/linkgraph.cpp
@@ -0,0 +1,554 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph.cpp Definition of link graph classes used for cargo distribution. */
+
+#include "../stdafx.h"
+#include "../map_func.h"
+#include "../core/bitmath_func.hpp"
+#include "../debug.h"
+#include "../moving_average.h"
+#include "linkgraph.h"
+#include "demands.h"
+#include "mcf.h"
+#include "flowmapper.h"
+#include <queue>
+
+/**
+ * Global array of link graphs, one for each cargo.
+ */
+LinkGraph _link_graphs[NUM_CARGO];
+
+/**
+ * Handlers to be run for each job.
+ */
+LinkGraphJob::HandlerList LinkGraphJob::_handlers;
+
+/**
+ * Create a node or clear it.
+ * @param st ID of the associated station.
+ * @param sup Supply of cargo at the station last month.
+ * @param dem Acceptance for cargo at the station.
+ */
+void Node::Init(StationID st, uint sup, uint dem)
+{
+	this->supply = sup;
+	this->undelivered_supply = sup;
+	this->demand = dem;
+	this->station = st;
+
+	for (PathSet::iterator i = this->paths.begin(); i != this->paths.end(); ++i) {
+		delete *i;
+	}
+	this->paths.clear();
+	this->flows.clear();
+}
+
+/**
+ * Create an edge.
+ * @param distance Length of the link as manhattan distance.
+ * @param capacity Capacity of the link.
+ */
+FORCEINLINE void Edge::Init(uint distance, uint capacity)
+{
+	this->distance = distance;
+	this->capacity = capacity;
+	this->demand = 0;
+	this->unsatisfied_demand = 0;
+	this->flow = 0;
+	this->next_edge = INVALID_NODE;
+}
+
+
+/**
+ * 1. Build the link graph component containing the given station by using BFS on the link stats.
+ * 2. Set every included station's last_component to the new component's ID (this->current_component_id).
+ * 3. Start a link graph job with the new component.
+ * @param first Station to start the search at.
+ */
+void LinkGraph::CreateComponent(Station *first)
+{
+	std::map<Station *, NodeID> index;
+	index[first] = this->AddNode(first);
+
+	std::queue<Station *> search_queue;
+	search_queue.push(first);
+
+	/* find all stations belonging to the current component */
+	while (!search_queue.empty()) {
+		Station *source = search_queue.front();
+		search_queue.pop();
+
+		const LinkStatMap &links = source->goods[this->cargo].link_stats;
+		for (LinkStatMap::const_iterator i = links.begin(); i != links.end(); ++i) {
+			Station *target = Station::GetIfValid(i->first);
+			if (target == NULL) continue;
+
+			std::map<Station *, NodeID>::iterator index_it = index.find(target);
+			if (index_it == index.end()) {
+				search_queue.push(target);
+				NodeID node = this->AddNode(target);
+				index[target] = node;
+
+				this->AddEdge(index[source], node, i->second.Capacity());
+			} else {
+				this->AddEdge(index[source], index_it->second, i->second.Capacity());
+			}
+		}
+	}
+
+	/* here the list of nodes and edges for this component is complete. */
+	this->SpawnThread();
+}
+
+/**
+ * Looks for a suitable station to create the next link graph component from.
+ * Linearly searches all stations starting from current_station_id for one that
+ * hasn't been visited in this run over the link graph. The current run and the
+ * last run are differentiated by giving the components IDs divisible by 2
+ * every second run and ones not divisible by 2 on the other runs.
+ *
+ * If such a station is found current_station_id is set to that station's ID
+ * and CreateComponent is called with it.
+ *
+ * The search wraps around and changes current_component_id to 0 or 1
+ * accordingly. If the starting point is reached again it stops.
+ */
+void LinkGraph::NextComponent()
+{
+	/* Check for no stations to avoid problems with Station::GetPoolSize()
+	 * being 0 later and to avoid searching an empty pool.
+	 */
+	if (Station::GetNumItems() == 0) return;
+
+	/* Don't mess with running jobs (might happen when changing interval).*/
+	if (this->GetSize() > 0) return;
+
+	/* The station pool may shrink when saving and subsequently loading a game as
+	 * NULL entries at the end are cut off then. If the current station id points
+	 * to one of those NULL entries we have to clamp it here to avoid an infinite
+	 * loop later.
+	 */
+	StationID last_station_id = min(this->current_station_id, Station::GetPoolSize() - 1);
+	LinkGraphComponentID current_component_id = this->LinkGraphComponent::index;
+
+	do {
+		if (++this->current_station_id >= Station::GetPoolSize()) {
+			/* Wrap around and recycle the component IDs. Use different
+			 * divisibility by 2 than in the last run so that we can find out
+			 * which stations haven't been seen in this run.
+			 */
+			this->current_station_id = 0;
+			if (current_component_id % 2 == 0) {
+				current_component_id = 1;
+			} else {
+				current_component_id = 0;
+			}
+		}
+
+		/* find first station of next component */
+		Station *station = Station::GetIfValid(this->current_station_id);
+		if (station != NULL) {
+			GoodsEntry &ge = station->goods[this->cargo];
+			if (ge.last_component == INVALID_LINKGRAPH_COMPONENT ||
+					(ge.last_component + current_component_id) % 2 != 0) {
+				/* Different divisibility by 2: This station has not been seen
+				 * in the current run over the link graph.
+				 */
+
+				if (!ge.link_stats.empty()) {
+					this->LinkGraphComponent::Init(current_component_id + 2);
+					CreateComponent(station);
+					return;
+				}
+			}
+		}
+
+	} while (this->current_station_id != last_station_id);
+}
+
+/**
+ * Spawn or join a link graph component if any link graph is due to do so.
+ * Spawning is done on COMPONENTS_SPAWN_TICK every day, joining on
+ * COMPONENT_JOIN_TICK. Each link graph is due every recalc_interval days.
+ */
+void OnTick_LinkGraph()
+{
+	if (_date_fract == LinkGraph::COMPONENTS_SPAWN_TICK ||
+			_date_fract == LinkGraph::COMPONENTS_JOIN_TICK) {
+
+		/* This creates a fair distribution of all link graphs' turns over
+		 * the available dates.
+		 */
+		for (uint cargo = _date % _settings_game.linkgraph.recalc_interval; cargo < NUM_CARGO;
+				cargo += _settings_game.linkgraph.recalc_interval) {
+
+			/* don't calculate a link graph if the distribution is manual */
+			if (_settings_game.linkgraph.GetDistributionType(cargo) == DT_MANUAL) continue;
+
+			if (_date_fract == LinkGraph::COMPONENTS_SPAWN_TICK) {
+				_link_graphs[cargo].NextComponent();
+			} else /* LinkGraph::COMPONENTS_JOIN_TICK */ {
+				_link_graphs[cargo].Join();
+			}
+		}
+	}
+}
+
+/**
+ * Add a node to the component and create empty edges associated with it. Set
+ * the station's last_component to this component. Calculate the distances to all
+ * other nodes. The distances to _all_ nodes are important as the demand
+ * calculator relies on their availability.
+ * @param st New node's station.
+ * @return New node's ID.
+ */
+NodeID LinkGraphComponent::AddNode(Station *st)
+{
+	GoodsEntry &good = st->goods[this->cargo];
+	good.last_component = this->index;
+
+	bool do_resize = (this->nodes.size() == this->num_nodes);
+
+	if (do_resize) {
+		this->nodes.push_back(Node());
+		this->edges.push_back(std::vector<Edge>(this->num_nodes + 1));
+	}
+
+	this->nodes[this->num_nodes].Init(st->index, good.supply,
+			HasBit(good.acceptance_pickup, GoodsEntry::GES_ACCEPTANCE));
+
+	std::vector<Edge> &new_edges = this->edges[this->num_nodes];
+
+	/* reset the first edge starting at the new node */
+	new_edges[this->num_nodes].next_edge = INVALID_NODE;
+
+	for (NodeID i = 0; i < this->num_nodes; ++i) {
+		uint distance = DistanceManhattan(st->xy, Station::Get(this->nodes[i].station)->xy);
+		if (do_resize) this->edges[i].push_back(Edge());
+		new_edges[i].Init(distance);
+		this->edges[i][this->num_nodes].Init(distance);
+	}
+	return this->num_nodes++;
+}
+
+/**
+ * Fill an edge with values from a link.
+ * @param from Source node of the link.
+ * @param to Destination node of the link.
+ * @param capacity Capacity of the link.
+ */
+FORCEINLINE void LinkGraphComponent::AddEdge(NodeID from, NodeID to, uint capacity)
+{
+	assert(from != to);
+	Edge &edge = this->edges[from][to];
+	Edge &first = this->edges[from][from];
+	edge.capacity = capacity;
+	edge.next_edge = first.next_edge;
+	first.next_edge = to;
+}
+
+/**
+ * Resize the component and fill it with empty nodes and edges. Used when
+ * loading from save games.
+ *
+ * WARNING: The nodes and edges are expected to contain anything while
+ * num_nodes is expected to contain the desired size. Normally this is an
+ * invalid state, but just after loading the component's structure it is valid.
+ * This method should only be called from Load_LGRP.
+ */
+void LinkGraphComponent::SetSize()
+{
+	if (this->nodes.size() < this->num_nodes) {
+		for (EdgeMatrix::iterator i = this->edges.begin(); i != this->edges.end(); ++i) {
+			i->resize(this->num_nodes);
+		}
+		this->nodes.resize(this->num_nodes);
+		this->edges.resize(this->num_nodes, std::vector<Edge>(this->num_nodes));
+	}
+
+	for (uint i = 0; i < this->num_nodes; ++i) {
+		this->nodes[i].Init();
+		for (uint j = 0; j < this->num_nodes; ++j) {
+			this->edges[i][j].Init();
+		}
+	}
+}
+
+/**
+ * Create an empty component.
+ */
+LinkGraphComponent::LinkGraphComponent() :
+		settings(_settings_game.linkgraph),
+		cargo(INVALID_CARGO),
+		num_nodes(0),
+		index(INVALID_LINKGRAPH_COMPONENT)
+{}
+
+/**
+ * (Re-)initialize this component with a new ID and a new copy of the settings.
+ */
+void LinkGraphComponent::Init(LinkGraphComponentID id)
+{
+	assert(this->num_nodes == 0);
+	this->index = id;
+	this->settings = _settings_game.linkgraph;
+}
+
+
+/**
+ * Exports all entries in the FlowViaMap pointed to by "source_flows_it", erases the source
+ * flows and increments the iterator afterwards.
+ * @param it Iterator pointing to the flows to be exported into the main game state.
+ * @param dest Flow stats to which the flows shall be exported.
+ * @param cargo Cargo we're exporting flows for (used to check if the link stats for the new
+ *        flows still exist).
+ */
+void Node::ExportNewFlows(FlowMap::iterator &it, FlowStatSet &dest, CargoID cargo)
+{
+	StationID source = it->first;
+	FlowViaMap &source_flows = it->second;
+	if (!Station::IsValidID(source)) {
+		source_flows.clear();
+	} else {
+		Station *curr_station = Station::Get(this->station);
+		for (FlowViaMap::iterator update = source_flows.begin(); update != source_flows.end();) {
+			StationID next = update->first;
+			int planned = update->second;
+			assert(planned >= 0);
+
+			Station *via = Station::GetIfValid(next);
+			if (planned > 0 && via != NULL) {
+				uint distance = GetMovingAverageLength(curr_station, via);
+				if (next != this->station) {
+					const LinkStatMap &ls = curr_station->goods[cargo].link_stats;
+					if (ls.find(next) != ls.end()) {
+						dest.insert(FlowStat(distance, next, planned, 0));
+					}
+				} else {
+					dest.insert(FlowStat(distance, next, planned, 0));
+				}
+			}
+			source_flows.erase(update++);
+		}
+	}
+	assert(source_flows.empty());
+
+	this->flows.erase(it++);
+}
+
+/**
+ * Export all flows of this node to the main game state.
+ * @param cargo the cargo we're exporting flows for.
+ */
+void Node::ExportFlows(CargoID cargo)
+{
+	FlowStatMap &station_flows = Station::Get(this->station)->goods[cargo].flows;
+	FlowStatSet new_flows;
+	/* loop over all existing flows in the station and update them */
+	for (FlowStatMap::iterator station_outer_it(station_flows.begin()); station_outer_it != station_flows.end();) {
+		FlowMap::iterator node_outer_it(this->flows.find(station_outer_it->first));
+		if (node_outer_it == this->flows.end()) {
+			/* there are no flows for this source node anymore */
+			station_flows.erase(station_outer_it++);
+		} else {
+			FlowViaMap &source = node_outer_it->second;
+			FlowStatSet &dest = station_outer_it->second;
+			/* loop over the station's flow stats for this source node and update them */
+			for (FlowStatSet::iterator station_inner_it(dest.begin()); station_inner_it != dest.end();) {
+				FlowViaMap::iterator node_inner_it(source.find(station_inner_it->Via()));
+				if (node_inner_it != source.end()) {
+					assert(node_inner_it->second >= 0);
+					if (node_inner_it->second > 0) {
+						new_flows.insert(FlowStat(*station_inner_it, node_inner_it->second));
+					}
+					source.erase(node_inner_it);
+				}
+				dest.erase(station_inner_it++);
+			}
+			/* swap takes constant time, so we swap instead of adding all entries */
+			dest.swap(new_flows);
+			assert(new_flows.empty());
+			/* insert remaining flows for this source node */
+			ExportNewFlows(node_outer_it, dest, cargo);
+			/* careful: source_flows is dangling here */
+			++station_outer_it;
+		}
+	}
+	/* loop over remaining flows (for other sources) in the node's map and insert them into the station */
+	for (FlowMap::iterator it(this->flows.begin()); it != this->flows.end();) {
+		ExportNewFlows(it, station_flows[it->first], cargo);
+	}
+	assert(this->flows.empty());
+}
+
+/**
+ * Merge the current job's results into the main game state.
+ */
+void LinkGraph::Join()
+{
+	this->LinkGraphJob::Join();
+
+	for (NodeID node_id = 0; node_id < this->GetSize(); ++node_id) {
+		Node &node = this->GetNode(node_id);
+		if (Station::IsValidID(node.station)) {
+			node.ExportFlows(this->cargo);
+		}
+	}
+
+	this->LinkGraphComponent::Clear();
+}
+
+/**
+ * Run all handlers for the given Job.
+ * @param j Pointer to a link graph job.
+ */
+/* static */ void LinkGraphJob::RunLinkGraphJob(void *j)
+{
+	LinkGraphJob *job = (LinkGraphJob *)j;
+	for (HandlerList::iterator i = _handlers.begin(); i != _handlers.end(); ++i) {
+		(*i)->Run(job);
+	}
+}
+
+/**
+ * Clear the handlers.
+ */
+/* static */ void LinkGraphJob::ClearHandlers()
+{
+	for (HandlerList::iterator i = _handlers.begin(); i != _handlers.end(); ++i) {
+		delete *i;
+	}
+	_handlers.clear();
+}
+
+/**
+ * Add this path as a new child to the given base path, thus making this path
+ * a "fork" of the base path.
+ * @param base the path to fork from
+ * @param cap maximum capacity of the new path
+ * @param dist distance of the new leg
+ */
+void Path::Fork(Path *base, uint cap, int free_cap, uint dist)
+{
+	this->capacity = min(base->capacity, cap);
+	this->free_capacity = min(base->free_capacity, free_cap);
+	this->distance = base->distance + dist;
+	assert(this->distance > 0);
+	if (this->parent != base) {
+		this->Detach();
+		this->parent = base;
+		this->parent->num_children++;
+	}
+	this->origin = base->origin;
+}
+
+/**
+ * Push some flow along a path and register the path in the nodes it passes if
+ * successful.
+ * @param new_flow amount of flow to push
+ * @param graph the link graph component this node belongs to
+ * @param only_positive if true, don't push more flow than there is capacity
+ * @return the amount of flow actually pushed
+ */
+uint Path::AddFlow(uint new_flow, LinkGraphComponent *graph, bool only_positive)
+{
+	if (this->parent != NULL) {
+		Edge &edge = graph->GetEdge(this->parent->node, this->node);
+		if (only_positive) {
+			uint usable_cap = edge.capacity * graph->GetSettings().short_path_saturation / 100;
+			if (usable_cap > edge.flow) {
+				new_flow = min(new_flow, usable_cap - edge.flow);
+			} else {
+				return 0;
+			}
+		}
+		new_flow = this->parent->AddFlow(new_flow, graph, only_positive);
+		if (new_flow > 0) {
+			graph->GetNode(this->parent->node).paths.insert(this);
+		}
+		edge.flow += new_flow;
+	}
+	this->flow += new_flow;
+	return new_flow;
+}
+
+/**
+ * create a leg of a path in the link graph.
+ * @param n id of the link graph node this path passes
+ * @param source if true, this is the first leg of the path
+ */
+Path::Path(NodeID n, bool source) :
+	distance(source ? 0 : UINT_MAX),
+	capacity(0),
+	free_capacity(source ? INT_MAX : INT_MIN),
+	flow(0), node(n), origin(source ? n : INVALID_NODE),
+	num_children(0), parent(NULL)
+{}
+
+/**
+ * Join the calling thread with this job's thread if threading is enabled.
+ */
+FORCEINLINE void LinkGraphJob::Join()
+{
+	if (this->thread == NULL) return;
+	this->thread->Join();
+	delete this->thread;
+	this->thread = NULL;
+}
+
+/**
+ * Spawn a thread if possible and run the link graph job in the thread. If
+ * that's not possible run the job right now in the current thread.
+ */
+void LinkGraphJob::SpawnThread()
+{
+	assert(this->thread == NULL);
+	if (!ThreadObject::New(&(LinkGraphJob::RunLinkGraphJob), this, &(this->thread))) {
+		this->thread = NULL;
+		/* Of course this will hang a bit.
+		 * On the other hand, if you want to play games which make this hang noticably
+		 * on a platform without threads then you'll probably get other problems first.
+		 * OK:
+		 * If someone comes and tells me that this hangs for him/her, I'll implement a
+		 * smaller grained "Step" method for all handlers and add some more ticks where
+		 * "Step" is called. No problem in principle.
+		 */
+		LinkGraphJob::RunLinkGraphJob(this);
+	}
+}
+
+/**
+ * (Re-)Initialize the link graph: join all jobs and set current_station_id and
+ * cargo to their start values.
+ * @param cargo New cargo ID for the link graph.
+ */
+void LinkGraph::Init(CargoID cargo)
+{
+	this->LinkGraphJob::Join();
+	this->LinkGraphComponent::Clear();
+
+	this->current_station_id = 0;
+	this->LinkGraphComponent::cargo = cargo;
+}
+
+/**
+ * Initialize all link graphs. Used when loading a game.
+ */
+void InitializeLinkGraphs()
+{
+	for (CargoID c = 0; c < NUM_CARGO; ++c) _link_graphs[c].Init(c);
+
+	LinkGraphJob::ClearHandlers();
+	LinkGraphJob::AddHandler(new DemandHandler);
+	LinkGraphJob::AddHandler(new MCFHandler<MCF1stPass>);
+	LinkGraphJob::AddHandler(new FlowMapper);
+	LinkGraphJob::AddHandler(new MCFHandler<MCF2ndPass>);
+	LinkGraphJob::AddHandler(new FlowMapper);
+}
diff --git a/src/linkgraph/linkgraph.h b/src/linkgraph/linkgraph.h
new file mode 100644
index 0000000..acea738
--- /dev/null
+++ b/src/linkgraph/linkgraph.h
@@ -0,0 +1,348 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph.h Declaration of link graph classes used for cargo distribution. */
+
+#ifndef LINKGRAPH_H_
+#define LINKGRAPH_H_
+
+#include "../station_base.h"
+#include "../cargo_type.h"
+#include "../thread/thread.h"
+#include "../settings_type.h"
+#include "../date_func.h"
+#include "linkgraph_type.h"
+#include <list>
+#include <vector>
+#include <set>
+
+struct SaveLoad;
+class Path;
+
+typedef std::set<Path *> PathSet;
+typedef std::map<NodeID, Path *> PathViaMap;
+typedef std::map<StationID, int> FlowViaMap;
+typedef std::map<StationID, FlowViaMap> FlowMap;
+
+/**
+ * Node of the link graph. contains all relevant information from the associated
+ * station. It's copied so that the link graph job can work on its own data set
+ * in a separate thread.
+ */
+class Node {
+public:
+	uint supply;             ///< Supply at the station.
+	uint undelivered_supply; ///< Amount of supply that hasn't been distributed yet.
+	uint demand;             ///< Acceptance at the station.
+	StationID station;       ///< Station ID.
+	PathSet paths;           ///< Paths through this node.
+	FlowMap flows;           ///< Planned flows to other nodes.
+
+	/**
+	 * Clear a node on destruction to delete paths that might remain.
+	 */
+	~Node() {this->Init();}
+
+	void Init(StationID st = INVALID_STATION, uint sup = 0, uint dem = 0);
+	void ExportFlows(CargoID cargo);
+
+private:
+	void ExportNewFlows(FlowMap::iterator &it, FlowStatSet &via_set, CargoID cargo);
+};
+
+/**
+ * An edge in the link graph. Corresponds to a link between two stations or at
+ * least the distance between them. Edges from one node to itself contain the
+ * ID of the opposite Node of the first active edge (i.e. not just distance) in
+ * the column as next_edge.
+ */
+class Edge {
+public:
+	uint distance;           ///< Length of the link.
+	uint capacity;           ///< Capacity of the link.
+	uint demand;             ///< Transport demand between the nodes.
+	uint unsatisfied_demand; ///< Demand over this edge that hasn't been satisfied yet.
+	uint flow;               ///< Planned flow over this edge.
+	NodeID next_edge;        ///< Destination of next valid edge starting at the same source node.
+
+	void Init(uint distance = 0, uint capacity = 0);
+};
+
+/**
+ * A connected component of a link graph. Contains a complete set of stations
+ * connected by links as nodes and edges. Each component also holds a copy of
+ * the link graph settings at the time of its creation. The global settings
+ * might change between the creation and join time so we can't rely on them.
+ */
+class LinkGraphComponent {
+private:
+	typedef std::vector<Node> NodeVector;
+	typedef std::vector<std::vector<Edge> > EdgeMatrix;
+
+public:
+	LinkGraphComponent();
+
+	void Init(LinkGraphComponentID id);
+
+	/**
+	 * Get a reference to an edge.
+	 * @param from Origin node.
+	 * @param to Destination node.
+	 * @return Edge between from and to.
+	 */
+	FORCEINLINE Edge &GetEdge(NodeID from, NodeID to)
+	{
+		return this->edges[from][to];
+	}
+
+	/**
+	 * Get a reference to a node with the specified id.
+	 * @param num ID of the node.
+	 * @return the Requested node.
+	 */
+	FORCEINLINE Node &GetNode(NodeID num)
+	{
+		return this->nodes[num];
+	}
+
+	/**
+	 * Get the current size of the component.
+	 * @return Size.
+	 */
+	FORCEINLINE uint GetSize() const
+	{
+		return this->num_nodes;
+	}
+
+	void SetSize();
+
+	NodeID AddNode(Station *st);
+
+	void AddEdge(NodeID from, NodeID to, uint capacity);
+
+	/**
+	 * Get the ID of this component.
+	 * @return ID.
+	 */
+	FORCEINLINE LinkGraphComponentID GetIndex() const
+	{
+		return this->index;
+	}
+
+	/**
+	 * Get the cargo ID this component's link graph refers to.
+	 * @return Cargo ID.
+	 */
+	FORCEINLINE CargoID GetCargo() const
+	{
+		return this->cargo;
+	}
+
+	/**
+	 * Get the link graph settings for this component.
+	 * @return Settings.
+	 */
+	FORCEINLINE const LinkGraphSettings &GetSettings() const
+	{
+		return this->settings;
+	}
+
+	/**
+	 * Get the first valid edge starting at the specified node.
+	 * @param from ID of the source node
+	 * @return ID of the destination node
+	 */
+	FORCEINLINE NodeID GetFirstEdge(NodeID from) {return edges[from][from].next_edge;}
+
+	/**
+	 * Set the number of nodes to 0 to mark this component as done.
+	 */
+	FORCEINLINE void Clear()
+	{
+		this->num_nodes = 0;
+	}
+
+protected:
+	LinkGraphSettings settings; ///< Copy of _settings_game.linkgraph at creation time.
+	CargoID cargo;              ///< Cargo of this component's link graph.
+	uint num_nodes;             ///< Number of nodes in the component.
+	LinkGraphComponentID index; ///< ID of the component.
+	NodeVector nodes;           ///< Nodes in the component.
+	EdgeMatrix edges;           ///< Edges in the component.
+};
+
+/**
+ * A handler doing "something" on a link graph component. It must not keep any
+ * state as it is called concurrently from different threads.
+ */
+class ComponentHandler {
+public:
+	/**
+	 * Destroy the handler. Must be given due to virtual Run.
+	 */
+	virtual ~ComponentHandler() {}
+
+	/**
+	 * Run the handler. A link graph handler must not read or write any data
+	 * outside the given component as that would create a potential desync.
+	 * @param component Link graph component to run the handler on.
+	 */
+	virtual void Run(LinkGraphComponent *component) = 0;
+};
+
+/**
+ * A job to be executed on a link graph component. It inherits a component and
+ * keeps a static list of handlers to be run on it. It may or may not run in a
+ * thread and contains a thread object for this option.
+ */
+class LinkGraphJob : public LinkGraphComponent {
+private:
+	typedef std::list<ComponentHandler *> HandlerList;
+
+public:
+
+	LinkGraphJob() : thread(NULL) {}
+
+	/**
+	 * Destructor; Clean up the thread if it's there.
+	 */
+	~LinkGraphJob()
+	{
+		this->Join();
+	}
+
+	static void RunLinkGraphJob(void *j);
+
+	/**
+	 * Add a handler to the end of the list.
+	 * @param handler Handler to be added.
+	 */
+	static void AddHandler(ComponentHandler *handler)
+	{
+		LinkGraphJob::_handlers.push_back(handler);
+	}
+
+	static void ClearHandlers();
+
+	void SpawnThread();
+
+	void Join();
+
+private:
+	static HandlerList _handlers;   ///< Handlers the job is executing.
+	ThreadObject *thread;           ///< Thread the job is running in or NULL if it's running in the main thread.
+
+	/**
+	 * Private Copy-Constructor: there cannot be two identical LinkGraphJobs.
+	 * @param other hypothetical other job to be copied.
+	 * @note It's necessary to explicitly initialize the link graph component in order to silence some compile warnings.
+	 */
+	LinkGraphJob(const LinkGraphJob &other) : LinkGraphComponent(other) {NOT_REACHED();}
+};
+
+/**
+ * A link graph, inheriting one job.
+ */
+class LinkGraph : public LinkGraphJob {
+public:
+	/* Those are ticks where not much else is happening, so a small lag might go unnoticed. */
+	static const uint COMPONENTS_JOIN_TICK  = 21; ///< Tick when jobs are joined every day.
+	static const uint COMPONENTS_SPAWN_TICK = 58; ///< Tick when jobs are spawned every day.
+
+	/**
+	 * Create a link graph.
+	 */
+	LinkGraph() : current_station_id(0) {}
+
+	void Init(CargoID cargo);
+
+	void NextComponent();
+
+	void Join();
+
+private:
+	StationID current_station_id; ///< ID of the last station examined while creating components.
+
+	friend const SaveLoad *GetLinkGraphDesc();
+
+	void CreateComponent(Station *first);
+};
+
+/**
+ * A leg of a path in the link graph. Paths can form trees by being "forked".
+ */
+class Path {
+public:
+	Path(NodeID n, bool source = false);
+
+	/** Get the node this leg passes. */
+	FORCEINLINE NodeID GetNode() const {return this->node;}
+
+	/** Get the overall origin of the path. */
+	FORCEINLINE NodeID GetOrigin() const {return this->origin;}
+
+	/** Get the parent leg of this one. */
+	FORCEINLINE Path *GetParent() {return this->parent;}
+
+	/** Get the overall capacity of the path. */
+	FORCEINLINE uint GetCapacity() const {return this->capacity;}
+
+	/** Get the free capacity of the path. */
+	FORCEINLINE int GetFreeCapacity() const {return this->free_capacity;}
+
+	/**
+	 * Get ratio of free * 16 (so that we get fewer 0) /
+	 * overall capacity + 1 (so that we don't divide by 0).
+	 */
+	FORCEINLINE int GetCapacityRatio() const {return (this->free_capacity << 4) / (this->capacity + 1);}
+
+	/** Get the overall distance of the path. */
+	FORCEINLINE uint GetDistance() const {return this->distance;}
+
+	/** Reduce the flow on this leg only by the specified amount. */
+	FORCEINLINE void ReduceFlow(uint f) {this->flow -= f;}
+
+	/** Increase the flow on this leg only by the specified amount. */
+	FORCEINLINE void AddFlow(uint f) {this->flow += f;}
+
+	/** Get the flow on this leg. */
+	FORCEINLINE uint GetFlow() const {return this->flow;}
+
+	/** Get the number of "forked off" child legs of this one. */
+	FORCEINLINE uint GetNumChildren() const {return this->num_children;}
+
+	/**
+	 * Detach this path from its parent.
+	 */
+	FORCEINLINE void Detach()
+	{
+		if (this->parent != NULL) {
+			this->parent->num_children--;
+			this->parent = NULL;
+		}
+	}
+
+	uint AddFlow(uint f, LinkGraphComponent *graph, bool only_positive);
+	void Fork(Path *base, uint cap, int free_cap, uint dist);
+
+protected:
+	uint distance;     ///< Sum(distance of all legs up to this one).
+	uint capacity;     ///< This capacity is min(capacity) fom all edges.
+	int free_capacity; ///< This capacity is min(edge.capacity - edge.flow) for the current run of Dijkstra.
+	uint flow;         ///< Flow the current run of the mcf solver assigns.
+	NodeID node;       ///< Link graph node this leg passes.
+	NodeID origin;     ///< Link graph node this path originates from.
+	uint num_children; ///< Number of child legs that have been forked from this path.
+	Path *parent;      ///< Parent leg of this one.
+};
+
+void InitializeLinkGraphs();
+extern LinkGraph _link_graphs[NUM_CARGO];
+
+#endif /* LINKGRAPH_H_ */
diff --git a/src/linkgraph/linkgraph_type.h b/src/linkgraph/linkgraph_type.h
new file mode 100644
index 0000000..cd73b1c
--- /dev/null
+++ b/src/linkgraph/linkgraph_type.h
@@ -0,0 +1,36 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_type.h Declaration of link graph types used for cargo distribution. */
+
+#ifndef LINKGRAPH_TYPE_H_
+#define LINKGRAPH_TYPE_H_
+
+typedef uint16 LinkGraphComponentID;
+static const LinkGraphComponentID INVALID_LINKGRAPH_COMPONENT = UINT16_MAX;
+
+typedef uint NodeID;
+static const NodeID INVALID_NODE = UINT_MAX;
+
+enum DistributionType {
+	DT_BEGIN = 0,
+	DT_SYMMETRIC = 0, ///< symmetric distribution. The same amount of cargo travels in each direction between each pair of nodes.
+	DT_ASYMMETRIC,    ///< asymmetric distribution. Usually cargo will only travel in one direction.
+	DT_MANUAL,        ///< manual distribution. No link graph calculations are run.
+	DT_NUM = 3,
+	DT_END = 3
+};
+
+/* It needs to be 8bits, because we save and load it as such
+ * Define basic enum properties
+ */
+template <> struct EnumPropsT<DistributionType> : MakeEnumPropsT<DistributionType, byte, DT_BEGIN, DT_END, DT_NUM> {};
+typedef TinyEnumT<DistributionType> DistributionTypeByte; // typedefing-enumification of DistributionType
+
+#endif /* LINKGRAPH_TYPE_H_ */
diff --git a/src/linkgraph/mcf.cpp b/src/linkgraph/mcf.cpp
new file mode 100644
index 0000000..505d873
--- /dev/null
+++ b/src/linkgraph/mcf.cpp
@@ -0,0 +1,417 @@
+/** @file mcf.cpp Definition of Multi-Commodity-Flow solver. */
+
+#include "../stdafx.h"
+#include "../core/math_func.hpp"
+#include "mcf.h"
+
+/**
+ * Determines if an extension to the given Path with the given parameters is
+ * better than this path.
+ * @param base Other path.
+ * @param cap Capacity of the new edge to be added to base.
+ * @param dist Distance of the new edge.
+ * @return True if base + the new edge would be better than the path associated
+ * with this annotation.
+ */
+bool DistanceAnnotation::IsBetter(const DistanceAnnotation *base, uint cap,
+		int free_cap, uint dist) const
+{
+	/* If any of the paths is disconnected, the other one is better. If both
+	 * are disconnected, this path is better.
+	 */
+	if (base->distance == UINT_MAX) {
+		return false;
+	} else if (this->distance == UINT_MAX) {
+		return true;
+	}
+
+	if (free_cap > 0 && base->free_capacity > 0) {
+		/* If both paths have capacity left, compare their distances.
+		 * If the other path has capacity left and this one hasn't, the
+		 * other one's better.
+		 */
+		return this->free_capacity > 0 ? (base->distance + dist < this->distance) : true;
+	} else {
+		/* If the other path doesn't have capacity left, but this one has,
+		 * this one is better.
+		 * If both paths are out of capacity, do the regular distance
+		 * comparison.
+		 */
+		return this->free_capacity > 0 ? false : (base->distance + dist < this->distance);
+	}
+}
+
+/**
+ * Determines if an extension to the given Path with the given parameters is
+ * better than this path.
+ * @param base Other path.
+ * @param cap Capacity of the new edge to be added to base.
+ * @param dist Distance of the new edge.
+ * @return True if base + the new edge would be better than the path associated
+ * with this annotation.
+ */
+bool CapacityAnnotation::IsBetter(const CapacityAnnotation *base, uint cap,
+		int free_cap, uint dist) const
+{
+	int min_cap = (min(base->free_capacity, free_cap) << 4) / (min(base->capacity, cap) + 1);
+	int this_cap = this->GetCapacityRatio();
+	if (min_cap == this_cap) {
+		/* If the capacities are the same and the other path isn't disconnected
+		 * choose the shorter path.
+		 */
+		return base->distance == UINT_MAX ? false : (base->distance + dist < this->distance);
+	} else {
+		return min_cap > this_cap;
+	}
+}
+
+/**
+ * A slightly modified Dijkstra algorithm. Grades the paths not necessarily by
+ * distance, but by the value Tannotation computes. It can also be configured
+ * to only use paths already created before and not create new ones. If this is
+ * not done it uses the short_path_saturation setting to artificially decrease
+ * capacities. If a path has already been created is determined by checking the
+ * flows associated with its nodes.
+ * @tparam Tannotation Annotation to be used.
+ * @param source_node Node where the algorithm starts.
+ * @param paths Container for the paths to be calculated.
+ * @param create_new_paths If false, only use paths already seen before,
+ *                         otherwise artificially limit the capacity.
+ */
+template<class Tannotation>
+void MultiCommodityFlow::Dijkstra(NodeID source_node, PathVector &paths,
+		bool create_new_paths)
+{
+	typedef std::set<Tannotation *, typename Tannotation::Comparator> AnnoSet;
+	uint size = this->graph->GetSize();
+	StationID source_station = this->graph->GetNode(source_node).station;
+	AnnoSet annos;
+	paths.resize(size, NULL);
+	for (NodeID node = 0; node < size; ++node) {
+		Tannotation *anno = new Tannotation(node, node == source_node);
+		annos.insert(anno);
+		paths[node] = anno;
+	}
+	while (!annos.empty()) {
+		typename AnnoSet::iterator i = annos.begin();
+		Tannotation *source = *i;
+		annos.erase(i);
+		NodeID from = source->GetNode();
+		NodeID to = this->graph->GetFirstEdge(from);
+		while (to != INVALID_NODE) {
+			Edge &edge = this->graph->GetEdge(from, to);
+			assert(edge.distance < UINT_MAX);
+			if (create_new_paths || this->graph->GetNode(from)
+					.flows[source_station][this->graph->GetNode(to).station] > 0) {
+				uint capacity = edge.capacity;
+				if (create_new_paths) {
+					capacity *= this->graph->GetSettings().short_path_saturation;
+					capacity /= 100;
+					if (capacity == 0) capacity = 1;
+				}
+				/* punish in-between stops a little */
+				uint distance = edge.distance + 1;
+				Tannotation *dest = static_cast<Tannotation *>(paths[to]);
+				if (dest->IsBetter(source, capacity, capacity - edge.flow, distance)) {
+					annos.erase(dest);
+					dest->Fork(source, capacity, capacity - edge.flow, distance);
+					annos.insert(dest);
+				}
+			}
+			to = edge.next_edge;
+		}
+	}
+}
+
+/**
+ * Clean up paths that lead nowhere and the root path.
+ * @param source_id ID of the root node.
+ * @param paths Paths to be cleaned up.
+ */
+void MultiCommodityFlow::CleanupPaths(NodeID source_id, PathVector &paths)
+{
+	Path *source = paths[source_id];
+	paths[source_id] = NULL;
+	for (PathVector::iterator i = paths.begin(); i != paths.end(); ++i) {
+		Path *path = *i;
+		if (path == NULL) continue;
+		if (path->GetParent() == source) path->Detach();
+		while (path != source && path != NULL && path->GetFlow() == 0) {
+			Path *parent = path->GetParent();
+			path->Detach();
+			if (path->GetNumChildren() == 0) {
+				paths[path->GetNode()] = NULL;
+				delete path;
+			}
+			path = parent;
+		}
+	}
+	delete source;
+	paths.clear();
+}
+
+/**
+ * Push flow along a path and update the unsatisfied_demand of the associated
+ * edge.
+ * @param edge Edge whose ends the path connects.
+ * @param path End of the path the flow should be pushed on.
+ * @param accuracy Accuracy of the calculation.
+ * @param positive_cap If true only push flow up to the paths capacity,
+ *                     otherwise the path can be "overloaded".
+ */
+uint MultiCommodityFlow::PushFlow(Edge &edge, Path *path, uint accuracy,
+		bool positive_cap)
+{
+	assert(edge.unsatisfied_demand > 0);
+	uint flow = Clamp(edge.demand / accuracy, 1, edge.unsatisfied_demand);
+	flow = path->AddFlow(flow, this->graph, positive_cap);
+	edge.unsatisfied_demand -= flow;
+	return flow;
+}
+
+/**
+ * Find the flow along a cycle including cycle_begin in path.
+ * @param path Set of paths that form the cycle.
+ * @param cycle_begin Path to start at.
+ * @return Flow along the cycle.
+ */
+uint MCF1stPass::FindCycleFlow(const PathVector &path, const Path *cycle_begin)
+{
+	uint flow = UINT_MAX;
+	const Path *cycle_end = cycle_begin;
+	do {
+		flow = min(flow, cycle_begin->GetFlow());
+		cycle_begin = path[cycle_begin->GetNode()];
+	} while (cycle_begin != cycle_end);
+	return flow;
+}
+
+/**
+ * Eliminate a cycle of the given flow in the given set of paths.
+ * @param path Set of paths containing the cycle.
+ * @param cycle_begin Part of the cycle to start at.
+ * @param flow Flow along the cycle.
+ */
+void MCF1stPass::EliminateCycle(PathVector &path, Path *cycle_begin, uint flow)
+{
+	Path *cycle_end = cycle_begin;
+	do {
+		NodeID prev = cycle_begin->GetNode();
+		cycle_begin->ReduceFlow(flow);
+		cycle_begin = path[cycle_begin->GetNode()];
+		Edge &edge = this->graph->GetEdge(prev, cycle_begin->GetNode());
+		edge.flow -= flow;
+	} while (cycle_begin != cycle_end);
+}
+
+/**
+ * Eliminate cycles for origin_id in the graph. Start searching at next_id and
+ * work recursively. Also "summarize" paths: Add up the flows along parallel
+ * paths in one.
+ * @param path Paths checked in parent calls to this method.
+ * @param origin_id Origin of the paths to be checked.
+ * @param next_id Next node to be checked.
+ * @return If any cycles have been found and eliminated.
+ */
+bool MCF1stPass::EliminateCycles(PathVector &path, NodeID origin_id, NodeID next_id)
+{
+	static Path *invalid_path = new Path(INVALID_NODE, true);
+	Path *at_next_pos = path[next_id];
+	if (at_next_pos == invalid_path) {
+		/* this node has already been searched */
+		return false;
+	} else if (at_next_pos == NULL) {
+		/* summarize paths; add up the paths with the same source and next hop
+		 * in one path each
+		 */
+		PathSet &paths = this->graph->GetNode(next_id).paths;
+		PathViaMap next_hops;
+		for (PathSet::iterator i = paths.begin(); i != paths.end(); ++i) {
+			Path *new_child = *i;
+			if (new_child->GetOrigin() == origin_id) {
+				PathViaMap::iterator via_it = next_hops.find(new_child->GetNode());
+				if (via_it == next_hops.end()) {
+					next_hops[new_child->GetNode()] = new_child;
+				} else {
+					Path *child = via_it->second;
+					uint new_flow = new_child->GetFlow();
+					child->AddFlow(new_flow);
+					new_child->ReduceFlow(new_flow);
+				}
+			}
+		}
+		bool found = false;
+		/* search the next hops for nodes we have already visited */
+		for (PathViaMap::iterator via_it = next_hops.begin();
+				via_it != next_hops.end(); ++via_it) {
+			Path *child = via_it->second;
+			if (child->GetFlow() > 0) {
+				/* push one child into the path vector and search this child's
+				 * children
+				 */
+				path[next_id] = child;
+				found = this->EliminateCycles(path, origin_id, child->GetNode()) || found;
+			}
+		}
+		/* All paths departing from this node have been searched. Mark as
+		 * resolved if no cycles found. If cycles were found further cycles
+		 * could be found in this branch, thus it has to be searched again next
+		 * time we spot it.
+		 */
+		path[next_id] = found ? NULL : invalid_path;
+		return found;
+	} else {
+		/* this node has already been visited => we have a cycle
+		 * backtrack to find the exact flow
+		 */
+		uint flow = this->FindCycleFlow(path, at_next_pos);
+		if (flow > 0) {
+			this->EliminateCycle(path, at_next_pos, flow);
+			return true;
+		} else {
+			return false;
+		}
+	}
+}
+
+/**
+ * Eliminate all cycles in the graph. Check paths starting at each node for
+ * potential cycles.
+ * @return If any cycles have been found and eliminated.
+ */
+bool MCF1stPass::EliminateCycles()
+{
+	bool cycles_found = false;
+	uint size = this->graph->GetSize();
+	PathVector path(size, NULL);
+	for (NodeID node = 0; node < size; ++node) {
+		/* starting at each node in the graph find all cycles involving this
+		 * node
+		 */
+		std::fill(path.begin(), path.end(), (Path *)NULL);
+		cycles_found |= this->EliminateCycles(path, node, node);
+	}
+	return cycles_found;
+}
+
+/**
+ * Run the first pass of the MCF calculation.
+ * @param graph Component to calculate.
+ */
+MCF1stPass::MCF1stPass(LinkGraphComponent *graph) : MultiCommodityFlow(graph)
+{
+	PathVector paths;
+	uint size = this->graph->GetSize();
+	uint accuracy = this->graph->GetSettings().accuracy;
+	bool more_loops = true;
+
+	while (more_loops) {
+		more_loops = false;
+
+		for (NodeID source = 0; source < size; ++source) {
+			/* first saturate the shortest paths */
+			this->Dijkstra<DistanceAnnotation>(source, paths, true);
+
+			for (NodeID dest = 0; dest < size; ++dest) {
+				Edge &edge = this->graph->GetEdge(source, dest);
+				if (edge.unsatisfied_demand > 0) {
+					Path *path = paths[dest];
+					assert(path != NULL);
+					/* generally only allow paths that don't exceed the
+					 * available capacity. But if no demand has been assigned
+					 * yet, make an exception and allow any valid path *once*.
+					 */
+					if (path->GetFreeCapacity() > 0 && this->PushFlow(edge, path,
+							accuracy, true) > 0) {
+						/* if a path has been found there is a chance we can
+						 * find more
+						 */
+						more_loops = (edge.unsatisfied_demand > 0);
+					} else if (edge.unsatisfied_demand == edge.demand &&
+							path->GetFreeCapacity() > INT_MIN) {
+						this->PushFlow(edge, path, accuracy, false);
+					}
+				}
+			}
+			this->CleanupPaths(source, paths);
+		}
+		if (!more_loops) more_loops = this->EliminateCycles();
+	}
+}
+
+/**
+ * Run the second pass of the MCF calculation which assigns all remaining
+ * demands to existing paths.
+ * @param graph Component to calculate.
+ */
+MCF2ndPass::MCF2ndPass(LinkGraphComponent *graph) : MultiCommodityFlow(graph)
+{
+	PathVector paths;
+	uint size = this->graph->GetSize();
+	uint accuracy = this->graph->GetSettings().accuracy;
+	bool demand_left = true;
+	while (demand_left) {
+		demand_left = false;
+		for (NodeID source = 0; source < size; ++source) {
+			this->Dijkstra<CapacityAnnotation>(source, paths, false);
+			for (NodeID dest = 0; dest < size; ++dest) {
+				Edge &edge = this->graph->GetEdge(source, dest);
+				Path *path = paths[dest];
+				if (edge.unsatisfied_demand > 0 && path->GetFreeCapacity() > INT_MIN) {
+					this->PushFlow(edge, path, accuracy, false);
+					if (edge.unsatisfied_demand > 0) demand_left = true;
+				}
+			}
+			this->CleanupPaths(source, paths);
+		}
+	}
+}
+
+/**
+ * Relation that creates a weak order without duplicates.
+ * Avoid accidentally deleting different paths of the same capacity/distance in
+ * a set. When the annotation is the same node IDs are compared, so there are
+ * no equal ranges.
+ * @tparam T Type to be compared on.
+ * @param x_anno First value.
+ * @param y_anno Second value.
+ * @param x Node id associated with the first value.
+ * @param y Node id associated with the second value.
+ */
+template <typename T>
+bool greater(T x_anno, T y_anno, NodeID x, NodeID y)
+{
+	if (x_anno > y_anno) {
+		return true;
+	} else if (x_anno < y_anno) {
+		return false;
+	} else {
+		return x > y;
+	}
+}
+
+/**
+ * Compare two capacity annotations.
+ * @param x First capacity annotation.
+ * @param y Second capacity annotation.
+ * @return If x is better than y.
+ */
+bool CapacityAnnotation::Comparator::operator()(const CapacityAnnotation *x,
+		const CapacityAnnotation *y) const
+{
+	return x != y && greater<int>(x->GetAnnotation(), y->GetAnnotation(),
+			x->GetNode(), y->GetNode());
+}
+
+/**
+ * Compare two distance annotations.
+ * @param x First distance annotation.
+ * @param y Second distance annotation.
+ * @return If x is better than y.
+ */
+bool DistanceAnnotation::Comparator::operator()(const DistanceAnnotation *x,
+		const DistanceAnnotation *y) const
+{
+	return x != y && !greater<uint>(x->GetAnnotation(), y->GetAnnotation(),
+			x->GetNode(), y->GetNode());
+}
diff --git a/src/linkgraph/mcf.h b/src/linkgraph/mcf.h
new file mode 100644
index 0000000..f1a6349
--- /dev/null
+++ b/src/linkgraph/mcf.h
@@ -0,0 +1,129 @@
+/** @file mcf.h Declaration of Multi-Commodity-Flow solver */
+
+#ifndef MCF_H_
+#define MCF_H_
+
+#include "linkgraph.h"
+#include <vector>
+
+/**
+ * Distance-based annotation for use in the Dijkstra algorithm. This is close
+ * to the original meaning of "annotation" in this context. Paths are rated
+ * according to the sum of distances of their edges.
+ */
+class DistanceAnnotation : public Path {
+public:
+
+	DistanceAnnotation(NodeID n, bool source = false) : Path(n, source) {}
+
+	bool IsBetter(const DistanceAnnotation *base, uint cap, int free_cap, uint dist) const;
+
+	/**
+	 * Return the actual value of the annotation, in this case the distance.
+	 * @return Distance.
+	 */
+	FORCEINLINE  uint GetAnnotation() const {return this->distance;}
+
+	struct Comparator {
+		bool operator()(const DistanceAnnotation *x, const DistanceAnnotation *y) const;
+	};
+};
+
+/**
+ * Capacity-based annotation for use in the Dijkstra algorithm. This annotation
+ * rates paths according to the maximum capacity of their edges. The Dijkstra
+ * algorithm still gives meaningful results like this as the capacity of a path
+ * can only decrease or stay the same if you add more edges.
+ */
+class CapacityAnnotation : public Path {
+public:
+
+	CapacityAnnotation(NodeID n, bool source = false) : Path(n, source) {}
+
+	bool IsBetter(const CapacityAnnotation *base, uint cap, int free_cap, uint dist) const;
+
+	/**
+	 * Return the actual value of the annotation, in this case the capacity.
+	 * @return Capacity.
+	 */
+	FORCEINLINE int GetAnnotation() const {return this->GetCapacityRatio();}
+
+	struct Comparator {
+		bool operator()(const CapacityAnnotation *x, const CapacityAnnotation *y) const;
+	};
+};
+
+
+typedef std::vector<Path *> PathVector;
+
+/**
+ * Multi-commodity flow calculating base class.
+ */
+class MultiCommodityFlow {
+protected:
+	MultiCommodityFlow(LinkGraphComponent *graph) : graph(graph) {}
+
+	template<class ANNOTATION> void Dijkstra(NodeID from, PathVector &paths, bool create_new_paths);
+
+	uint PushFlow(Edge &edge, Path *path, uint accuracy, bool positive_cap);
+
+	void CleanupPaths(NodeID source, PathVector &paths);
+
+	LinkGraphComponent *graph; ///< Component we're working with.
+};
+
+/**
+ * First pass of the MCF calculation. Saturates shortest paths first, creates
+ * new paths if needed, eliminates cycles. This calculation is of exponential
+ * complexity in the number of nodes but the constant factors are sufficiently
+ * small to make it usable for most real-life link graph components. You can
+ * deal with performance problems that might occur here in multiple ways:
+ * - The overall accuracy is used here to determine how much flow is assigned
+ *   in each loop. The lower the accuracy, the more flow is assigned, the less
+ *   loops it takes to assign all flow.
+ * - The short_path_saturation setting determines when this pass stops. The
+ *   lower you set it, the less flow will be assigned in this pass, the less
+ *   time it will take.
+ * - You can increase the recalculation interval to allow for longer running
+ *   times without creating lags.
+ */
+class MCF1stPass : public MultiCommodityFlow {
+private:
+	bool EliminateCycles();
+	bool EliminateCycles(PathVector &path, NodeID origin_id, NodeID next_id);
+	void EliminateCycle(PathVector &path, Path *cycle_begin, uint flow);
+	uint FindCycleFlow(const PathVector &path, const Path *cycle_begin);
+public:
+	MCF1stPass(LinkGraphComponent *graph);
+};
+
+/**
+ * Second pass of the MCF calculation. Saturates paths with most capacity left
+ * first and doesn't create any paths along edges that haven't been visited in
+ * the first pass. This is why it doesn't have to do any cycle detection and
+ * elimination. As cycle detection is the most intense problem in the first
+ * pass this pass is cheaper. The accuracy is used here, too.
+ */
+class MCF2ndPass : public MultiCommodityFlow {
+public:
+	MCF2ndPass(LinkGraphComponent *graph);
+};
+
+/**
+ * Link graph handler for MCF. Creates MultiCommodityFlow instance according to
+ * the template parameter.
+ */
+template<class Tpass>
+class MCFHandler : public ComponentHandler {
+public:
+
+	/**
+	 * Run the calculation.
+	 * @param graph Component to be calculated.
+	 */
+	virtual void Run(LinkGraphComponent *graph) {Tpass pass(graph);}
+
+	virtual ~MCFHandler() {}
+};
+
+#endif /* MCF_H_ */
diff --git a/src/misc.cpp b/src/misc.cpp
index 614ca40..f12d47d 100644
--- a/src/misc.cpp
+++ b/src/misc.cpp
@@ -47,6 +47,7 @@ void InitializeCompanies();
 void InitializeCheats();
 void InitializeNPF();
 void InitializeOldNames();
+void InitializeLinkGraphs();
 
 void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settings)
 {
@@ -102,6 +103,7 @@ void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settin
 #endif /* ENABLE_NETWORK */
 	InitializeAnimatedTiles();
 
+	InitializeLinkGraphs();
 	InitializeEconomy();
 
 	ResetObjectToPlace();
diff --git a/src/moving_average.cpp b/src/moving_average.cpp
new file mode 100644
index 0000000..9b840e6
--- /dev/null
+++ b/src/moving_average.cpp
@@ -0,0 +1,32 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.cpp Implementation of moving average functions. */
+
+#include "stdafx.h"
+#include "moving_average.h"
+#include "date_func.h"
+#include "station_base.h"
+
+/**
+ * Run moving average decrease function on all items from a pool which are due
+ * this tick. This function expects to be run every tick. It calls a method
+ * "RunAverages()" on all items for which id % DAY_TICKS == _tick_counter % DAY_TICKS.
+ * So each item is called once a day.
+ */
+template <class Titem> void RunAverages()
+{
+	for (uint id = _tick_counter % DAY_TICKS; id < Titem::GetPoolSize(); id += DAY_TICKS) {
+		Titem *item = Titem::GetIfValid(id);
+		if (item != NULL) item->RunAverages();
+	}
+}
+
+template class MovingAverage<uint>;
+template void RunAverages<Station>();
diff --git a/src/moving_average.h b/src/moving_average.h
new file mode 100644
index 0000000..3a4d2eb
--- /dev/null
+++ b/src/moving_average.h
@@ -0,0 +1,78 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file moving_average.h Utility class for moving averages. */
+
+#ifndef MOVING_AVERAGE_H_
+#define MOVING_AVERAGE_H_
+
+#include "settings_type.h"
+#include "core/math_func.hpp"
+
+/**
+ * Class implementing moving average functionality. An instance of this class
+ * can be used to get a meaningful (Monthly()) value from a moving average and
+ * it can be used to do the decrease operation.
+ * @tparam Tvalue Type supporting operator*(uint), operator/(uint),
+ * operator*=(uint) and operator/=(uint) with the usual semantics.
+ */
+template<class Tvalue>
+class MovingAverage {
+protected:
+	uint length;
+
+public:
+	/**
+	 * Create a moving average.
+	 * @param length Length to be used.
+	 */
+	FORCEINLINE MovingAverage(uint length) : length(length)
+	{
+		assert(this->length > 0);
+	}
+
+	/**
+	 * Get the length of this moving average.
+	 * @return Length.
+	 */
+	FORCEINLINE uint Length() const
+	{
+		return this->length;
+	}
+
+	/**
+	 * Get the current average for 30 "length units" from the given value.
+	 * Mind that no one forces you to decrease the average daily. If you
+	 * don't this is not a real "monthly" value. In any case it's not really
+	 * "monthly" as we don't account for months with different numbers of
+	 * days than 30. It doesn't matter, though. The point is to get an
+	 * average over a defined past timeframe.
+	 * @param value Raw moving average.
+	 * @return 30 "length unit" average.
+	 */
+	FORCEINLINE Tvalue Monthly(const Tvalue &value) const
+	{
+		return (value * 30) / (this->length);
+	}
+
+	/**
+	 * Decrease the given value using this moving average.
+	 * @param value Moving average value to be decreased.
+	 * @return Decreased value.
+	 */
+	FORCEINLINE Tvalue &Decrease(Tvalue &value) const
+	{
+		return value = (value * this->length) / (this->length + 1);
+	}
+};
+
+template<class Titem> void RunAverages();
+
+#endif /* MOVING_AVERAGE_H_ */
+
diff --git a/src/openttd.cpp b/src/openttd.cpp
index a0c16f9..6f4fbf4 100644
--- a/src/openttd.cpp
+++ b/src/openttd.cpp
@@ -66,6 +66,8 @@
 #include "town.h"
 #include "industry.h"
 
+#include "linkgraph/linkgraph.h"
+
 #include <stdarg.h>
 
 #include "table/strings.h"
@@ -292,6 +294,12 @@ static void ShutdownGame()
 	/* Uninitialize variables that are allocated dynamically */
 	GamelogReset();
 
+	/* Reinitialize the link graphs to forcibly stop the threads.
+	 * If a link graph thread is running while the link graph handlers are
+	 * deleted we get a crash.
+	 */
+	InitializeLinkGraphs();
+
 #ifdef ENABLE_NETWORK
 	free(_config_file);
 #endif
diff --git a/src/order_base.h b/src/order_base.h
index e2279da..6adb858 100644
--- a/src/order_base.h
+++ b/src/order_base.h
@@ -166,6 +166,9 @@ public:
 	inline void SetConditionValue(uint16 value) { SB(this->dest, 0, 11, value); }
 
 	bool ShouldStopAtStation(const Vehicle *v, StationID station) const;
+	bool CanLoadOrUnload() const;
+	bool CanLeaveWithCargo(bool has_cargo) const;
+
 	TileIndex GetLocation(const Vehicle *v) const;
 
 	/** Checks if this order has travel_time and if needed wait_time set. */
@@ -237,6 +240,14 @@ public:
 	inline Order *GetLastOrder() const { return this->GetOrderAt(this->num_orders - 1); }
 
 	/**
+	 * Get the order after the given one or the first one, if the given one is the
+	 * last one.
+	 * @param curr Order to find the next one for.
+	 * @return Next order.
+	 */
+	inline const Order *GetNext(const Order *curr) const { return (curr->next == NULL) ? this->GetFirstOrder() : curr->next; }
+
+	/**
 	 * Get number of orders in the order list.
 	 * @return number of orders in the chain.
 	 */
@@ -248,6 +259,9 @@ public:
 	 */
 	inline VehicleOrderID GetNumManualOrders() const { return this->num_manual_orders; }
 
+	StationID GetNextStoppingStation(const Vehicle *v) const;
+	const Order *GetNextStoppingOrder(const Vehicle *v, const Order *next, uint hops) const;
+
 	void InsertOrderAt(Order *new_order, int index);
 	void DeleteOrderAt(int index);
 	void MoveOrder(int from, int to);
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
index ad84b58..da174de 100644
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -22,6 +22,7 @@
 #include "vehicle_func.h"
 #include "depot_base.h"
 #include "core/pool_func.hpp"
+#include "core/random_func.hpp"
 #include "aircraft.h"
 #include "roadveh.h"
 #include "station_base.h"
@@ -354,6 +355,91 @@ Order *OrderList::GetOrderAt(int index) const
 }
 
 /**
+ * Get the next order which will make the given vehicle stop at a station
+ * or refit at a depot if its state doesn't change.
+ * @param v The vehicle in question.
+ * @param next The order to start looking at.
+ * @param hops The number of orders we have already looked at.
+ * @return Either an order or NULL if the vehicle won't stop anymore.
+ */
+const Order *OrderList::GetNextStoppingOrder(const Vehicle *v, const Order *next, uint hops) const
+{
+	if (hops > this->GetNumOrders() || next == NULL) return NULL;
+
+	if (next->IsType(OT_CONDITIONAL)) {
+		if (next->GetConditionVariable() == OCV_LOAD_PERCENTAGE) {
+			/* If the condition is based on load percentage we can't
+			 * tell what it will do. So we choose randomly.
+			 */
+			const Order *skip_to = this->GetNextStoppingOrder(v,
+					this->GetOrderAt(next->GetConditionSkipToOrder()),
+					hops + 1);
+			const Order *advance = this->GetNextStoppingOrder(v,
+					this->GetNext(next), hops + 1);
+			if (advance == NULL) {
+				return skip_to;
+			} else if (skip_to == NULL) {
+				return advance;
+			} else {
+				return RandomRange(2) == 0 ? skip_to : advance;
+			}
+		} else {
+			/* Otherwise we're optimistic and expect that the
+			 * condition value won't change until it's evaluated.
+			 */
+			VehicleOrderID skip_to = ProcessConditionalOrder(next, v);
+			if (skip_to != INVALID_VEH_ORDER_ID) {
+				return this->GetNextStoppingOrder(v,
+						this->GetOrderAt(skip_to), hops + 1);
+			} else {
+				return this->GetNextStoppingOrder(v,
+						this->GetNext(next), hops + 1);
+			}
+		}
+	}
+
+	if (next->IsType(OT_GOTO_DEPOT)) {
+		if (next->GetDepotActionType() == ODATFB_HALT) return NULL;
+		if (next->IsRefit()) return next;
+	}
+
+	if (!next->CanLoadOrUnload()) {
+		return this->GetNextStoppingOrder(v, this->GetNext(next), hops + 1);
+	}
+
+	return next;
+}
+
+/**
+ * Recursively determine the next deterministic station to stop at.
+ * @param v The vehicle we're looking at.
+ * @return Next stoppping station or INVALID_STATION.
+ */
+StationID OrderList::GetNextStoppingStation(const Vehicle *v) const
+{
+	
+	const Order *next = this->GetOrderAt(v->cur_implicit_order_index);
+	if (next == NULL) {
+		next = this->GetFirstOrder();
+		if (next == NULL) return INVALID_STATION;
+	} else {
+		next = this->GetNext(next);
+	}
+
+	uint hops = 0;
+	do {
+		next = this->GetNextStoppingOrder(v, next, ++hops);
+		/* Don't return a next stop if the vehicle has to unload everything. */
+		if (next == NULL || (next->GetDestination() == v->last_station_visited &&
+				(next->GetUnloadType() & (OUFB_TRANSFER | OUFB_UNLOAD)) == 0)) {
+			return INVALID_STATION;
+		}
+	} while (next->IsType(OT_GOTO_DEPOT) || next->GetDestination() == v->last_station_visited);
+
+	return next->GetDestination();
+}
+
+/**
  * Insert a new order into the order chain.
  * @param new_order is the order to insert into the chain.
  * @param index is the position where the order is supposed to be inserted.
@@ -899,6 +985,7 @@ static CommandCost DecloneOrder(Vehicle *dst, DoCommandFlag flags)
 	if (flags & DC_EXEC) {
 		DeleteVehicleOrders(dst);
 		InvalidateVehicleOrder(dst, -1);
+
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(dst->type), 0);
 	}
 	return CommandCost();
@@ -1032,11 +1119,11 @@ CommandCost CmdSkipToOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 	if (ret.Failed()) return ret;
 
 	if (flags & DC_EXEC) {
+		if (v->current_order.IsType(OT_LOADING)) v->LeaveStation();
+
 		v->cur_implicit_order_index = v->cur_real_order_index = sel_ord;
 		v->UpdateRealOrderIndex();
 
-		if (v->current_order.IsType(OT_LOADING)) v->LeaveStation();
-
 		InvalidateVehicleOrder(v, -2);
 	}
 
@@ -2070,3 +2157,23 @@ bool Order::ShouldStopAtStation(const Vehicle *v, StationID station) const
 			/* Finally do stop when there is no non-stop flag set for this type of station. */
 			!(this->GetNonStopType() & (is_dest_station ? ONSF_NO_STOP_AT_DESTINATION_STATION : ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS));
 }
+
+bool Order::CanLoadOrUnload() const
+{
+	return (this->IsType(OT_GOTO_STATION) || this->IsType(OT_IMPLICIT)) &&
+			(this->GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION) == 0 &&
+			((this->GetLoadType() & OLFB_NO_LOAD) == 0 ||
+			(this->GetUnloadType() & OUFB_NO_UNLOAD) == 0);
+}
+
+/**
+ * A vehicle can leave the current station with cargo if:
+ * 1. it can load cargo here OR
+ * 2a. it could leave the last station with cargo AND
+ * 2b. it doesn't have to unload all cargo here.
+ */
+bool Order::CanLeaveWithCargo(bool has_cargo) const
+{
+	return (this->GetLoadType() & OLFB_NO_LOAD) == 0 || (has_cargo &&
+			(this->GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) == 0);
+}
diff --git a/src/roadveh_cmd.cpp b/src/roadveh_cmd.cpp
index ff18089..901415d 100644
--- a/src/roadveh_cmd.cpp
+++ b/src/roadveh_cmd.cpp
@@ -262,6 +262,7 @@ CommandCost CmdBuildRoadVehicle(TileIndex tile, DoCommandFlag flags, const Engin
 		v->cargo_cap = rvi->capacity;
 
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 		v->engine_type = e->index;
 		v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
 
diff --git a/src/saveload/afterload.cpp b/src/saveload/afterload.cpp
index 2fc3e0e..6d0e2fc 100644
--- a/src/saveload/afterload.cpp
+++ b/src/saveload/afterload.cpp
@@ -2681,6 +2681,8 @@ bool AfterLoadGame()
 	InitializeWindowsAndCaches();
 	/* Restore the signals */
 	ResetSignalHandlers();
+
+	AfterLoadLinkGraphs();
 	return true;
 }
 
diff --git a/src/saveload/linkgraph_sl.cpp b/src/saveload/linkgraph_sl.cpp
new file mode 100644
index 0000000..97702b0
--- /dev/null
+++ b/src/saveload/linkgraph_sl.cpp
@@ -0,0 +1,159 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file linkgraph_sl.cpp Code handling saving and loading of link graphs */
+
+#include "../stdafx.h"
+#include "../linkgraph/linkgraph.h"
+#include "../linkgraph/demands.h"
+#include "../settings_internal.h"
+#include "saveload.h"
+#include <vector>
+
+const SettingDesc *GetSettingDescription(uint index);
+
+/**
+ * Get a SaveLoad array for a link graph. The settings struct is derived from
+ * the global settings saveload array. The exact entries are calculated when the function
+ * is called the first time.
+ * It's necessary to keep a copy of the settings for each link graph so that you can
+ * change the settings while in-game and still not mess with current link graph runs.
+ * Of course the settings have to be saved and loaded, too, to avoid desyncs.
+ * @return Array of SaveLoad structs.
+ */
+const SaveLoad *GetLinkGraphDesc()
+{
+	static std::vector<SaveLoad> saveloads;
+	static const char *prefix = "linkgraph.";
+
+	/* Build the SaveLoad array on first call and don't touch it later on */
+	if (saveloads.empty()) {
+		size_t offset_gamesettings = cpp_offsetof(GameSettings, linkgraph);
+		size_t offset_component = cpp_offsetof(LinkGraph, settings);
+
+		size_t prefixlen = strlen(prefix);
+
+		int setting = 0;
+		const SettingDesc *desc = GetSettingDescription(setting);
+		while (desc->save.cmd != SL_END) {
+			if (desc->desc.name != NULL && strncmp(desc->desc.name, prefix, prefixlen) == 0) {
+				SaveLoad sl = desc->save;
+				char *&address = reinterpret_cast<char *&>(sl.address);
+				address -= offset_gamesettings;
+				address += offset_component;
+				saveloads.push_back(sl);
+			}
+			desc = GetSettingDescription(++setting);
+		}
+
+		const SaveLoad component_desc[] = {
+			SLE_CONDVAR(LinkGraph, num_nodes,          SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, index,              SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, current_station_id, SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_CONDVAR(LinkGraph, cargo,              SLE_UINT8,  SL_COMPONENTS, SL_MAX_VERSION),
+			SLE_END()
+		};
+
+		int i = 0;
+		do {
+			saveloads.push_back(component_desc[i++]);
+		} while (saveloads.back().cmd != SL_END);
+	}
+
+	return &saveloads[0];
+}
+
+/* Edges and nodes are saved in the correct order, so we don't need to save their ids. */
+
+/**
+ * SaveLoad desc for a link graph node.
+ */
+static const SaveLoad _node_desc[] = {
+	 SLE_CONDVAR(Node, supply,    SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Node, demand,    SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Node, station,   SLE_UINT16, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_END()
+};
+
+/**
+ * SaveLoad desc for a link graph edge.
+ */
+static const SaveLoad _edge_desc[] = {
+	 SLE_CONDVAR(Edge, distance,  SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Edge, capacity,  SLE_UINT32, SL_COMPONENTS, SL_MAX_VERSION),
+	 SLE_CONDVAR(Edge, next_edge, SLE_UINT32,        SL_MCF, SL_MAX_VERSION),
+	 SLE_END()
+};
+
+/**
+ * Save/load a component of a link graph
+ * @param comp the component to be saved or loaded
+ */
+static void SaveLoad_LinkGraphComponent(LinkGraphComponent &comp)
+{
+	uint size = comp.GetSize();
+	for (NodeID from = 0; from < size; ++from) {
+		Node *node = &comp.GetNode(from);
+		SlObject(node, _node_desc);
+		for (NodeID to = 0; to < size; ++to) {
+			SlObject(&comp.GetEdge(from, to), _edge_desc);
+		}
+	}
+}
+
+/**
+ * Save all link graphs.
+ */
+static void DoSave_LGRP(void *)
+{
+	for (CargoID cargo = 0; cargo < NUM_CARGO; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		SlObject(&graph, GetLinkGraphDesc());
+		SaveLoad_LinkGraphComponent(graph);
+	}
+}
+
+/**
+ * Load all link graphs.
+ */
+static void Load_LGRP()
+{
+	for (CargoID cargo = 0; cargo < NUM_CARGO; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		assert(graph.GetSize() == 0);
+		SlObject(&graph, GetLinkGraphDesc());
+		graph.SetSize();
+		SaveLoad_LinkGraphComponent(graph);
+		for (uint i = 0; i < graph.GetSize(); ++i) {
+			Node &node = graph.GetNode(i);
+			node.undelivered_supply = node.supply;
+		}
+	}
+}
+
+/**
+ * Spawn the threads for running link graph calculations.
+ * Has to be done after loading as the cargo classes might have changed.
+ */
+void AfterLoadLinkGraphs()
+{
+	for (CargoID cargo = 0; cargo < NUM_CARGO; ++cargo) {
+		LinkGraph &graph = _link_graphs[cargo];
+		if (graph.GetSize() > 0) graph.SpawnThread();
+	}
+}
+
+static void Save_LGRP()
+{
+	SlAutolength((AutolengthProc*)DoSave_LGRP, NULL);
+}
+
+extern const ChunkHandler _linkgraph_chunk_handlers[] = {
+	{ 'LGRP', Save_LGRP, Load_LGRP, NULL, NULL, CH_LAST},
+};
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
index c2c1588..733d96b 100644
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -229,7 +229,7 @@
  *  162   22713
  *  163   22767
  */
-extern const uint16 SAVEGAME_VERSION = 163; ///< Current savegame version of OpenTTD.
+extern const uint16 SAVEGAME_VERSION = SL_FLOWMAP; ///< Current savegame version of OpenTTD.
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
@@ -405,6 +405,7 @@ extern const ChunkHandler _group_chunk_handlers[];
 extern const ChunkHandler _cargopacket_chunk_handlers[];
 extern const ChunkHandler _autoreplace_chunk_handlers[];
 extern const ChunkHandler _labelmaps_chunk_handlers[];
+extern const ChunkHandler _linkgraph_chunk_handlers[];
 extern const ChunkHandler _airport_chunk_handlers[];
 extern const ChunkHandler _object_chunk_handlers[];
 extern const ChunkHandler _persistent_storage_chunk_handlers[];
@@ -436,6 +437,7 @@ static const ChunkHandler * const _chunk_handlers[] = {
 	_cargopacket_chunk_handlers,
 	_autoreplace_chunk_handlers,
 	_labelmaps_chunk_handlers,
+	_linkgraph_chunk_handlers,
 	_airport_chunk_handlers,
 	_object_chunk_handlers,
 	_persistent_storage_chunk_handlers,
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
index db3af4d..7567d6d 100644
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -85,9 +85,6 @@ enum SLRefType {
 	REF_STORAGE       = 9, ///< Load/save a reference to a persistent storage.
 };
 
-/** Highest possible savegame version. */
-#define SL_MAX_VERSION 255
-
 /** Flags of a chunk. */
 enum ChunkType {
 	CH_RIFF         =  0,
@@ -544,4 +541,20 @@ bool SaveloadCrashWithMissingNewGRFs();
 extern char _savegame_format[8];
 extern bool _do_autosave;
 
+/**
+ * Save/load versions used for the various branches.
+ * SL_TRUNK is always the current trunk version.
+ */
+enum SaveLoadVersions {
+	SL_TRUNK = 163,
+	SL_CAPACITIES = SL_TRUNK + 20,
+	SL_COMPONENTS,
+	SL_DEMANDS = SL_COMPONENTS + 20,
+	SL_MCF,
+	SL_FLOWMAP,
+
+	/** Highest possible savegame version. */
+	SL_MAX_VERSION = 255
+};
+
 #endif /* SAVELOAD_H */
diff --git a/src/saveload/saveload_internal.h b/src/saveload/saveload_internal.h
index b400861..4bf5646 100644
--- a/src/saveload/saveload_internal.h
+++ b/src/saveload/saveload_internal.h
@@ -30,6 +30,7 @@ void AfterLoadVehicles(bool part_of_load);
 void AfterLoadStations();
 void AfterLoadRoadStops();
 void AfterLoadLabelMaps();
+void AfterLoadLinkGraphs();
 void UpdateHousesAndTowns();
 
 void UpdateOldAircraft();
diff --git a/src/saveload/station_sl.cpp b/src/saveload/station_sl.cpp
index 78277d4..82de190 100644
--- a/src/saveload/station_sl.cpp
+++ b/src/saveload/station_sl.cpp
@@ -225,6 +225,8 @@ static const SaveLoad _old_station_desc[] = {
 };
 
 static uint16 _waiting_acceptance;
+static uint16 _num_links;
+static uint32 _num_flows;
 static uint16 _cargo_source;
 static uint32 _cargo_source_xy;
 static uint16 _cargo_days;
@@ -237,6 +239,46 @@ static const SaveLoad _station_speclist_desc[] = {
 	SLE_END()
 };
 
+static StationID _station_id;
+
+/**
+ * Wrapper function to get the LinkStat's internal structure while
+ * some of the variables are private.
+ * @return Saveload description for LinkStat.
+ */
+const SaveLoad *GetLinkStatDesc()
+{
+	static const SaveLoad linkstat_desc[] = {
+		SLEG_VAR(             _station_id,         SLE_UINT16),
+		 SLE_VAR(LinkStat,    length,              SLE_UINT32),
+		 SLE_VAR(LinkStat,    capacity,            SLE_UINT32),
+		 SLE_VAR(LinkStat,    timeout,             SLE_UINT32),
+		 SLE_VAR(LinkStat,    usage,               SLE_UINT32),
+		 SLE_END()
+	};
+
+	return linkstat_desc;
+}
+
+/**
+ * Wrapper function to get the FlowStats's internal structure while
+ * some of the variables are private.
+ * @return the saveload description for FlowStat.
+ */
+const SaveLoad *GetFlowStatDesc()
+{
+	static const SaveLoad _flowstat_desc[] = {
+		SLEG_CONDVAR(             _station_id,         SLE_UINT16,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    via,                 SLE_UINT16,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    length,              SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    planned,             SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(FlowStat,    sent,                SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_END()
+	};
+
+	return _flowstat_desc;
+}
+
 /**
  * Wrapper function to get the GoodsEntry's internal structure while
  * some of the variables itself are private.
@@ -260,7 +302,11 @@ const SaveLoad *GetGoodsDesc()
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_INT64,                  65, 67),
 		 SLE_CONDVAR(GoodsEntry, amount_fract,        SLE_UINT8,                 150, SL_MAX_VERSION),
 		 SLE_CONDLST(GoodsEntry, cargo.packets,       REF_CARGO_PACKET,           68, SL_MAX_VERSION),
-
+		 SLE_CONDVAR(GoodsEntry, supply,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, supply_new,          SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_flows,          SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, last_component,      SLE_UINT16,      SL_COMPONENTS, SL_MAX_VERSION),
 		SLE_END()
 	};
 
@@ -410,7 +456,24 @@ static void RealSave_STNN(BaseStation *bst)
 	if (!waypoint) {
 		Station *st = Station::From(bst);
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
+			_num_links = (uint16)st->goods[i].link_stats.size();
+			_num_flows = 0;
+			for (FlowStatMap::const_iterator it(st->goods[i].flows.begin()); it != st->goods[i].flows.end(); ++it) {
+				_num_flows += (uint32)it->second.size();
+			}
 			SlObject(&st->goods[i], GetGoodsDesc());
+			for (LinkStatMap::const_iterator it(st->goods[i].link_stats.begin()); it != st->goods[i].link_stats.end(); ++it) {
+				_station_id = it->first;
+				LinkStat ls(it->second); // make a copy to avoid constness problems
+				SlObject(&ls, GetLinkStatDesc());
+			}
+			for (FlowStatMap::const_iterator outer_it(st->goods[i].flows.begin()); outer_it != st->goods[i].flows.end(); ++outer_it) {
+				_station_id = outer_it->first;
+				for (FlowStatSet::const_iterator inner_it(outer_it->second.begin()); inner_it != outer_it->second.end(); ++inner_it) {
+					FlowStat fs(*inner_it); // make a copy to avoid constness problems
+					SlObject(&fs, GetFlowStatDesc());
+				}
+			}
 		}
 	}
 
@@ -452,6 +515,17 @@ static void Load_STNN()
 
 			for (CargoID i = 0; i < NUM_CARGO; i++) {
 				SlObject(&st->goods[i], GetGoodsDesc());
+				LinkStat ls(1);
+				for (uint16 j = 0; j < _num_links; ++j) {
+					SlObject(&ls, GetLinkStatDesc());
+					assert(ls.IsValid());
+					st->goods[i].link_stats.insert(std::make_pair(_station_id, ls));
+				}
+				FlowStat fs;
+				for (uint32 j = 0; j < _num_flows; ++j) {
+					SlObject(&fs, GetFlowStatDesc());
+					st->goods[i].flows[_station_id].insert(fs);
+				}
 			}
 		}
 
diff --git a/src/saveload/vehicle_sl.cpp b/src/saveload/vehicle_sl.cpp
index 4dc0a7f..d03a593 100644
--- a/src/saveload/vehicle_sl.cpp
+++ b/src/saveload/vehicle_sl.cpp
@@ -499,6 +499,7 @@ const SaveLoad *GetVehicleDescription(VehicleType vt)
 		     SLE_VAR(Vehicle, vehstatus,             SLE_UINT8),
 		 SLE_CONDVAR(Vehicle, last_station_visited,  SLE_FILE_U8  | SLE_VAR_U16,   0,   4),
 		 SLE_CONDVAR(Vehicle, last_station_visited,  SLE_UINT16,                   5, SL_MAX_VERSION),
+		 SLE_CONDVAR(Vehicle, last_loading_station,  SLE_UINT16,       SL_CAPACITIES, SL_MAX_VERSION),
 
 		     SLE_VAR(Vehicle, cargo_type,            SLE_UINT8),
 		 SLE_CONDVAR(Vehicle, cargo_subtype,         SLE_UINT8,                   35, SL_MAX_VERSION),
@@ -507,6 +508,7 @@ const SaveLoad *GetVehicleDescription(VehicleType vt)
 		SLEG_CONDVAR(         _cargo_source,         SLE_UINT16,                   7,  67),
 		SLEG_CONDVAR(         _cargo_source_xy,      SLE_UINT32,                  44,  67),
 		     SLE_VAR(Vehicle, cargo_cap,             SLE_UINT16),
+		 SLE_CONDVAR(Vehicle, refit_cap,             SLE_UINT16,       SL_CAPACITIES, SL_MAX_VERSION),
 		SLEG_CONDVAR(         _cargo_count,          SLE_UINT16,                   0,  67),
 		 SLE_CONDLST(Vehicle, cargo.packets,         REF_CARGO_PACKET,            68, SL_MAX_VERSION),
 		 SLE_CONDVAR(Vehicle, cargo_age_counter,     SLE_UINT16,                 162, SL_MAX_VERSION),
@@ -793,6 +795,8 @@ void Load_VEHS()
 			v->last_station_visited = INVALID_STATION;
 		}
 
+		if (IsSavegameVersionBefore(SL_CAPACITIES)) v->last_loading_station = INVALID_STATION;
+
 		if (IsSavegameVersionBefore(5)) {
 			/* Convert the current_order.type (which is a mix of type and flags, because
 			 *  in those versions, they both were 4 bits big) to type and flags */
diff --git a/src/settings.cpp b/src/settings.cpp
index 0cffb63..bd5b82a 100644
--- a/src/settings.cpp
+++ b/src/settings.cpp
@@ -1632,7 +1632,7 @@ void DeleteGRFPresetFromConfig(const char *config_name)
 	delete ini;
 }
 
-static const SettingDesc *GetSettingDescription(uint index)
+const SettingDesc *GetSettingDescription(uint index)
 {
 	if (index >= lengthof(_settings)) return NULL;
 	return &_settings[index];
diff --git a/src/settings_gui.cpp b/src/settings_gui.cpp
index dbf537f..a0d1e56 100644
--- a/src/settings_gui.cpp
+++ b/src/settings_gui.cpp
@@ -1488,6 +1488,20 @@ static SettingEntry _settings_economy[] = {
 /** Economy sub-page */
 static SettingsPage _settings_economy_page = {_settings_economy, lengthof(_settings_economy)};
 
+static SettingEntry _settings_linkgraph[] = {
+	SettingEntry("linkgraph.recalc_interval"),
+	SettingEntry("linkgraph.distribution_pax"),
+	SettingEntry("linkgraph.distribution_mail"),
+	SettingEntry("linkgraph.distribution_armoured"),
+	SettingEntry("linkgraph.distribution_default"),
+	SettingEntry("linkgraph.accuracy"),
+	SettingEntry("linkgraph.demand_distance"),
+	SettingEntry("linkgraph.demand_size"),
+	SettingEntry("linkgraph.short_path_saturation"),
+};
+/** Linkgraph sub-page */
+static SettingsPage _settings_linkgraph_page = {_settings_linkgraph, lengthof(_settings_linkgraph)};
+
 static SettingEntry _settings_ai_npc[] = {
 	SettingEntry("ai.ai_in_multiplayer"),
 	SettingEntry("ai.ai_disable_veh_train"),
@@ -1580,6 +1594,7 @@ static SettingEntry _settings_main[] = {
 	SettingEntry(&_settings_vehicles_page,     STR_CONFIG_SETTING_VEHICLES),
 	SettingEntry(&_settings_stations_page,     STR_CONFIG_SETTING_STATIONS),
 	SettingEntry(&_settings_economy_page,      STR_CONFIG_SETTING_ECONOMY),
+	SettingEntry(&_settings_linkgraph_page,    STR_CONFIG_SETTING_LINKGRAPH),
 	SettingEntry(&_settings_ai_page,           STR_CONFIG_SETTING_AI),
 };
 
diff --git a/src/settings_type.h b/src/settings_type.h
index 12063f1..9aa4eaa 100644
--- a/src/settings_type.h
+++ b/src/settings_type.h
@@ -17,6 +17,8 @@
 #include "transport_type.h"
 #include "network/core/config.h"
 #include "company_type.h"
+#include "cargotype.h"
+#include "linkgraph/linkgraph_type.h"
 #include "openttd.h"
 
 /** Available industry map generation densities. */
@@ -410,6 +412,30 @@ struct EconomySettings {
 	bool   allow_town_level_crossings;       ///< towns are allowed to build level crossings
 };
 
+struct LinkGraphSettings {
+	uint16 recalc_interval;                     ///< minimum interval (in days) between subsequent calculations of components in the same link graph
+	DistributionTypeByte distribution_pax;      ///< distribution type for passengers
+	DistributionTypeByte distribution_mail;     ///< distribution type for mail
+	DistributionTypeByte distribution_armoured; ///< distribution type for armoured cargo class
+	DistributionTypeByte distribution_default;  ///< distribution type for all other goods
+	uint8 accuracy;                             ///< accuracy when calculating things on the link graph. low accuracy => low running time
+	uint8 demand_size;                          ///< influence of supply ("station size") on the demand function
+	uint8 demand_distance;                      ///< influence of distance between stations on the demand function
+	uint8 short_path_saturation;                ///< percentage up to which short paths are saturated before saturating most capacious paths
+
+	FORCEINLINE DistributionType GetDistributionType(CargoID cargo) const {
+		if (IsCargoInClass(cargo, CC_PASSENGERS)) {
+			return this->distribution_pax;
+		} else if (IsCargoInClass(cargo, CC_MAIL)) {
+			return this->distribution_mail;
+		} else if (IsCargoInClass(cargo, CC_ARMOURED)) {
+			return this->distribution_armoured;
+		} else {
+			return this->distribution_default;
+		}
+	}
+};
+
 /** Settings related to stations. */
 struct StationSettings {
 	bool   modified_catchment;               ///< different-size catchment areas
@@ -448,6 +474,7 @@ struct GameSettings {
 	OrderSettings        order;              ///< settings related to orders
 	VehicleSettings      vehicle;            ///< options for vehicles
 	EconomySettings      economy;            ///< settings to change the economy
+	LinkGraphSettings    linkgraph;          ///< settings for link graph calculations
 	StationSettings      station;            ///< settings related to station management
 	LocaleSettings       locale;             ///< settings related to used currency/unit system in the current game
 };
diff --git a/src/ship_cmd.cpp b/src/ship_cmd.cpp
index 66f7746..99a9be6 100644
--- a/src/ship_cmd.cpp
+++ b/src/ship_cmd.cpp
@@ -654,6 +654,7 @@ CommandCost CmdBuildShip(TileIndex tile, DoCommandFlag flags, const Engine *e, u
 		v->cargo_cap = svi->capacity;
 
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 		v->engine_type = e->index;
 
 		v->reliability = e->reliability;
diff --git a/src/station.cpp b/src/station.cpp
index a3df6fe..b1f0a6b 100644
--- a/src/station.cpp
+++ b/src/station.cpp
@@ -64,7 +64,8 @@ Station::Station(TileIndex tile) :
 }
 
 /**
- * Clean up a station by clearing vehicle orders and invalidating windows.
+ * Clean up a station by clearing vehicle orders, invalidating windows and
+ * removing link stats.
  * Aircraft-Hangar orders need special treatment here, as the hangars are
  * actually part of a station (tiletype is STATION), but the order type
  * is OT_GOTO_DEPOT.
@@ -88,12 +89,24 @@ Station::~Station()
 		if (a->targetairport == this->index) a->targetairport = INVALID_STATION;
 	}
 
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID c = 0; c < NUM_CARGO; ++c) {
+			GoodsEntry &ge = st->goods[c];
+			ge.link_stats.erase(this->index);
+			DeleteStaleFlows(st->index, c, this->index);
+		}
+	}
+
 	Vehicle *v;
 	FOR_ALL_VEHICLES(v) {
 		/* Forget about this station if this station is removed */
 		if (v->last_station_visited == this->index) {
 			v->last_station_visited = INVALID_STATION;
 		}
+		if (v->last_loading_station == this->index) {
+			v->last_loading_station = INVALID_STATION;
+		}
 	}
 
 	/* Clear the persistent storage. */
diff --git a/src/station_base.h b/src/station_base.h
index 2a7fedb..39adc23 100644
--- a/src/station_base.h
+++ b/src/station_base.h
@@ -16,7 +16,11 @@
 #include "newgrf_airport.h"
 #include "cargopacket.h"
 #include "industry_type.h"
+#include "linkgraph/linkgraph_type.h"
 #include "newgrf_storage.h"
+#include "moving_average.h"
+#include <map>
+#include <set>
 
 typedef Pool<BaseStation, StationID, 32, 64000> StationPool;
 extern StationPool _station_pool;
@@ -24,6 +28,266 @@ extern StationPool _station_pool;
 static const byte INITIAL_STATION_RATING = 175;
 
 /**
+ * Link statistics. They include figures for capacity and usage of a link. Both
+ * are moving averages which are increased for every vehicle arriving at the
+ * destination station and decreased in regular intervals. Additionally while a
+ * vehicle is loading at the source station part of the capacity is frozen and
+ * prevented from being decreased. This is done so that the link won't break
+ * down all the time when the typical "full load" order is used.
+ */
+class LinkStat : private MovingAverage<uint> {
+private:
+	/**
+	 * Capacity of the link.
+	 * This is a moving average. Use MovingAverage::Monthly() to get a meaningful value.
+	 */
+	uint capacity;
+
+	/**
+	 * Time until the link is removed. Decreases exponentially.
+	 */
+	uint timeout;
+
+	/**
+	 * Usage of the link.
+	 * This is a moving average. Use MovingAverage::Monthly() to get a meaningful value.
+	 */
+	uint usage;
+
+public:
+	/**
+	 * Minimum length of moving averages for capacity and usage.
+	 */
+	static const uint MIN_AVERAGE_LENGTH = 48;
+
+	friend const SaveLoad *GetLinkStatDesc();
+
+	/**
+	 * We don't allow creating a link stat without a timeout/length.
+         */
+	LinkStat() : MovingAverage<uint>(0) {NOT_REACHED();}
+
+	/**
+	 * Create a link stat with at least a distance.
+         * @param distance Length for the moving average and link timeout.
+         * @param capacity Initial capacity of the link.
+         * @param usage Initial usage of the link.
+         */
+	FORCEINLINE LinkStat(uint distance, uint capacity = 1, uint usage = 0) :
+		MovingAverage<uint>(distance), capacity(capacity), timeout(distance), usage(usage)
+	{
+		assert(this->usage <= this->capacity);
+	}
+
+	/**
+	 * Reset everything to 0.
+	 */
+	FORCEINLINE void Clear()
+	{
+		this->capacity = 1;
+		this->usage = 0;
+		this->timeout = this->length;
+	}
+
+	/**
+	 * Apply the moving averages to usage and capacity.
+	 */
+	FORCEINLINE void Decrease()
+	{
+		this->MovingAverage<uint>::Decrease(this->usage);
+		this->timeout = this->timeout * MIN_AVERAGE_LENGTH / (MIN_AVERAGE_LENGTH + 1);
+		this->capacity = max(this->MovingAverage<uint>::Decrease(this->capacity), (uint)1);
+		assert(this->usage <= this->capacity);
+	}
+
+	/**
+	 * Get an estimate of the current the capacity by calculating the moving average.
+	 * @return Capacity.
+	 */
+	FORCEINLINE uint Capacity() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->capacity);
+	}
+
+	/**
+	 * Get an estimage of the current usage by calculating the moving average.
+	 * @return Usage.
+	 */
+	FORCEINLINE uint Usage() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->usage);
+	}
+
+	/**
+	 * Add some capacity and usage.
+	 * @param capacity Additional capacity.
+	 * @param usage Additional usage.
+	 */
+	FORCEINLINE void Increase(uint capacity, uint usage)
+	{
+		this->timeout = this->length;
+		this->capacity += capacity;
+		this->usage += usage;
+		assert(this->usage <= this->capacity);
+	}
+
+	/**
+	 * Reset the timeout and make sure there is at least a minimum capacity.
+         */
+	FORCEINLINE void Refresh(uint min_capacity)
+	{
+		this->capacity = max(this->capacity, min_capacity);
+		this->timeout = this->length;
+	}
+
+	/**
+	 * Check if the timeout has hit.
+	 * @return If timeout is > 0.
+	 */
+	FORCEINLINE bool IsValid() const
+	{
+		return this->timeout > 0;
+	}
+};
+
+/**
+ * Flow statistics telling how much flow should be and was sent along a link.
+ */
+class FlowStat : private MovingAverage<uint> {
+private:
+	uint planned;  ///< Cargo planned to be sent along a link each "month" (30 units of time, determined by moving average).
+	uint sent;     ///< Moving average of cargo being sent.
+	StationID via; ///< Other end of the link. Can be this station, then it means "deliver here".
+
+public:
+	friend const SaveLoad *GetFlowStatDesc();
+
+	/**
+	 * Create a flow stat.
+	 * @param distance Distance to be used as length of moving average.
+	 * @param st Remote station.
+	 * @param planned Cargo planned to be sent along this link.
+	 * @param sent Cargo already sent along this link.
+	 */
+	FORCEINLINE FlowStat(uint distance = 1, StationID st = INVALID_STATION, uint planned = 0, uint sent = 0) :
+		MovingAverage<uint>(distance), planned(planned), sent(sent), via(st) {}
+
+	/**
+	 * Clone an existing flow stat, changing the plan.
+	 * @param prev Flow stat to be cloned.
+	 * @param new_plan New value for planned.
+	 */
+	FORCEINLINE FlowStat(const FlowStat &prev, uint new_plan) :
+		MovingAverage<uint>(prev.length), planned(new_plan), sent(prev.sent), via(prev.via) {}
+
+	/**
+	 * Prevents one copy operation when moving a flowstat from one set to another and decreasing it at the same time.
+	 */
+	FORCEINLINE FlowStat GetDecreasedCopy() const
+	{
+		FlowStat ret(this->length, this->via, this->planned, this->sent);
+		this->MovingAverage<uint>::Decrease(ret.sent);
+		return ret;
+	}
+
+	/**
+	 * Increase the sent value.
+	 * @param sent Amount to be added to sent.
+	 */
+	FORCEINLINE void Increase(uint sent)
+	{
+		this->sent += sent;
+	}
+
+	/**
+	 * Get an estimate of cargo sent along this link during the last 30 time units.
+	 * @return Cargo sent along this link.
+	 */
+	FORCEINLINE uint Sent() const
+	{
+		return this->MovingAverage<uint>::Monthly(sent);
+	}
+
+	/**
+	 * Get the amount of cargo planned to be sent along this link in 30 time units.
+	 * @return Cargo planned to be sent.
+	 */
+	FORCEINLINE uint Planned() const
+	{
+		return this->planned;
+	}
+
+	/**
+	 * Get the station this link is connected to.
+	 * @return Remote station.
+	 */
+	FORCEINLINE StationID Via() const
+	{
+		return this->via;
+	}
+
+	/**
+	 * Comparator for two flow stats for ordering them in a way that makes
+	 * the next flow stat to sent cargo for show up as first element.
+	 */
+	struct Comparator {
+		/**
+		 * Comparator function. Decides by planned - sent or via, if those
+		 * are equal.
+		 * @param x First flow stat.
+		 * @param y Second flow stat.
+		 * @return True if x.planned - x.sent is greater than y.planned - y.sent.
+		 */
+		bool operator()(const FlowStat &x, const FlowStat &y) const
+		{
+			int diff_x = (int)x.Planned() - (int)x.Sent();
+			int diff_y = (int)y.Planned() - (int)y.Sent();
+			if (diff_x != diff_y) {
+				return diff_x > diff_y;
+			} else {
+				return x.Via() > y.Via();
+			}
+		}
+	};
+
+	/**
+	 * Add up two flow stats' planned and sent figures and assign via from the other one to this one.
+	 * @param other Flow stat to add to this one.
+	 * @return This flow stat.
+	 */
+	FORCEINLINE FlowStat &operator+=(const FlowStat &other)
+	{
+		assert(this->via == INVALID_STATION || other.via == INVALID_STATION || this->via == other.via);
+		if (other.via != INVALID_STATION) this->via = other.via;
+		this->planned += other.planned;
+		uint sent = this->sent + other.sent;
+		if (sent > 0) {
+			this->length = (this->length * this->sent + other.length * other.sent) / sent;
+			assert(this->length > 0);
+		}
+		this->sent = sent;
+		return *this;
+	}
+
+	/**
+	 * Clear this flow stat.
+	 */
+	FORCEINLINE void Clear()
+	{
+		this->planned = 0;
+		this->sent = 0;
+		this->via = INVALID_STATION;
+	}
+};
+
+typedef std::set<FlowStat, FlowStat::Comparator> FlowStatSet; ///< Percentage of flow to be sent via specified station (or consumed locally).
+
+typedef std::map<StationID, LinkStat> LinkStatMap;
+typedef std::map<StationID, FlowStatSet> FlowStatMap; ///< Flow descriptions by origin stations.
+
+uint GetMovingAverageLength(const Station *from, const Station *to);
+
+/**
  * Stores station stats for a single cargo.
  */
 struct GoodsEntry {
@@ -42,7 +306,10 @@ struct GoodsEntry {
 		days_since_pickup(255),
 		rating(INITIAL_STATION_RATING),
 		last_speed(0),
-		last_age(255)
+		last_age(255),
+		supply(0),
+		supply_new(0),
+		last_component(INVALID_LINKGRAPH_COMPONENT)
 	{}
 
 	byte acceptance_pickup; ///< Status of this cargo, see #GoodsEntryStatus.
@@ -52,6 +319,12 @@ struct GoodsEntry {
 	byte last_age;          ///< Age in years of the last vehicle that picked up this cargo.
 	byte amount_fract;      ///< Fractional part of the amount in the cargo list
 	StationCargoList cargo; ///< The cargo packets of cargo waiting in this station
+	uint supply;            ///< Cargo supplied last month.
+	uint supply_new;        ///< Cargo supplied so far this month.
+	FlowStatMap flows;      ///< Planned flows through this station.
+	LinkStatMap link_stats; ///< Capacities and usage statistics for outgoing links.
+	LinkGraphComponentID last_component; ///< Component this station was last part of in this cargo's link graph.
+	FlowStat GetSumFlowVia(StationID via) const;
 };
 
 /** All airport-related information. Only valid if tile != INVALID_TILE. */
@@ -257,6 +530,8 @@ public:
 	/* virtual */ uint32 GetNewGRFVariable(const ResolverObject *object, byte variable, byte parameter, bool *available) const;
 
 	/* virtual */ void GetTileArea(TileArea *ta, StationType type) const;
+
+	void RunAverages();
 };
 
 #define FOR_ALL_STATIONS(var) FOR_ALL_BASE_STATIONS_OF_TYPE(Station, var)
diff --git a/src/station_cmd.cpp b/src/station_cmd.cpp
index 177d2c7..1ed4c25 100644
--- a/src/station_cmd.cpp
+++ b/src/station_cmd.cpp
@@ -46,6 +46,7 @@
 #include "debug.h"
 #include "core/random_func.hpp"
 #include "company_base.h"
+#include "moving_average.h"
 #include "table/airporttile_ids.h"
 #include "newgrf_airporttiles.h"
 #include "order_backup.h"
@@ -3179,6 +3180,138 @@ static void UpdateStationRating(Station *st)
 	}
 }
 
+/**
+ * Delete all flows at a station for specific cargo and destination.
+ * @param at Station to delete flows from.
+ * @param c_id Cargo for which flows shall be deleted.
+ * @param to Remote station of flows to be deleted.
+ */
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to)
+{
+	FlowStatMap &flows = Station::Get(at)->goods[c_id].flows;
+	for (FlowStatMap::iterator f_it = flows.begin(); f_it != flows.end();) {
+		FlowStatSet &s_flows = f_it->second;
+		for (FlowStatSet::iterator s_it = s_flows.begin(); s_it != s_flows.end();) {
+			if (s_it->Via() == to) {
+				s_flows.erase(s_it++);
+				break; // There can only be one flow stat for this remote station in each set.
+			} else {
+				++s_it;
+			}
+		}
+		if (s_flows.empty()) {
+			flows.erase(f_it++);
+		} else {
+			++f_it;
+		}
+	}
+}
+
+/**
+ * Get the length of a moving average for a link between two stations.
+ * @param from Source station.
+ * @param to Destination station.
+ * @return Moving average length.
+ */
+uint GetMovingAverageLength(const Station *from, const Station *to)
+{
+	return LinkStat::MIN_AVERAGE_LENGTH + (DistanceManhattan(from->xy, to->xy) >> 2);
+}
+
+/**
+ * Run the moving average decrease function for all link stats.
+ */
+void Station::RunAverages()
+{
+	FlowStatSet new_flows;
+	for (int goods_index = 0; goods_index < NUM_CARGO; ++goods_index) {
+		LinkStatMap &links = this->goods[goods_index].link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end();) {
+			StationID id = i->first;
+			Station *other = Station::GetIfValid(id);
+			if (other == NULL) {
+				links.erase(i++);
+			} else {
+				LinkStat &ls = i->second;
+				ls.Decrease();
+				if (ls.IsValid()) {
+					++i;
+				} else {
+					DeleteStaleFlows(this->index, goods_index, id);
+					links.erase(i++);
+				}
+			}
+		}
+
+		if (_settings_game.linkgraph.GetDistributionType(goods_index) == DT_MANUAL) {
+			this->goods[goods_index].flows.clear();
+			continue;
+		}
+
+		FlowStatMap &flows = this->goods[goods_index].flows;
+		for (FlowStatMap::iterator i = flows.begin(); i != flows.end();) {
+			if (!Station::IsValidID(i->first)) {
+				flows.erase(i++);
+			} else {
+				FlowStatSet &flow_set = i->second;
+				for (FlowStatSet::iterator j = flow_set.begin(); j != flow_set.end(); ++j) {
+					if (Station::IsValidID(j->Via())) {
+						new_flows.insert(j->GetDecreasedCopy());
+					}
+				}
+				flow_set.swap(new_flows);
+				new_flows.clear();
+				++i;
+			}
+		}
+	}
+}
+
+/**
+ * Increase capacity for a link stat given by station cargo and next hop.
+ * @param st Station to get the link stats from.
+ * @param cargo Cargo to increase stat for.
+ * @param next_station_id Station the consist will be travelling to next.
+ * @param capacity Capacity to add to link stat.
+ * @param usage Usage to add to link stat. If UINT_MAX refresh the link instead of increasing.
+ */
+void IncreaseStats(Station *st, CargoID cargo, StationID next_station_id, uint capacity, uint usage)
+{
+	LinkStatMap &stats = st->goods[cargo].link_stats;
+	LinkStatMap::iterator i = stats.find(next_station_id);
+	if (i == stats.end()) {
+		assert(st->index != next_station_id);
+		stats.insert(std::make_pair(next_station_id, LinkStat(
+				GetMovingAverageLength(st, 
+				Station::Get(next_station_id)), capacity,
+				usage == UINT_MAX ? 0 : usage)));
+	} else {
+		LinkStat &link_stat = i->second;
+		if (usage == UINT_MAX) {
+			link_stat.Refresh(capacity);
+		} else {
+			assert(capacity >= usage);
+			link_stat.Increase(capacity, usage);
+		}
+		assert(link_stat.IsValid());
+	}
+}
+
+/**
+ * Increase capacity for all link stats associated with vehicles in the given consist.
+ * @param st Station to get the link stats from.
+ * @param front First vehicle in the consist.
+ * @param next_station_id Station the consist will be travelling to next.
+ */
+void IncreaseStats(Station *st, const Vehicle *front, StationID next_station_id)
+{
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->refit_cap > 0) {
+			IncreaseStats(st, v->cargo_type, next_station_id, v->refit_cap, v->cargo.Count());
+		}
+	}
+}
+
 /* called for every station each tick */
 static void StationHandleSmallTick(BaseStation *st)
 {
@@ -3195,6 +3328,8 @@ void OnTick_Station()
 {
 	if (_game_mode == GM_EDITOR) return;
 
+	RunAverages<Station>();
+
 	BaseStation *st;
 	FOR_ALL_BASE_STATIONS(st) {
 		StationHandleSmallTick(st);
@@ -3221,6 +3356,8 @@ void StationMonthlyLoop()
 			GoodsEntry *ge = &st->goods[i];
 			SB(ge->acceptance_pickup, GoodsEntry::GES_LAST_MONTH, 1, GB(ge->acceptance_pickup, GoodsEntry::GES_CURRENT_MONTH, 1));
 			ClrBit(ge->acceptance_pickup, GoodsEntry::GES_CURRENT_MONTH);
+			ge->supply = ge->supply_new;
+			ge->supply_new = 0;
 		}
 	}
 }
@@ -3259,6 +3396,7 @@ static uint UpdateStationWaiting(Station *st, CargoID type, uint amount, SourceT
 	if (amount == 0) return 0;
 
 	ge.cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id));
+	ge.supply_new += amount;
 
 	if (!HasBit(ge.acceptance_pickup, GoodsEntry::GES_PICKUP)) {
 		InvalidateWindowData(WC_STATION_LIST, st->index);
@@ -3632,6 +3770,25 @@ static CommandCost TerraformTile_Station(TileIndex tile, DoCommandFlag flags, in
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 }
 
+/**
+ * Get the sum of flows via a specific station from this GoodsEntry.
+ * @param via Remote station to look for.
+ * @return a FlowStat with all flows for 'via' added up.
+ */
+FlowStat GoodsEntry::GetSumFlowVia(StationID via) const
+{
+	FlowStat ret(1, via);
+	for (FlowStatMap::const_iterator i = this->flows.begin(); i != this->flows.end(); ++i) {
+		const FlowStatSet &flow_set = i->second;
+		for (FlowStatSet::const_iterator j = flow_set.begin(); j != flow_set.end(); ++j) {
+			const FlowStat &flow = *j;
+			if (flow.Via() == via) {
+				ret += flow;
+			}
+		}
+	}
+	return ret;
+}
 
 extern const TileTypeProcs _tile_type_station_procs = {
 	DrawTile_Station,           // draw_tile_proc
diff --git a/src/station_func.h b/src/station_func.h
index 0fe5b2f..4eaf727 100644
--- a/src/station_func.h
+++ b/src/station_func.h
@@ -18,6 +18,7 @@
 #include "road_type.h"
 #include "cargo_type.h"
 #include "company_type.h"
+#include "vehicle_type.h"
 
 void ModifyStationRatingAround(TileIndex tile, Owner owner, int amount, uint radius);
 
@@ -46,4 +47,10 @@ bool IsStationTileElectrifiable(TileIndex tile);
 
 void UpdateAirportsNoise();
 
+void IncreaseStats(Station *st, const Vehicle *v, StationID next_station_id);
+
+void IncreaseStats(Station *st, CargoID cargo, StationID next_station_id, uint capacity, uint usage);
+
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to);
+
 #endif /* STATION_FUNC_H */
diff --git a/src/table/settings.ini b/src/table/settings.ini
index f519db6..08136af 100644
--- a/src/table/settings.ini
+++ b/src/table/settings.ini
@@ -512,6 +512,115 @@ guiflags = SGF_NO_NETWORK
 def      = true
 str      = STR_CONFIG_SETTING_ALLOW_TOWN_LEVEL_CROSSINGS
 
+; link graph
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.recalc_interval
+type     = SLE_UINT16
+from     = SL_COMPONENTS
+def      = 16
+min      = 1
+max      = 4096
+interval = 1
+str      = STR_CONFIG_SETTING_LINKGRAPH_INTERVAL
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_pax
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_PAX
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_mail
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_MAIL
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_armoured
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_default
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_ASYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.accuracy
+type     = SLE_UINT8
+from     = SL_DEMANDS
+def      = 16
+min      = 2
+max      = 64
+interval = 1
+str      = STR_CONFIG_SETTING_LINKGRAPH_ACCURACY
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.demand_distance
+type     = SLE_UINT8
+from     = SL_DEMANDS
+def      = 100
+min      = 0
+max      = 255
+interval = 5
+str      = STR_CONFIG_SETTING_DEMAND_DISTANCE
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.demand_size
+type     = SLE_UINT8
+from     = SL_DEMANDS
+def      = 100
+min      = 0
+max      = 100
+interval = 5
+str      = STR_CONFIG_SETTING_DEMAND_SIZE
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.short_path_saturation
+type     = SLE_UINT8
+from     = SL_MCF
+def      = 80
+min      = 0
+max      = 250
+interval = 5
+str      = STR_CONFIG_SETTING_SHORT_PATH_SATURATION
+
 ; Vehicles
 
 [SDT_VAR]
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
index 2ba4061..e263097 100644
--- a/src/train_cmd.cpp
+++ b/src/train_cmd.cpp
@@ -696,6 +696,7 @@ CommandCost CmdBuildRailVehicle(TileIndex tile, DoCommandFlag flags, const Engin
 		v->cargo_type = e->GetDefaultCargoType();
 		v->cargo_cap = rvi->capacity;
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 
 		v->engine_type = e->index;
 		v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index 69c4097..8da439c 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -1932,6 +1932,13 @@ void Vehicle::BeginLoading()
 
 	Station::Get(this->last_station_visited)->loading_vehicles.push_back(this);
 
+	if (this->last_loading_station != INVALID_STATION &&
+			this->last_loading_station != this->last_station_visited &&
+			((this->current_order.GetLoadType() & OLFB_NO_LOAD) == 0 ||
+			(this->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0)) {
+		IncreaseStats(Station::Get(this->last_loading_station), this, this->last_station_visited);
+	}
+
 	PrepareUnload(this);
 
 	SetWindowDirty(GetWindowClassForVehicleType(this->type), this->owner);
@@ -1957,6 +1964,25 @@ void Vehicle::LeaveStation()
 	/* Only update the timetable if the vehicle was supposed to stop here. */
 	if (this->current_order.GetNonStopType() != ONSF_STOP_EVERYWHERE) UpdateVehicleTimetable(this, false);
 
+	if ((this->current_order.GetLoadType() & OLFB_NO_LOAD) == 0 ||
+			(this->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
+		if (this->current_order.CanLeaveWithCargo(this->last_loading_station != INVALID_STATION)) {
+			/* Refresh next hop stats to make sure we've done that at least once
+			 * during the stop and that refit_cap == cargo_cap for each vehicle in
+			 * the consist.
+			 */
+			this->RefreshNextHopsStats();
+
+			/* if the vehicle could load here or could stop with cargo loaded set the last loading station */
+			this->last_loading_station = this->last_station_visited;
+		} else {
+			/* if the vehicle couldn't load and had to unload or transfer everything
+			 * set the last loading station to invalid as it will leave empty.
+			 */
+			this->last_loading_station = INVALID_STATION;
+		}
+	}
+
 	this->current_order.MakeLeaveStation();
 	Station *st = Station::Get(this->last_station_visited);
 	st->loading_vehicles.remove(this);
@@ -1971,6 +1997,97 @@ void Vehicle::LeaveStation()
 	}
 }
 
+/**
+ * Predict a vehicle's course from it's current state and refresh all links it
+ * will visit. As a side effect reset the refit_cap of all vehicles in the
+ * consist to the cargo_cap. This method is expected to be called when loading
+ * at a station so it's safe to do so.
+ */
+void Vehicle::RefreshNextHopsStats()
+{
+	/* Assemble list of capacities and set last loading stations to 0. */
+	SmallMap<CargoID, uint, 1> capacities;
+	for (Vehicle *v = this; v != NULL; v = v->Next()) {
+		v->refit_cap = v->cargo_cap;
+		if (v->refit_cap == 0) continue;
+		SmallPair<CargoID, uint> *i = capacities.Find(v->cargo_type);
+		if (i == capacities.End()) {
+			/* Braindead smallmap not providing a good method for that. */
+			i = capacities.Append();
+			i->first = v->cargo_type;
+			i->second = v->cargo_cap;
+		} else {
+			i->second += v->cargo_cap;
+		}
+	}
+
+	uint hops = 0;
+	const Order *first = this->orders.list->GetNextStoppingOrder(this,
+			this->GetOrder(this->cur_implicit_order_index), hops);
+	const Order *cur = first;
+	const Order *next = first;
+	while (next != NULL && cur->CanLeaveWithCargo(true)) {
+		next = this->orders.list->GetNextStoppingOrder(this,
+				this->orders.list->GetNext(next), ++hops);
+		if (next == NULL) break;
+
+		if (next->IsType(OT_GOTO_DEPOT)) {
+			/* handle refit by dropping some vehicles. */
+			CargoID new_cid = next->GetRefitCargo();
+			byte new_subtype = next->GetRefitSubtype();
+			for (Vehicle *v = this; v != NULL; v = v->Next()) {
+				const Engine *e = Engine::Get(v->engine_type);
+				if (!HasBit(e->info.refit_mask, new_cid)) continue;
+
+				/* Back up the vehicle's cargo type */
+				CargoID temp_cid = v->cargo_type;
+				byte temp_subtype = v->cargo_subtype;
+				v->cargo_type = new_cid;
+				v->cargo_subtype = new_subtype;
+
+				uint16 mail_capacity = 0;
+				uint amount = e->DetermineCapacity(v, &mail_capacity);
+
+				/* Restore the original cargo type */
+				v->cargo_type = temp_cid;
+				v->cargo_subtype = temp_subtype;
+
+				/* Skip on next refit. */
+				if (new_cid != v->cargo_type && v->refit_cap > 0) {
+					capacities[v->cargo_type] -= v->refit_cap;
+					v->refit_cap = 0;
+				} else if (amount < v->refit_cap) {
+					capacities[v->cargo_type] -= v->refit_cap - amount;
+					v->refit_cap = amount;
+				}
+
+				/* Special case for aircraft with mail. */
+				if (v->type == VEH_AIRCRAFT) {
+					Vehicle *u = v->Next();
+					if (mail_capacity < u->refit_cap) {
+						capacities[u->cargo_type] -= u->refit_cap - mail_capacity;
+						u->refit_cap = mail_capacity;
+					}
+					break; // aircraft have only one vehicle
+				}
+				if (v->type == VEH_SHIP) break; // ships too
+			}
+		} else {
+			StationID next_station = next->GetDestination();
+			Station *st = Station::GetIfValid(cur->GetDestination());
+			if (st != NULL && next_station != INVALID_STATION && next_station != st->index) {
+				for (const SmallPair<CargoID, uint> *i = capacities.Begin(); i != capacities.End(); ++i) {
+					/* Refresh the link and give it a minimum capacity. */
+					if (i->second > 0) IncreaseStats(st, i->first, next_station, i->second, UINT_MAX);
+				}
+			}
+			cur = next;
+			if (cur == first) break;
+		}
+	}
+
+	for (Vehicle *v = this; v != NULL; v = v->Next()) v->refit_cap = v->cargo_cap;
+}
 
 /**
  * Handle the loading of the vehicle; when not it skips through dummy
@@ -2009,6 +2126,34 @@ void Vehicle::HandleLoading(bool mode)
 }
 
 /**
+ * Get a map of cargoes and free capacities in the consist.
+ * @param capacities Map to be filled with cargoes and capacities.
+ */
+void Vehicle::GetConsistFreeCapacities(SmallMap<CargoID, uint> &capacities) const
+{
+	for (const Vehicle *v = this; v != NULL; v = v->Next()) {
+		if (v->cargo_cap == 0) continue;
+		SmallPair<CargoID, uint> *pair = capacities.Find(v->cargo_type);
+		if (pair == capacities.End()) {
+			pair = capacities.Append();
+			pair->first = v->cargo_type;
+			pair->second = v->cargo_cap - v->cargo.Count();
+		} else {
+			pair->second += v->cargo_cap - v->cargo.Count();
+		}
+	}
+}
+
+uint Vehicle::GetConsistTotalCapacity() const
+{
+	uint result = 0;
+	for (const Vehicle *v = this; v != NULL; v = v->Next()) {
+		result += v->cargo_cap;
+	}
+	return result;
+}
+
+/**
  * Send this vehicle to the depot using the given command(s).
  * @param flags   the command flags (like execute and such).
  * @param command the command to execute.
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index e7c8fd3..0034087 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -12,6 +12,7 @@
 #ifndef VEHICLE_BASE_H
 #define VEHICLE_BASE_H
 
+#include "core/smallmap_type.hpp"
 #include "track_type.h"
 #include "command_type.h"
 #include "order_base.h"
@@ -129,6 +130,7 @@ private:
 
 	Vehicle *next_shared;               ///< pointer to the next vehicle that shares the order
 	Vehicle *previous_shared;           ///< NOSAVE: pointer to the previous vehicle in the shared order chain
+
 public:
 	friend const SaveLoad *GetVehicleDescription(VehicleType vt); ///< So we can use private/protected variables in the saveload code
 	friend void FixOldVehicles();
@@ -211,10 +213,12 @@ public:
 	byte waiting_triggers;              ///< Triggers to be yet matched before rerandomizing the random bits.
 
 	StationID last_station_visited;     ///< The last station we stopped at.
+	StationID last_loading_station;     ///< Last station the vehicle has stopped at and could possibly leave from with any cargo loaded.
 
 	CargoID cargo_type;                 ///< type of cargo this vehicle is carrying
 	byte cargo_subtype;                 ///< Used for livery refits (NewGRF variations)
 	uint16 cargo_cap;                   ///< total capacity
+	uint16 refit_cap;                   ///< Capacity left over from before last refit.
 	VehicleCargoList cargo;             ///< The cargo this vehicle is carrying
 	uint16 cargo_age_counter;           ///< Ticks till cargo is aged next.
 
@@ -260,6 +264,10 @@ public:
 
 	void HandleLoading(bool mode = false);
 
+	void GetConsistFreeCapacities(SmallMap<CargoID, uint> &capacities) const;
+
+	uint GetConsistTotalCapacity() const;
+
 	/**
 	 * Marks the vehicles to be redrawn and updates cached variables
 	 *
@@ -567,6 +575,17 @@ public:
 	inline VehicleOrderID GetNumManualOrders() const { return (this->orders.list == NULL) ? 0 : this->orders.list->GetNumManualOrders(); }
 
 	/**
+	 * Get the next station the vehicle will stop at.
+	 * @return ID of the next station the vehicle will stop at or INVALID_STATION.
+	 */
+	inline StationID GetNextStoppingStation() const
+	{
+		return (this->orders.list == NULL) ? INVALID_STATION : this->orders.list->GetNextStoppingStation(this);
+	}
+
+	void RefreshNextHopsStats();
+	
+	/**
 	 * Copy certain configurations and statistics of a vehicle after successful autoreplace/renew
 	 * The function shall copy everything that cannot be copied by a command (like orders / group etc),
 	 * and that shall not be resetted for the new vehicle.
diff --git a/src/vehicle_cmd.cpp b/src/vehicle_cmd.cpp
index 4293e5f..620071b 100644
--- a/src/vehicle_cmd.cpp
+++ b/src/vehicle_cmd.cpp
@@ -348,12 +348,14 @@ static CommandCost RefitVehicle(Vehicle *v, bool only_this, uint8 num_vehicles,
 		}
 
 		if (flags & DC_EXEC) {
-			v->cargo.Truncate((v->cargo_type == new_cid) ? amount : 0);
+			v->refit_cap = (v->cargo_type == new_cid) ? min(amount, v->cargo_cap) : 0;
+			v->cargo.Truncate(v->refit_cap);
 			v->cargo_type = new_cid;
 			v->cargo_cap = amount;
 			v->cargo_subtype = new_subtype;
 			if (v->type == VEH_AIRCRAFT) {
 				Vehicle *u = v->Next();
+				u->refit_cap = min(u->cargo_cap, mail_capacity);
 				u->cargo_cap = mail_capacity;
 				u->cargo.Truncate(mail_capacity);
 			}
